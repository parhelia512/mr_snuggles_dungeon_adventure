package main

import (
	"fmt"
	"math"
	"os"
	"strconv"
	"strings"

	rl "github.com/gen2brain/raylib-go/raylib"
)

// 01.2024-002 - MR SNUGGLES DUNGEON ADVENTURE
// MARK: VAR
var (

	//HELP
	helpon, help1        bool
	helpimgrec           = rl.NewRectangle(0, 0, 720, 720)
	controlsimg, helpimg rl.Texture2D

	//END GAME
	endgame, end1, end2, endgameclose bool
	endfd, endfd2                     = float32(0), float32(0)
	endimg                            rl.Texture2D
	endRec                            rl.Rectangle
	endtextureRec                     = rl.NewRectangle(0, 0, 800, 800)

	//GAME OVER
	gameoverRec, gameoveranimRec rl.Rectangle
	gameover, gameoverreset      bool
	gameoverfd, gameoverRo       float32

	//SAVES LOAD DIFF
	loadtxT, loadedT                   int32
	loadon                             bool
	save1, save2, save3, delsave       bool
	savestore1, savestore2, savestore3 []xitm
	selSave, currentSave, delsaveNum   int

	//SPECIAL BONUS WEAPON PROJ
	lightningEnm   []int
	lightningCount int32

	//SOUND
	musicNumPrev, currentMusic int
	audfx                      []rl.Sound
	music                      []rl.Music
	musicon                    bool
	volumemax                  = 10
	volume                     = 5
	prevol                     = volume
	dispMusic                  = 3
	prevMusic                  = dispMusic

	//INTRO START
	gamestartT            = fps
	savenum               int
	startScreen, endIntro bool
	introbgimgnum         int
	introbg               []xbgpix
	intro                 bool
	raylibAnim            []rl.Texture2D
	raylibFrameNum        int
	raylibRec             = rl.NewRectangle(0, 0, 288, 288)
	unklnikLogoF          = float32(0)
	introT1               = fps * 2
	introT2               = fps * 2
	introT3               = fps * 2
	unklnikRec            rl.Rectangle
	goLogoRec             rl.Rectangle
	introfd               = float32(0)
	introfd2              = float32(0)
	introAnim             rl.Rectangle

	//BOSS
	bosskillist                            []int
	bosskey1, bosskey2, bosskey3           bool
	bossKeyChanged                         bool
	boss                                   xenm
	bossnum                                int
	bosson, bosslevon                      bool
	camBoss                                rl.Camera2D
	bossBordRec                            rl.Rectangle
	bossIDL, bossWALKL, bossWALKR, bossATK rl.Texture2D

	//ITEM
	rollocomp              = xenm{}
	batcomp                = xenm{}
	crateItmLen, unlockNum int
	invisItm               []xitm

	scopeon, drillon, telBase, telCntr, medikiton, vineon, vineon2, vineRing, thornson, twin, tesla, purplerain, frisbee, mirror, toxic, feather, cloak, toaster, noodles, mappin, chestpin, umbrella, treasureroom, icecrystal, mrfrisbee, spinna, pyroball, zombiehead, batty, landmine, rollo bool

	shrimpnum, basketballnum, broccolinum, garlicnum, tenderisernum, cleavernum, deathbottlenum, gascannum, beartrapnum, toiletpapernum, vineRingArtNum, teslacount, purpleraincount, frisbeecount, beltnum, beltAtk, throwingknifenum, magicianshatnum, pearlnum, lightbulbnum, mugnum, teanum, ninjanum, ovenglovenum, poisongasCount, medikitnum, sneakersnum, weaponcasenum, spacehelmetnum, zombienum int

	candycanenum            = int32(4)
	candycanemax            = int32(12)
	flamingonum, gasmasknum int32
	flamingomax, gasmaskmax = int32(5), int32(5)
	teamax, ninjamax        = 2, 2
	basketballmax           = 10
	garlicmax               = 12
	throwingknifemax        = 8
	medikitmax              = 1

	sneakersmax, weaponcasemax, spacehelmetmax = 4, 4, 4

	deathbottlemax, beartrapmax, beltmax, magicianshatmax, pearlmax, lightbulbmax, ovenglovemax = 5, 5, 5, 5, 5, 5, 5

	broccolimax, cleavermax, gascanmax, toiletpapermax, mugmax, tenderisermax = 6, 6, 6, 6, 6, 6

	watchT, scopeT, slugT, pistolT, turtleT, sodaT, icecreamT, gasT, bloodT, icelollyT, intangibleT, teleportT, inflictT, powerT, steroidsT, reviveT, beartrapT, quailT, teslaT, purplerainT, frisbeeT, beetrootT, cloakT, flamingoT, orangeT, tvT, lollipopT, honeycombT, eggsT, gasmaskT, psychedelicsT, bootsT, fartT, teleportPauseT, exitPauseT, saltT, icecrystalT, mrfrisbeeT, spinnaT, spinnaT2, pyroballT, landmineT int32

	scopeZ               = float32(2)
	scopeZmax, cam2Zorig float32
	itmlist              []xitm

	//CAMP
	exitcollis     bool
	weapstandon    = true
	weapstandro    float32
	campfximgrecs2 []rl.Rectangle
	campfxrecs2    []rl.Rectangle
	campfximgrecs  []rl.Rectangle
	campfxrecs     []rl.Rectangle

	exiting bool

	notenoughscrapT, weapchangedT    int32
	apothTxt, weapUpgTXT             string
	selnumWeap                       int
	leadcost                         = 20
	bronzecost                       = 25
	silvercost                       = 30
	goldcost                         = 40
	platinumcost                     = 50
	mushCol                          rl.Color
	storeItm, potionList, scrollList []xitm
	bgpix                            []xbgpix
	base                             = xbas{}
	baseBG                           []xbgi
	scrapNum, nxStoreNum             int
	baseBordRec, storeRec            rl.Rectangle

	storetxT, storetxT2, storetxT3, saveT int32

	mushroomTimer, mushroomTimerMax, mushPause int

	baseon, bookon, storeon, weaponshedon, apothercaryon, storeunlocked bool

	//ENEMIES
	xpadded       bool
	enmlist       []xenm
	blackdotCount int
	//INVEN QUICK WEAPON SLOTS
	disTxt1, disTxt2                             string
	inquick, inweapslots, weapInfon              bool
	nxInvnNum, nxQuikNum, inMenuItm              int
	invMax                                       = 27
	inMenuOn, inMenuOn2, invenInfo, inWeapMenuOn bool
	inMenuRec                                    rl.Rectangle
	invDisTxtT, invInfoT, inMenuExitT, cantmoveT int32
	//CHESTS CRATES
	inchest, inchestslot bool
	crateitm             []xitm
	//CHAR SCR OPTIONS SIDEBAR
	sideY            float32
	charscr, options bool
	optionsRec       rl.Rectangle
	//WEAPONS PROJECTILES
	weap, projPL, projEn []xweap
	maxWeapDmg           int
	//OPTIONS
	disconnectT              int32
	deadZ                    = float32(0.30)
	stickMov                 = float32(0.55)
	stickMovdis, deadZDis    int
	scan                     []rl.Vector2
	res169, res1610, reslist []string

	currentres, windowType, prevres, prevWindowType int

	scanlines, pixels, asp169, asp1610, credits, exit bool

	creditlist = []string{"grafxkid", "kenney", "clementpanchout", "greatdocbrown", "ilkaytobello", "crumpaloo", "engvee", "segel2d", "pixelboyz", "stealthix", "piiixl", "free-game-assets", "flippurgatory", "ateliermagicae", "dusk-games", "ragnapixel", "bdragon1727", "0x72", "that-gray-guy", "analogstudios", "the-outlander", "luquigames", "ninjikin", "thkaspar", "im-dagon", "ladyluck", "eternalpixel", "ateliermagicae", "ghostpixxells", "jpcu", "admurin", "verzatiledev", "ssugmi", "pixelfrog-assets", "ahninniah", "wildlifestudios", "karsiori", "flixberry-entertainment", "osmic", "nushio", "mumu", "alexander123", "hapiel", "imogiagames", "ludicarts", "saint11", "anarres", "pch-vector", "freepik", "publicdomainvectors", "pixabay"}

	//MSG
	msgT    int32
	msg     []xmsg
	exitmsg string

	exitTxt = []string{"leaving so soon", "ready to go", "we'll miss you", "too much dungeoneering", "goodbye kind sir", "try and get some fresh air", "exit or not to exit that is the question", "i'll be waiting", "tell your friends", "buy 1k fb likes for $1", "advertise here contact me", "we only just met", "slogans r us", "that's all folks"}

	welcome = []string{"welcome back", "so we meet again", "ciao", "more dungeon fun", "clever phrase here", "these are dumb", "i am not an ai", "quote of the day", "back again i see", "enter at your periwinkle", "not a 1 bit game", "asdf", "qwerty", "better than cga", "yet another rogue game awaits", "better than ascii"}

	//FX
	fx          []xfx
	fireson     bool
	scanlineSpc float32
	//PLAYER
	pl, pl2, pl3  = xplayer{}, xplayer{}, xplayer{}
	plroom        int
	stats         = xstats{}
	atkV2, atkCNT rl.Vector2
	prevplayHP    int
	invincible    bool
	//GAME
	controllerINITIAL                 bool
	mouseoffpos, gameCursor           rl.Vector2
	mouseoff                          bool
	onoff15                           bool
	teleporting                       bool
	levMins, levSecs                  int32
	levT                              int32
	levels                            []x1scr
	levNum, exitRoomNum, chestRoomNum int
	levNumDis                         = 0
	Wbloks, Hbloks                    = 58, 31
	inRec, drawRec, screenBordRec     rl.Rectangle
	curRo                             float32
	toptx                             string
	toptxT                            int32
	//IMGS
	anm                                                []xanim
	bgilist, bgilist2                                  []xbgi
	floortile, walltile, floorBoss, wallBoss           rl.Rectangle
	floortiles, walltiles, etc, splat, flowers, rocksI []rl.Rectangle
	//BLANKS
	blankint = 777777777
	blankRec rl.Rectangle
	//CORE
	inpL, inpR, xxl, xl, lrg, med bool
	fadeblink, fadeblink2         bool
	fadeblinkF                    = float32(0.7)
	fadeblinkF2                   = float32(1)
	delta                         float32
	imgs                          rl.Texture2D
	shader                        rl.Shader
	renderTarget                  rl.RenderTexture2D
	frames, scrW, scrH            int
	scrW32, scrH32                int32
	scrWF32, scrHF32              float32
	fps                           = int32(60)
	ori                           = rl.NewVector2(0, 0)
	debug, pause, shaderon        bool
	clickT                        int32

	cam2, camMap, camInven, camBase, camStrucs, camEnd rl.Camera2D

	cursorV2camInven, cursorV2, cursorV2cam, cursorV2Base, cnt, cursorV2Strucs rl.Vector2
	//UNITS TXT
	tx = int32(10)
	b  = float32(32)

	tx2, tx3, tx4, tx5, tx6, tx7, tx8, tx9, tx10 = tx * 2, tx * 3, tx * 4, tx * 5, tx * 6, tx * 7, tx * 8, tx * 9, tx * 10

	b2, b3, b4, b5, b6, b7, b8, b9, b10 = b * 2, b * 3, b * 4, b * 5, b * 6, b * 7, b * 8, b * 9, b * 10

	bq  = b / 4
	bq3 = bq * 3
	be  = b / 8
	be3 = be * 3
	be5 = be * 5
	be7 = be * 7
)

// MARK:STRUCT
type xbgpix struct {
	v2                           rl.Vector2
	col                          rl.Color
	spd, dirX, dirY, siz, fd, ro float32
}
type xweapcrate struct {
	i       xtile
	weapnum int
	on      bool
}
type xbas struct {
	img, rec, crec, carec []rl.Rectangle
	nm                    []string
	unlock                []bool
	cost, lev             []int
	desc                  []string
	fd                    []float32
	pigeon                xtile
	pigeonT               int32
	pigeonoff             bool
	mouse                 xenm
}
type xbgi struct {
	img, rec rl.Rectangle
	fd, ro   float32
	sml      bool
}
type xenm struct {
	cnt                                                        rl.Vector2
	nm, nm2                                                    string
	hp, hpmax, numMax, xp, bleed, count                        int
	off, lr, idl, idlon, stat, nodmg, fast, fly, follow, xl    bool
	ro, ro2, spd, dirX, dirY, hpY, hpY2, stunF, stunSiz, stunY float32
	img, rec, hitImgR, hitImgL, crec, carec                    rl.Rectangle

	idleT, moveChangeT, animFrameT, hpT, atkT, burnT, bleedT, poisonT, stunT, atkT2, freezeT, oilT int32
	//BOSS
	walkL, walkR, atk, idlA xanim
	state                   int
	idlT, walkT             int32
	ud, onoff               bool
}
type xitm struct {
	rec, img               rl.Rectangle
	cnt                    rl.Vector2
	dropT, coolT           int32
	costPotion, costScroll []int

	numof, mana, cost, listNum int

	off, art, notquick, invis, unlok, nocrate, noChestMove, uniq bool

	nm, des, des2, des3, des4, des5, des6, des7 string
}
type xchst struct {
	rec, crec, img rl.Rectangle
	slots          int
	cnt            rl.Vector2
	opn, aud       bool
	itm            []xitm
}
type xweap struct {
	cnt                               rl.Vector2
	crec, rec, img, carec, rec2, rec3 rl.Rectangle
	col                               rl.Color
	T, moveT, collisT, dropT          int32

	off, lr, direc, onoff, below, lightning, firework, turret, bomb, potion, xp, ringoffire, sludgegeyser bool

	nm, des, des2, des3, des4, des5, des6, des7 string

	spd, dirX, dirY, ro, fd, rospd, WOrig, angl1, angl2 float32

	dmg, origDMG, num, bounce, weapListNum, level, spec1, spec2 int
}
type xplayer struct {
	cnt                                              rl.Vector2
	rec, crec, carec, perrec, bosseffectrec          rl.Rectangle
	anim                                             []xanim
	wp1, wp2                                         xweap
	invn, quik, art                                  []xitm
	direc, push, gameover                            bool
	spd, spd2, spdmax, angl, ro, angl2, angl3, angl4 float32
	v1, v2, v3, v4                                   rl.Vector2

	hp, hpmax, aninum, xp, mana, manamax, weapmax int
	weaps                                         []xweap

	hpT, dampT, burnT, poisonT, atkT, pushT, resFireT, resPoisT, invisT, armorT, enCollisT, freezeT, collectT int32
}
type xmsg struct {
	txt string
	col rl.Color
}
type xfx struct {
	nm                        string
	img, rec, crec            rl.Rectangle
	col                       rl.Color
	off, below                bool
	T, clearT                 int32
	cnt                       rl.Vector2
	fade, dirX, dirY, spd, ro float32
	circs                     []xcirc
	recs                      []xrec
	recs2                     []rl.Rectangle
	crecs                     []rl.Rectangle
	v2                        []rl.Vector2
	v22                       []rl.Vector2
	onoff                     []bool
}
type xcirc struct {
	cnt             rl.Vector2
	col             rl.Color
	fd, rad         float32
	dirX, dirY, spd float32
}
type xanim struct {
	frames      float32
	H, W, X, YT float32
	rec         rl.Rectangle
}
type x1scr struct {
	walls, floors, etc []xtile
	recs, doors        []rl.Rectangle
	doornums           []int
	inf                []xinf
	dbg                []xdbg
	chst               []xchst
	itm                []xitm
	enm                []xenm
	bgi, bgi2, flowers []xbgi
	weapcrate          xweapcrate
	weaps              []xweap
	enNum              int
}
type xdbg struct {
	conecRoom, side int
}
type xinf struct {
	num, numW, numH int
	W, H            float32
	wallsadded, vis bool
	cnt             rl.Vector2
}
type xtile struct {
	img, img2, rec, rec2, crec          rl.Rectangle
	color, col2                         rl.Color
	dirX, dirY, spd, fade, ro, angl     float32
	off, spikes, onoff, solid, firework bool
	nm                                  string
	spikerecs                           []rl.Rectangle
	hp, numType, room                   int
	hpT, moveT, T                       int32
	cnt, v2                             rl.Vector2
}
type xrec struct {
	rec             rl.Rectangle
	col             rl.Color
	fd              float32
	dirX, dirY, spd float32
}
type xstats struct {
	str, luk, dex, int, per, str2, luk2, dex2, int2, per2, crit, crit2 int
}

// MARK: DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW
func drawhelp() { //MARK: DRAW HELP
	W := scrHF32 - b4
	rec := rl.NewRectangle(cnt.X-W/2, cnt.Y-W/2, W, W)

	if help1 {
		rl.DrawRectangle(0, 0, scrW32, scrH32, rl.Yellow)
		rl.DrawTexturePro(helpimg, helpimgrec, rec, rl.Vector2Zero(), 0, rl.White)
		if inpL || inpR {
			help1 = false
			helpon = false
		}
	} else {
		rl.DrawRectangle(0, 0, scrW32, scrH32, rl.Magenta)
		rl.DrawTexturePro(controlsimg, helpimgrec, rec, rl.Vector2Zero(), 0, rl.White)
		if inpL || inpR {
			help1 = true
		}
	}
}
func drawendgame() { //MARK: DRAW END GAME

	if end1 {
		if endfd > 0 {
			endfd -= 0.004
		} else {
			end2 = true
		}
	} else {
		if endfd < 1 {
			endfd += 0.01
		} else {
			end1 = true
		}
	}

	if end2 {
		rl.BeginMode2D(camEnd)
		rl.DrawTexturePro(endimg, endtextureRec, endRec, rl.Vector2Zero(), 0, rl.Fade(rl.White, endfd2))
		txs := tx3
		txt := "the last known picture of mr snuggles, taken from a passing hang glider."
		txlen := rl.MeasureText(txt, txs)
		y := endRec.ToInt32().Y + endRec.ToInt32().Height + int32(b/2)
		x := int32(cnt.X) - txlen/2
		rl.DrawText(txt, x-2, y+2, txs, rl.Fade(rl.Magenta, endfd2))
		rl.DrawText(txt, x-1, y+1, txs, rl.Fade(rl.Black, endfd2))
		rl.DrawText(txt, x, y, txs, rl.Fade(rl.White, endfd2))
		y += txs + txs/4
		txt = "he had escaped the dungeon only to find himself on a desert island and"
		txlen = rl.MeasureText(txt, txs)
		x = int32(cnt.X) - txlen/2
		rl.DrawText(txt, x-2, y+2, txs, rl.Fade(rl.Magenta, endfd2))
		rl.DrawText(txt, x-1, y+1, txs, rl.Fade(rl.Black, endfd2))
		rl.DrawText(txt, x, y, txs, rl.Fade(rl.White, endfd2))
		y += txs + txs/4
		txt = "is preparing to dive in and swim home - good luck mr snuggles!"
		txlen = rl.MeasureText(txt, txs)
		x = int32(cnt.X) - txlen/2
		rl.DrawText(txt, x-2, y+2, txs, rl.Fade(rl.Magenta, endfd2))
		rl.DrawText(txt, x-1, y+1, txs, rl.Fade(rl.Black, endfd2))
		rl.DrawText(txt, x, y, txs, rl.Fade(rl.White, endfd2))
		if endfd2 < 0.7 {
			endfd2 += 0.01
		} else {
			if inpL || inpR {
				clickT = fps
				pause = true
				endgame = false
				endgameclose = true
				options = true
				credits = true
			}
		}
		rl.EndMode2D()
	} else {
		multi := float32(2)
		if med {
			multi = 1.4
		}
		W := etc[212].Width * multi
		H := etc[212].Height * multi
		rec2 := rl.NewRectangle(cnt.X-W/2, cnt.Y-H/2, W, H)
		rl.DrawTexturePro(imgs, etc[212], rec2, rl.Vector2Zero(), 0, rl.Fade(rl.Magenta, endfd))
	}

}
func drawload() { //MARK: DRAW LOAD
	rl.DrawRectangleRec(optionsRec, rl.Fade(rl.Yellow, 0.9))
	txs := tx7
	txlen := rl.MeasureText("load save", txs)
	y := tx7
	x := int32(cnt.X) - txlen/2
	rl.DrawText("load save", x-5, y+5, txs, DarkRed())
	rl.DrawText("load save", x-2, y+2, txs, rl.White)
	rl.DrawText("load save", x, y, txs, rl.Black)

	W := b8
	H := b2
	txt := "empty"
	if save1 {
		txt = "one"
	}
	rec2 := rl.NewRectangle(cnt.X-W/2, b5, W, H)
	txs = tx4
	txlen = rl.MeasureText(txt, txs)
	x = int32(cnt.X) - txlen/2
	y = rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
	if savenum == 0 {
		rl.DrawRectangleRec(rec2, rl.Black)
		rl.DrawRectangleRec(rec2, rl.Fade(rl.Magenta, fadeblinkF))
		rl.DrawText(txt, x-4, y+4, txs, BrightPink())
		rl.DrawText(txt, x-2, y+2, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, rl.White)
	} else {
		rl.DrawRectangleRec(rec2, rl.Blue)
		rl.DrawText(txt, x-1, y+1, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, rl.Black)
	}
	rl.DrawRectangleLinesEx(rec2, 4, rl.Black) //0

	if rl.CheckCollisionPointRec(cursorV2camInven, rec2) {
		savenum = 0
		if inpL {
			if save1 {
				selSave = 1
			} else {
				loadtxT = fps * 2
			}
		}
	}

	txt = "empty"
	if save2 {
		txt = "two"
	}
	txlen = rl.MeasureText(txt, txs)
	rec2.Y += H + b/2
	x = int32(cnt.X) - txlen/2
	y = rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2

	if savenum == 1 {
		rl.DrawRectangleRec(rec2, rl.Black)
		rl.DrawRectangleRec(rec2, rl.Fade(rl.Magenta, fadeblinkF))
		rl.DrawText(txt, x-4, y+4, txs, BrightPink())
		rl.DrawText(txt, x-2, y+2, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, rl.White)
	} else {
		rl.DrawRectangleRec(rec2, rl.Blue)
		rl.DrawText(txt, x-1, y+1, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, rl.Black)
	}
	rl.DrawRectangleLinesEx(rec2, 4, rl.Black) //1

	if rl.CheckCollisionPointRec(cursorV2camInven, rec2) {
		savenum = 1
		if inpL {
			if save2 {
				selSave = 2
			} else {
				loadtxT = fps * 2
			}
		}
	}

	rec2.Y += H + b/2
	txt = "empty"
	if save3 {
		txt = "three"
	}
	txlen = rl.MeasureText(txt, txs)
	x = int32(cnt.X) - txlen/2
	y = rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
	if savenum == 2 {
		rl.DrawRectangleRec(rec2, rl.Black)
		rl.DrawRectangleRec(rec2, rl.Fade(rl.Magenta, fadeblinkF))
		rl.DrawText(txt, x-4, y+4, txs, BrightPink())
		rl.DrawText(txt, x-2, y+2, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, rl.White)
	} else {
		rl.DrawRectangleRec(rec2, rl.Blue)
		rl.DrawText(txt, x-1, y+1, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, rl.Black)
	}
	rl.DrawRectangleLinesEx(rec2, 4, rl.Black) //2

	if rl.CheckCollisionPointRec(cursorV2camInven, rec2) {
		savenum = 2
		if inpL {
			if save3 {
				selSave = 3
			} else {
				loadtxT = fps * 2
			}
		}
	}

	txt = "slot is empty"
	txlen = rl.MeasureText(txt, txs)
	y += int32(b2)
	x = int32(cnt.X) - txlen/2

	if loadtxT > 0 {
		loadtxT--
		rl.DrawText("slot is empty", x-1, y+1, txs, rl.Black)
		rl.DrawText("slot is empty", x, y, txs, rl.Black)
	}

	if selSave != 0 {
		currentSave = selSave
		Reset()
		for i := 0; i < len(storeItm); i++ {
			storeItm[i] = xitm{}
		}
		switch selSave {
		case 1:
			if save1 {
				copy(storeItm, savestore1)
			}
			storeunlocked = true
			for i := 0; i < len(base.nm); i++ {
				if base.nm[i] == "store room" {
					base.unlock[i] = true
				}
			}
		case 2:
			if save2 {
				copy(storeItm, savestore2)
			}
			storeunlocked = true
			for i := 0; i < len(base.nm); i++ {
				if base.nm[i] == "store room" {
					base.unlock[i] = true
				}
			}
		case 3:
			if save3 {
				copy(storeItm, savestore3)
			}
			storeunlocked = true
			for i := 0; i < len(base.nm); i++ {
				if base.nm[i] == "store room" {
					base.unlock[i] = true
				}
			}
		}

		options = false
		baseon = true
		savenum = 0
		selSave = 0
		loadedT = fps * 2
		loadon = false
	}

	//CLOSE REC
	siz2 := b2
	closerec := rl.NewRectangle(optionsRec.X+optionsRec.Width-siz2, optionsRec.Y+bq, siz2, siz2)
	closerec.X += 16
	closerec.Y += 16
	closerec.Width -= 32
	closerec.Height -= 32
	v1 := rl.NewVector2(closerec.X, closerec.Y)
	v1.X += 8
	v1.Y += 8
	v2 := v1
	v2.X += closerec.Width - 16
	v3 := v2
	v3.Y += closerec.Width - 16
	v4 := v3
	v4.X -= closerec.Width - 16
	if rl.CheckCollisionPointRec(cursorV2camInven, closerec) {
		rl.DrawRectangleRec(closerec, DarkRed())
		rl.DrawLineEx(v1, v3, 4, rl.Black)
		rl.DrawLineEx(v2, v4, 4, rl.Black)
		if inpL {
			rl.PlaySound(audfx[41])
			loadon = false
		}
	} else {
		rl.DrawRectangleRec(closerec, rl.Black)
		rl.DrawLineEx(v1, v3, 4, rl.Orange)
		rl.DrawLineEx(v2, v4, 4, rl.Orange)
	}
	if rl.IsGamepadButtonPressed(0, 6) {
		rl.PlaySound(audfx[41])
		loadon = false
	}

}
func drawOptions() { //MARK:DRAW OPTIONS
	//cnt = rl.NewVector2(scrWF32/2,scrHF32/2)
	if !exit {
		for i := 0; i < len(bgpix); i++ {
			rec := rl.NewRectangle(bgpix[i].v2.X, bgpix[i].v2.Y, bgpix[i].siz, bgpix[i].siz)
			rl.DrawRectangleRec(rec, rl.Fade(bgpix[i].col, bgpix[i].fd))
			bgpix[i].v2.X += bgpix[i].dirX
			bgpix[i].v2.Y += bgpix[i].dirY

			if bgpix[i].v2.X < 0 {
				bgpix[i].v2.X = scrWF32
			}
			if bgpix[i].v2.X > scrWF32 {
				bgpix[i].v2.X = 0
			}
			if bgpix[i].v2.Y < 0 {
				bgpix[i].v2.Y = scrHF32
			}
			if bgpix[i].v2.Y > scrHF32 {
				bgpix[i].v2.Y = 0
			}

			if bgpix[i].fd > 0 {
				bgpix[i].fd -= 0.005
			} else {
				bgpix[i].fd = RandF32(0.5, 1)
			}
		}
	}

	rl.BeginMode2D(camInven) //CHANGE ZOOM FOR SCREEN RES
	if credits {
		drawcredits()
	} else if exit {
		drawexit()
	} else if loadon {
		drawload()
	} else {
		rl.DrawRectangleRec(optionsRec, rl.Fade(rl.Yellow, 0.9))
		cursorV2camInven = rl.GetScreenToWorld2D(cursorV2, camInven)
		//CLOSE REC
		siz2 := b2
		closerec := rl.NewRectangle(optionsRec.X+optionsRec.Width-siz2, optionsRec.Y+bq, siz2, siz2)
		closerec.X += 16
		closerec.Y += 16
		closerec.Width -= 32
		closerec.Height -= 32
		v1 := rl.NewVector2(closerec.X, closerec.Y)
		v1.X += 8
		v1.Y += 8
		v2 := v1
		v2.X += closerec.Width - 16
		v3 := v2
		v3.Y += closerec.Width - 16
		v4 := v3
		v4.X -= closerec.Width - 16
		if rl.CheckCollisionPointRec(cursorV2camInven, closerec) {
			rl.DrawRectangleRec(closerec, DarkRed())
			rl.DrawLineEx(v1, v3, 4, rl.Black)
			rl.DrawLineEx(v2, v4, 4, rl.Black)
			if inpL {
				rl.PlaySound(audfx[41])
				if !baseon {
					pause = false
				}
				options = false
			}
		} else {
			rl.DrawRectangleRec(closerec, rl.Black)
			rl.DrawLineEx(v1, v3, 4, rl.Orange)
			rl.DrawLineEx(v2, v4, 4, rl.Orange)
		}

		if rl.IsGamepadButtonPressed(0, 6) {
			rl.PlaySound(audfx[41])
			if !baseon {
				pause = false
			}
			options = false
		}
		txlen := rl.MeasureText("options", tx10)
		x := int32(cnt.X) - txlen/2
		y := tx4
		rl.DrawText("options", x-5, y+5, tx10, DarkRed())
		rl.DrawText("options", x-1, y+1, tx10, rl.White)
		rl.DrawText("options", x, y, tx10, rl.Black)
		y += tx10
		y += tx2
		x = optionsRec.ToInt32().X + 32
		txs := tx4

		swchX := (optionsRec.X + optionsRec.Width/2) - b2
		swchY := float32(y + 3)

		backrec := rl.NewRectangle(optionsRec.X+4, swchY-2, optionsRec.Width/2-12, b+bq)
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if inpL {
				rl.PlaySound(audfx[44])
				scanlines = !scanlines
			}
		}
		rl.DrawText("scan lines", x-3, y+3, txs, DarkRed())
		rl.DrawText("scan lines", x-1, y+1, txs, rl.Black)
		rl.DrawText("scan lines", x, y, txs, rl.Black)
		opswch(swchX, swchY, scanlines)

		x = optionsRec.ToInt32().X + optionsRec.ToInt32().Width/2 + 12
		swchX = (optionsRec.X + optionsRec.Width) - b2
		backrec.X = optionsRec.X + optionsRec.Width/2 - 2
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if inpL {
				rl.PlaySound(audfx[44])
				pixels = !pixels
			}
		}
		rl.DrawText("pixl noise", x-3, y+3, txs, DarkRed())
		rl.DrawText("pixl noise", x-1, y+1, txs, rl.Black)
		rl.DrawText("pixl noise", x, y, txs, rl.Black)
		opswch(swchX, swchY, pixels)

		y += txs + txs/4
		x = optionsRec.ToInt32().X + 32

		swchY = float32(y)
		swchX = (optionsRec.X + optionsRec.Width/2) - b2
		backrec = rl.NewRectangle(optionsRec.X+4, swchY-2, optionsRec.Width/2-12, b+bq)
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if inpL {
				rl.PlaySound(audfx[44])
				musicon = !musicon
			}
		}
		rl.DrawText("music on", x-3, y+3, txs, DarkRed())
		rl.DrawText("music on", x-1, y+1, txs, rl.Black)
		rl.DrawText("music on", x, y, txs, rl.Black)
		opswch(swchX, swchY, musicon)

		x = optionsRec.ToInt32().X + optionsRec.ToInt32().Width/2 + 12
		swchX = (optionsRec.X + optionsRec.Width) - b2
		backrec.X = optionsRec.X + optionsRec.Width/2 - 2
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if rl.IsKeyPressed(rl.KeyA) || rl.IsKeyPressed(rl.KeyLeft) || rl.GetGamepadAxisMovement(0, 0) < 0 || rl.IsGamepadButtonPressed(0, 4) {
				if volume > 0 {
					volume--
				}
			}
			if rl.IsKeyPressed(rl.KeyD) || rl.IsKeyPressed(rl.KeyRight) || rl.GetGamepadAxisMovement(0, 0) > 0 || rl.IsGamepadButtonPressed(0, 2) {
				if volume < volumemax {
					volume++
				}
			}
		}
		rl.DrawText("volume", x-3, y+3, txs, DarkRed())
		rl.DrawText("volume", x-1, y+1, txs, rl.Black)
		rl.DrawText("volume", x, y, txs, rl.Black)
		volume = opadj(volume, volumemax, swchX, swchY, false, 0)
		if prevol != volume {
			rl.PlaySound(audfx[44])
			rl.SetMasterVolume(float32(volume) / 10)
			rl.SetMusicVolume(music[currentMusic], float32(volume)/10)
			prevol = volume
		}

		y += txs + txs/4
		x = optionsRec.ToInt32().X + 32

		swchY = float32(y)
		backrec = rl.NewRectangle(optionsRec.X+4, swchY-2, optionsRec.Width/2+b3, b+bq)
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if rl.IsKeyPressed(rl.KeyA) || rl.IsKeyPressed(rl.KeyLeft) || rl.GetGamepadAxisMovement(0, 0) < 0 || rl.IsGamepadButtonPressed(0, 4) {
				if dispMusic > 0 {
					dispMusic--
				}
			}
			if rl.IsKeyPressed(rl.KeyD) || rl.IsKeyPressed(rl.KeyRight) || rl.GetGamepadAxisMovement(0, 0) > 0 || rl.IsGamepadButtonPressed(0, 2) {
				if dispMusic < 3 {
					dispMusic++
				}
			}
		}
		rl.DrawText("music track", x-3, y+3, txs, DarkRed())
		rl.DrawText("music track", x-1, y+1, txs, rl.Black)
		rl.DrawText("music track", x, y, txs, rl.Black)
		txlen = rl.MeasureText("music track", txs)
		swchX = float32(x+txlen) + b3
		x = int32(swchX + b2 + b/2)
		dispMusic = opadj(dispMusic, 3, swchX, swchY, false, 0)
		if prevMusic != dispMusic {
			rl.PlaySound(audfx[44])
			switch dispMusic {
			case 0:
				rl.StopMusicStream(music[currentMusic])
				currentMusic = RandInt(4, len(music))
				rl.PlayMusicStream(music[currentMusic])
			case 1:
				rl.StopMusicStream(music[currentMusic])
				currentMusic = 4
				rl.PlayMusicStream(music[currentMusic])
			case 2:
				rl.StopMusicStream(music[currentMusic])
				currentMusic = 5
				rl.PlayMusicStream(music[currentMusic])
			case 3:
				rl.StopMusicStream(music[currentMusic])
				currentMusic = 6
				rl.PlayMusicStream(music[currentMusic])
			}
			prevMusic = dispMusic
		}
		if dispMusic == 0 {
			rl.DrawText("random", x-3, y+3, txs, DarkRed())
			rl.DrawText("random", x-1, y+1, txs, rl.Black)
			rl.DrawText("random", x, y, txs, rl.Black)
		} else if dispMusic == 1 {
			rl.DrawText("skool", x-3, y+3, txs, DarkRed())
			rl.DrawText("skool", x-1, y+1, txs, rl.Black)
			rl.DrawText("skool", x, y, txs, rl.Black)
		} else if dispMusic == 2 {
			rl.DrawText("raver", x-3, y+3, txs, DarkRed())
			rl.DrawText("raver", x-1, y+1, txs, rl.Black)
			rl.DrawText("raver", x, y, txs, rl.Black)
		} else if dispMusic == 3 {
			rl.DrawText("funky", x-3, y+3, txs, DarkRed())
			rl.DrawText("funky", x-1, y+1, txs, rl.Black)
			rl.DrawText("funky", x, y, txs, rl.Black)
		}

		y += txs + txs/4
		x = optionsRec.ToInt32().X + 32

		swchY = float32(y)
		swchX = (optionsRec.X + optionsRec.Width/2) - b2

		backrec = rl.NewRectangle(optionsRec.X+4, swchY-2, optionsRec.Width-8, b+bq)
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if rl.IsKeyPressed(rl.KeyA) || rl.IsKeyPressed(rl.KeyLeft) || rl.GetGamepadAxisMovement(0, 0) < 0 || rl.IsGamepadButtonPressed(0, 4) {
				if currentres > 0 {
					currentres--
				}
			}
			if rl.IsKeyPressed(rl.KeyD) || rl.IsKeyPressed(rl.KeyRight) || rl.GetGamepadAxisMovement(0, 0) > 0 || rl.IsGamepadButtonPressed(0, 2) {
				if currentres < len(reslist)-1 {
					currentres++
				}
			}
		}

		rl.DrawText("resolution >>", x-3, y+3, txs, DarkRed())
		rl.DrawText("resolution >>", x-1, y+1, txs, rl.Black)
		rl.DrawText("resolution >>", x, y, txs, rl.Black)
		x = int32(swchX)
		x += txs
		rl.DrawText(reslist[currentres], x-3, y+3, txs, DarkRed())
		rl.DrawText(reslist[currentres], x-1, y+1, txs, rl.Black)
		rl.DrawText(reslist[currentres], x, y, txs, rl.Black)
		swchX = (optionsRec.X + optionsRec.Width) - b2
		currentres = oplr(currentres, len(reslist)-1, swchX, swchY)
		//CHANGE RESOLUTION
		if prevres != currentres {
			rl.PlaySound(audfx[44])
			makeintroexitbg()
			if !rl.IsWindowFullscreen() {
				windowType = 1
			}
			if asp1610 {
				if reslist[currentres] == res1610[0] {
					scrW, scrH = 1280, 800
				} else if reslist[currentres] == res1610[1] {
					scrW, scrH = 1440, 900
				} else if reslist[currentres] == res1610[2] {
					scrW, scrH = 1680, 1050
				} else if reslist[currentres] == res1610[3] {
					scrW, scrH = 1920, 1200
				} else if reslist[currentres] == res1610[4] {
					scrW, scrH = 2560, 1600
				} else if reslist[currentres] == res1610[5] {
					scrW, scrH = 3840, 2400
				}
				scrW32, scrH32 = int32(scrW), int32(scrH)
				scrWF32, scrHF32 = float32(scrW), float32(scrH)

				rl.UnloadShader(shader)
				if med {
					shader = rl.LoadShader("", "shaders/bloom_sml.fs")
				} else {
					shader = rl.LoadShader("", "shaders/bloom.fs")
				}
				renderTarget = rl.LoadRenderTexture(scrW32, scrH32)

				rl.SetWindowSize(scrW, scrH)
				rl.SetWindowPosition(int(cnt.X)-scrW/2, int(cnt.Y)-scrH/2)
				xxl = false
				xl = false
				med = false
				if scrH >= 2160 {
					cam2.Zoom = 4
					xxl = true
				} else if scrH >= 1440 && scrH < 2160 {
					cam2.Zoom = 3
					xl = true
				} else if scrH > 1050 && scrH <= 1200 {
					cam2.Zoom = 2.5
					lrg = true
				} else if scrH >= 990 && scrH <= 1050 {
					cam2.Zoom = 2
					lrg = true
				} else if scrH >= 900 && scrH < 990 {
					cam2.Zoom = 2
					lrg = true
				} else if scrH >= 720 && scrH < 900 {
					cam2.Zoom = 1.75
					med = true
				} else if scrH >= 600 && scrH < 720 {
					cam2.Zoom = 0.8

				} else if scrH < 600 && scrH > 300 {
					cam2.Zoom = 0.5
				} else if scrH < 300 {
					cam2.Zoom = 0.2
				}

				if med {
					scanlines = false
					pixels = false
				}
				//CAM STRUCTURES
				cntr := rl.NewVector2(scrWF32/2, scrHF32)
				camStrucs.Zoom = 1
				camStrucs.Target.Y = cntr.Y
				camStrucs.Offset.X = scrWF32 / 2
				camStrucs.Offset.Y = scrHF32 / 2
				if xl {
					camStrucs.Zoom = 1.5
					camStrucs.Offset.Y = scrHF32 / 0.67
				} else if xxl {
					camStrucs.Zoom = 2.25
					camStrucs.Offset.Y = scrHF32 / 0.89
				} else if med {
					camStrucs.Zoom = 0.75
					camStrucs.Offset.Y = scrHF32 / 1.34
				} else if lrg {
					camStrucs.Zoom = 1
					camStrucs.Offset.Y = scrHF32
				}
				//CAM MAP
				camMap.Zoom = 0.1
				if xxl {
					camMap.Zoom = 0.2
				}
				if xl {
					camMap.Zoom = 0.15
				}
				//CAM INVEN
				camInven.Zoom = 1
				camInven.Target = cnt
				camInven.Offset.X = scrWF32 / 2
				camInven.Offset.Y = optionsRec.Height / 4.05
				if xl {
					camInven.Zoom = 1.5
					camInven.Offset.Y = scrHF32 / 1.35
				} else if xxl {
					camInven.Zoom = 2.25
					camInven.Offset.Y = scrHF32 / 0.89
				} else if med {
					camInven.Zoom = 0.8
					camInven.Offset.Y = optionsRec.Height / 5
				}
				//CAM BASE
				if scrHF32 > 720 {
					diff := scrHF32 - 720
					diff = diff / 720
					camBase.Zoom = 1 + diff
				} else if scrHF32 == 720 {
					camBase.Zoom = 1
				}
				camBase.Target = cnt
				camBase.Offset.X = scrWF32 / 2
				camBase.Offset.Y = scrHF32 / 2
				camBoss.Target = cnt
				camBoss.Zoom = 3
				camBoss.Offset.X = scrWF32 / 2
				camBoss.Offset.Y = scrHF32 / 2

				//CAM END GAME
				camEnd.Zoom = 1
				if xl {
					camEnd.Zoom = 1.5
				}
				if xxl {
					camEnd.Zoom = 2.5
				}
				if med {
					camEnd.Zoom = 0.75
				}
				camEnd.Target = cnt
				camEnd.Offset.X = scrWF32 / 2
				camEnd.Offset.Y = scrHF32 / 2

			} else if asp169 {
				if reslist[currentres] == res169[0] {
					scrW, scrH = 1280, 720
				} else if reslist[currentres] == res169[1] {
					scrW, scrH = 1366, 768
				} else if reslist[currentres] == res169[2] {
					scrW, scrH = 1600, 900
				} else if reslist[currentres] == res169[3] {
					scrW, scrH = 1760, 990
				} else if reslist[currentres] == res169[4] {
					scrW, scrH = 1920, 1080
				} else if reslist[currentres] == res169[5] {
					scrW, scrH = 2560, 1440
				} else if reslist[currentres] == res169[5] {
					scrW, scrH = 3840, 3840
				}
				scrW32, scrH32 = int32(scrW), int32(scrH)
				scrWF32, scrHF32 = float32(scrW), float32(scrH)

				rl.SetWindowSize(scrW, scrH)
				rl.SetWindowPosition(int(cnt.X)-scrW/2, int(cnt.Y)-scrH/2)
				xxl = false
				xl = false
				med = false
				if scrH >= 2160 {
					cam2.Zoom = 4
					xxl = true
				} else if scrH >= 1440 && scrH < 2160 {
					cam2.Zoom = 3
					xl = true
				} else if scrH == 1200 {
					cam2.Zoom = 1.65
					lrg = true
				} else if scrH > 1050 && scrH < 1200 {
					cam2.Zoom = 2.5
					lrg = true
				} else if scrH >= 990 && scrH <= 1050 {
					cam2.Zoom = 2
					lrg = true
				} else if scrH >= 900 && scrH < 990 {
					cam2.Zoom = 2
					lrg = true
				} else if scrH >= 720 && scrH < 900 {
					cam2.Zoom = 1.75
					med = true
				} else if scrH >= 600 && scrH < 720 {
					cam2.Zoom = 0.8
				} else if scrH < 600 && scrH > 300 {
					cam2.Zoom = 0.5
				} else if scrH < 300 {
					cam2.Zoom = 0.2
				}
				if med {
					scanlines = false
					pixels = false
				}
				//CAM STRUCTURES
				cntr := rl.NewVector2(scrWF32/2, scrHF32)
				camStrucs.Zoom = 1
				camStrucs.Target.Y = cntr.Y
				camStrucs.Offset.X = scrWF32 / 2
				camStrucs.Offset.Y = scrHF32 / 2
				if xl {
					camStrucs.Zoom = 1.5
					camStrucs.Offset.Y = scrHF32 / 0.67
				} else if xxl {
					camStrucs.Zoom = 2.25
					camStrucs.Offset.Y = scrHF32 / 0.89
				} else if med {
					camStrucs.Zoom = 0.75
					camStrucs.Offset.Y = scrHF32 / 1.34
				} else if lrg {
					camStrucs.Zoom = 1
					camStrucs.Offset.Y = scrHF32
				}
				//CAM MAP
				camMap.Zoom = 0.1
				if xxl {
					camMap.Zoom = 0.2
				}
				if xl {
					camMap.Zoom = 0.15
				}
				//CAM INVEN
				camInven.Zoom = 1
				camInven.Target = cnt
				camInven.Offset.X = scrWF32 / 2
				camInven.Offset.Y = optionsRec.Height / 4.05
				if xl {
					camInven.Zoom = 1.5
					camInven.Offset.Y = scrHF32 / 1.35
				} else if xxl {
					camInven.Zoom = 2.25
					camInven.Offset.Y = scrHF32 / 0.89
				} else if med {
					camInven.Zoom = 0.8
					camInven.Offset.Y = optionsRec.Height / 5
				}
				//CAM BASE
				if scrHF32 > 720 {
					diff := scrHF32 - 720
					diff = diff / 720
					camBase.Zoom = 1 + diff
				} else if scrHF32 == 720 {
					camBase.Zoom = 1
				}
				camBase.Target = cnt
				camBase.Offset.X = scrWF32 / 2
				camBase.Offset.Y = scrHF32 / 2
				camBoss.Target = cnt
				camBoss.Zoom = 3
				camBoss.Offset.X = scrWF32 / 2
				camBoss.Offset.Y = scrHF32 / 2

				//CAM END GAME
				camEnd.Zoom = 1
				if xl {
					camEnd.Zoom = 1.5
				}
				if xxl {
					camEnd.Zoom = 2.5
				}
				if med {
					camEnd.Zoom = 0.75
				}
				camEnd.Target = cnt
				camEnd.Offset.X = scrWF32 / 2
				camEnd.Offset.Y = scrHF32 / 2

			}
			makescan()

			prevres = currentres
		}

		y += txs + txs/4
		x = optionsRec.ToInt32().X + 32

		swchY = float32(y)
		swchX = (optionsRec.X + optionsRec.Width) - b2
		backrec = rl.NewRectangle(optionsRec.X+4, swchY-2, optionsRec.Width-8, b+bq)
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if rl.IsKeyPressed(rl.KeyA) || rl.IsKeyPressed(rl.KeyLeft) || rl.GetGamepadAxisMovement(0, 0) < 0 || rl.IsGamepadButtonPressed(0, 4) {
				if windowType == 1 {
					windowType = 0
				} else {
					windowType = 1
				}
			}
			if rl.IsKeyPressed(rl.KeyD) || rl.IsKeyPressed(rl.KeyRight) || rl.GetGamepadAxisMovement(0, 0) > 0 || rl.IsGamepadButtonPressed(0, 2) {
				if windowType == 1 {
					windowType = 0
				} else {
					windowType = 1
				}
			}
		}
		rl.DrawText("display >>", x-3, y+3, txs, DarkRed())
		rl.DrawText("display >>", x-1, y+1, txs, rl.Black)
		rl.DrawText("display >>", x, y, txs, rl.Black)
		txtlen := rl.MeasureText("display >>", txs)
		x += txtlen + txs
		switch windowType {
		case 0:
			rl.DrawText("fullscreen", x-3, y+3, txs, DarkRed())
			rl.DrawText("fullscreen", x-1, y+1, txs, rl.Black)
			rl.DrawText("fullscreen", x, y, txs, rl.Black)
		case 1:
			rl.DrawText("window", x-3, y+3, txs, DarkRed())
			rl.DrawText("window", x-1, y+1, txs, rl.Black)
			rl.DrawText("window", x, y, txs, rl.Black)
		}

		windowType = oplr(windowType, 1, swchX, swchY)
		if prevWindowType != windowType {
			rl.PlaySound(audfx[44])
			switch windowType {
			case 0:
				if rl.IsWindowState(rl.FlagBorderlessWindowedMode) {
					rl.ClearWindowState(rl.FlagBorderlessWindowedMode)
				}
				if !rl.IsWindowFullscreen() {
					rl.ToggleFullscreen()
				}
			case 1:
				if rl.IsWindowFullscreen() {
					rl.ToggleFullscreen()
				}
				if rl.IsWindowState(rl.FlagBorderlessWindowedMode) {
					rl.ClearWindowState(rl.FlagBorderlessWindowedMode)
				}
				rl.SetWindowSize(scrW, scrH)
				rl.SetWindowPosition(int(cnt.X)-scrW/2, int(cnt.Y)-scrH/2)
			}
			prevWindowType = windowType
		}

		y += txs + txs/4
		x = optionsRec.ToInt32().X + 32

		//CONTROLLER IMG
		x2 := float32(x)
		y2 := float32(y) - b/3
		siz := b4
		rec3 := rl.NewRectangle(x2, y2, siz, siz)
		rl.DrawTexturePro(imgs, etc[199], rec3, rl.Vector2Zero(), 0, rl.White)
		x += int32(siz + b/2)
		xorig := x
		swchY = float32(y)
		swchX = (optionsRec.X + optionsRec.Width) - b2
		backrec = rl.NewRectangle(optionsRec.X+optionsRec.Width/4, swchY-2, ((optionsRec.Width/4)*3)-4, b+bq)
		txt2 := fmt.Sprintf("%.2f", stickMov)
		txt2 = strings.TrimLeft(txt2, "0.")
		num2, err := strconv.Atoi(txt2)
		if err != nil {

		}
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if rl.IsKeyPressed(rl.KeyA) || rl.IsKeyPressed(rl.KeyLeft) || rl.GetGamepadAxisMovement(0, 0) < 0 || rl.IsGamepadButtonPressed(0, 4) {
				if num2 > 0 {
					rl.PlaySound(audfx[44])
					num2--
					if stickMov > 0 {
						stickMov -= 0.01
					}
					stickMovdis = num2
				}
			}
			if rl.IsKeyPressed(rl.KeyD) || rl.IsKeyPressed(rl.KeyRight) || rl.GetGamepadAxisMovement(0, 0) > 0 || rl.IsGamepadButtonPressed(0, 2) {
				if num2 < 99 {
					rl.PlaySound(audfx[44])
					num2++
					if stickMov < 0.99 {
						stickMov += 0.01
					}
					stickMovdis = num2
				}
			}
		}
		rl.DrawText("cursor speed", x-3, y+3, txs, DarkRed())
		rl.DrawText("cursor speed", x-1, y+1, txs, rl.Black)
		rl.DrawText("cursor speed", x, y, txs, rl.Black)

		stickMovdis = opadj(num2, 99, swchX, swchY, true, 1)

		y += txs + txs/4
		x = xorig

		swchY = float32(y)
		swchX = (optionsRec.X + optionsRec.Width) - b2
		backrec = rl.NewRectangle(optionsRec.X+optionsRec.Width/4, swchY-2, ((optionsRec.Width/4)*3)-4, b+bq)
		txt2 = fmt.Sprintf("%.2f", deadZ)
		txt2 = strings.TrimLeft(txt2, "0.")
		num2, err = strconv.Atoi(txt2)
		if err != nil {

		}
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if rl.IsKeyPressed(rl.KeyA) || rl.IsKeyPressed(rl.KeyLeft) || rl.GetGamepadAxisMovement(0, 0) < 0 || rl.IsGamepadButtonPressed(0, 4) {
				if num2 > 0 {
					rl.PlaySound(audfx[44])
					num2--
					if deadZ > 0 {
						deadZ -= 0.01
					}
					deadZDis = num2
				}
			}
			if rl.IsKeyPressed(rl.KeyD) || rl.IsKeyPressed(rl.KeyRight) || rl.GetGamepadAxisMovement(0, 0) > 0 || rl.IsGamepadButtonPressed(0, 2) {
				if num2 < 99 {
					rl.PlaySound(audfx[44])
					num2++
					if deadZ < 0.99 {
						deadZ += 0.01
					}
					deadZDis = num2
				}
			}
		}
		rl.DrawText("dead zone", x-3, y+3, txs, DarkRed())
		rl.DrawText("dead zone", x-1, y+1, txs, rl.Black)
		rl.DrawText("dead zone", x, y, txs, rl.Black)
		deadZDis = opadj(num2, 99, swchX, swchY, true, 2)

		//MOUSE + KEYB
		y += txs + (txs/12)*9
		txt := ">> mouse+keyb recommended"
		txlen = rl.MeasureText(txt, txs)
		x = int32(cnt.X) - txlen/2
		rl.DrawText(txt, x-3, y+3, txs, DarkRed())
		rl.DrawText(txt, x-1, y+1, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, rl.Black)

		//HELP
		y += txs + txs/2
		y2 = float32(y)
		//txs = tx6
		H := float32(txs) + b/2
		siz2 = b7
		spc := b / 2

		rec := rl.NewRectangle(cnt.X-(siz2+spc/2), y2, siz2, H)
		if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
			rl.DrawRectangleRec(rec, rl.Pink)
			if inpL {
				rl.PlaySound(audfx[44])
				helpon = true
			}
		} else {
			rl.DrawRectangleRec(rec, rl.Blue)
		}
		rl.DrawRectangleLinesEx(rec, 4, rl.Black)
		txt = "help"
		txlen = rl.MeasureText(txt, txs)
		xtx := int32(rec.X+rec.Width/2) - txlen/2
		ytx := int32(rec.Y+rec.Height/2) - txs/2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)

		//CREDITS
		rec.X += rec.Width + spc
		if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
			rl.DrawRectangleRec(rec, rl.Pink)
			if inpL {
				rl.PlaySound(audfx[44])
				credits = true
			}
		} else {
			rl.DrawRectangleRec(rec, rl.Blue)
		}
		rl.DrawRectangleLinesEx(rec, 4, rl.Black)
		txt = "credits"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(rec.X+rec.Width/2) - txlen/2
		ytx = int32(rec.Y+rec.Height/2) - txs/2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)

		//LOAD
		rec.Y += rec.Height + spc
		rec.X = cnt.X - (siz2 + spc/2)
		if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
			rl.DrawRectangleRec(rec, rl.Pink)
			if inpL {
				rl.PlaySound(audfx[44])
				ReadSaves()
				savenum = 0
				loadon = true
			}
		} else {
			rl.DrawRectangleRec(rec, rl.Blue)
		}
		rl.DrawRectangleLinesEx(rec, 4, rl.Black)
		txt = "load"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(rec.X+rec.Width/2) - txlen/2
		ytx = int32(rec.Y+rec.Height/2) - txs/2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)

		//EXIT
		rec.X += rec.Width + spc
		if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
			rl.DrawRectangleRec(rec, rl.Pink)
			if inpL {
				rl.PlaySound(audfx[44])
				exitmsg = exitTxt[RandInt(0, len(exitTxt))]
				exit = true
			}
		} else {
			rl.DrawRectangleRec(rec, rl.Blue)
		}
		rl.DrawRectangleLinesEx(rec, 4, rl.Black)
		txt = "exit"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(rec.X+rec.Width/2) - txlen/2
		ytx = int32(rec.Y+rec.Height/2) - txs/2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)

		//DISCONNECT TXT
		if disconnectT > 0 {
			ytx = rec.ToInt32().Y + rec.ToInt32().Height + tx
			txt := "controller disconnected"
			txlen = rl.MeasureText(txt, txs)
			x = int32(cnt.X) - txlen/2
			rl.DrawText(txt, x-3, ytx+3, txs, DarkRed())
			rl.DrawText(txt, x-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, x, ytx, txs, RandColor())
			disconnectT--
		}

	}

	rl.EndMode2D()
}
func drawgameover() { //MARK:DRAW GAME OVER
	rl.DrawRectangle(0, 0, scrW32, scrH32, rl.Fade(rl.Black, gameoverfd))
	if gameoverfd < 1 && !baseon {
		gameoverfd += 0.02
	} else {
		pause = true

	}
	cntr := rl.NewVector2(scrWF32/2, scrHF32/2)
	gameoverRec = rl.NewRectangle(cntr.X-gameoverRec.Width/2, cntr.Y-gameoverRec.Height/2, gameoverRec.Width, gameoverRec.Height)
	if !baseon {
		rl.DrawTexturePro(imgs, gameoveranimRec, drec(gameoverRec), orgn(gameoverRec), gameoverRo, rl.White)
		gameoverRo += 12
	}

	if gameoverRec.Y > -scrHF32/2 {
		if frames%2 == 0 {
			chng := float32(24)
			gameoverRec.Y -= chng
			gameoverRec.X -= chng
			gameoverRec.Width += chng * 2
			gameoverRec.Height += chng * 2
		}
	} else {
		if !gameoverreset {
			Reset()
			gameoverreset = true
		}
		baseon = true
	}

	if baseon {
		if gameoverfd > 0 {
			gameoverfd -= 0.01
		} else {
			gameover = false
		}
	}

	gameoveranimRec.X += anm[205].W
	if gameoveranimRec.X > anm[205].X+anm[205].frames*anm[205].W {
		gameoveranimRec.X = anm[205].X
	}

}
func drawStartScreen() { //MARK:DRAW START SCREEN
	//BG
	for i := 0; i < len(introbg); i++ {
		rec := rl.NewRectangle(introbg[i].v2.X-introbg[i].siz/2, introbg[i].v2.Y-introbg[i].siz/2, introbg[i].siz, introbg[i].siz)
		if xxl {
			rec = rl.NewRectangle(introbg[i].v2.X-introbg[i].siz, introbg[i].v2.Y-introbg[i].siz, introbg[i].siz*2, introbg[i].siz*2)
		}
		switch introbgimgnum {
		case 1:
			rl.DrawTexturePro(imgs, etc[193], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].col, introbg[i].fd))
		case 2:
			rl.DrawTexturePro(imgs, etc[194], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].col, introbg[i].fd))
		case 3:
			rl.DrawTexturePro(imgs, etc[195], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].col, introbg[i].fd))
		case 4:
			rl.DrawTexturePro(imgs, etc[196], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].col, introbg[i].fd))
		}

		introbg[i].v2.X += introbg[i].dirX + delta
		introbg[i].v2.Y += introbg[i].dirY + delta

		if introbg[i].v2.X > scrWF32+introbg[i].siz {
			introbg[i].v2.X = -introbg[i].siz
		}
		if introbg[i].v2.Y > scrHF32+introbg[i].siz {
			introbg[i].v2.Y = -introbg[i].siz
		}
		if introbg[i].v2.X < -introbg[i].siz {
			introbg[i].v2.X = scrWF32 + introbg[i].siz
		}
		if introbg[i].v2.Y < -introbg[i].siz {
			introbg[i].v2.Y = scrHF32 + introbg[i].siz
		}
		introbg[i].ro += 4
	}
	txs := tx10
	if med {
		txs = tx7
	}
	if xxl {
		txs = tx10 * 2
	}
	txlen := rl.MeasureText("select save", txs)
	x := int32(cnt.X) - txlen/2
	y := tx10 + tx5
	if med {
		y -= tx4
	}
	if xxl {
		y += tx4
	}
	rl.DrawText("select save", x-5, y+5, txs, rl.Magenta)
	rl.DrawText("select save", x-2, y+2, txs, rl.Black)
	rl.DrawText("select save", x, y, txs, RandColor())

	W := b10 + b4
	H := b3
	if med {
		W = b10
		H = b2 + b/2
	}
	if xxl {
		W = b10 * 2
		H = b5
	}
	y2 := float32(y+txs) + b
	if xxl {
		y2 += b
	}

	rec2 := rl.NewRectangle(cnt.X-W/2, y2, W, H)
	if savenum == 0 {
		rl.DrawRectangleRec(rec2, rl.Fade(rl.Magenta, fadeblinkF))
	}
	rl.DrawRectangleLinesEx(rec2, 4, rl.Orange) //0
	txt := "empty"
	if save1 {
		txt = "one"
		if delsave && delsaveNum == 1 {
			txt = "delete?"
		}
	}
	txs = tx6
	if med {
		txs = tx4
	}
	if xxl {
		txs = tx10
	}
	txlen = rl.MeasureText(txt, txs)
	x = int32(cnt.X) - txlen/2
	y = rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
	rl.DrawText(txt, x-4, y+4, txs, BrightPink())
	rl.DrawText(txt, x-2, y+2, txs, rl.Black)
	rl.DrawText(txt, x, y, txs, rl.White)
	if rl.CheckCollisionPointRec(cursorV2, rec2) {
		if savenum != 0 {
			rl.PlaySound(audfx[40])
		}
		savenum = 0
		if inpL {
			if delsave && delsaveNum == 1 {
				clearsave(1)
				delsave = false
				rl.PlaySound(audfx[43])
				delsaveNum = 0
			} else if delsave && delsaveNum != 1 {
				delsave = false
				rl.PlaySound(audfx[43])
				delsaveNum = 0
			} else {
				rl.PlaySound(audfx[41])
				selSave = 1
			}
		}
		if inpR && save1 {
			if !delsave {
				delsaveNum = 1
				rl.PlaySound(audfx[42])
			} else {
				delsaveNum = 0
			}
			delsave = !delsave
		}
	}
	rec2.Y += H + b
	if xxl {
		rec2.Y += b
	}
	if savenum == 1 {
		rl.DrawRectangleRec(rec2, rl.Fade(rl.Magenta, fadeblinkF))
	}
	rl.DrawRectangleLinesEx(rec2, 4, rl.Orange) //1
	txt = "empty"
	if save2 {
		txt = "two"
		if delsave && delsaveNum == 2 {
			txt = "delete?"
		}
	}
	txlen = rl.MeasureText(txt, txs)
	x = int32(cnt.X) - txlen/2
	y = rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
	rl.DrawText(txt, x-4, y+4, txs, BrightPink())
	rl.DrawText(txt, x-2, y+2, txs, rl.Black)
	rl.DrawText(txt, x, y, txs, rl.White)
	if rl.CheckCollisionPointRec(cursorV2, rec2) {
		if savenum != 1 {
			rl.PlaySound(audfx[40])
		}
		savenum = 1
		if inpL {
			if delsave && delsaveNum == 2 {
				clearsave(2)
				delsave = false
				rl.PlaySound(audfx[43])
				delsaveNum = 0
			} else if delsave && delsaveNum != 2 {
				delsave = false
				rl.PlaySound(audfx[43])
				delsaveNum = 0
			} else {
				rl.PlaySound(audfx[41])
				selSave = 2
			}
		}
		if inpR && save2 {
			if !delsave {
				rl.PlaySound(audfx[42])
				delsaveNum = 2
			} else {
				delsaveNum = 0
			}
			delsave = !delsave
		}
	}
	rec2.Y += H + b
	if xxl {
		rec2.Y += b
	}
	if savenum == 2 {
		rl.DrawRectangleRec(rec2, rl.Fade(rl.Magenta, fadeblinkF))
	}
	rl.DrawRectangleLinesEx(rec2, 4, rl.Orange) //2
	txt = "empty"
	if save3 {
		txt = "three"
		if delsave && delsaveNum == 3 {
			txt = "delete?"
		}
	}
	txlen = rl.MeasureText(txt, txs)
	x = int32(cnt.X) - txlen/2
	y = rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
	rl.DrawText(txt, x-4, y+4, txs, BrightPink())
	rl.DrawText(txt, x-2, y+2, txs, rl.Black)
	rl.DrawText(txt, x, y, txs, rl.White)
	if rl.CheckCollisionPointRec(cursorV2, rec2) {
		if savenum != 2 {
			rl.PlaySound(audfx[40])
		}
		savenum = 2
		if inpL {
			if delsave && delsaveNum == 3 {
				clearsave(3)
				delsave = false
				rl.PlaySound(audfx[43])
				delsaveNum = 0
			} else if delsave && delsaveNum != 3 {
				delsave = false
				rl.PlaySound(audfx[43])
				delsaveNum = 0
			} else {
				rl.PlaySound(audfx[41])
				selSave = 3
			}
		}
		if inpR && save3 {
			if !delsave {
				rl.PlaySound(audfx[42])
				delsaveNum = 3
			} else {
				delsaveNum = 0
			}
			delsave = !delsave
		}
	}
	//DELETE TXT
	if save1 || save2 || save3 {

		y += rec2.ToInt32().Height + txs/2
		txt = "right click to delete"
		txt2 := ""
		if mouseoff {
			txt = "xbox x / l trigger to delete"
		}
		if delsave {
			txt = "left click confirm"
			txt2 = "right click cancel"
			if mouseoff {
				txt = "xbox a & r trigger confirm"
				txt2 = "xbox x & l trigger cancel"
			}
		}
		txlen = rl.MeasureText(txt, txs)
		x = int32(cnt.X) - txlen/2
		rl.DrawText(txt, x-4, y+4, txs, BrightPink())
		rl.DrawText(txt, x-2, y+2, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, rl.White)
		y += txs + txs/4
		txlen = rl.MeasureText(txt2, txs)
		x = int32(cnt.X) - txlen/2
		rl.DrawText(txt2, x-4, y+4, txs, BrightPink())
		rl.DrawText(txt2, x-2, y+2, txs, rl.Black)
		rl.DrawText(txt2, x, y, txs, rl.White)
	}

	//FADE IN REC
	if introfd > 0 {
		rec := rl.NewRectangle(0, 0, scrWF32, scrHF32)
		introfd -= 0.02
		rl.DrawRectangleRec(rec, rl.Fade(rl.Black, introfd))
	}

	if rl.IsKeyPressed(rl.KeyDown) || rl.IsKeyPressed(rl.KeyS) {
		savenum++
		if savenum > 2 {
			savenum = 0
		}
	}
	if rl.IsKeyPressed(rl.KeyUp) || rl.IsKeyPressed(rl.KeyW) {
		savenum--
		if savenum < 0 {
			savenum = 2
		}
	}

	if selSave != 0 {
		currentSave = selSave
		rl.DrawRectangle(0, 0, scrW32, scrH32, rl.Black)
		if introAnim.X < anm[204].X+anm[204].frames*anm[204].W {
			siz2 := b10 * 2
			if lrg {
				siz2 = b10 * 3
			}
			if xl {
				siz2 = b10 * 4
			}
			if xxl {
				siz2 = b10 * 7
			}
			rec2 := rl.NewRectangle(cnt.X-siz2/2, cnt.Y-siz2/2, siz2, siz2)
			rl.DrawTexturePro(imgs, introAnim, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.5, 0.7)))
			rl.DrawTexturePro(imgs, introAnim, brec(rec2, 7), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.3, 0.5)))
			rl.DrawTexturePro(imgs, introAnim, brec(rec2, 12), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.1, 0.3)))
			if frames%3 == 0 {
				introAnim.X += anm[204].W
			}
		} else {
			introAnim.X = anm[204].X

			switch selSave {
			case 1:
				if save1 {
					copy(storeItm, savestore1)
					storeunlocked = true
					for i := 0; i < len(base.nm); i++ {
						if base.nm[i] == "store room" {
							base.unlock[i] = true
						}
					}
				}
			case 2:
				if save2 {
					copy(storeItm, savestore2)
					storeunlocked = true
					for i := 0; i < len(base.nm); i++ {
						if base.nm[i] == "store room" {
							base.unlock[i] = true
						}
					}
				}
			case 3:
				if save3 {
					copy(storeItm, savestore3)
					storeunlocked = true
					for i := 0; i < len(base.nm); i++ {
						if base.nm[i] == "store room" {
							base.unlock[i] = true
						}
					}
				}
			}

			rl.StopMusicStream(music[currentMusic])
			currentMusic = 2
			rl.PlayMusicStream(music[currentMusic])
			selSave = 0
			savenum = 0
			startScreen = false
			baseon = true

		}
	}

}
func drawIntro() { //MARK:DRAW INTRO

	if gamestartT > 0 {
		gamestartT--
	} else {

		if introT1 > 0 { //UNKLNIK LOGO
			W := etc[190].Width
			H := etc[190].Height
			if lrg || xl {
				W = W / 1.5
				H = H / 1.5
			}
			if med {
				W = W / 2.5
				H = H / 2.5
			}
			unklnikRec = rl.NewRectangle(cnt.X-W/2, cnt.Y-H/2, W, H)
			rl.DrawTexturePro(imgs, etc[190], unklnikRec, rl.Vector2Zero(), 0, rl.Fade(rl.White, unklnikLogoF))
			if unklnikLogoF < 1 {
				unklnikLogoF += 0.005
			}
			introT1--
			if introT1 == 1 {
				W2 := etc[191].Width
				H2 := etc[191].Height
				if med {
					W2 = W2 / 2
					H2 = H2 / 2
				}
				if xxl {
					W2 = W2 * 1.5
					H2 = H2 * 1.5
				}
				goLogoRec = rl.NewRectangle(0-W2, cnt.Y-H2/2, W2, H2)
			}
		} else if introT2 > 0 { //GO LOGO
			rl.DrawTexturePro(imgs, etc[190], unklnikRec, rl.Vector2Zero(), 0, rl.White)
			rl.DrawTexturePro(imgs, etc[191], goLogoRec, rl.Vector2Zero(), 0, rl.White)
			if unklnikRec.X < scrWF32 {
				unklnikRec.X += 20
			}
			if goLogoRec.X < cnt.X-goLogoRec.Width/2 {
				goLogoRec.X += 20
			} else {
				introT2--
			}
		} else if introT3 > 0 { //RAYLIB LOGO
			siz := b10
			if med {
				siz = b5
			}
			if xxl {
				siz = siz + b5
			}
			rec := rl.NewRectangle(cnt.X-siz/2, cnt.Y-siz/2, siz, siz)
			rl.DrawTexturePro(raylibAnim[raylibFrameNum], raylibRec, rec, rl.Vector2Zero(), 0, rl.White)

			if raylibFrameNum < len(raylibAnim)-1 {
				if frames%3 == 0 {
					raylibFrameNum++
				}
			} else {
				introT3--
			}
		} else { //MR SNUGGLES LOGO

			if inpL || rl.IsKeyPressed(rl.KeySpace) || rl.IsKeyPressed(rl.KeyEnter) {
				endIntro = true
				rl.PlaySound(audfx[44])
			}
			//BG
			for i := 0; i < len(introbg); i++ {
				rec := rl.NewRectangle(introbg[i].v2.X-introbg[i].siz/2, introbg[i].v2.Y-introbg[i].siz/2, introbg[i].siz, introbg[i].siz)
				if xxl {
					rec = rl.NewRectangle(introbg[i].v2.X-introbg[i].siz, introbg[i].v2.Y-introbg[i].siz, introbg[i].siz*2, introbg[i].siz*2)
				}
				switch introbgimgnum {
				case 1:
					rl.DrawTexturePro(imgs, etc[193], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].col, introbg[i].fd))
				case 2:
					rl.DrawTexturePro(imgs, etc[194], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].col, introbg[i].fd))
				case 3:
					rl.DrawTexturePro(imgs, etc[195], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].col, introbg[i].fd))
				case 4:
					rl.DrawTexturePro(imgs, etc[196], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].col, introbg[i].fd))
				}

				introbg[i].v2.X += introbg[i].dirX + delta
				introbg[i].v2.Y += introbg[i].dirY + delta

				if introbg[i].v2.X > scrWF32+introbg[i].siz {
					introbg[i].v2.X = -introbg[i].siz
				}
				if introbg[i].v2.Y > scrHF32+introbg[i].siz {
					introbg[i].v2.Y = -introbg[i].siz
				}
				if introbg[i].v2.X < -introbg[i].siz {
					introbg[i].v2.X = scrWF32 + introbg[i].siz
				}
				if introbg[i].v2.Y < -introbg[i].siz {
					introbg[i].v2.Y = scrHF32 + introbg[i].siz
				}
				introbg[i].ro += 4
			}

			siz := b10 * 2
			if med {
				siz = b10 + b2
			}
			if xxl {
				siz = b10 * 4
			}

			rec2 := rl.NewRectangle(cnt.X-siz/2, cnt.Y-siz/2, siz, siz)
			rec2.Y -= b2
			rl.DrawTexturePro(imgs, etc[192], rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, introfd))
			if introfd < 1 {
				introfd += 0.01
			}
			txt := "press start"
			txs := tx6
			if med {
				txs = tx3
			}
			if xxl {
				txs = tx10
			}
			txlen := rl.MeasureText(txt, txs)
			xtx := int32(cnt.X) - txlen/2
			ytx := int32(rec2.Y + rec2.Height + b)
			if onoff15 {
				rl.DrawText(txt, xtx-4, ytx+4, txs, rl.Yellow)
			} else {
				rl.DrawText(txt, xtx-4, ytx+4, txs, rl.Orange)
			}
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
			if onoff15 {
				rl.DrawText(txt, xtx, ytx, txs, rl.Magenta)
			} else {
				rl.DrawText(txt, xtx, ytx, txs, BrightPink())
			}

			//VERSION
			txt = "v1.00"
			txs = tx2
			if med {
				txs = tx
			}
			if xxl {
				txs = tx4
			}
			txlen = rl.MeasureText(txt, txs)
			xtx = scrW32 - (txlen * 2)
			ytx = scrH32 - (txs * 2)
			rl.DrawText(txt, xtx, ytx, txs, rl.Magenta)

			if endIntro {
				rec3 := rl.NewRectangle(0, 0, scrWF32, scrHF32)
				rl.DrawRectangleRec(rec3, rl.Fade(rl.Black, introfd2))
				if introfd2 < 1 {
					introfd2 += 0.02
				} else {
					intro = false
					startScreen = true
					introfd2 = 0
					introfd = 1
				}
			}

		}
		if introT3 > 0 {
			if rl.IsKeyPressed(rl.KeySpace) || inpL {
				introT1 = 0
				introT2 = 0
				introT3 = 0
			}
		}
	}
}

func drawexit() { //MARK:DRAW EXIT

	rl.DrawRectangleRec(optionsRec, rl.Black)
	//BG
	for i := 0; i < len(introbg); i++ {
		rec := rl.NewRectangle(introbg[i].v2.X-introbg[i].siz/2, introbg[i].v2.Y-introbg[i].siz/2, introbg[i].siz, introbg[i].siz)
		switch introbgimgnum {
		case 1:
			rl.DrawTexturePro(imgs, etc[193], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].col, introbg[i].fd))
		case 2:
			rl.DrawTexturePro(imgs, etc[194], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].col, introbg[i].fd))
		case 3:
			rl.DrawTexturePro(imgs, etc[195], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].col, introbg[i].fd))
		case 4:
			rl.DrawTexturePro(imgs, etc[196], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].col, introbg[i].fd))
		}

		introbg[i].v2.X += introbg[i].dirX + delta
		introbg[i].v2.Y += introbg[i].dirY + delta

		if introbg[i].v2.X > scrWF32+introbg[i].siz {
			introbg[i].v2.X = -introbg[i].siz
		}
		if introbg[i].v2.Y > scrHF32+introbg[i].siz {
			introbg[i].v2.Y = -introbg[i].siz
		}
		if introbg[i].v2.X < -introbg[i].siz {
			introbg[i].v2.X = scrWF32 + introbg[i].siz
		}
		if introbg[i].v2.Y < -introbg[i].siz {
			introbg[i].v2.Y = scrHF32 + introbg[i].siz
		}
		introbg[i].ro += 4
	}

	cntr := rl.NewVector2(scrWF32/2, scrHF32/2)
	txs := tx5
	txlen := rl.MeasureText(exitmsg, txs)

	camCnt := rl.GetScreenToWorld2D(cntr, camInven)
	xtx := int32(camCnt.X) - txlen/2
	ytx := int32(camCnt.Y - b4)
	rl.DrawText(exitmsg, xtx, ytx, txs, rl.White)

	siz := b4
	txs = tx3
	H := float32(txs) + b
	spc := b
	x := camCnt.X - siz - spc/2
	y := camCnt.Y - b2

	rec := rl.NewRectangle(x, y, siz, H)
	txs = tx4
	ytx = int32(rec.Y+rec.Height/2) - txs/2
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		rl.DrawRectangleRec(rec, rl.Magenta)
		txlen = rl.MeasureText("yes", txs)
		xtx = int32(rec.X+rec.Width/2) - txlen/2
		rl.DrawText("yes", xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText("yes", xtx, ytx, txs, rl.Black)
		if inpL {
			if storeunlocked {
				savestore()
			}
			rl.StopMusicStream(music[currentMusic])
			rl.EndMode2D()
			rl.EndTextureMode()
			rl.EndShaderMode()
			rl.EndDrawing()
			unload()
			rl.CloseAudioDevice()
			rl.CloseWindow()
			os.Exit(0)
		}
	} else {
		txlen = rl.MeasureText("yes", txs)
		xtx = int32(rec.X+rec.Width/2) - txlen/2
		rl.DrawText("yes", xtx, ytx, txs, rl.White)
	}
	rl.DrawRectangleLinesEx(rec, 4, rl.Orange)

	rec.X += rec.Width + spc
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		rl.DrawRectangleRec(rec, rl.Magenta)
		txlen = rl.MeasureText("no", txs)
		xtx = int32(rec.X+rec.Width/2) - txlen/2
		rl.DrawText("no", xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText("no", xtx, ytx, txs, rl.Black)
		if inpL {
			rl.PlaySound(audfx[44])
			exit = false
		}
	} else {
		txlen = rl.MeasureText("no", txs)
		xtx = int32(rec.X+rec.Width/2) - txlen/2
		rl.DrawText("no", xtx, ytx, txs, rl.White)
	}
	rl.DrawRectangleLinesEx(rec, 4, rl.Orange)

	txs = tx2
	ytx = int32(y + H + b/2)
	txlen = rl.MeasureText("progress is saved up to last camp", txs)
	xtx = int32(camCnt.X) - txlen/2
	rl.DrawText("progress is saved up to last camp", xtx, ytx, txs, rl.White)

}

func drawWeaponShed() { //MARK:DRAW WEAPON SHED

	levStruc := 0
	for i := 0; i < len(base.nm); i++ {
		if base.nm[i] == "weapon shed" {
			levStruc = base.lev[i]
			break
		}
	}

	for i := 0; i < len(bgpix); i++ {
		rec := rl.NewRectangle(bgpix[i].v2.X, bgpix[i].v2.Y, bgpix[i].siz, bgpix[i].siz)
		rl.DrawRectangleRec(rec, rl.Fade(bgpix[i].col, bgpix[i].fd))
		bgpix[i].v2.X += bgpix[i].dirX
		bgpix[i].v2.Y += bgpix[i].dirY

		if bgpix[i].v2.X < 0 {
			bgpix[i].v2.X = scrWF32
		}
		if bgpix[i].v2.X > scrWF32 {
			bgpix[i].v2.X = 0
		}
		if bgpix[i].v2.Y < 0 {
			bgpix[i].v2.Y = scrHF32
		}
		if bgpix[i].v2.Y > scrHF32 {
			bgpix[i].v2.Y = 0
		}

		if bgpix[i].fd > 0 {
			bgpix[i].fd -= 0.005
		} else {
			bgpix[i].fd = RandF32(0.5, 1)
		}
	}

	rl.BeginMode2D(camStrucs)

	rl.DrawRectangleRec(storeRec, rl.Black)
	rl.DrawRectangleRec(storeRec, rl.Fade(rl.Orange, 0.7))

	//DRAW ORE
	leadnum, bronzenum, silvernum, goldnum, platinumnum := 0, 0, 0, 0, 0
	for i := 0; i < len(storeItm); i++ {
		if storeItm[i].nm == "lead" {
			leadnum += storeItm[i].numof
		}
		if storeItm[i].nm == "bronze" {
			bronzenum += storeItm[i].numof
		}
		if storeItm[i].nm == "silver" {
			silvernum += storeItm[i].numof
		}
		if storeItm[i].nm == "gold" {
			goldnum += storeItm[i].numof
		}
		if storeItm[i].nm == "platinum" {
			platinumnum += storeItm[i].numof
		}
	}
	for i := 0; i < len(pl.invn); i++ {
		if pl.invn[i].nm == "lead" {
			leadnum += pl.invn[i].numof
		}
		if pl.invn[i].nm == "bronze" {
			bronzenum += pl.invn[i].numof
		}
		if pl.invn[i].nm == "silver" {
			silvernum += pl.invn[i].numof
		}
		if pl.invn[i].nm == "gold" {
			goldnum += pl.invn[i].numof
		}
		if pl.invn[i].nm == "platinum" {
			platinumnum += pl.invn[i].numof
		}
	}
	siz := b2
	spc := float32(8)
	W := (siz + spc) * 15
	x := cnt.X - W/2
	y := b4
	for i := 0; i < 5; i++ {
		rec := rl.NewRectangle(x, y, siz, siz)
		rec2 := rec
		rec2.X -= 4
		rec2.Y += 4
		rl.DrawRectangleRec(rec2, rl.Black)
		rl.DrawRectangleRec(rec, rl.Black)
		rl.DrawRectangleRec(rec, rl.Fade(rl.DarkGray, 0.5))
		xtx := rec.ToInt32().X + rec.ToInt32().Width/2
		ytx := rec.ToInt32().Y + rec.ToInt32().Height + 4
		xtx2 := rec.ToInt32().X + rec.ToInt32().Width + 12
		ytx2 := rec.ToInt32().Y + 8
		txs := tx3
		txs2 := tx5
		txt := ""
		switch i {
		case 0:
			rl.DrawTexturePro(imgs, etc[53], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[53], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "lead"
			rl.DrawText(fmt.Sprint(leadnum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(leadnum), xtx2, ytx2, txs2, rl.Black)
		case 1:
			rl.DrawTexturePro(imgs, etc[52], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[52], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "bronze"
			rl.DrawText(fmt.Sprint(bronzenum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(bronzenum), xtx2, ytx2, txs2, rl.Black)
		case 2:
			rl.DrawTexturePro(imgs, etc[51], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[51], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "silver"
			rl.DrawText(fmt.Sprint(silvernum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(silvernum), xtx2, ytx2, txs2, rl.Black)
		case 3:
			rl.DrawTexturePro(imgs, etc[50], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[50], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "gold"
			rl.DrawText(fmt.Sprint(goldnum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(goldnum), xtx2, ytx2, txs2, rl.Black)
		case 4:
			rl.DrawTexturePro(imgs, etc[54], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[54], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "platinum"
			rl.DrawText(fmt.Sprint(platinumnum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(platinumnum), xtx2, ytx2, txs2, rl.Black)
		}
		txlen := rl.MeasureText(txt, txs)
		xtx -= txlen / 2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		x += (siz + spc) * 3
	}

	//WEAPONS
	var changeWeaps []bool
	changeWeaps = append(changeWeaps, false)
	for i := 0; i < 6; i++ {
		changeWeaps = append(changeWeaps, false)
	}
	if pl.wp1.nm != "" {
		changeWeaps[0] = true

	}
	if pl.wp2.nm != "" {
		changeWeaps[1] = true

	}
	if len(pl.weaps) > 0 {
		if len(pl.weaps) >= 1 {
			if pl.weaps[0].nm != "" {
				changeWeaps[2] = true
			}
		}
		if len(pl.weaps) >= 2 {
			if pl.weaps[1].nm != "" {
				changeWeaps[3] = true
			}
		}
		if len(pl.weaps) >= 3 {
			if pl.weaps[2].nm != "" {
				changeWeaps[4] = true
			}
		}
		if len(pl.weaps) == 4 {
			if pl.weaps[3].nm != "" {
				changeWeaps[5] = true
			}
		}
	}
	count := float32(0)
	for i := 0; i < len(changeWeaps); i++ {
		if changeWeaps[i] {
			count++
		}
	}
	siz = b3
	spc = 16
	W = count * (siz + spc)
	x = cnt.X - W/2
	y += b4
	selweapnm := ""
	selweaplev := 0
	for i := 0; i < len(changeWeaps); i++ {
		if changeWeaps[i] {
			rec := rl.NewRectangle(x, y, siz, siz)
			rec2 := rec
			rec2.X += 8
			rec2.Y += 8
			rec2.Width -= 16
			rec2.Height -= 16
			rec3 := rec2
			rec3.X -= 8
			rec3.Y += 8
			rl.DrawRectangleRec(rec3, rl.Magenta)
			rl.DrawRectangleRec(rec2, rl.Black)
			if selnumWeap == i {
				rl.DrawRectangleRec(rec2, rl.Fade(RandColor(), fadeblinkF))
			} else {
				if rl.CheckCollisionPointRec(cursorV2Strucs, rec) {
					if inpL {
						selnumWeap = i
					}
					rl.DrawRectangleRec(rec2, rl.Fade(rl.Green, fadeblinkF))
				} else {
					rl.DrawRectangleRec(rec2, rl.Fade(rl.DarkGray, 0.5))
				}
				rl.DrawRectangleLinesEx(rec2, 2, rl.Black)
			}
			if i == 0 {
				rl.DrawTexturePro(imgs, pl.wp1.img, shrec(rec, 12), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, pl.wp1.img, rec, rl.Vector2Zero(), 0, rl.White)
				if selnumWeap == i {
					selweapnm = pl.wp1.nm
					selweaplev = pl.wp1.level
				}
				//BONUS STARS
				if pl.wp1.spec1 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
				if pl.wp1.spec2 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					if pl.wp1.spec1 != 0 {
						rec3.X -= (siz / 12) * 9
					}
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
			}
			if i == 1 {
				rl.DrawTexturePro(imgs, pl.wp2.img, shrec(rec, 12), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, pl.wp2.img, rec, rl.Vector2Zero(), 0, rl.White)
				if selnumWeap == i {
					selweapnm = pl.wp2.nm
					selweaplev = pl.wp2.level
				}
				//BONUS STARS
				if pl.wp2.spec1 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
				if pl.wp2.spec2 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					if pl.wp2.spec1 != 0 {
						rec3.X -= (siz / 12) * 9
					}
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
			}
			if i == 2 {
				rl.DrawTexturePro(imgs, pl.weaps[0].img, shrec(rec, 12), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, pl.weaps[0].img, rec, rl.Vector2Zero(), 0, rl.White)
				if selnumWeap == i {
					selweapnm = pl.weaps[0].nm
					selweaplev = pl.weaps[0].level
				}
				//BONUS STARS
				if pl.weaps[0].spec1 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
				if pl.weaps[0].spec2 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					if pl.weaps[0].spec1 != 0 {
						rec3.X -= (siz / 12) * 9
					}
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
			}
			if i == 3 {
				rl.DrawTexturePro(imgs, pl.weaps[1].img, shrec(rec, 12), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, pl.weaps[1].img, rec, rl.Vector2Zero(), 0, rl.White)
				if selnumWeap == i {
					selweapnm = pl.weaps[1].nm
					selweaplev = pl.weaps[1].level
				}
				//BONUS STARS
				if pl.weaps[1].spec1 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
				if pl.weaps[1].spec2 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					if pl.weaps[1].spec1 != 0 {
						rec3.X -= (siz / 12) * 9
					}
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
			}
			if i == 4 {
				rl.DrawTexturePro(imgs, pl.weaps[2].img, shrec(rec, 12), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, pl.weaps[2].img, rec, rl.Vector2Zero(), 0, rl.White)
				if selnumWeap == i {
					selweapnm = pl.weaps[2].nm
					selweaplev = pl.weaps[2].level
				}
				//BONUS STARS
				if pl.weaps[2].spec1 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
				if pl.weaps[2].spec2 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					if pl.weaps[2].spec1 != 0 {
						rec3.X -= (siz / 12) * 9
					}
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
			}
			if i == 5 {
				rl.DrawTexturePro(imgs, pl.weaps[3].img, shrec(rec, 12), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, pl.weaps[3].img, rec, rl.Vector2Zero(), 0, rl.White)
				if selnumWeap == i {
					selweapnm = pl.weaps[3].nm
					selweaplev = pl.weaps[3].level
				}
				//BONUS STARS
				if pl.weaps[3].spec1 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
				if pl.weaps[3].spec2 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					if pl.weaps[3].spec1 != 0 {
						rec3.X -= (siz / 12) * 9
					}
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
			}
			x += siz + spc
		}
	}

	txs := tx6
	ytx := int32(y + b4)
	txt := selweapnm + " > level " + fmt.Sprint(selweaplev)
	txlen := rl.MeasureText(txt, txs)
	xtx := int32(cnt.X) - txlen/2
	rl.DrawText(txt, xtx-3, ytx+3, txs, rl.Magenta)
	rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
	rl.DrawText(txt, xtx, ytx, txs, rl.Black)
	ytx += txs + 24
	xtx = storeRec.ToInt32().X + 32
	txs = tx4
	linespc := txs + txs/2
	if storetxT > 0 {
		storetxT--
	}
	if storetxT2 > 0 {
		storetxT2--
	}
	if storetxT3 > 0 {
		storetxT3--
	}
	if selweaplev == 1 { //LEVEL 1
		txt = "level 2 > " + fmt.Sprint(leadcost) + " lead > +1 dmg"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(cnt.X) - txlen/2
		bgrec2 := rl.NewRectangle(storeRec.X, float32(ytx-4), storeRec.Width, float32(txs+8))
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if leadnum >= leadcost {
					upWeapon(selnumWeap, 2)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else {
					rl.PlaySound(audfx[43])
					storetxT = fps * 2
				}
			}
		}
		if leadnum >= leadcost {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 3 > " + fmt.Sprint(bronzecost) + " bronze > +2 dmg"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(cnt.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if bronzenum >= bronzecost {
					upWeapon(selnumWeap, 3)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else {
					rl.PlaySound(audfx[43])
					storetxT = fps * 2
				}
			}
		}
		if bronzenum >= bronzecost {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 4 > " + fmt.Sprint(silvercost) + " silver > +3 dmg"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(cnt.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if silvernum >= silvercost && levStruc >= 2 {
					upWeapon(selnumWeap, 4)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if silvernum >= silvercost && levStruc < 2 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if silvernum < silvercost {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if silvernum >= silvercost {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 5 > " + fmt.Sprint(goldcost) + " gold > +3 dmg +1 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(cnt.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if goldnum >= goldcost && levStruc >= 2 {
					upWeapon(selnumWeap, 5)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if goldnum >= goldcost && levStruc < 2 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if goldnum < goldcost {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if goldnum >= goldcost {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 6 > " + fmt.Sprint(platinumcost) + " platinum > +3 dmg +2 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(cnt.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if platinumnum >= platinumcost && levStruc == 3 {
					upWeapon(selnumWeap, 6)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if platinumnum >= platinumcost && levStruc < 3 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if platinumnum < platinumcost {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if platinumnum >= platinumcost {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
	} else if selweaplev == 2 { //LEVEL 2
		txt = "level 3 > " + fmt.Sprint(bronzecost) + " bronze > +2 dmg"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(cnt.X) - txlen/2
		bgrec2 := rl.NewRectangle(storeRec.X, float32(ytx-4), storeRec.Width, float32(txs+8))
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if bronzenum >= bronzecost {
					upWeapon(selnumWeap, 3)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else {
					rl.PlaySound(audfx[43])
					storetxT = fps * 2
				}
			}
		}
		if bronzenum >= bronzecost {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 4 > " + fmt.Sprint(silvercost) + " silver > +3 dmg +1 hp"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(cnt.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if silvernum >= silvercost && levStruc >= 2 {
					upWeapon(selnumWeap, 4)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if silvernum >= silvercost && levStruc < 2 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if silvernum < silvercost {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if silvernum >= silvercost {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 5 > " + fmt.Sprint(goldcost) + " gold > +3 dmg +1 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(cnt.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if goldnum >= goldcost && levStruc >= 2 {
					upWeapon(selnumWeap, 5)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if goldnum >= goldcost && levStruc < 2 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if goldnum < goldcost {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if goldnum >= goldcost {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 6 > " + fmt.Sprint(platinumcost) + " platinum > +3 dmg +2 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(cnt.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if platinumnum >= platinumcost && levStruc == 3 {
					upWeapon(selnumWeap, 6)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if platinumnum >= platinumcost && levStruc < 3 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if platinumnum < platinumcost {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if platinumnum >= platinumcost {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
	} else if selweaplev == 3 { //LEVEL 3
		txt = "level 4 > " + fmt.Sprint(silvercost) + " silver > +3 dmg +1 hp"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(cnt.X) - txlen/2
		bgrec2 := rl.NewRectangle(storeRec.X, float32(ytx-4), storeRec.Width, float32(txs+8))
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if silvernum >= silvercost && levStruc >= 2 {
					upWeapon(selnumWeap, 4)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if silvernum >= silvercost && levStruc < 2 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if silvernum < silvercost {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if silvernum >= silvercost {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 5 > " + fmt.Sprint(goldcost) + " gold > +3 dmg +1 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(cnt.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if goldnum >= goldcost && levStruc >= 2 {
					upWeapon(selnumWeap, 5)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if goldnum >= goldcost && levStruc < 2 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if goldnum < goldcost {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if goldnum >= goldcost {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 6 > " + fmt.Sprint(platinumcost) + " platinum > +3 dmg +2 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(cnt.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if platinumnum >= platinumcost && levStruc == 3 {
					upWeapon(selnumWeap, 6)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if platinumnum >= platinumcost && levStruc < 3 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if platinumnum < platinumcost {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if platinumnum >= platinumcost {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
	} else if selweaplev == 4 { //LEVEL 4
		txt = "level 5 > " + fmt.Sprint(goldcost) + " gold > +3 dmg +1 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(cnt.X) - txlen/2
		bgrec2 := rl.NewRectangle(storeRec.X, float32(ytx-4), storeRec.Width, float32(txs+8))
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if goldnum >= goldcost && levStruc >= 2 {
					upWeapon(selnumWeap, 5)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if goldnum >= goldcost && levStruc < 2 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if goldnum < goldcost {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if goldnum >= goldcost {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 6 > " + fmt.Sprint(platinumcost) + " platinum > +3 dmg +2 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(cnt.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if platinumnum >= platinumcost && levStruc == 3 {
					upWeapon(selnumWeap, 6)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if platinumnum >= platinumcost && levStruc < 3 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if platinumnum < platinumcost {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if platinumnum >= platinumcost {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
	} else if selweaplev == 5 { //LEVEL 5
		txt = "level 6 > " + fmt.Sprint(platinumcost) + " platinum > +3 dmg +2 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(cnt.X) - txlen/2
		bgrec2 := rl.NewRectangle(storeRec.X, float32(ytx-4), storeRec.Width, float32(txs+8))
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if platinumnum >= platinumcost && levStruc == 3 {
					upWeapon(selnumWeap, 6)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if platinumnum >= platinumcost && levStruc < 3 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if platinumnum < platinumcost {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if platinumnum >= platinumcost {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
	} else if selweaplev == 6 {
		txt = "weapon is max level > no further upgrades"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(cnt.X) - txlen/2
		rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)
	}

	ytx += tx5
	txs = tx4

	if storetxT > 0 {
		txt := "not enough ore > keep exploring"
		xtx2 := storeRec.ToInt32().X + 16
		ytx2 := storeRec.ToInt32().Y + 16
		rl.DrawText(txt, xtx2-1, ytx2+1, tx3, rl.Black)
		rl.DrawText(txt, xtx2, ytx2, tx3, rl.Black)
	} else if storetxT2 > 0 {
		txt := "structure not required level > upgrade with scrap"
		xtx2 := storeRec.ToInt32().X + 16
		ytx2 := storeRec.ToInt32().Y + 16
		rl.DrawText(txt, xtx2-1, ytx2+1, tx3, rl.Black)
		rl.DrawText(txt, xtx2, ytx2, tx3, rl.Black)
	} else if storetxT3 > 0 {
		txt := "weapon upgraded " + weapUpgTXT
		xtx2 := storeRec.ToInt32().X + 16
		ytx2 := storeRec.ToInt32().Y + 16
		rl.DrawText(txt, xtx2-1, ytx2+1, tx3, rl.Black)
		rl.DrawText(txt, xtx2, ytx2, tx3, rl.Black)
	}

	//CLOSE REC
	siz2 := b2
	closerec := rl.NewRectangle(storeRec.X+storeRec.Width-siz2, storeRec.Y+bq, siz2, siz2)
	closerec.X += 16
	closerec.Y += 16
	closerec.Width -= 32
	closerec.Height -= 32
	v1 := rl.NewVector2(closerec.X, closerec.Y)
	v1.X += 8
	v1.Y += 8
	v2 := v1
	v2.X += closerec.Width - 16
	v3 := v2
	v3.Y += closerec.Width - 16
	v4 := v3
	v4.X -= closerec.Width - 16
	if rl.CheckCollisionPointRec(cursorV2Strucs, closerec) {
		rl.DrawRectangleRec(closerec, DarkRed())
		rl.DrawLineEx(v1, v3, 4, rl.Black)
		rl.DrawLineEx(v2, v4, 4, rl.Black)
		if inpL {
			rl.PlaySound(audfx[41])
			weaponshedon = false
		}
	} else {
		rl.DrawRectangleRec(closerec, rl.Black)
		rl.DrawLineEx(v1, v3, 4, rl.Orange)
		rl.DrawLineEx(v2, v4, 4, rl.Orange)
	}
	if rl.IsGamepadButtonPressed(0, 6) {
		rl.PlaySound(audfx[41])
		weaponshedon = false
	}

	rl.EndMode2D()

}

func drawApoth() { //MARK:DRAW APOTHECARY

	for i := 0; i < len(bgpix); i++ {
		rec := rl.NewRectangle(bgpix[i].v2.X, bgpix[i].v2.Y, bgpix[i].siz, bgpix[i].siz)
		rl.DrawRectangleRec(rec, rl.Fade(bgpix[i].col, bgpix[i].fd))
		bgpix[i].v2.X += bgpix[i].dirX
		bgpix[i].v2.Y += bgpix[i].dirY

		if bgpix[i].v2.X < 0 {
			bgpix[i].v2.X = scrWF32
		}
		if bgpix[i].v2.X > scrWF32 {
			bgpix[i].v2.X = 0
		}
		if bgpix[i].v2.Y < 0 {
			bgpix[i].v2.Y = scrHF32
		}
		if bgpix[i].v2.Y > scrHF32 {
			bgpix[i].v2.Y = 0
		}

		if bgpix[i].fd > 0 {
			bgpix[i].fd -= 0.005
		} else {
			bgpix[i].fd = RandF32(0.5, 1)
		}
	}
	rl.BeginMode2D(camStrucs)
	rl.DrawRectangleRec(storeRec, rl.Black)
	rl.DrawRectangleRec(storeRec, rl.Fade(rl.Orange, 0.7))

	if storetxT > 0 {
		if apothTxt != "" {
			xtx2 := storeRec.ToInt32().X + 16
			ytx2 := storeRec.ToInt32().Y + 16
			rl.DrawText(apothTxt, xtx2-1, ytx2+1, tx3, rl.Black)
			rl.DrawText(apothTxt, xtx2, ytx2, tx3, rl.Black)
		}
		storetxT--
	}

	apothLev := 0
	for i := 0; i < len(base.nm); i++ {
		if base.nm[i] == "apothecary" {
			apothLev = base.lev[i]
		}
	}

	//DRAW MUSROOMS
	amethystnum, zirconnum, topaznum, rubelitenum, jadenum, larimarnum := 0, 0, 0, 0, 0, 0
	for i := 0; i < len(storeItm); i++ {
		if storeItm[i].nm == "amethyst mushroom" {
			amethystnum += storeItm[i].numof
		}
		if storeItm[i].nm == "zircon mushroom" {
			zirconnum += storeItm[i].numof
		}
		if storeItm[i].nm == "topaz mushroom" {
			topaznum += storeItm[i].numof
		}
		if storeItm[i].nm == "rubelite mushroom" {
			rubelitenum += storeItm[i].numof
		}
		if storeItm[i].nm == "jade mushroom" {
			jadenum += storeItm[i].numof
		}
		if storeItm[i].nm == "larimar mushroom" {
			larimarnum += storeItm[i].numof
		}
	}
	for i := 0; i < len(pl.invn); i++ {
		if pl.invn[i].nm == "amethyst mushroom" {
			amethystnum += pl.invn[i].numof
		}
		if pl.invn[i].nm == "zircon mushroom" {
			zirconnum += pl.invn[i].numof
		}
		if pl.invn[i].nm == "topaz mushroom" {
			topaznum += pl.invn[i].numof
		}
		if pl.invn[i].nm == "rubelite mushroom" {
			rubelitenum += pl.invn[i].numof
		}
		if pl.invn[i].nm == "jade mushroom" {
			jadenum += pl.invn[i].numof
		}
		if pl.invn[i].nm == "larimar mushroom" {
			larimarnum += pl.invn[i].numof
		}
	}
	siz := b2
	spc := float32(8)
	W := (siz + spc) * 15
	x := (cnt.X - W/2) - b
	xorig := x
	y := b3
	//DRAW MUSHROOMS
	for i := 0; i < 6; i++ {
		rec := rl.NewRectangle(x, y, siz, siz)
		rec2 := rec
		rec2.X -= 4
		rec2.Y += 4
		rl.DrawRectangleRec(rec2, rl.Black)
		rl.DrawRectangleRec(rec, rl.Black)
		rl.DrawRectangleRec(rec, rl.Fade(rl.DarkGray, 0.5))
		xtx := rec.ToInt32().X + rec.ToInt32().Width/2
		ytx := rec.ToInt32().Y + rec.ToInt32().Height + 4
		xtx2 := rec.ToInt32().X + rec.ToInt32().Width + 12
		ytx2 := rec.ToInt32().Y + 8
		txs := tx3
		txs2 := tx5
		txt := ""
		switch i {
		case 0:
			rl.DrawTexturePro(imgs, etc[139], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[139], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "amethyst"
			rl.DrawText(fmt.Sprint(amethystnum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(amethystnum), xtx2, ytx2, txs2, rl.Black)
		case 1:
			rl.DrawTexturePro(imgs, etc[140], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[140], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "zircon"
			rl.DrawText(fmt.Sprint(zirconnum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(zirconnum), xtx2, ytx2, txs2, rl.Black)
		case 2:
			rl.DrawTexturePro(imgs, etc[141], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[141], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "topaz"
			rl.DrawText(fmt.Sprint(topaznum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(topaznum), xtx2, ytx2, txs2, rl.Black)
		case 3:
			rl.DrawTexturePro(imgs, etc[142], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[142], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "rubelite"
			rl.DrawText(fmt.Sprint(rubelitenum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(rubelitenum), xtx2, ytx2, txs2, rl.Black)
		case 4:
			rl.DrawTexturePro(imgs, etc[143], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[143], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "jade"
			rl.DrawText(fmt.Sprint(jadenum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(jadenum), xtx2, ytx2, txs2, rl.Black)
		case 5:
			rl.DrawTexturePro(imgs, etc[144], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[144], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "larimar"
			rl.DrawText(fmt.Sprint(larimarnum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(larimarnum), xtx2, ytx2, txs2, rl.Black)
		}
		txlen := rl.MeasureText(txt, txs)
		xtx -= txlen / 2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		x += (siz + spc) * 2.7
	}
	//DRAW POTIONS
	y += b4
	siz = b3
	spc = float32(24)
	txt, txt2 := "", ""
	W = float32(len(potionList)/2) * (siz + spc)
	x = cnt.X - W/2
	x = xorig
	for i := 0; i < len(potionList); i++ {
		rec := rl.NewRectangle(x, y, siz, siz)
		if rl.CheckCollisionPointRec(cursorV2Strucs, rec) {
			txt = potionList[i].nm
			rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.5))
			for j := 0; j < len(potionList[i].costPotion); j++ {
				if potionList[i].costPotion[j] != 0 {
					switch j {
					case 0:
						txt2 = txt2 + fmt.Sprint(potionList[i].costPotion[j]) + " amethyst  "
					case 1:
						txt2 = txt2 + fmt.Sprint(potionList[i].costPotion[j]) + " zircon  "
					case 2:
						txt2 = txt2 + fmt.Sprint(potionList[i].costPotion[j]) + " topaz  "
					case 3:
						txt2 = txt2 + fmt.Sprint(potionList[i].costPotion[j]) + " rubelite  "
					case 4:
						txt2 = txt2 + fmt.Sprint(potionList[i].costPotion[j]) + " jade  "
					case 5:
						txt2 = txt2 + fmt.Sprint(potionList[i].costPotion[j]) + " larimar"
					}
				}
			}
			if inpL && clickT == 0 {
				canmake := true
				for j := 0; j < len(potionList[i].costPotion); j++ {
					if potionList[i].costPotion[j] != 0 {
						switch j {
						case 0:
							if amethystnum < potionList[i].costPotion[j] {
								canmake = false
							}
						case 1:
							if zirconnum < potionList[i].costPotion[j] {
								canmake = false
							}
						case 2:
							if topaznum < potionList[i].costPotion[j] {
								canmake = false
							}
						case 3:
							if rubelitenum < potionList[i].costPotion[j] {
								canmake = false
							}
						case 4:
							if jadenum < potionList[i].costPotion[j] {
								canmake = false
							}
						case 5:
							if larimarnum < potionList[i].costPotion[j] {
								canmake = false
							}
						}
					}
				}
				if canmake {

					switch potionList[i].nm {
					case "resist fire full", "resist fire half", "resist fire quarter", "resist poison full", "resist poison half", "resist poison quarter":
						if apothLev == 1 {
							canmake = false
						}
					case "invisibility full", "invisibility half", "invisibility quarter", "armor potion full", "armor potion half", "armor potion quarter":
						if apothLev == 1 || apothLev == 2 {
							canmake = false
						}
					}
					if !canmake {
						rl.PlaySound(audfx[43])
						apothTxt = "structure not required level > upgrade with scrap"
						storetxT = fps * 3
					} else {
						clickT = fps / 3
						apothTxt = makePotion(i)
						storetxT = fps * 2
					}
				} else {
					rl.PlaySound(audfx[43])
					apothTxt = "not enough mushrooms > continue exploring or use mushroom patch"
					storetxT = fps * 3
				}
			}
		} else {
			rl.DrawRectangleRec(rec, rl.Fade(rl.DarkGray, 0.7))
		}
		rl.DrawTexturePro(imgs, potionList[i].img, shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
		rl.DrawTexturePro(imgs, potionList[i].img, rec, rl.Vector2Zero(), 0, rl.White)
		x += siz + spc
		if x >= storeRec.X+storeRec.Width-(siz*2) {
			x = xorig
			y += siz + spc
		}

	}

	if txt != "" {
		txs := tx4
		txlen := rl.MeasureText(txt, txs)
		xtx := int32(cnt.X) - txlen/2
		ytx := int32(y) - 4
		rl.DrawText(txt, xtx-3, ytx+3, txs, rl.Magenta)
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		ytx += txs + 8
		txs = tx3
		txlen = rl.MeasureText(txt2, txs)
		xtx = int32(cnt.X) - txlen/2
		rl.DrawText(txt2, xtx-2, ytx+2, txs, rl.Magenta)
		rl.DrawText(txt2, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt2, xtx, ytx, txs, rl.Black)
	}

	//DRAW INK & PAPER
	inknum, papernum := 0, 0
	for i := 0; i < len(storeItm); i++ {
		if storeItm[i].nm == "scroll ink" {
			inknum += storeItm[i].numof
		}
		if storeItm[i].nm == "scroll paper" {
			papernum += storeItm[i].numof
		}
	}
	for i := 0; i < len(pl.invn); i++ {
		if pl.invn[i].nm == "scroll ink" {
			inknum += pl.invn[i].numof
		}
		if pl.invn[i].nm == "scroll paper" {
			papernum += pl.invn[i].numof
		}
	}
	siz = b2
	spc = float32(8)
	W = (siz + spc) * 15
	x = (cnt.X - W/2) - b
	y += b4
	for i := 0; i < 2; i++ {
		rec := rl.NewRectangle(x, y, siz, siz)
		rec2 := rec
		rec2.X -= 4
		rec2.Y += 4
		rl.DrawRectangleRec(rec2, rl.Black)
		rl.DrawRectangleRec(rec, rl.Black)
		rl.DrawRectangleRec(rec, rl.Fade(rl.DarkGray, 0.5))
		xtx := rec.ToInt32().X + rec.ToInt32().Width/2
		ytx := rec.ToInt32().Y + rec.ToInt32().Height + 4
		xtx2 := rec.ToInt32().X + rec.ToInt32().Width + 12
		ytx2 := rec.ToInt32().Y + 8
		txs := tx3
		txs2 := tx5
		txt := ""
		switch i {
		case 0:
			rl.DrawTexturePro(imgs, etc[145], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[145], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "paper"
			rl.DrawText(fmt.Sprint(papernum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(papernum), xtx2, ytx2, txs2, rl.Black)
		case 1:
			rl.DrawTexturePro(imgs, etc[146], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[146], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "ink"
			rl.DrawText(fmt.Sprint(inknum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(inknum), xtx2, ytx2, txs2, rl.Black)
		}
		txlen := rl.MeasureText(txt, txs)
		xtx -= txlen / 2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		x += (siz + spc) * 2.7
	}
	//DRAW SCROLLS
	y += b4
	siz = b3
	spc = float32(24)
	txt, txt2 = "", ""
	W = float32(len(scrollList)) * (siz + spc)
	x = cnt.X - W/2
	for i := 0; i < len(scrollList); i++ {
		rec := rl.NewRectangle(x, y, siz, siz)
		if rl.CheckCollisionPointRec(cursorV2Strucs, rec) {
			txt = scrollList[i].nm
			txt2 = fmt.Sprint(scrollList[i].costScroll[0]) + " paper " + fmt.Sprint(scrollList[i].costScroll[1]) + " ink"
			rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.5))
			if inpL && clickT == 0 {
				canmake := true
				for j := 0; j < len(scrollList[i].costScroll); j++ {
					switch j {
					case 0:
						if papernum < scrollList[i].costScroll[j] {
							canmake = false
						}
					case 1:
						if inknum < scrollList[i].costScroll[j] {
							canmake = false
						}
					}
				}
				if canmake {
					switch scrollList[i].nm {
					case "scroll of poison gas", "scroll of detection", "scroll of home":
						if apothLev == 1 {
							canmake = false
						}
					case "scroll of frogs", "scroll of inflict", "scroll of power":
						if apothLev == 1 || apothLev == 2 {
							canmake = false
						}
					}

					if !canmake {
						rl.PlaySound(audfx[43])
						apothTxt = "structure not required level > upgrade with scrap"
						storetxT = fps * 3
					} else {
						clickT = fps / 3
						apothTxt = makeScroll(i)
						storetxT = fps * 2
					}

				} else {
					rl.PlaySound(audfx[43])
					apothTxt = "not enough scroll components > continue exploring"
					storetxT = fps * 3
				}
			}

		} else {
			rl.DrawRectangleRec(rec, rl.Fade(rl.DarkGray, 0.7))
		}
		rl.DrawTexturePro(imgs, scrollList[i].img, shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
		rl.DrawTexturePro(imgs, scrollList[i].img, rec, rl.Vector2Zero(), 0, rl.White)
		x += siz + spc
		if x >= storeRec.X+storeRec.Width-(siz*2) {
			x = xorig
			y += siz + spc
		}

	}

	if txt != "" {
		txs := tx4
		txlen := rl.MeasureText(txt, txs)
		xtx := int32(cnt.X) - txlen/2
		ytx := int32(y) - 10
		rl.DrawText(txt, xtx-3, ytx+3, txs, rl.Magenta)
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		ytx += txs + 8
		txs = tx3
		txlen = rl.MeasureText(txt2, txs)
		xtx = int32(cnt.X) - txlen/2
		rl.DrawText(txt2, xtx-2, ytx+2, txs, rl.Magenta)
		rl.DrawText(txt2, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt2, xtx, ytx, txs, rl.Black)
	}

	//CLOSE REC
	siz2 := b2
	closerec := rl.NewRectangle(storeRec.X+storeRec.Width-siz2, storeRec.Y+bq, siz2, siz2)
	closerec.X += 16
	closerec.Y += 16
	closerec.Width -= 32
	closerec.Height -= 32
	v1 := rl.NewVector2(closerec.X, closerec.Y)
	v1.X += 8
	v1.Y += 8
	v2 := v1
	v2.X += closerec.Width - 16
	v3 := v2
	v3.Y += closerec.Width - 16
	v4 := v3
	v4.X -= closerec.Width - 16
	if rl.CheckCollisionPointRec(cursorV2Strucs, closerec) {
		rl.DrawRectangleRec(closerec, DarkRed())
		rl.DrawLineEx(v1, v3, 4, rl.Black)
		rl.DrawLineEx(v2, v4, 4, rl.Black)
		if inpL {
			rl.PlaySound(audfx[41])
			apothercaryon = false
		}
	} else {
		rl.DrawRectangleRec(closerec, rl.Black)
		rl.DrawLineEx(v1, v3, 4, rl.Orange)
		rl.DrawLineEx(v2, v4, 4, rl.Orange)
	}
	if rl.IsGamepadButtonPressed(0, 6) {
		rl.PlaySound(audfx[41])
		apothercaryon = false
	}

	rl.EndMode2D()

	for i := 0; i < len(potionList); i++ {
		switch potionList[i].nm {
		//POTION ANIM
		case "armor potion full":
			if frames%6 == 0 {
				potionList[i].img.X += anm[20].W
				if potionList[i].img.X > anm[20].X+anm[20].frames*anm[20].W {
					potionList[i].img.X = anm[20].X
				}
			}
		case "armor potion half":
			if frames%6 == 0 {
				potionList[i].img.X += anm[18].W
				if potionList[i].img.X > anm[18].X+anm[18].frames*anm[18].W {
					potionList[i].img.X = anm[18].X
				}
			}
		case "armor potion quarter":
			if frames%6 == 0 {
				potionList[i].img.X += anm[19].W
				if potionList[i].img.X > anm[19].X+anm[19].frames*anm[19].W {
					potionList[i].img.X = anm[19].X
				}
			}
		case "invisibility full":
			if frames%6 == 0 {
				potionList[i].img.X += anm[17].W
				if potionList[i].img.X > anm[17].X+anm[17].frames*anm[17].W {
					potionList[i].img.X = anm[17].X
				}
			}
		case "invisibility half":
			if frames%6 == 0 {
				potionList[i].img.X += anm[18].W
				if potionList[i].img.X > anm[18].X+anm[18].frames*anm[18].W {
					potionList[i].img.X = anm[18].X
				}
			}
		case "invisibility quarter":
			if frames%6 == 0 {
				potionList[i].img.X += anm[19].W
				if potionList[i].img.X > anm[19].X+anm[19].frames*anm[19].W {
					potionList[i].img.X = anm[19].X
				}
			}
		case "resist poison full":
			if frames%6 == 0 {
				potionList[i].img.X += anm[14].W
				if potionList[i].img.X > anm[14].X+anm[14].frames*anm[14].W {
					potionList[i].img.X = anm[14].X
				}
			}
		case "resist poison half":
			if frames%6 == 0 {
				potionList[i].img.X += anm[15].W
				if potionList[i].img.X > anm[15].X+anm[15].frames*anm[15].W {
					potionList[i].img.X = anm[15].X
				}
			}
		case "resist poison quarter":
			if frames%6 == 0 {
				potionList[i].img.X += anm[16].W
				if potionList[i].img.X > anm[16].X+anm[16].frames*anm[16].W {
					potionList[i].img.X = anm[16].X
				}
			}
		case "resist fire full":
			if frames%6 == 0 {
				potionList[i].img.X += anm[11].W
				if potionList[i].img.X > anm[11].X+anm[11].frames*anm[11].W {
					potionList[i].img.X = anm[11].X
				}
			}
		case "resist fire half":
			if frames%6 == 0 {
				potionList[i].img.X += anm[12].W
				if potionList[i].img.X > anm[12].X+anm[12].frames*anm[12].W {
					potionList[i].img.X = anm[12].X
				}
			}
		case "resist fire quarter":
			if frames%6 == 0 {
				potionList[i].img.X += anm[13].W
				if potionList[i].img.X > anm[13].X+anm[13].frames*anm[13].W {
					potionList[i].img.X = anm[13].X
				}
			}
		case "mana potion full":
			if frames%6 == 0 {
				potionList[i].img.X += anm[8].W
				if potionList[i].img.X > anm[8].X+anm[8].frames*anm[8].W {
					potionList[i].img.X = anm[8].X
				}
			}
		case "mana potion half":
			if frames%6 == 0 {
				potionList[i].img.X += anm[9].W
				if potionList[i].img.X > anm[9].X+anm[9].frames*anm[9].W {
					potionList[i].img.X = anm[9].X
				}
			}
		case "mana potion quarter":
			if frames%6 == 0 {
				potionList[i].img.X += anm[10].W
				if potionList[i].img.X > anm[10].X+anm[10].frames*anm[10].W {
					potionList[i].img.X = anm[10].X
				}
			}
		case "hp potion full":
			if frames%6 == 0 {
				potionList[i].img.X += anm[5].W
				if potionList[i].img.X > anm[5].X+anm[5].frames*anm[5].W {
					potionList[i].img.X = anm[5].X
				}
			}
		case "hp potion half":
			if frames%6 == 0 {
				potionList[i].img.X += anm[6].W
				if potionList[i].img.X > anm[6].X+anm[6].frames*anm[6].W {
					potionList[i].img.X = anm[6].X
				}
			}
		case "hp potion quarter":
			if frames%6 == 0 {
				potionList[i].img.X += anm[7].W
				if potionList[i].img.X > anm[7].X+anm[7].frames*anm[7].W {
					potionList[i].img.X = anm[7].X
				}
			}
		}
	}

}

func drawcredits() { //MARK:DRAW CREDITS

	txlen := rl.MeasureText("thanks to all these people...", tx5)
	x := int32(cnt.X) - txlen/2
	y := tx4
	rl.DrawText("thanks to all these people...", x-4, y+4, tx5, rl.Yellow)
	rl.DrawText("thanks to all these people...", x-2, y+2, tx5, rl.Black)
	rl.DrawText("thanks to all these people...", x, y, tx5, rl.Magenta)

	xtx := int32(storeRec.X)
	xorig := xtx
	ytx := int32(y) + tx7
	txs := tx3

	for i := 0; i < len(creditlist); i++ {
		txlen = rl.MeasureText(creditlist[i], txs)
		if xtx+txlen > int32(storeRec.X+storeRec.Width) {
			ytx += txs + txs/3
			xtx = xorig
		}
		rl.DrawText(creditlist[i], xtx-2, ytx+2, txs, rl.Magenta)
		rl.DrawText(creditlist[i], xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(creditlist[i], xtx, ytx, txs, rl.White)
		xtx += txlen + txs*2
	}

	if clickT == 0 {
		if inpL || inpR {

			if endgameclose {
				if storeunlocked {
					savestore()
				}
				rl.StopMusicStream(music[currentMusic])
				rl.EndMode2D()
				rl.EndTextureMode()
				rl.EndShaderMode()
				rl.EndDrawing()
				unload()
				rl.CloseAudioDevice()
				rl.CloseWindow()
				os.Exit(0)
			} else {
				credits = false
			}
		}
	}

}

func drawBook() { //MARK:DRAW BOOK
	for i := 0; i < len(bgpix); i++ {
		rec := rl.NewRectangle(bgpix[i].v2.X, bgpix[i].v2.Y, bgpix[i].siz, bgpix[i].siz)
		rl.DrawRectangleRec(rec, rl.Fade(bgpix[i].col, bgpix[i].fd))
		bgpix[i].v2.X += bgpix[i].dirX
		bgpix[i].v2.Y += bgpix[i].dirY

		if bgpix[i].v2.X < 0 {
			bgpix[i].v2.X = scrWF32
		}
		if bgpix[i].v2.X > scrWF32 {
			bgpix[i].v2.X = 0
		}
		if bgpix[i].v2.Y < 0 {
			bgpix[i].v2.Y = scrHF32
		}
		if bgpix[i].v2.Y > scrHF32 {
			bgpix[i].v2.Y = 0
		}

		if bgpix[i].fd > 0 {
			bgpix[i].fd -= 0.005
		} else {
			bgpix[i].fd = RandF32(0.5, 1)
		}
	}

	txt := ""
	txt2 := ""
	txtT := int32(0)

	numW := float32(14)
	numH := float32(9)
	spc := float32(12)
	H := scrHF32 - b2
	siz := H / numH
	W := siz * numW
	siz -= spc
	cntr := rl.NewVector2(scrWF32/2, scrHF32/2)
	xl2 := cntr.X - W/2
	yt := cntr.Y - H/2
	yt += b
	if lrg {
		yt += b
	}
	if xxl || xl {
		yt += b2
	}
	xr := xl2 + W

	x := xl2
	y := yt
	count := float32(0)

	//CLOSE REC
	siz2 := b2 + b/2
	if xxl {
		siz2 = b3
	}
	if med {
		siz2 = b2
	}
	closerec := rl.NewRectangle(xr-siz2, 2, siz2, siz2)
	closerec.X += 16
	closerec.Y += 16
	closerec.Width -= 32
	closerec.Height -= 32
	v1 := rl.NewVector2(closerec.X, closerec.Y)
	v1.X += 8
	v1.Y += 8
	v2 := v1
	v2.X += closerec.Width - 16
	v3 := v2
	v3.Y += closerec.Width - 16
	v4 := v3
	v4.X -= closerec.Width - 16
	if rl.CheckCollisionPointRec(cursorV2, closerec) {
		rl.DrawRectangleRec(closerec, DarkRed())
		rl.DrawLineEx(v1, v3, 4, rl.Black)
		rl.DrawLineEx(v2, v4, 4, rl.Black)
		if inpL {
			rl.PlaySound(audfx[41])
			upunlocks()
			bookon = false
		}
	} else {
		rl.DrawRectangleRec(closerec, rl.Magenta)
		rl.DrawLineEx(v1, v3, 4, rl.Black)
		rl.DrawLineEx(v2, v4, 4, rl.Black)
	}
	if rl.IsGamepadButtonPressed(0, 6) {
		rl.PlaySound(audfx[41])
		upunlocks()
		bookon = false
	}
	//BG RECS
	for i := 0; i < crateItmLen; i++ {
		rec := rl.NewRectangle(x, y, siz, siz)
		rl.DrawRectangleRec(rec, rl.Black)
		rl.DrawRectangleRec(rec, rl.Fade(rl.DarkPurple, 0.1))
		rl.DrawRectangleLinesEx(rec, 2, rl.Magenta)
		x += siz + spc
		count++
		if count == numW {
			count = 0
			x = xl2
			y += siz + spc
		}
	}

	//COOK BOOK
	foundCookbook := false
	for i := 0; i < len(pl.invn); i++ {
		if pl.invn[i].nm == "cook book" {
			foundCookbook = true
			break
		}
	}
	if !foundCookbook {
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].nm == "cook book" {
				foundCookbook = true
				break
			}
		}
	}

	x = xl2
	y = yt
	count = float32(0)
	//UNLOCKED
	for i := 0; i < len(itmlist); i++ {
		if !itmlist[i].nocrate {
			if itmlist[i].unlok {
				rec := rl.NewRectangle(x, y, siz, siz)
				rec.X += 2
				rec.Y += 2
				rec.Width -= 4
				rec.Height -= 4
				rl.DrawTexturePro(imgs, itmlist[i].img, shrec(rec, 7), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, itmlist[i].img, rec, rl.Vector2Zero(), 0, rl.White)

				//POTION ANIM
				switch itmlist[i].nm {
				//ANIM
				case "armor potion full":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[20].W
						if itmlist[i].img.X > anm[20].X+anm[20].frames*anm[20].W {
							itmlist[i].img.X = anm[20].X
						}
					}
				case "armor potion half":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[18].W
						if itmlist[i].img.X > anm[18].X+anm[18].frames*anm[18].W {
							itmlist[i].img.X = anm[18].X
						}
					}
				case "armor potion quarter":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[19].W
						if itmlist[i].img.X > anm[19].X+anm[19].frames*anm[19].W {
							itmlist[i].img.X = anm[19].X
						}
					}
				case "invisibility full":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[17].W
						if itmlist[i].img.X > anm[17].X+anm[17].frames*anm[17].W {
							itmlist[i].img.X = anm[17].X
						}
					}
				case "invisibility half":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[18].W
						if itmlist[i].img.X > anm[18].X+anm[18].frames*anm[18].W {
							itmlist[i].img.X = anm[18].X
						}
					}
				case "invisibility quarter":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[19].W
						if itmlist[i].img.X > anm[19].X+anm[19].frames*anm[19].W {
							itmlist[i].img.X = anm[19].X
						}
					}
				case "resist poison full":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[14].W
						if itmlist[i].img.X > anm[14].X+anm[14].frames*anm[14].W {
							itmlist[i].img.X = anm[14].X
						}
					}
				case "resist poison half":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[15].W
						if itmlist[i].img.X > anm[15].X+anm[15].frames*anm[15].W {
							itmlist[i].img.X = anm[15].X
						}
					}
				case "resist poison quarter":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[16].W
						if itmlist[i].img.X > anm[16].X+anm[16].frames*anm[16].W {
							itmlist[i].img.X = anm[16].X
						}
					}
				case "resist fire full":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[11].W
						if itmlist[i].img.X > anm[11].X+anm[11].frames*anm[11].W {
							itmlist[i].img.X = anm[11].X
						}
					}
				case "resist fire half":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[12].W
						if itmlist[i].img.X > anm[12].X+anm[12].frames*anm[12].W {
							itmlist[i].img.X = anm[12].X
						}
					}
				case "resist fire quarter":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[13].W
						if itmlist[i].img.X > anm[13].X+anm[13].frames*anm[13].W {
							itmlist[i].img.X = anm[13].X
						}
					}
				case "mana potion full":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[8].W
						if itmlist[i].img.X > anm[8].X+anm[8].frames*anm[8].W {
							itmlist[i].img.X = anm[8].X
						}
					}
				case "mana potion half":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[9].W
						if itmlist[i].img.X > anm[9].X+anm[9].frames*anm[9].W {
							itmlist[i].img.X = anm[9].X
						}
					}
				case "mana potion quarter":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[10].W
						if itmlist[i].img.X > anm[10].X+anm[10].frames*anm[10].W {
							itmlist[i].img.X = anm[10].X
						}
					}
				case "hp potion full":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[5].W
						if itmlist[i].img.X > anm[5].X+anm[5].frames*anm[5].W {
							itmlist[i].img.X = anm[5].X
						}
					}
				case "hp potion half":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[6].W
						if itmlist[i].img.X > anm[6].X+anm[6].frames*anm[6].W {
							itmlist[i].img.X = anm[6].X
						}
					}
				case "hp potion quarter":
					if frames%6 == 0 {
						itmlist[i].img.X += anm[7].W
						if itmlist[i].img.X > anm[7].X+anm[7].frames*anm[7].W {
							itmlist[i].img.X = anm[7].X
						}
					}
				}

				//CURSOR
				if rl.CheckCollisionPointRec(cursorV2, rec) {
					txtT = fps * 2
					txt = itmlist[i].nm
					txt2 = "unlocked"
				}

				x += siz + spc
				count++
				if count == numW {
					count = 0
					x = xl2
					y += siz + spc
				}
			}
		}
	}
	//LOCKED
	foundLowerPrice := false
	currentItmNum := blankint
	for i := 0; i < len(itmlist); i++ {
		if !itmlist[i].nocrate {
			if !itmlist[i].unlok {
				rec := rl.NewRectangle(x, y, siz, siz)
				rec.X += 2
				rec.Y += 2
				rec.Width -= 4
				rec.Height -= 4
				if pl.xp >= itmlist[i].cost {
					foundLowerPrice = true
					rec = rl.NewRectangle(x, y, siz, siz)
					if med {
						rl.DrawRectangleLinesEx(rec, 4, RandColor())
					} else {
						rl.DrawRectangleLinesEx(rec, 8, RandColor())
					}

					rl.DrawTexturePro(imgs, itmlist[i].img, rec, rl.Vector2Zero(), 0, rl.White)
					rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.3))
				} else {
					if foundCookbook && itmlist[i].cost <= 100 {
						rec = rl.NewRectangle(x, y, siz, siz)
						if med {
							rl.DrawRectangleLinesEx(rec, 4, RandColor())
						} else {
							rl.DrawRectangleLinesEx(rec, 8, RandColor())
						}
						rl.DrawTexturePro(imgs, itmlist[i].img, rec, rl.Vector2Zero(), 0, rl.White)
						rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.3))
					} else {
						rl.DrawTexturePro(imgs, itmlist[i].img, rec, rl.Vector2Zero(), 0, rl.White)
						rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.8))
					}
				}
				//CURSOR
				if rl.CheckCollisionPointRec(cursorV2, rec) {
					txtT = fps * 2
					txt = itmlist[i].nm
					txt2 = fmt.Sprint(itmlist[i].cost) + "xp to unlock"
					currentItmNum = i
					if pl.xp >= itmlist[i].cost && clickT == 0 && !itmlist[i].unlok && inpL {
						rl.PlaySound(audfx[44])
						clickT = fps / 4
						itmlist[i].unlok = true
						if foundCookbook && itmlist[i].cost <= 100 {
							found := false
							for i := 0; i < len(pl.invn); i++ {
								if pl.invn[i].nm == "cook book" {
									found = true
									foundCookbook = false
									if pl.invn[i].numof > 1 {
										pl.invn[i].numof--
									} else {
										pl.invn[i] = xitm{}
									}
									break
								}
							}
							if !found {
								for i := 0; i < len(storeItm); i++ {
									if storeItm[i].nm == "cook book" {
										found = true
										foundCookbook = false
										if storeItm[i].numof > 1 {
											storeItm[i].numof--
										} else {
											storeItm[i] = xitm{}
										}
										break
									}
								}
							}
						} else {
							pl.xp -= itmlist[i].cost
						}
					} else if pl.xp < itmlist[i].cost && clickT == 0 && !itmlist[i].unlok && foundCookbook && inpL {
						rl.PlaySound(audfx[44])
						clickT = fps / 4
						itmlist[i].unlok = true
						if foundCookbook && itmlist[i].cost <= 100 {
							found := false
							for i := 0; i < len(pl.invn); i++ {
								if pl.invn[i].nm == "cook book" {
									found = true
									foundCookbook = false
									if pl.invn[i].numof > 1 {
										pl.invn[i].numof--
									} else {
										pl.invn[i] = xitm{}
									}
									break
								}
							}
							if !found {
								for i := 0; i < len(storeItm); i++ {
									if storeItm[i].nm == "cook book" {
										found = true
										foundCookbook = false
										if storeItm[i].numof > 1 {
											storeItm[i].numof--
										} else {
											storeItm[i] = xitm{}
										}
										break
									}
								}
							}
						}
					} else if inpL {
						rl.PlaySound(audfx[43])
					}
				}
				x += siz + spc
				count++
				if count == numW {
					count = 0
					x = xl2
					y += siz + spc
				}
			}
		}
	}

	//TOP TXT
	txs := tx5
	if xxl {
		txs = tx7
	}
	if lrg {
		txs = tx4
	}
	if med {
		txs = tx2
	}
	xtx := int32(xl2)
	ytx := int32(20)
	if txtT > 0 && txt != "" {
		rl.DrawText(txt, xtx, ytx, txs, rl.White)
		txlen := rl.MeasureText(txt, txs)
		txlen += txs
		xtx += txlen
		if txt2 == "unlocked" {
			rl.DrawText(txt2, xtx, ytx, txs, rl.Green)
		} else {
			if currentItmNum != blankint {
				if pl.xp >= itmlist[currentItmNum].cost {
					rl.DrawText(txt2, xtx, ytx, txs, rl.Green)
				} else {
					rl.DrawText(txt2, xtx, ytx, txs, rl.Red)
				}
			} else {
				rl.DrawText(txt2, xtx, ytx, txs, rl.Red)
			}

		}
	}

	//PLAYER XP
	ytx = int32(20)
	txt = fmt.Sprint(pl.xp) + "xp to spend"
	if foundCookbook {
		txt = txt + " + cook book"
	}
	txtlen := rl.MeasureText(txt, txs)
	xtx = int32(xr-spc) - txtlen
	xtx -= int32(siz2 + b/4)
	rl.DrawText(txt, xtx-3, ytx+3, txs, rl.Magenta)
	rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
	rl.DrawText(txt, xtx-1, ytx+1, txs, rl.White)
	rl.DrawText(txt, xtx, ytx, txs, rl.White)

	ytx = scrH32 - (txs + txs/2)
	if !foundLowerPrice {
		txt = "not enough xp to unlock > kill some enemies..."
		txtlen = rl.MeasureText(txt, txs)
		xtx = int32(cntr.X) - txtlen/2
		rl.DrawText(txt, xtx, ytx, txs, DarkRed())
	} else {
		txt = "unlocked items will drop from crates"
		txtlen = rl.MeasureText(txt, txs)
		xtx = int32(cntr.X) - txtlen/2
		rl.DrawText(txt, xtx, ytx, txs, rl.Green)
	}

}
func drawStore() { //MARK:DRAW STORE ROOM
	findnextstoreslotnum()
	if invDisTxtT > 0 {
		invDisTxtT--
	}
	if invInfoT > 0 {
		invInfoT--
	}
	if storetxT > 0 {
		storetxT--
	}
	txt := ""

	for i := 0; i < len(bgpix); i++ {
		rec := rl.NewRectangle(bgpix[i].v2.X, bgpix[i].v2.Y, bgpix[i].siz, bgpix[i].siz)
		rl.DrawRectangleRec(rec, rl.Fade(bgpix[i].col, bgpix[i].fd))
		bgpix[i].v2.X += bgpix[i].dirX
		bgpix[i].v2.Y += bgpix[i].dirY

		if bgpix[i].v2.X < 0 {
			bgpix[i].v2.X = scrWF32
		}
		if bgpix[i].v2.X > scrWF32 {
			bgpix[i].v2.X = 0
		}
		if bgpix[i].v2.Y < 0 {
			bgpix[i].v2.Y = scrHF32
		}
		if bgpix[i].v2.Y > scrHF32 {
			bgpix[i].v2.Y = 0
		}

		if bgpix[i].fd > 0 {
			bgpix[i].fd -= 0.005
		} else {
			bgpix[i].fd = RandF32(0.5, 1)
		}
	}
	rl.BeginMode2D(camStrucs)
	//MARK: DRAW STORE ROOM INVEN INFO
	if invenInfo {

		invInfoT++
		if invInfoT > fps*2 {
			invInfoT = fps
		}
		//BG REC
		rl.DrawRectangleRec(optionsRec, rl.Magenta)
		bgtxrec := rl.NewRectangle(optionsRec.X, optionsRec.Y+b/2, optionsRec.Width, b2+b/4)
		rl.DrawRectangleRec(bgtxrec, rl.Orange)
		rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
		closeY := bgtxrec.Y
		closeH := bgtxrec.Height
		//IMG
		irec := rl.NewRectangle(optionsRec.X+optionsRec.Width/4, b3+b/2, optionsRec.Width/2, optionsRec.Width/2)
		rl.DrawRectangleRec(irec, rl.Fade(rl.Black, 0.8))
		rl.DrawRectangleLinesEx(irec, 8, rl.Black)
		irec.X += b
		irec.Y += b
		irec.Width -= b2
		irec.Height -= b2

		if inMenuOn2 {

			rl.DrawTexturePro(imgs, pl.invn[inMenuItm].img, shrec(irec, 8), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, pl.invn[inMenuItm].img, irec, rl.Vector2Zero(), 0, rl.White)
			//TITLE TX
			txs := tx4
			txlen := rl.MeasureText(pl.invn[inMenuItm].nm, txs)
			xtx := int32(cnt.X) - txlen/2
			ytx := bgtxrec.ToInt32().Y + bgtxrec.ToInt32().Height/2 - txs/2
			rl.DrawText(pl.invn[inMenuItm].nm, xtx, ytx, txs, rl.Black)

			//DESC
			txs = tx4
			txlen = rl.MeasureText(pl.invn[inMenuItm].des, txs)
			xtx = int32(cnt.X) - txlen/2
			ytx = irec.ToInt32().Y + irec.ToInt32().Height + tx6
			bgtxrec.Y = float32(ytx) - 4
			bgtxrec.Height = float32(txs) + 12
			rl.DrawRectangleRec(bgtxrec, rl.Orange)
			rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
			rl.DrawText(pl.invn[inMenuItm].des, xtx, ytx, txs, rl.Black)

			bgtxrec = rl.NewRectangle(optionsRec.X, bgtxrec.Y+bgtxrec.Height+b/2, optionsRec.Width, b10+b/2)
			rl.DrawRectangleRec(bgtxrec, rl.Black)
			rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Orange)
			rl.DrawText(">> more info...", optionsRec.ToInt32().X+tx3, bgtxrec.ToInt32().Y+tx, tx5, rl.Orange)

			txs = tx2
			ytx = int32(bgtxrec.Y) + tx5

			//DESC
			if pl.invn[inMenuItm].des2 != "" {
				txlen := rl.MeasureText(pl.invn[inMenuItm].des2, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(pl.invn[inMenuItm].des2, xtx, ytx, txs, rl.Yellow)
			}
			if pl.invn[inMenuItm].des3 != "" {
				txlen := rl.MeasureText(pl.invn[inMenuItm].des3, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(pl.invn[inMenuItm].des3, xtx, ytx, txs, rl.Yellow)
			}
			if pl.invn[inMenuItm].des4 != "" {
				txlen := rl.MeasureText(pl.invn[inMenuItm].des4, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(pl.invn[inMenuItm].des4, xtx, ytx, txs, rl.Yellow)
			}
			if pl.invn[inMenuItm].des5 != "" {
				txlen := rl.MeasureText(pl.invn[inMenuItm].des5, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(pl.invn[inMenuItm].des5, xtx, ytx, txs, rl.Yellow)
			}
			if pl.invn[inMenuItm].des6 != "" {
				txlen := rl.MeasureText(pl.invn[inMenuItm].des6, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(pl.invn[inMenuItm].des6, xtx, ytx, txs, rl.Yellow)
			}
			if pl.invn[inMenuItm].des7 != "" {
				txlen := rl.MeasureText(pl.invn[inMenuItm].des7, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(pl.invn[inMenuItm].des7, xtx, ytx, txs, rl.Yellow)
			}

		} else if inMenuOn {
			rl.DrawTexturePro(imgs, storeItm[inMenuItm].img, shrec(irec, 8), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, storeItm[inMenuItm].img, irec, rl.Vector2Zero(), 0, rl.White)
			//TITLE TX
			txs := tx4
			txlen := rl.MeasureText(storeItm[inMenuItm].nm, txs)
			xtx := int32(cnt.X) - txlen/2
			ytx := bgtxrec.ToInt32().Y + bgtxrec.ToInt32().Height/2 - txs/2
			rl.DrawText(storeItm[inMenuItm].nm, xtx, ytx, txs, rl.Black)

			//DESC
			txs = tx4
			txlen = rl.MeasureText(storeItm[inMenuItm].des, txs)
			xtx = int32(cnt.X) - txlen/2
			ytx = irec.ToInt32().Y + irec.ToInt32().Height + tx6
			bgtxrec.Y = float32(ytx) - 4
			bgtxrec.Height = float32(txs) + 12
			rl.DrawRectangleRec(bgtxrec, rl.Orange)
			rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
			rl.DrawText(storeItm[inMenuItm].des, xtx, ytx, txs, rl.Black)

			bgtxrec = rl.NewRectangle(optionsRec.X, bgtxrec.Y+bgtxrec.Height+b/2, optionsRec.Width, b10+b/2)
			rl.DrawRectangleRec(bgtxrec, rl.Black)
			rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Orange)
			rl.DrawText(">> more info...", optionsRec.ToInt32().X+tx3, bgtxrec.ToInt32().Y+tx, tx5, rl.Orange)

			txs = tx2
			ytx = int32(bgtxrec.Y) + tx5

			//DESC
			if storeItm[inMenuItm].des2 != "" {
				txlen := rl.MeasureText(storeItm[inMenuItm].des2, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(storeItm[inMenuItm].des2, xtx, ytx, txs, rl.Yellow)
			}
			if storeItm[inMenuItm].des3 != "" {
				txlen := rl.MeasureText(storeItm[inMenuItm].des3, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(storeItm[inMenuItm].des3, xtx, ytx, txs, rl.Yellow)
			}
			if storeItm[inMenuItm].des4 != "" {
				txlen := rl.MeasureText(storeItm[inMenuItm].des4, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(storeItm[inMenuItm].des4, xtx, ytx, txs, rl.Yellow)
			}
			if storeItm[inMenuItm].des5 != "" {
				txlen := rl.MeasureText(storeItm[inMenuItm].des5, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(storeItm[inMenuItm].des5, xtx, ytx, txs, rl.Yellow)
			}
			if storeItm[inMenuItm].des6 != "" {
				txlen := rl.MeasureText(storeItm[inMenuItm].des6, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(storeItm[inMenuItm].des6, xtx, ytx, txs, rl.Yellow)
			}
			if storeItm[inMenuItm].des7 != "" {
				txlen := rl.MeasureText(storeItm[inMenuItm].des7, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(storeItm[inMenuItm].des7, xtx, ytx, txs, rl.Yellow)
			}
		}

		//EXIT
		if inpR {
			invenInfo = false
			weapInfon = false
			inMenuOn = false
			inMenuOn2 = false
			inWeapMenuOn = false
		}
		//CLOSE REC
		siz2 := closeH
		closerec := rl.NewRectangle(optionsRec.X+optionsRec.Width-siz2, closeY, siz2, siz2)
		closerec.X += 16
		closerec.Y += 16
		closerec.Width -= 32
		closerec.Height -= 32
		v1 := rl.NewVector2(closerec.X, closerec.Y)
		v1.X += 8
		v1.Y += 8
		v2 := v1
		v2.X += closerec.Width - 16
		v3 := v2
		v3.Y += closerec.Width - 16
		v4 := v3
		v4.X -= closerec.Width - 16
		if rl.CheckCollisionPointRec(cursorV2camInven, closerec) {
			rl.DrawRectangleRec(closerec, DarkRed())
			rl.DrawLineEx(v1, v3, 4, rl.Black)
			rl.DrawLineEx(v2, v4, 4, rl.Black)
			if clickT == 0 {
				if inpL {
					rl.PlaySound(audfx[41])
					clickT = fps / 4
					invInfoT = fps / 2
					weapInfon = false
					invenInfo = false
					inMenuOn = false
					inMenuOn2 = false
					inWeapMenuOn = false
				}
			}
		} else {
			rl.DrawRectangleRec(closerec, rl.Black)
			rl.DrawLineEx(v1, v3, 4, rl.Orange)
			rl.DrawLineEx(v2, v4, 4, rl.Orange)
		}
	} else {
		rl.DrawRectangleRec(storeRec, rl.Fade(rl.Magenta, 0.9))
		bgtxrec := rl.NewRectangle(storeRec.X, storeRec.Y+b/2, storeRec.Width, b2+b/4)
		rl.DrawRectangleRec(bgtxrec, rl.Orange)
		rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
		rl.DrawText(">> inventory", storeRec.ToInt32().X+tx3-1, bgtxrec.ToInt32().Y+9, tx5, rl.Black)
		rl.DrawText(">> inventory", storeRec.ToInt32().X+tx3, bgtxrec.ToInt32().Y+8, tx5, rl.Black)
		//CLOSE REC
		siz2 := bgtxrec.Height
		closerec := rl.NewRectangle(storeRec.X+storeRec.Width-siz2, bgtxrec.Y, siz2, siz2)
		closerec.X += 16
		closerec.Y += 16
		closerec.Width -= 32
		closerec.Height -= 32
		v1 := rl.NewVector2(closerec.X, closerec.Y)
		v1.X += 8
		v1.Y += 8
		v2 := v1
		v2.X += closerec.Width - 16
		v3 := v2
		v3.Y += closerec.Width - 16
		v4 := v3
		v4.X -= closerec.Width - 16
		if rl.CheckCollisionPointRec(cursorV2Strucs, closerec) {
			rl.DrawRectangleRec(closerec, DarkRed())
			rl.DrawLineEx(v1, v3, 4, rl.Black)
			rl.DrawLineEx(v2, v4, 4, rl.Black)
			if invInfoT == 0 {
				if clickT == 0 {
					if inpL {
						rl.PlaySound(audfx[41])
						storeon = false
					}
				}
			}
		} else {
			rl.DrawRectangleRec(closerec, rl.Black)
			rl.DrawLineEx(v1, v3, 4, rl.Orange)
			rl.DrawLineEx(v2, v4, 4, rl.Orange)
		}
		if rl.IsGamepadButtonPressed(0, 6) {
			rl.PlaySound(audfx[41])
			storeon = false
		}
		//INVEN
		siz := b2
		x := storeRec.X + bq3
		y := bgtxrec.Y + bgtxrec.Height + b
		spc := float32(4)
		for i := 0; i < len(pl.invn); i++ {
			rec := rl.NewRectangle(x, y, siz, siz)
			if rl.CheckCollisionPointRec(cursorV2Strucs, rec) {
				rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.7))
				if pl.invn[i].nm != "" {
					storetxT = fps * 2
					txt = pl.invn[i].nm
					if inpL && !inMenuOn2 { //MOVE INVEN TO STORE
						found := false
						for j := 0; j < len(storeItm); j++ {
							if storeItm[j].nm == pl.invn[i].nm {
								rl.PlaySound(audfx[18])
								storeItm[j].numof += pl.invn[i].numof
								pl.invn[i] = xitm{}
								found = true
								break
							}
						}
						if !found {
							for j := 0; j < len(storeItm); j++ {
								if storeItm[j].nm == "" {
									rl.PlaySound(audfx[18])
									storeItm[j] = pl.invn[i]
									pl.invn[i] = xitm{}
									found = true
									break
								}
							}
						}
						if !found {
							rl.PlaySound(audfx[43])
							storetxT = fps * 2
							txt = "no more space in store room"
						}
					}

					//MENU
					if clickT == 0 {
						if inpR && !inMenuOn2 {
							rl.PlaySound(audfx[44])
							clickT = fps / 4
							inMenuOn2 = true
							siz2 := (siz + spc) * 2
							siz2 -= spc
							inMenuRec = rl.NewRectangle(rec.X+rec.Width+spc, rec.Y, siz2, siz2)
							if pl.invn[i].numof == 1 {
								inMenuRec.Height -= siz / 2
							}
							if cursorV2.X > cnt.X+siz2 {
								inMenuRec.X -= siz2 + siz + spc
							}
							inMenuItm = i
						}
					}

				}
			} else {
				rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
			}
			rl.DrawRectangleLinesEx(rec, 4, rl.Fade(rl.Purple, 0.7))
			if pl.invn[i].nm != "" {
				rl.DrawTexturePro(imgs, pl.invn[i].img, shrec(rec, 7), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, pl.invn[i].img, rec, rl.Vector2Zero(), 0, rl.White)
				if pl.invn[i].numof > 1 {
					txlen := rl.MeasureText(fmt.Sprint(pl.invn[i].numof), tx2)
					xtx := int32(rec.X+rec.Width) - (txlen + 4)
					ytx := int32(rec.Y+rec.Height) - tx2
					rl.DrawText(fmt.Sprint(pl.invn[i].numof), xtx-2, ytx+2, tx2, rl.Black)
					rl.DrawText(fmt.Sprint(pl.invn[i].numof), xtx, ytx, tx2, rl.Gold)
				}
			}
			x += siz + spc
			if x+siz >= storeRec.X+storeRec.Width-b {
				x = storeRec.X + bq3
				y += siz + spc
			}
		}
		//QUIK SLOTS
		y += spc * 3
		x = storeRec.X + bq3
		for i := 0; i < len(pl.quik); i++ {
			rec := rl.NewRectangle(x, y, siz, siz)
			if rl.CheckCollisionPointRec(cursorV2Strucs, rec) {
				rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.7))
				if pl.quik[i].nm != "" {
					storetxT = fps * 2
					txt = pl.quik[i].nm
					if inpL && !inMenuOn2 {
						found := false
						for j := 0; j < len(storeItm); j++ { //MOVE QUIK TO STORE
							if storeItm[j].nm == pl.quik[i].nm {
								rl.PlaySound(audfx[18])
								storeItm[j].numof += pl.quik[i].numof
								pl.quik[i] = xitm{}
								found = true
								break
							}
						}
						if !found {
							for j := 0; j < len(storeItm); j++ {
								if storeItm[j].nm == "" {
									rl.PlaySound(audfx[18])
									storeItm[j] = pl.quik[i]
									pl.quik[i] = xitm{}
									found = true
									break
								}
							}
						}
						if !found {
							rl.PlaySound(audfx[43])
							storetxT = fps * 2
							txt = "no more space in store room"
						}
					}
				}
			} else {
				rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
			}
			rl.DrawRectangleLinesEx(rec, 4, rl.Fade(rl.Purple, 0.7))
			if pl.quik[i].nm != "" {
				rl.DrawTexturePro(imgs, pl.quik[i].img, shrec(rec, 7), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, pl.quik[i].img, rec, rl.Vector2Zero(), 0, rl.White)
				if pl.quik[i].numof > 1 {
					txlen := rl.MeasureText(fmt.Sprint(pl.quik[i].numof), tx2)
					xtx := int32(rec.X+rec.Width) - (txlen + 4)
					ytx := int32(rec.Y+rec.Height) - tx2
					rl.DrawText(fmt.Sprint(pl.quik[i].numof), xtx-2, ytx+2, tx2, rl.Black)
					rl.DrawText(fmt.Sprint(pl.quik[i].numof), xtx, ytx, tx2, rl.Gold)
				}
			}
			x += siz + spc
			if x+siz >= storeRec.X+storeRec.Width-b {
				x = storeRec.X + bq3
				y += siz + spc
			}
		}
		xtx := int32(x + b/2)
		ytx := int32(y + 4)
		rl.DrawText("<< quick slots", xtx-1, ytx+1, tx5, rl.Black)
		rl.DrawText("<< quick slots", xtx, ytx, tx5, rl.Black)

		//STORE ALL
		txt3 := "store all"
		txlen := rl.MeasureText(txt3, tx3)
		W2 := float32(txlen) + b2
		x = storeRec.X + storeRec.Width - W2 - b
		rec3 := rl.NewRectangle(x, y+b/2, W2, b+b/2)
		if rl.CheckCollisionPointRec(cursorV2Strucs, rec3) {
			rl.DrawRectangleRec(rec3, DarkRed())
			rl.DrawRectangleLinesEx(rec3, 4, rl.Black)
			xtx = ((rec3.ToInt32().X + rec3.ToInt32().Width/2) - txlen/2)
			ytx = rec3.ToInt32().Y + rec3.ToInt32().Height/2 - tx3/2
			rl.DrawText(txt3, xtx, ytx, tx3, rl.White)
			if inpL {
				rl.PlaySound(audfx[18])
				for i := 0; i < len(pl.invn); i++ {
					found := false
					for j := 0; j < len(storeItm); j++ {
						if storeItm[j].nm == pl.invn[i].nm {
							storeItm[j].numof += pl.invn[i].numof
							pl.invn[i] = xitm{}
							found = true
							break
						}
					}
					if !found {
						for j := 0; j < len(storeItm); j++ {
							if storeItm[j].nm == "" {
								storeItm[j] = pl.invn[i]
								pl.invn[i] = xitm{}
								found = true
								break
							}
						}
					}
					if !found {
						rl.PlaySound(audfx[43])
						storetxT = fps * 2
						txt = "no more space in store room"
					}
				}
			}
		} else {
			rl.DrawRectangleRec(rec3, rl.Orange)
			rl.DrawRectangleLinesEx(rec3, 4, rl.Black)
			xtx = ((rec3.ToInt32().X + rec3.ToInt32().Width/2) - txlen/2)
			ytx = rec3.ToInt32().Y + rec3.ToInt32().Height/2 - tx3/2
			rl.DrawText(txt3, xtx-1, ytx+1, tx3, rl.Black)
			rl.DrawText(txt3, xtx, ytx, tx3, rl.Black)
		}

		//STORE
		bgtxrec = rl.NewRectangle(storeRec.X, y+b3, storeRec.Width, b2+b/4)
		rl.DrawRectangleRec(bgtxrec, rl.Orange)
		rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
		if mouseoff {
			rl.DrawText(">> store room > x for menu", storeRec.ToInt32().X+tx3-1, bgtxrec.ToInt32().Y+9, tx5, rl.Black)
			rl.DrawText(">> store room > x for menu", storeRec.ToInt32().X+tx3, bgtxrec.ToInt32().Y+8, tx5, rl.Black)
		} else {
			rl.DrawText(">> store room > right click for menu", storeRec.ToInt32().X+tx3-1, bgtxrec.ToInt32().Y+9, tx5, rl.Black)
			rl.DrawText(">> store room > right click for menu", storeRec.ToInt32().X+tx3, bgtxrec.ToInt32().Y+8, tx5, rl.Black)
		}

		x = storeRec.X + bq3
		y = bgtxrec.Y + bgtxrec.Height + b
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].nm == "map" && pl.invn[i].notquick {
				storeItm[i].notquick = false
			}
			rec := rl.NewRectangle(x, y, siz, siz)
			if rl.CheckCollisionPointRec(cursorV2Strucs, rec) {
				rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.7))
				if storeItm[i].nm != "" {
					storetxT = fps * 2
					txt = storeItm[i].nm
					if inpL && !inMenuOn {
						found := movestoreitm(i)
						if !found {
							rl.PlaySound(audfx[43])
							storetxT = fps * 2
							txt = "no more space in inventory"
						} else {
							rl.PlaySound(audfx[18])
						}
					}
					//MENU
					if storeItm[i].nm != "" && clickT == 0 {
						if inpR && !inMenuOn {
							rl.PlaySound(audfx[44])
							clickT = fps / 4
							inMenuOn = true
							siz2 := (siz + spc) * 2
							siz2 -= spc
							inMenuRec = rl.NewRectangle(rec.X+rec.Width+spc, rec.Y, siz2, siz2)
							if storeItm[i].numof == 1 {
								inMenuRec.Height -= siz / 2
							}
							if cursorV2.X > cnt.X+siz2 {
								inMenuRec.X -= siz2 + siz + spc
							}
							inMenuItm = i
						}
					}
				}
			} else {
				rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
			}
			rl.DrawRectangleLinesEx(rec, 4, rl.Fade(rl.Purple, 0.7))
			if storeItm[i].nm != "" {
				rl.DrawTexturePro(imgs, storeItm[i].img, shrec(rec, 7), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, storeItm[i].img, rec, rl.Vector2Zero(), 0, rl.White)
				if storeItm[i].numof > 1 {
					txlen := rl.MeasureText(fmt.Sprint(storeItm[i].numof), tx2)
					xtx := int32(rec.X+rec.Width) - (txlen + 4)
					ytx := int32(rec.Y+rec.Height) - tx2
					rl.DrawText(fmt.Sprint(storeItm[i].numof), xtx-2, ytx+2, tx2, rl.Black)
					rl.DrawText(fmt.Sprint(storeItm[i].numof), xtx, ytx, tx2, rl.Gold)
				}
			}
			x += siz + spc
			if x+siz >= storeRec.X+storeRec.Width-b {
				x = storeRec.X + bq3
				y += siz + spc
			}
		}

		//STACK
		y += b
		siz = b4
		rec2 := rl.NewRectangle(storeRec.X+storeRec.Width-((siz*2)+b+b/4), y, b4, b+b/2)
		if rl.CheckCollisionPointRec(cursorV2Strucs, rec2) {
			rl.DrawRectangleRec(rec2, DarkRed())
			rl.DrawRectangleLinesEx(rec2, 4, rl.Black)
			txt := "stack"
			txs := tx3
			txlen := rl.MeasureText(txt, txs)
			ytx := rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
			xtx := rec2.ToInt32().X + rec2.ToInt32().Width/2 - txlen/2
			rl.DrawText(txt, xtx, ytx, txs, rl.White)
			if clickT == 0 {
				if inpL {
					rl.PlaySound(audfx[44])
					clickT = fps / 4
					stackStore()
				}
			}
		} else {
			rl.DrawRectangleRec(rec2, rl.Orange)
			rl.DrawRectangleLinesEx(rec2, 4, rl.Black)
			txt := "stack"
			txs := tx3
			txlen := rl.MeasureText(txt, txs)
			ytx := rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
			xtx := rec2.ToInt32().X + rec2.ToInt32().Width/2 - txlen/2
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		}
		//PACK
		rec2.X += rec2.Width + b/4
		if rl.CheckCollisionPointRec(cursorV2Strucs, rec2) {
			rl.DrawRectangleRec(rec2, DarkRed())
			rl.DrawRectangleLinesEx(rec2, 4, rl.Black)
			txt := "pack"
			txs := tx3
			txlen := rl.MeasureText(txt, txs)
			ytx := rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
			xtx := rec2.ToInt32().X + rec2.ToInt32().Width/2 - txlen/2
			rl.DrawText(txt, xtx, ytx, txs, rl.White)
			if clickT == 0 {
				if inpL {
					rl.PlaySound(audfx[44])
					clickT = fps / 4
					packStore()
				}
			}
		} else {
			rl.DrawRectangleRec(rec2, rl.Orange)
			rl.DrawRectangleLinesEx(rec2, 4, rl.Black)
			txt := "pack"
			txs := tx3
			txlen := rl.MeasureText(txt, txs)
			ytx := rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
			xtx := rec2.ToInt32().X + rec2.ToInt32().Width/2 - txlen/2
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		}
		//STORE TXT
		if storetxT > 0 {
			txs := tx4
			xtx := int32(storeRec.X + b)
			ytx := int32(y) - txs/2
			txt = ">> " + txt
			rl.DrawText(txt, xtx-3, ytx+3, txs, rl.Yellow)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		}

		//MENU INVEN ITEMS
		if inMenuOn2 {
			rl.DrawRectangleRec(inMenuRec, rl.Magenta)
			rl.DrawRectangleRec(inMenuRec, rl.Fade(rl.Black, 0.7))
			rl.DrawRectangleLinesEx(inMenuRec, 4, rl.Fade(rl.Purple, 0.7))
			if !rl.CheckCollisionPointRec(cursorV2Strucs, inMenuRec) {
				inMenuExitT++
				if inMenuExitT >= (fps/3)*2 {
					inMenuExitT = 0
					inMenuOn2 = false
				}
			} else {
				inMenuExitT = 0
			}
			xtx := int32(inMenuRec.X) + 12
			ytx := int32(inMenuRec.Y) + 12
			txs := tx3
			txrecy := float32(ytx) - 2
			if pl.invn[inMenuItm].numof > 1 {
				for i := 0; i < 3; i++ {
					txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
					if rl.CheckCollisionPointRec(cursorV2Strucs, txrec) {
						rl.DrawRectangleRec(txrec, RandColor())
						if inpL {
							switch i {
							case 0: //INFO
								inMenuOn2 = false
								rl.PlaySound(audfx[40])
								invInfoT = fps
								invenInfo = true
							case 1: //SCRAP
								inMenuOn2 = false
								rl.PlaySound(audfx[40])
								num := pl.invn[inMenuItm].numof
								pl.invn[inMenuItm] = xitm{}
								pl.invn[inMenuItm].nm = ""
								found := false
								for j := 0; j < len(pl.invn); j++ {
									if j != inMenuItm {
										if pl.invn[j].nm == "scrap" {
											pl.invn[j].numof += num
											found = true
											break
										}
									}
								}
								if !found {
									pl.invn[inMenuItm] = itmlist[43]
									pl.invn[inMenuItm].numof = num
								}

							case 2: //SPLIT
								inMenuOn2 = false
								if nxInvnNum != blankint {
									rl.PlaySound(audfx[40])
									num1, num2 := 0, 0
									if pl.invn[inMenuItm].numof%2 == 0 {
										num1 = pl.invn[inMenuItm].numof / 2
										num2 = num1
									} else {
										num2 = pl.invn[inMenuItm].numof / 2
										num1 = num2 + 1
									}
									newItm := pl.invn[inMenuItm]
									newItm.numof = num1
									pl.invn[inMenuItm].numof = num2
									pl.invn[nxInvnNum] = newItm
								} else {
									rl.PlaySound(audfx[43])
									admsg("no free store room slots", rl.Red)
								}
							}
						}
					}
					txrecy += txrec.Height
				}
				rl.DrawText("info", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("scrap", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("split", xtx, ytx, txs, rl.Black)
			} else {
				for i := 0; i < 2; i++ {
					txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
					if rl.CheckCollisionPointRec(cursorV2Strucs, txrec) {
						rl.DrawRectangleRec(txrec, RandColor())
						if inpL {
							switch i {
							case 0: //INFO
								rl.PlaySound(audfx[40])
								invInfoT = fps
								invenInfo = true
							case 1: //SCRAP
								rl.PlaySound(audfx[40])
								num := pl.invn[inMenuItm].numof
								pl.invn[inMenuItm] = xitm{}
								pl.invn[inMenuItm].nm = ""
								found := false
								for j := 0; j < len(pl.invn); j++ {
									if j != inMenuItm {
										if pl.invn[j].nm == "scrap" {
											pl.invn[j].numof += num
											found = true
											break
										}
									}
								}
								if !found {
									pl.invn[inMenuItm] = itmlist[43]
									pl.invn[inMenuItm].numof = num
								}
								inMenuOn = false
							}
						}
					}
					txrecy += txrec.Height
				}
				rl.DrawText("info", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("scrap", xtx, ytx, txs, rl.Black)
			}

			if clickT == 0 {
				if inpR {
					clickT = fps / 3
					inMenuOn2 = false
				}
			}
		}

		//MENU STORE ITEMS
		if inMenuOn {
			rl.DrawRectangleRec(inMenuRec, rl.Magenta)
			rl.DrawRectangleRec(inMenuRec, rl.Fade(rl.Black, 0.7))
			rl.DrawRectangleLinesEx(inMenuRec, 4, rl.Fade(rl.Purple, 0.7))
			if !rl.CheckCollisionPointRec(cursorV2Strucs, inMenuRec) {
				inMenuExitT++
				if inMenuExitT >= (fps/3)*2 {
					inMenuExitT = 0
					inMenuOn = false
				}
			} else {
				inMenuExitT = 0
			}
			xtx := int32(inMenuRec.X) + 12
			ytx := int32(inMenuRec.Y) + 12
			txs := tx3
			txrecy := float32(ytx) - 2
			if storeItm[inMenuItm].numof > 1 {
				for i := 0; i < 3; i++ {
					txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
					if rl.CheckCollisionPointRec(cursorV2Strucs, txrec) {
						rl.DrawRectangleRec(txrec, RandColor())
						if inpL {
							switch i {
							case 0: //INFO
								rl.PlaySound(audfx[40])
								invInfoT = fps
								invenInfo = true
							case 1: //SCRAP
								rl.PlaySound(audfx[40])
								num := storeItm[inMenuItm].numof
								storeItm[inMenuItm] = xitm{}
								storeItm[inMenuItm].nm = ""
								found := false
								for j := 0; j < len(storeItm); j++ {
									if j != inMenuItm {
										if storeItm[j].nm == "scrap" {
											storeItm[j].numof += num
											found = true
											break
										}
									}
								}
								if !found {
									storeItm[inMenuItm] = itmlist[43]
									storeItm[inMenuItm].numof = num
								}
								inMenuOn = false
							case 2: //SPLIT
								findnextstoreslotnum()
								if nxStoreNum != blankint {
									rl.PlaySound(audfx[40])
									num1, num2 := 0, 0
									if storeItm[inMenuItm].numof%2 == 0 {
										num1 = storeItm[inMenuItm].numof / 2
										num2 = num1
									} else {
										num2 = storeItm[inMenuItm].numof / 2
										num1 = num2 + 1
									}
									newItm := storeItm[inMenuItm]
									newItm.numof = num1
									storeItm[inMenuItm].numof = num2
									storeItm[nxStoreNum] = newItm
									inMenuOn = false
								} else {
									rl.PlaySound(audfx[43])
									admsg("no free store room slots", rl.Red)
									inMenuOn = false
								}
							}
						}
					}
					txrecy += txrec.Height
				}
				rl.DrawText("info", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("scrap", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("split", xtx, ytx, txs, rl.Black)
			} else {
				for i := 0; i < 2; i++ {
					txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
					if rl.CheckCollisionPointRec(cursorV2Strucs, txrec) {
						rl.DrawRectangleRec(txrec, RandColor())
						if inpL {
							switch i {
							case 0: //INFO
								rl.PlaySound(audfx[40])
								invInfoT = fps
								invenInfo = true
							case 1: //SCRAP
								rl.PlaySound(audfx[40])
								num := storeItm[inMenuItm].numof
								storeItm[inMenuItm] = xitm{}
								storeItm[inMenuItm].nm = ""
								found := false
								for j := 0; j < len(storeItm); j++ {
									if j != inMenuItm {
										if storeItm[j].nm == "scrap" {
											storeItm[j].numof += num
											found = true
											break
										}
									}
								}
								if !found {
									pl.invn[inMenuItm] = itmlist[43]
									pl.invn[inMenuItm].numof = num
								}
								inMenuOn = false
							}
						}
					}
					txrecy += txrec.Height
				}
				rl.DrawText("info", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("scrap", xtx, ytx, txs, rl.Black)
			}

			if clickT == 0 {
				if inpR {
					clickT = fps / 3
					inMenuOn = false
				}
			}
		}
	}
	rl.EndMode2D()
}

func drawBase() { //MARK:DRAW BASE

	if bookon {
		drawBook()
	} else if weaponshedon {
		drawWeaponShed()
	} else if storeon {
		drawStore()
	} else if apothercaryon {
		drawApoth()
	} else {

		if mushPause > 0 {
			mushPause--
		}

		//SCRAPNUM
		scrapNum = 0
		for i := 0; i < len(pl.invn); i++ {
			if pl.invn[i].nm == "scrap" {
				scrapNum += pl.invn[i].numof
			}
		}
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].nm == "scrap" {
				scrapNum += storeItm[i].numof
			}
		}

		rl.BeginMode2D(camBase)

		//BG
		if !exiting {
			for i := 0; i < len(baseBG); i++ {
				rl.DrawTexturePro(imgs, baseBG[i].img, baseBG[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.9))
			}
		}

		//MOUSE
		if !exiting {
			rl.DrawTexturePro(imgs, base.mouse.img, shrec(base.mouse.rec, 2), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, base.mouse.img, base.mouse.rec, rl.Vector2Zero(), 0, rl.White)
		}
		if checkmovemouse() {
			base.mouse.rec.X += base.mouse.dirX
			base.mouse.rec.Y += base.mouse.dirY
		} else {
			base.mouse.dirX = RandF32(-base.mouse.spd, base.mouse.spd)
			base.mouse.dirY = RandF32(-base.mouse.spd, base.mouse.spd)
		}
		if frames%4 == 0 {
			if base.mouse.onoff {
				base.mouse.img.X += anm[183].W
				if base.mouse.img.X > anm[183].X+anm[183].frames*anm[183].W {
					base.mouse.img.X = anm[183].X
				}
			} else {
				base.mouse.img.X += anm[182].W
				if base.mouse.img.X > anm[182].X+anm[182].frames*anm[182].W {
					base.mouse.img.X = anm[182].X
				}
			}
		}
		if Abs(base.mouse.dirX) > Abs(base.mouse.dirY) {
			if base.mouse.dirX < 0 {
				base.mouse.img.Y = 0
			} else {
				base.mouse.img.Y = 16
			}
		} else {
			if base.mouse.dirY < 0 {
				base.mouse.img.Y = 48
			} else {
				base.mouse.img.Y = 32
			}
		}

		//IMG
		for i := 0; i < len(base.rec); i++ {
			if base.unlock[i] {
				if !exiting {
					rl.DrawTexturePro(imgs, base.img[i], shrec(base.rec[i], 4), rl.Vector2Zero(), 0, shcol())
					if base.nm[i] == "mushroom patch" && mushroomTimer == mushroomTimerMax {
						if frames%10 == 0 {
							mushCol = RandColor()
						}
						rl.DrawTexturePro(imgs, base.img[i], base.rec[i], rl.Vector2Zero(), 0, mushCol)
					} else if base.nm[i] == "boss key 1" && bosskey1 {
						rl.DrawTexturePro(imgs, base.img[i], base.rec[i], rl.Vector2Zero(), 0, rl.White)
						rl.DrawTexturePro(imgs, base.img[i], base.rec[i], rl.Vector2Zero(), 0, rl.Fade(rl.Orange, fadeblinkF2))
					} else if base.nm[i] == "boss key 2" && bosskey2 {
						rl.DrawTexturePro(imgs, base.img[i], base.rec[i], rl.Vector2Zero(), 0, rl.White)
						rl.DrawTexturePro(imgs, base.img[i], base.rec[i], rl.Vector2Zero(), 0, rl.Fade(rl.Orange, fadeblinkF2))
					} else if base.nm[i] == "boss key 3" && bosskey3 {
						rl.DrawTexturePro(imgs, base.img[i], base.rec[i], rl.Vector2Zero(), 0, rl.White)
						rl.DrawTexturePro(imgs, base.img[i], base.rec[i], rl.Vector2Zero(), 0, rl.Fade(rl.Orange, fadeblinkF2))
					} else if base.nm[i] == "weapon stand" {
						if weapstandon {
							rl.DrawTexturePro(imgs, base.img[i], base.rec[i], rl.Vector2Zero(), 0, rl.Black)
							rl.DrawTexturePro(imgs, base.img[i], base.rec[i], rl.Vector2Zero(), 0, rl.Fade(rl.White, fadeblinkF2))
							if base.fd[i] < 1 {
								base.fd[i] += 0.02
							}
						} else {
							rl.DrawTexturePro(imgs, base.img[i], base.rec[i], rl.Vector2Zero(), 0, rl.Black)
							rl.DrawTexturePro(imgs, base.img[i], base.rec[i], rl.Vector2Zero(), 0, rl.Fade(RandRed(), fadeblinkF2))
							if base.fd[i] < 1 {
								base.fd[i] += 0.02
							}
						}

						siz2 := b + bq
						cntr2 := makecnt(base.rec[i])
						rec2 := rl.NewRectangle(cntr2.X-siz2/2, cntr2.Y-siz2/2, siz2, siz2)
						rec2.Y += b / 2
						rl.DrawTexturePro(imgs, pl.wp1.img, shrec(drec(rec2), 5), orgn(rec2), weapstandro, shcol())
						rl.DrawTexturePro(imgs, pl.wp1.img, drec(rec2), orgn(rec2), weapstandro, rl.White)
						weapstandro += 4

					} else {
						rl.DrawTexturePro(imgs, base.img[i], base.rec[i], rl.Vector2Zero(), 0, rl.Fade(rl.White, base.fd[i]))
						if base.fd[i] < 1 {
							base.fd[i] += 0.02
						}
					}
				}

				if rl.CheckCollisionPointRec(cursorV2Base, base.rec[i]) {
					toptx = base.nm[i]
					if base.nm[i] == "weapon stand" && weapstandon {
						toptx = toptx + " > 1 random weapon change per run"
						if inpL {
							choose := RandInt(1, 6)
							switch choose {
							case 1:
								rl.PlaySound(audfx[124])
							case 2:
								rl.PlaySound(audfx[125])
							case 3:
								rl.PlaySound(audfx[126])
							case 4:
								rl.PlaySound(audfx[127])
							case 5:
								rl.PlaySound(audfx[128])
							}
							weapchangedT = fps * 2
							for {
								choose := weap[RandInt(0, len(weap))]
								if pl.wp1 != choose {
									pl.wp1 = choose
									break
								}
							}
							weapstandon = false
							campfxrecs2 = append(campfxrecs2, base.rec[i])
							campfximgrecs2 = append(campfximgrecs2, anm[200].rec)
						}
					} else if base.nm[i] == "weapon stand" && !weapstandon {
						toptx = "unavailable till next run"
					}
					if base.nm[i] == "to the dungeon" && treasureroom {
						toptx = "the treasure room awaits"
					}
					if base.lev[i] != 0 {
						toptx += " > level " + fmt.Sprint(base.lev[i])
					}
					if base.lev[i] > 0 && base.lev[i] < 3 {
						toptx = toptx + " > 20 scrap to upgrade"
					}
					toptxT = fps
				}

				//MUSHROOM TIMER
				if base.nm[i] == "mushroom patch" {
					if !exiting {
						siz2 := b / 3
						W := float32(mushroomTimerMax) * siz2
						x2 := (base.rec[i].X + base.rec[i].Width/2) - W/2
						y2 := base.rec[i].Y + base.rec[i].Height + 12
						bgrec := rl.NewRectangle(x2-2, y2-2, W+4, siz2+4)
						rl.DrawRectangleRec(bgrec, rl.Fade(rl.Black, 0.9))
						x2 = (base.rec[i].X + base.rec[i].Width/2) - W/2
						y2 = base.rec[i].Y + base.rec[i].Height + 12
						for j := 0; j < mushroomTimer; j++ {
							rec := rl.NewRectangle(x2, y2, siz2, siz2)
							rl.DrawRectangleRec(rec, rl.DarkPurple)
							x2 += siz2
						}
					}
				}

				//TREASURE ROOM COIN
				if base.nm[i] == "to the dungeon" && treasureroom {
					if !exiting {
						siz := b + b/2
						x2 := base.rec[i].X + base.rec[i].Width/2 - (siz/4)*3
						y2 := base.rec[i].Y - siz/4
						rec3 := rl.NewRectangle(x2, y2, siz, siz)
						rl.DrawTexturePro(imgs, anm[187].rec, rec3, rl.Vector2Zero(), 0, rl.White)
						//rl.DrawRectangleRec(rec3, RandColor())
						if frames%5 == 0 {
							anm[187].rec.X += anm[187].W
							if anm[187].rec.X > anm[187].X+anm[187].frames*anm[187].W {
								anm[187].rec.X = anm[187].X
							}
						}
					}
				}

				//DRAW LEVEL STARS
				if base.lev[i] >= 1 {
					if !exiting {
						siz := bq3
						x2 := base.rec[i].X
						y2 := base.rec[i].Y
						if base.nm[i] == "mushroom patch" {
							y2 -= siz
						} else if base.nm[i] == "weapon shed" {
							y2 -= siz / 3
						}
						for j := 1; j < 4; j++ {
							rec := rl.NewRectangle(x2, y2, siz, siz)
							rec2 := rec
							rec2.X -= 2
							rec2.Y -= 2
							rec2.Width += 4
							rec2.Height += 4
							rl.DrawTexturePro(imgs, etc[181], rec2, rl.Vector2Zero(), 0, rl.Fade(rl.Black, 0.7))
							if j <= base.lev[i] {
								rl.DrawTexturePro(imgs, etc[181], rec, rl.Vector2Zero(), 0, rl.White)
							}
							x2 += rec2.Width
						}
					}
				}

				if base.nm[i] == "campfire" {
					if frames%6 == 0 {
						base.img[i].X += anm[72].W
						if base.img[i].X > anm[72].X+anm[72].frames*anm[72].W {
							base.img[i].X = anm[72].X
						}
					}
				}

				//UPGRADE STRUCTURE LEVEL
				if base.lev[i] < 3 && base.lev[i] > 0 {
					if rl.CheckCollisionPointRec(cursorV2Base, base.rec[i]) {
						if scrapNum >= base.cost[i] {
							if inpL {
								rl.PlaySound(audfx[47])
								base.lev[i]++
								total := base.cost[i]
								for j := 0; j < len(storeItm); j++ {
									if storeItm[j].nm == "scrap" {
										if storeItm[j].numof > total {
											storeItm[j].numof -= total
											total = 0
										} else {
											total -= storeItm[j].numof
											storeItm[j].off = true
											storeItm[j] = xitm{}
										}
										if total == 0 {
											break
										}
									}
								}
								if total != 0 {
									for j := 0; j < len(pl.invn); j++ {
										if pl.invn[j].nm == "scrap" {
											if pl.invn[j].numof > total {
												pl.invn[j].numof -= total
												total = 0
											} else {
												total -= pl.invn[j].numof
												pl.invn[j].off = true
												pl.invn[j] = xitm{}
											}
											if total == 0 {
												break
											}
										}
									}
								}
								campfxrecs2 = append(campfxrecs2, base.rec[i])
								campfximgrecs2 = append(campfximgrecs2, anm[200].rec)
							}
						} else {
							if inpL {
								notenoughscrapT = fps * 2
								rl.PlaySound(audfx[43])
							}
						}
					}
				}

			} else {
				if !exiting {
					if base.nm[i] == "boss key 1" {
						rl.DrawTexturePro(imgs, base.img[i], shrec(base.rec[i], 4), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, base.img[i], base.rec[i], rl.Vector2Zero(), 0, DarkRed())
					} else if base.nm[i] == "boss key 2" {
						rl.DrawTexturePro(imgs, base.img[i], shrec(base.rec[i], 4), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, base.img[i], base.rec[i], rl.Vector2Zero(), 0, DarkRed())
					} else if base.nm[i] == "boss key 3" {
						rl.DrawTexturePro(imgs, base.img[i], shrec(base.rec[i], 4), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, base.img[i], base.rec[i], rl.Vector2Zero(), 0, DarkRed())
					} else {
						rl.DrawTexturePro(imgs, base.img[i], base.rec[i], rl.Vector2Zero(), 0, rl.Fade(rl.Black, 0.8))
						cntr := rl.NewVector2(base.rec[i].X+base.rec[i].Width/2, base.rec[i].Y+base.rec[i].Height/2)
						siz2 := b + bq3
						if base.nm[i] == "weapon stand" {
							siz2 = b + bq
						}
						rec3 := rl.NewRectangle(cntr.X-siz2/2, cntr.Y-siz2/2, siz2, siz2)
						rec4 := rec3
						rec4.X -= 3
						rec4.Y += 3
						rl.DrawTexturePro(imgs, etc[46], rec4, rl.Vector2Zero(), 0, rl.Fade(rl.Black, 0.7))
						rl.DrawTexturePro(imgs, etc[46], rec3, rl.Vector2Zero(), 0, rl.White)
					}
				}

				//BASE UNLOCK
				if rl.CheckCollisionPointRec(cursorV2Base, base.rec[i]) && base.nm[i] != "boss key 1" && base.nm[i] != "boss key 2" && base.nm[i] != "boss key 3" {
					toptx = fmt.Sprint(base.cost[i]) + " scrap to unlock "
					toptxT = fps
					if scrapNum >= base.cost[i] {
						if inpL {
							rl.PlaySound(audfx[46])
							base.unlock[i] = true
							if base.nm[i] == "store room" {
								storeunlocked = true
							}
							total := base.cost[i]
							for j := 0; j < len(storeItm); j++ {
								if storeItm[j].nm == "scrap" {
									if storeItm[j].numof > total {
										storeItm[j].numof -= total
										total = 0
									} else {
										total -= storeItm[j].numof
										storeItm[j].off = true
										storeItm[j] = xitm{}
									}
									if total == 0 {
										break
									}
								}
							}
							if total != 0 {
								for j := 0; j < len(pl.invn); j++ {
									if pl.invn[j].nm == "scrap" {
										if pl.invn[j].numof > total {
											pl.invn[j].numof -= total
											total = 0
										} else {
											total -= pl.invn[j].numof
											pl.invn[j].off = true
											pl.invn[j] = xitm{}
										}
										if total == 0 {
											break
										}
									}
								}
							}

							campfxrecs = append(campfxrecs, base.rec[i])
							campfximgrecs = append(campfximgrecs, anm[199].rec)

						}
					} else {
						if inpL {
							notenoughscrapT = fps * 2
							rl.PlaySound(audfx[43])
						}
					}
				} else if rl.CheckCollisionPointRec(cursorV2Base, base.rec[i]) {
					toptx = base.nm[i]
					toptxT = fps
				}
			}

			//PLAYER BASE STRUCTURE COLLISIONS
			if rl.CheckCollisionRecs(pl2.crec, base.carec[i]) && !exitcollis {
				switch base.nm[i] {
				case "apothecary":
					if base.unlock[i] {
						rl.PlaySound(audfx[49])
						makebgpix()
						makePotionList()
						makeScrollList()
						apothercaryon = true
						pl2.cnt = cnt
						upplayerrec()
					}
				case "mushroom patch":
					if base.unlock[i] {
						if mushroomTimer == mushroomTimerMax && storeunlocked {
							rl.PlaySound(audfx[65])
							num := 0
							if base.lev[i] == 1 {
								num = 20
							} else if base.lev[i] == 2 {
								num = 30
							} else if base.lev[i] == 3 {
								num = 40
							}

							var newMush []xitm
							div := num / 10
							for div > 0 {
								choose := RandInt(1, 7)
								switch choose {
								case 1:
									zitm := itmlist[105]
									zitm.numof = 10
									newMush = append(newMush, zitm)
								case 2:
									zitm := itmlist[106]
									zitm.numof = 10
									newMush = append(newMush, zitm)
								case 3:
									zitm := itmlist[107]
									zitm.numof = 10
									newMush = append(newMush, zitm)
								case 4:
									zitm := itmlist[108]
									zitm.numof = 10
									newMush = append(newMush, zitm)
								case 5:
									zitm := itmlist[109]
									zitm.numof = 10
									newMush = append(newMush, zitm)
								case 6:
									zitm := itmlist[110]
									zitm.numof = 10
									newMush = append(newMush, zitm)
								}
								div--
							}
							full := false
							for i := 0; i < len(newMush); i++ {
								for j := 0; j < len(storeItm); j++ {
									if storeItm[j].nm == "" {
										storeItm[j] = newMush[i]
										break
									}
								}
							}
							if full {
								toptx = "store room is full > mushrooms disposed"
								toptxT = fps * 2
							} else {
								toptx = "mushrooms placed in store room"
								toptxT = fps * 2
							}
							mushPause = 600
							mushroomTimer = 0
						} else if mushroomTimer == mushroomTimerMax && !storeunlocked {
							if toptxT == 0 {
								toptx = "store room is locked"
								toptxT = fps * 2
							}
						} else {
							if mushPause == 0 {
								rl.PlaySound(audfx[43])
								toptx = "go back to the dungeons > mushrooms not ready"
								toptxT = fps * 2
							}
						}
					}
				case "weapon shed":
					if base.unlock[i] {
						rl.PlaySound(audfx[49])
						makebgpix()
						weaponshedon = true
						if pl.wp1.nm != "" {
							selnumWeap = 0
						} else {
							selnumWeap = 1
						}

						pl2.cnt = cnt
						upplayerrec()
					}
				case "store room":
					if base.unlock[i] {
						rl.PlaySound(audfx[49])
						makebgpix()
						storeon = true
						pl2.cnt = cnt
						upplayerrec()
					}
				case "book of unlock things":
					choose := RandInt(1, 9)
					switch choose {
					case 1:
						rl.PlaySound(audfx[58])
					case 2:
						rl.PlaySound(audfx[59])
					case 3:
						rl.PlaySound(audfx[60])
					case 4:
						rl.PlaySound(audfx[61])
					case 5:
						rl.PlaySound(audfx[62])
					case 6:
						rl.PlaySound(audfx[63])
					case 7:
						rl.PlaySound(audfx[64])
					}
					makebgpix()
					bookon = true
					pl2.cnt = cnt
					upplayerrec()
				case "to the dungeon":
					exitcollis = true
				}
			}
			if debug {
				rl.DrawRectangleLinesEx(base.rec[i], 1, rl.White)
				rl.DrawRectangleLinesEx(base.crec[i], 1, rl.Magenta)
				rl.DrawRectangleLinesEx(base.carec[i], 1, rl.Blue)
			}
		}

		//EXIT ANIMATION
		if exitcollis {
			if !exiting {
				choose := RandInt(1, 9)
				switch choose {
				case 1:
					rl.PlaySound(audfx[50])
				case 2:
					rl.PlaySound(audfx[51])
				case 3:
					rl.PlaySound(audfx[52])
				case 4:
					rl.PlaySound(audfx[53])
				case 5:
					rl.PlaySound(audfx[54])
				case 6:
					rl.PlaySound(audfx[55])
				case 7:
					rl.PlaySound(audfx[56])
				case 8:
					rl.PlaySound(audfx[57])
				}
				introAnim.X = anm[204].X
				exiting = true

			}

			if introAnim.X < anm[204].X+anm[204].frames*anm[204].W {
				siz2 := (b10 * 2) + 5
				if xxl {
					siz2 = b10 * 4
				}
				rec2 := rl.NewRectangle(cnt.X-siz2/2, cnt.Y-siz2/2, siz2, siz2)
				rl.DrawTexturePro(imgs, introAnim, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.5, 0.7)))
				rl.DrawTexturePro(imgs, introAnim, brec(rec2, 7), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.3, 0.5)))
				rl.DrawTexturePro(imgs, introAnim, brec(rec2, 12), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.1, 0.3)))
				if frames%3 == 0 {
					introAnim.X += anm[204].W
				}
			} else {
				pl2.cnt = cnt
				upplayerrec()
				if treasureroom {
					makelevel()
					if storeunlocked {
						savestore()
					}
					baseon = false
					pause = false
					saveT = fps * 2
					rl.StopMusicStream(music[currentMusic])
					currentMusic = 3
					rl.PlayMusicStream(music[currentMusic])

				} else {
					if storeunlocked {
						savestore()
					}
					baseon = false
					pause = false
					saveT = fps * 2
					rl.StopMusicStream(music[currentMusic])
					switch dispMusic {
					case 0:
						rl.StopMusicStream(music[currentMusic])
						currentMusic = RandInt(4, len(music))
						rl.PlayMusicStream(music[currentMusic])
					case 1:
						rl.StopMusicStream(music[currentMusic])
						currentMusic = 4
						rl.PlayMusicStream(music[currentMusic])
					case 2:
						rl.StopMusicStream(music[currentMusic])
						currentMusic = 5
						rl.PlayMusicStream(music[currentMusic])
					case 3:
						rl.StopMusicStream(music[currentMusic])
						currentMusic = 6
						rl.PlayMusicStream(music[currentMusic])
					}
				}

				introAnim.X = anm[204].X
				exitcollis = false
			}
		}

		//UNLOCK FX
		if len(campfxrecs) > 0 {
			clear := false
			num := 0
			for i := 0; i < len(campfxrecs); i++ {
				rl.DrawTexturePro(imgs, campfximgrecs[i], shrec(campfxrecs[i], 30), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, campfximgrecs[i], campfxrecs[i], rl.Vector2Zero(), 0, rl.White)
				rl.DrawTexturePro(imgs, campfximgrecs[i], brec(campfxrecs[i], 7), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.3, 0.5)))
				rl.DrawTexturePro(imgs, campfximgrecs[i], brec(campfxrecs[i], 12), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.1, 0.3)))
				if frames%3 == 0 {
					if campfximgrecs[i].X < anm[199].X+anm[199].frames*anm[199].W {
						campfximgrecs[i].X += anm[199].W
					} else {
						clear = true
						num = i
					}
				}
			}
			if clear {
				campfxrecs = RemoveRectangle(campfxrecs, num)
				campfximgrecs = RemoveRectangle(campfximgrecs, num)
			}
		}
		if len(campfxrecs2) > 0 {
			clear := false
			num := 0
			for i := 0; i < len(campfxrecs2); i++ {
				rl.DrawTexturePro(imgs, campfximgrecs2[i], shrec(campfxrecs2[i], 30), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, campfximgrecs2[i], campfxrecs2[i], rl.Vector2Zero(), 0, rl.White)
				rl.DrawTexturePro(imgs, campfximgrecs2[i], brec(campfxrecs2[i], 7), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.3, 0.5)))
				rl.DrawTexturePro(imgs, campfximgrecs2[i], brec(campfximgrecs2[i], 12), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.1, 0.3)))
				if frames%3 == 0 {
					if campfximgrecs2[i].X < anm[200].X+anm[200].frames*anm[200].W {
						campfximgrecs2[i].X += anm[200].W
					} else {
						clear = true
						num = i
					}
				}
			}
			if clear {
				campfxrecs2 = RemoveRectangle(campfxrecs2, num)
				campfximgrecs2 = RemoveRectangle(campfximgrecs2, num)
			}
		}
		//DRAW ROLLO COMPANION

		if rollo {
			if !exiting {
				rec3 := rollocomp.rec
				rec3.X -= 4
				rec3.Y -= 4
				rec3.Width += 8
				rec3.Height += 8
				rl.DrawTexturePro(imgs, rollocomp.img, shrec(rec3, 5), rl.Vector2Zero(), 0, shcol())
				rec2 := rec3
				rec2.X += (rollocomp.dirX * 2) * -1
				rec2.Y += (rollocomp.dirY * 2) * -1
				rec2.X += rec2.Width / 16
				rec2.Y += rec2.Height / 16
				rec2.Width -= rec2.Width / 8
				rec2.Height -= rec2.Height / 8
				rl.DrawTexturePro(imgs, rollocomp.img, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.2))
				rec2.X += (rollocomp.dirX * 2) * -1
				rec2.Y += (rollocomp.dirY * 2) * -1
				rec2.X += rec2.Width / 16
				rec2.Y += rec2.Height / 16
				rec2.Width -= rec2.Width / 8
				rec2.Height -= rec2.Height / 8
				rl.DrawTexturePro(imgs, rollocomp.img, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.15))
				rec2.X += (rollocomp.dirX * 2) * -1
				rec2.Y += (rollocomp.dirY * 2) * -1
				rec2.X += rec2.Width / 16
				rec2.Y += rec2.Height / 16
				rec2.Width -= rec2.Width / 8
				rec2.Height -= rec2.Height / 8
				rl.DrawTexturePro(imgs, rollocomp.img, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.1))
				rec2.X += (rollocomp.dirX * 2) * -1
				rec2.Y += (rollocomp.dirY * 2) * -1
				rec2.X += rec2.Width / 16
				rec2.Y += rec2.Height / 16
				rec2.Width -= rec2.Width / 8
				rec2.Height -= rec2.Height / 8
				rl.DrawTexturePro(imgs, rollocomp.img, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.05))
				rl.DrawTexturePro(imgs, rollocomp.img, rec3, rl.Vector2Zero(), 0, rl.White)
				if frames%2 == 0 {
					if rollocomp.lr {
						rollocomp.img.X -= anm[154].W
						if rollocomp.img.X < anm[154].X-anm[154].frames*anm[154].W {
							rollocomp.img.X = anm[154].X
						}
					} else {
						rollocomp.img.X += anm[153].W
						if rollocomp.img.X > anm[153].X+anm[153].frames*anm[153].W {
							rollocomp.img.X = anm[153].X
						}
					}
				}
			}
		}

		//DRAW PLAYER

		rec2 := pl2.rec //INCREASE SIZE OF PLAYER DRAW IMAGE
		rec2.X -= b / 8
		rec2.Y -= b / 5
		rec2.Width += b / 4
		rec2.Height += b / 4
		if !exiting {
			rl.DrawTexturePro(imgs, pl2.anim[pl2.aninum].rec, shrec(rec2, 3), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, pl2.anim[pl2.aninum].rec, rec2, rl.Vector2Zero(), 0, rl.White)

			if loadedT > 0 {
				txt := "loaded"
				txs := tx5
				txlen := rl.MeasureText(txt, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx := int32(cnt.Y) - txs/8
				ytx += pl.rec.ToInt32().Height
				rl.DrawText(txt, xtx, ytx, txs, rl.Fade(RandColor(), 0.2))
				loadedT--
			}
			if notenoughscrapT > 0 {
				txt := "not enough scrap"
				txs := tx5
				txlen := rl.MeasureText(txt, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx := int32(cnt.Y) - txs/8
				ytx += pl.rec.ToInt32().Height
				rl.DrawText(txt, xtx, ytx, txs, rl.Fade(RandColor(), 0.2))
				notenoughscrapT--
			}
			if weapchangedT > 0 {
				txt := pl.wp1.nm + " > new weapon"
				txs := tx5
				txlen := rl.MeasureText(txt, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx := int32(cnt.Y) - txs/8
				ytx += pl.rec.ToInt32().Height
				rl.DrawText(txt, xtx, ytx, txs, rl.Fade(RandColor(), 0.2))
				weapchangedT--
			}

			//DRAW BAT COMPANION
			if batty {
				rec3 := batcomp.rec
				rec3.X -= 7
				rec3.Y -= 7
				rec3.Width += 14
				rec3.Height += 14
				rl.DrawTexturePro(imgs, batcomp.img, shrec(rec3, 20), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, batcomp.img, rec3, rl.Vector2Zero(), 0, rl.White)
				if frames%2 == 0 {
					if batcomp.lr {
						batcomp.img.X -= anm[142].W
						if batcomp.img.X < anm[142].X-anm[142].frames*anm[142].W {
							batcomp.img.X = anm[142].X
						}
					} else {
						batcomp.img.X += anm[141].W
						if batcomp.img.X > anm[141].X+anm[141].frames*anm[141].W {
							batcomp.img.X = anm[141].X
						}
					}
				}
			}

			//PIGEON
			if base.pigeonT > 0 {
				base.pigeonT--
				if base.pigeonT == 1 {
					base.pigeonoff = !base.pigeonoff
				}
			}
			if !base.pigeonoff {
				rl.DrawTexturePro(imgs, base.pigeon.img, shrec(base.pigeon.rec, 20), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, base.pigeon.img, base.pigeon.rec, rl.Vector2Zero(), 0, rl.White)
				if frames%4 == 0 {
					if base.pigeon.dirX < 0 {
						base.pigeon.img.X -= anm[74].W
						if base.pigeon.img.X < anm[74].X-anm[74].frames*anm[74].W {
							base.pigeon.img.X = anm[74].X
						}
					} else {
						base.pigeon.img.X += anm[73].W
						if base.pigeon.img.X > anm[73].X+anm[73].frames*anm[73].W {
							base.pigeon.img.X = anm[73].X
							base.pigeonT = fps * RandInt32(5, 11)
						}
					}
				}
				base.pigeon.rec.X += base.pigeon.dirX
				if base.pigeon.rec.X > baseBordRec.X+baseBordRec.Width+base.pigeon.rec.Width {
					base.pigeon.dirX = -base.pigeon.dirX
					base.pigeon.rec.Y = RandF32(baseBordRec.Y+b/4, baseBordRec.Y+baseBordRec.Height/2)
					base.pigeonoff = true
				}
				if base.pigeon.rec.X < baseBordRec.X-base.pigeon.rec.Width*2 {
					base.pigeon.dirX = Abs(base.pigeon.dirX)
					base.pigeon.rec.Y = RandF32(baseBordRec.Y+b/4, baseBordRec.Y+baseBordRec.Height/2)
					base.pigeonoff = true
					base.pigeonT = fps * RandInt32(5, 11)
				}
			}
		}
		//DEBUG
		if debug {
			rl.DrawRectangleLinesEx(pl2.rec, 1, rl.Magenta)
			rl.DrawRectangleLinesEx(pl2.crec, 1, rl.Red)
			rl.DrawCircleV(pl2.cnt, 2, RandColor())
			rl.DrawRectangleLinesEx(baseBordRec, 2, rl.Yellow)
		}
		plWorldScreenV2 := rl.GetWorldToScreen2D(pl2.cnt, camBase)
		if cursorV2.X < plWorldScreenV2.X {
			pl2.direc = true
		} else if cursorV2.X > plWorldScreenV2.X {
			pl2.direc = false
		}
		pl2.aninum = 0
		if pl2.direc {
			pl2.aninum = 1
		}
		if rl.IsKeyDown(rl.KeyW) || rl.IsKeyDown(rl.KeyUp) || rl.GetGamepadAxisMovement(0, 1) < 0 || rl.IsGamepadButtonDown(0, 1) { //UP
			if checkplayermoveBase(1) {
				pl2.cnt.Y -= pl2.spd / 2
			}
			pl2.aninum = 4
		}
		if rl.IsKeyDown(rl.KeyS) || rl.IsKeyDown(rl.KeyDown) || rl.GetGamepadAxisMovement(0, 1) > 0 || rl.IsGamepadButtonDown(0, 3) { //DOWN
			if checkplayermoveBase(3) {
				pl2.cnt.Y += pl2.spd / 2
			}
			pl2.aninum = 2
			if pl2.direc {
				pl2.aninum = 3
			}
		}
		if rl.IsKeyDown(rl.KeyA) || rl.IsKeyDown(rl.KeyLeft) || rl.GetGamepadAxisMovement(0, 0) < 0 || rl.IsGamepadButtonDown(0, 4) { //LEFT
			if checkplayermoveBase(4) {
				pl2.cnt.X -= pl2.spd / 2
			}
			pl2.aninum = 3
			pl2.direc = true
		}
		if rl.IsKeyDown(rl.KeyD) || rl.IsKeyDown(rl.KeyRight) || rl.GetGamepadAxisMovement(0, 0) > 0 || rl.IsGamepadButtonDown(0, 2) { //RIGHT
			if checkplayermoveBase(2) {
				pl2.cnt.X += pl2.spd / 2
			}
			pl2.aninum = 2
			pl2.direc = false
		}
		upplayerrec()
		if frames%7 == 0 { //IDLE ANIM
			pl2.anim[0].rec.X += pl2.anim[0].W
			if pl2.anim[0].rec.X > pl2.anim[0].X+pl2.anim[0].frames*pl2.anim[0].W {
				pl2.anim[0].rec.X = pl2.anim[0].X
			}
			pl2.anim[1].rec.X -= pl2.anim[1].W
			if pl2.anim[1].rec.X < pl2.anim[1].X-pl2.anim[1].frames*pl2.anim[1].W {
				pl2.anim[1].rec.X = pl2.anim[1].X
			}
		}
		if frames%3 == 0 { //RUN PUSH ANIM
			pl2.anim[4].rec.X += pl2.anim[4].W
			if pl2.anim[4].rec.X > pl2.anim[4].X+pl2.anim[4].frames*pl2.anim[4].W {
				pl2.anim[4].rec.X = pl2.anim[4].X
			}
			pl2.anim[2].rec.X += pl2.anim[2].W
			if pl2.anim[2].rec.X > pl2.anim[2].X+pl2.anim[2].frames*pl2.anim[2].W {
				pl2.anim[2].rec.X = pl2.anim[2].X
			}
			pl2.anim[3].rec.X -= pl2.anim[3].W
			if pl2.anim[3].rec.X < pl2.anim[3].X-pl2.anim[3].frames*pl2.anim[3].W {
				pl2.anim[3].rec.X = pl2.anim[3].X
			}
		}

		rl.EndMode2D()

		//SCRAP NUM
		siz2 := b + bq
		txs := tx4
		if med {
			siz2 = bq3
			txs = tx2
		}
		if xxl {
			siz2 = b2
			txs = tx8
		}
		rec2 = rl.NewRectangle(4, 4, siz2, siz2)
		if !exiting {
			rl.DrawRectangleRec(rec2, rl.Black)
			rl.DrawTexturePro(imgs, etc[55], rec2, rl.Vector2Zero(), 0, rl.White)
			xtx := rec2.ToInt32().X + rec2.ToInt32().Width + txs/3
			ytx := rec2.ToInt32().Y + 2
			rl.DrawText(fmt.Sprint(scrapNum), xtx, ytx, txs, rl.Black)

			if rl.CheckCollisionPointRec(gameCursor, rec2) || rl.CheckCollisionPointRec(cursorV2, rec2) {
				toptx = "scrap available to unlock"
				toptxT = fps * 2
			}

			//TOP INFO
			if toptxT > 0 && !options && !charscr {
				siz := tx3
				if med {
					siz = tx2
				}
				if xxl {
					siz = tx6
				}
				txlen := rl.MeasureText(toptx, siz)
				cntr := rl.NewVector2(scrWF32/2, scrHF32/2)
				x := int32(cntr.X) - txlen/2
				y := int32(b / 4)
				txrec := rl.NewRectangle(float32(x-8), float32(y-4), float32(txlen+16), float32(siz+8))
				rl.DrawRectangleRec(txrec, rl.Fade(rl.Black, 0.7))
				rl.DrawText(toptx, x-2, y+2, siz, rl.Black)
				rl.DrawText(toptx, x, y, siz, rl.White)
			}
			if toptxT > 0 {
				toptxT--
			}
		}
	}
}

func drawcam() { //MARK:DRAW CAM

	//DRAW GAME LEVEL
	if !pause {
		//LEVEL
		lev := levels[levNum].recs
		floor := levels[levNum].floors
		dbg := levels[levNum].dbg
		inf := levels[levNum].inf
		doors := levels[levNum].doors
		walls := levels[levNum].walls
		etc2 := levels[levNum].etc
		chests := levels[levNum].chst
		itm := levels[levNum].itm
		enm := levels[levNum].enm
		bgi := levels[levNum].bgi
		bgi2 := levels[levNum].bgi2
		flowers := levels[levNum].flowers
		//FLOORS
		for i := 0; i < len(floor); i++ {
			if rl.CheckCollisionRecs(floor[i].rec, drawRec) {
				rl.DrawRectangleRec(floor[i].rec, rl.Black)
				if psychedelicsT > 0 {
					rl.DrawTexturePro(imgs, floortile, floor[i].rec, rl.Vector2Zero(), 0, rl.Fade(floor[i].col2, floor[i].fade))
				} else {
					rl.DrawTexturePro(imgs, floortile, floor[i].rec, rl.Vector2Zero(), 0, rl.Fade(floor[i].color, floor[i].fade))
				}
			}
		}
		//BGI
		for i := 0; i < len(bgi); i++ {
			if rl.CheckCollisionRecs(bgi[i].rec, drawRec) {
				rl.DrawTexturePro(imgs, bgi[i].img, shrec(bgi[i].rec, 12), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, bgi[i].img, bgi[i].rec, rl.Vector2Zero(), 0, rl.DarkGray)
			}
		}
		//BGI 2
		for i := 0; i < len(bgi2); i++ {
			if rl.CheckCollisionRecs(bgi2[i].rec, drawRec) {
				rl.DrawTexturePro(imgs, bgi2[i].img, shrec(drec(bgi2[i].rec), 12), orgn(bgi2[i].rec), bgi2[i].ro, shcol())
				rl.DrawTexturePro(imgs, bgi2[i].img, drec(bgi2[i].rec), orgn(bgi2[i].rec), bgi2[i].ro, rl.Fade(rl.DarkGray, 0.7))
			}
		}
		//FLOWERS
		for i := 0; i < len(flowers); i++ {
			if rl.CheckCollisionRecs(flowers[i].rec, drawRec) {
				rl.DrawTexturePro(imgs, flowers[i].img, shrec(flowers[i].rec, 5), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, flowers[i].img, flowers[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.7))
			}
		}
		//MARK: DRAW FX LAYER BELOW
		if len(fx) > 0 {
			clear := false
			for i := 0; i < len(fx); i++ {
				if !fx[i].off && fx[i].below {

					switch fx[i].nm {
					case "sludgegeyser":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 5), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.5, 0.7)))
						rl.DrawTexturePro(imgs, fx[i].img, brec(fx[i].rec, 5), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.3, 0.5)))
						if frames%5 == 0 {
							if fx[i].img.X < anm[203].X+anm[203].frames*anm[203].W {
								fx[i].img.X += anm[203].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, fx[i].rec) {
								if !levels[levNum].enm[j].nodmg {
									if levels[levNum].enm[j].fly {
										if msgT == 0 {
											admsg("immune > enemy is flying", rl.Yellow)
											msgT = fps
										}
									} else {
										if levels[levNum].enm[j].poisonT == 0 {
											levels[levNum].enm[j].poisonT += fps * 3
										}
									}
								}
							}
						}
					case "hotsoup":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 5), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(DarkRed(), fx[i].fade))
						rec3 := fx[i].rec
						rec3.X += RandF32(-4, 4)
						rec3.Y += RandF32(-4, 4)
						rl.DrawTexturePro(imgs, fx[i].img, rec3, rl.Vector2Zero(), 0, rl.Fade(DarkRed(), RandF32(0.05, 0.15)))
						fx[i].fade -= 0.005
						if fx[i].fade <= 0 {
							fx[i].off = true
							clear = true
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Yellow)
							rl.DrawRectangleLinesEx(fx[i].crec, 2, rl.Magenta)
						}
						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, fx[i].crec) {
								if !levels[levNum].enm[j].nodmg {
									if levels[levNum].enm[j].fly {
										if msgT == 0 {
											admsg("immune > enemy is flying", rl.Yellow)
											msgT = fps
										}
									} else {
										if levels[levNum].enm[j].burnT == 0 {
											levels[levNum].enm[j].burnT += fps * 3
										}
									}
								}
							}
						}
						if rl.CheckCollisionPointRec(cursorV2cam, fx[i].rec) {
							toptx = "hot soup"
							toptxT = fps
						}
					case "frenchfries":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 5), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.Black, fx[i].fade))
						rec3 := fx[i].rec
						rec3.X += RandF32(-4, 4)
						rec3.Y += RandF32(-4, 4)
						rl.DrawTexturePro(imgs, fx[i].img, rec3, rl.Vector2Zero(), 0, rl.Fade(RandBlue(), RandF32(0.05, 0.15)))
						fx[i].fade -= 0.005
						if fx[i].fade <= 0 {
							fx[i].off = true
							clear = true
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Yellow)
							rl.DrawRectangleLinesEx(fx[i].crec, 2, rl.Magenta)
						}
						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, fx[i].crec) {
								if !levels[levNum].enm[j].nodmg {
									if levels[levNum].enm[j].fly {
										if msgT == 0 {
											admsg("immune > enemy is flying", rl.Yellow)
											msgT = fps
										}
									} else {
										if levels[levNum].enm[j].oilT == 0 {
											levels[levNum].enm[j].oilT = fps * 5
										}
									}
								}
							}
						}
						if rl.CheckCollisionPointRec(cursorV2cam, fx[i].rec) {
							toptx = "oil slick"
							toptxT = fps
						}
					case "icecream":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 5), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandBlue(), RandF32(0.1, 0.3)))
						rec3 := fx[i].rec
						rec3.X += RandF32(-4, 4)
						rec3.Y += RandF32(-4, 4)
						rl.DrawTexturePro(imgs, fx[i].img, rec3, rl.Vector2Zero(), 0, rl.Fade(RandBlue(), RandF32(0.05, 0.15)))
						fx[i].fade -= 0.005
						if fx[i].fade <= 0 {
							fx[i].off = true
							clear = true
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Yellow)
							rl.DrawRectangleLinesEx(fx[i].crec, 2, rl.Magenta)
						}
						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, fx[i].crec) {
								if !levels[levNum].enm[j].nodmg {
									if levels[levNum].enm[j].fly {
										if msgT == 0 {
											admsg("immune > enemy is flying", rl.Yellow)
											msgT = fps
										}
									} else {
										if levels[levNum].enm[j].freezeT == 0 {
											levels[levNum].enm[j].freezeT = fps * 3
										}
									}
								}
							}
						}
						if rl.CheckCollisionPointRec(cursorV2cam, fx[i].rec) {
							toptx = "ice cream sludge"
							toptxT = fps
						}
					case "birdegg":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 4), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, fx[i].fade))
						fx[i].fade -= 0.007
						if fx[i].fade <= 0 {
							fx[i].off = true
							clear = true
						}
					case "mrfrisbeenear":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandYellow(), RandF32(0.4, 0.7)))
						if frames%3 == 0 {
							if fx[i].img.X < anm[117].X+anm[117].frames*anm[117].W {
								fx[i].img.X += anm[117].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
					case "bomb":
						//FUSE
						rec3 := fx[i].rec
						rec3.Y -= rec3.Height / 2
						rec3.X -= b / 4
						rec3.Y -= b / 4
						rec3.Width += b / 2
						rec3.Height += b / 2
						rl.DrawTexturePro(imgs, anm[105].rec, rec3, rl.Vector2Zero(), 0, rl.White)
						if frames%4 == 0 {
							anm[105].rec.X += anm[105].W
							if anm[105].rec.X > anm[105].X+anm[105].frames*anm[105].W {
								anm[105].rec.X = anm[105].X
							}
						}
						//IMG
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 5), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.White)
						fx[i].T--
						if fx[i].T == 0 {
							rl.PlaySound(audfx[94])
							zfx := xfx{}
							zfx.nm = "bombExplode"
							zfx.rec = fx[i].rec
							zfx.rec.X -= b10
							zfx.rec.Y -= b10
							zfx.rec.Width += b10 * 2
							zfx.rec.Height += b10 * 2
							zfx.img = anm[106].rec
							fx = append(fx, zfx)
							fx[i].off = true
							clear = true
						}
					case "chickenEgg":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 5), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.4, 0.7)))
						fx[i].T--
						if fx[i].T == 0 {
							zfx := xfx{}
							zfx.nm = "chickenExplode"
							zfx.img = anm[104].rec
							zfx.rec = fx[i].rec
							zfx.rec.X -= b5
							zfx.rec.Y -= b8
							zfx.rec.Width += b10
							zfx.rec.Height += b10
							zfx.crec = zfx.rec
							zfx.crec.X += b2
							zfx.crec.Y += b2
							zfx.crec.Width -= b4
							zfx.crec.Height -= b4
							fx = append(fx, zfx)
							fx[i].off = true
							clear = true
						}
					case "flamingoflame":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 5), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, fx[i].fade))
						rec3 := fx[i].rec
						rec3.X += RandF32(-4, 4)
						rec3.Y += RandF32(-4, 4)
						rl.DrawTexturePro(imgs, fx[i].img, rec3, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.2))
						if frames%4 == 0 {
							fx[i].img.X += anm[98].W
							if fx[i].img.X > anm[98].X+anm[98].frames*anm[98].W {
								fx[i].img.X = anm[98].X
							}
						}
						fx[i].T--
						if fx[i].T < fps {
							fx[i].fade -= 0.05
						}
						if fx[i].T == 0 {
							fx[i].off = true
							clear = true
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Yellow)
							rl.DrawRectangleLinesEx(fx[i].crec, 2, rl.Magenta)
						}
						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, fx[i].crec) {
								if !levels[levNum].enm[j].nodmg && levels[levNum].enm[j].burnT == 0 {
									if levels[levNum].enm[j].nm == "flamehead" || levels[levNum].enm[j].nm == "yellowdino" || levels[levNum].enm[j].nm == "ghost" || levels[levNum].enm[j].nm == "fly" || levels[levNum].enm[j].nm == "reddevil" {
										if msgT == 0 {
											admsg("immune to burn", rl.Yellow)
											msgT = fps
										}
									} else {
										levels[levNum].enm[j].burnT = fps * 3
									}
								}
							}
						}
					case "toxic":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 5), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandGreen(), fx[i].fade))
						rec3 := fx[i].rec
						rec3.X += RandF32(-4, 4)
						rec3.Y += RandF32(-4, 4)
						rl.DrawTexturePro(imgs, fx[i].img, rec3, rl.Vector2Zero(), 0, rl.Fade(RandGreen(), 0.1))
						fx[i].fade -= 0.005
						if fx[i].fade <= 0 {
							fx[i].off = true
							clear = true
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Yellow)
							rl.DrawRectangleLinesEx(fx[i].crec, 2, rl.Magenta)
						}
						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, fx[i].crec) {
								if !levels[levNum].enm[j].nodmg {
									if levels[levNum].enm[j].fly {
										if msgT == 0 {
											admsg("immune > enemy is flying", rl.Yellow)
											msgT = fps
										}
									} else {
										if levels[levNum].enm[j].poisonT == 0 {
											levels[levNum].enm[j].poisonT = fps * 3
										}
									}
								}
							}
						}
					}

				}
			}
			if clear {
				Remove(1)
			}
		}
		//MARK: DRAW ETC LAYER BELOW
		for i := 0; i < len(etc2); i++ {
			clear := false
			if rl.CheckCollisionRecs(etc2[i].rec, drawRec) {
				if !etc2[i].off {
					switch etc2[i].nm {
					case "stairs":
						rl.DrawTexturePro(imgs, etc2[i].img, shrec(etc2[i].rec, 5), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, etc2[i].img, etc2[i].rec, rl.Vector2Zero(), 0, rl.White)
						txs := tx2
						txt := "exit"
						txlen := rl.MeasureText(txt, txs)
						xtx := (etc2[i].rec.ToInt32().X + etc2[i].rec.ToInt32().Width/2) - txlen/2
						xtx += 2
						ytx := etc2[i].rec.ToInt32().Y + etc2[i].rec.ToInt32().Height - (txs + 1)
						rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
						rl.DrawText(txt, xtx, ytx, txs, RandColor())
						if rl.CheckCollisionRecs(pl.crec, etc2[i].rec) {
							exitPauseT--
							xtx := int32(etc2[i].rec.X+etc2[i].rec.Width/2) - tx/4
							ytx := int32(etc2[i].rec.Y) - tx2
							if exitPauseT > fps {
								rl.DrawText("2", xtx-2, ytx+2, tx2, rl.Black)
								rl.DrawText("2", xtx, ytx, tx2, rl.Yellow)
							} else if exitPauseT > 0 && exitPauseT < fps {
								rl.DrawText("1", xtx-2, ytx+2, tx2, rl.Black)
								rl.DrawText("1", xtx, ytx, tx2, rl.Yellow)
							}
							if exitPauseT == 0 {
								choose := RandInt(1, 6)
								switch choose {
								case 1:
									rl.PlaySound(audfx[124])
								case 2:
									rl.PlaySound(audfx[125])
								case 3:
									rl.PlaySound(audfx[126])
								case 4:
									rl.PlaySound(audfx[127])
								case 5:
									rl.PlaySound(audfx[128])
								}
								if treasureroom {
									treasureroom = false
									pause = true
									baseon = true
									rl.StopMusicStream(music[currentMusic])
									currentMusic = 2
									rl.PlayMusicStream(music[currentMusic])
									if vineRing {
										for i := 0; i < len(pl.art); i++ {
											if pl.art[i].nm == "ring of vine" {
												pl.art[i].off = false
											}
										}
									}
									if batty {
										batcomp.cnt = cnt
										batcomp.rec = rl.NewRectangle(batcomp.cnt.X-batcomp.rec.Width/2, batcomp.rec.Height/2, batcomp.rec.Width, batcomp.rec.Height)
										batcomp.moveChangeT = fps * 3
									}
									if rollo {
										rollocomp.cnt = cnt
										rollocomp.rec = rl.NewRectangle(rollocomp.cnt.X-rollocomp.rec.Width/2, rollocomp.cnt.Y-rollocomp.rec.Height/2, rollocomp.rec.Width, rollocomp.rec.Height)
									}
								}
								pl.cnt = cnt
								upplayerrec()
								makelevel()
							}
						} else {
							exitPauseT = fps * 2
						}
					case "rock":
						rl.DrawTexturePro(imgs, etc2[i].img, shrec(etc2[i].rec, 5), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, etc2[i].img, etc2[i].rec, rl.Vector2Zero(), 0, rl.White)
					case "switch": //SWITCHES
						rl.DrawTexturePro(imgs, etc2[i].img, shrec(etc2[i].rec, 3), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, etc2[i].img, etc2[i].rec, rl.Vector2Zero(), 0, rl.White)
						if rl.CheckCollisionRecs(pl.crec, etc2[i].rec) && !etc2[i].onoff {
							rl.PlaySound(audfx[4])
							etc2[i].onoff = true
							if etc2[i].img == etc[132] {
								etc2[i].img = etc[133]
							} else if etc2[i].img == etc[134] {
								etc2[i].img = etc[135]
							}
							switch etc2[i].numType {
							case 6: //ORE
								rl.PlaySound(audfx[114])
								zitm := xitm{}
								choose2 := RandInt(1, 6)
								switch choose2 {
								case 1:
									zitm = itmlist[38]
								case 2:
									zitm = itmlist[39]
								case 3:
									zitm = itmlist[40]
								case 4:
									zitm = itmlist[41]
								case 5:
									zitm = itmlist[42]
								}
								zitm.numof = 10
								count := 0
								for {
									zitm.cnt = pl.cnt
									switch count {
									case 0:
										zitm.cnt.X -= pl.rec.Width
									case 1:
										zitm.cnt.X -= pl.rec.Width
										zitm.cnt.Y -= pl.rec.Width
									case 2:
										zitm.cnt.Y -= pl.rec.Width
									case 3:
										zitm.cnt.X += pl.rec.Width
										zitm.cnt.Y -= pl.rec.Width
									case 4:
										zitm.cnt.X += pl.rec.Width
									case 5:
										zitm.cnt.X += pl.rec.Width
										zitm.cnt.Y += pl.rec.Width
									case 6:
										zitm.cnt.Y += pl.rec.Width
									case 7:
										zitm.cnt.X -= pl.rec.Width
										zitm.cnt.Y += pl.rec.Width
									}
									canadd := checkV2Walls(zitm.cnt)
									if canadd {
										zitm.rec = rl.NewRectangle(zitm.cnt.X-zitm.rec.Width/2, zitm.cnt.Y-zitm.rec.Height/2, zitm.rec.Width, zitm.rec.Height)
										levels[levNum].itm = append(levels[levNum].itm, zitm)
										zfx := xfx{}
										zfx.img = anm[108].rec
										zfx.rec = zitm.rec
										zfx.rec.X -= b
										zfx.rec.Y -= b
										zfx.rec.Width += b2
										zfx.rec.Height += b2
										zfx.nm = "summonitem"
										fx = append(fx, zfx)
										break
									}
									count++
									if count > 7 {
										admsg("nothing... sorry", rl.Yellow)
										break
									}
								}
							case 5: //TELEPORT CRYSTAL
								rl.PlaySound(audfx[114])
								zitm := itmlist[104]
								count := 0
								for {
									zitm.cnt = pl.cnt
									switch count {
									case 0:
										zitm.cnt.X -= pl.rec.Width
									case 1:
										zitm.cnt.X -= pl.rec.Width
										zitm.cnt.Y -= pl.rec.Width
									case 2:
										zitm.cnt.Y -= pl.rec.Width
									case 3:
										zitm.cnt.X += pl.rec.Width
										zitm.cnt.Y -= pl.rec.Width
									case 4:
										zitm.cnt.X += pl.rec.Width
									case 5:
										zitm.cnt.X += pl.rec.Width
										zitm.cnt.Y += pl.rec.Width
									case 6:
										zitm.cnt.Y += pl.rec.Width
									case 7:
										zitm.cnt.X -= pl.rec.Width
										zitm.cnt.Y += pl.rec.Width
									}
									canadd := checkV2Walls(zitm.cnt)
									if canadd {
										zitm.rec = rl.NewRectangle(zitm.cnt.X-zitm.rec.Width/2, zitm.cnt.Y-zitm.rec.Height/2, zitm.rec.Width, zitm.rec.Height)
										levels[levNum].itm = append(levels[levNum].itm, zitm)
										zfx := xfx{}
										zfx.img = anm[108].rec
										zfx.rec = zitm.rec
										zfx.rec.X -= b
										zfx.rec.Y -= b
										zfx.rec.Width += b2
										zfx.rec.Height += b2
										zfx.nm = "summonitem"
										fx = append(fx, zfx)
										break
									}
									count++
									if count > 7 {
										admsg("nothing... sorry", rl.Yellow)
										break
									}
								}
							case 4: //MULITPLE STATUS EFFECTS
								found := false
								countbreak := 100
								for {
									choose := RandInt(1, 9)
									switch choose {
									case 1:
										if lollipopT == 0 {
											rl.PlaySound(audfx[90])
											admsg("mana regeneration", rl.Yellow)
											lollipopT = fps * 30
											found = true
										}
									case 2:
										if tvT == 0 {
											rl.PlaySound(audfx[89])
											admsg("paused", rl.Yellow)
											tvT = fps * 10
											found = true
										}
									case 3:
										if orangeT == 0 {
											rl.PlaySound(audfx[88])
											admsg("health regeneration", rl.Yellow)
											orangeT = fps * 30
											found = true
										}
									case 4:
										if steroidsT == 0 {
											rl.PlaySound(audfx[75])
											admsg("rambo returns", rl.Yellow)
											steroidsT = fps * 30
											stats.str2 = stats.str
											stats.str = 5
											found = true
										}
									case 5:
										teleportT = fps / 2
										telCntr = true
										found = true
									case 6:
										if gasT == 0 {
											rl.PlaySound(audfx[16])
											admsg("burn baby burn", rl.Yellow)
											gasT = fps * 30
											found = true
										}
									case 7:
										if pistolT == 0 {
											rl.PlaySound(audfx[78])
											admsg("attack, attack, attack!", rl.Yellow)
											pistolT = fps * 30
											found = true
										}
									case 8:
										if slugT == 0 {
											rl.PlaySound(audfx[16])
											admsg("run like the wind", rl.Yellow)
											slugT = fps * 30
											found = true
										}
									}
									if found {
										zfx := xfx{}
										zfx.img = anm[180].rec
										zfx.rec = etc2[i].rec
										zfx.rec.X -= b2
										zfx.rec.Y -= b2
										zfx.rec.Width += b4
										zfx.rec.Height += b4
										zfx.nm = "switchfx"
										fx = append(fx, zfx)
										break
									}
									countbreak--
									if countbreak == 0 {
										break
									}
								}
							case 3: //BLACKDOT
								if blackdotCount < 50 {
									rl.PlaySound(audfx[116])
									for j := 0; j < 3; j++ {
										zenm := enmlist[10] //BLACKDOT
										zenm.numMax = RandInt(4, 11)
										zenm.atkT = fps
										zenm.cnt = findRanCntinRoom(levels[levNum].recs[etc2[i].room])
										zenm.rec = rl.NewRectangle(zenm.cnt.X-zenm.rec.Width/2, zenm.cnt.Y-zenm.rec.Height/2, zenm.rec.Width, zenm.rec.Height)
										zenm.crec = zenm.rec
										zenm.dirX = RandF32(-zenm.spd, zenm.spd)
										zenm.dirY = RandF32(-zenm.spd, zenm.spd)
										levels[levNum].enm = append(levels[levNum].enm, zenm)
										levels[levNum].enNum++
									}
								}
							case 2: //GHOSTS
								if len(levels[levNum].enm) < 70 {
									for j := 0; j < 3; j++ {
										rl.PlaySound(audfx[116])
										zenm := enmlist[3] //GHOST
										zenm.cnt = findRanCntinRoom(levels[levNum].recs[etc2[i].room])
										zenm.rec = rl.NewRectangle(zenm.cnt.X-zenm.rec.Width/2, zenm.cnt.Y-zenm.rec.Height/2, zenm.rec.Width, zenm.rec.Height)
										zenm.dirX = RandF32(-zenm.spd, zenm.spd)
										zenm.dirY = RandF32(-zenm.spd, zenm.spd)
										zenm.crec.X += zenm.crec.Width / 8
										zenm.crec.Y += zenm.crec.Height / 8
										zenm.crec.Width -= zenm.crec.Width / 4
										zenm.crec.Height -= zenm.crec.Height / 4
										//AREA REC
										zenm.carec = zenm.rec
										zenm.carec.X -= b3
										zenm.carec.Y -= b3
										zenm.carec.Width += b6
										zenm.carec.Height += b6
										levels[levNum].enm = append(levels[levNum].enm, zenm)
										levels[levNum].enNum++
									}
								}
							case 1: //DARTS
								rl.PlaySound(audfx[115])
								makedarts(etc2[i])
							}
						}
						if etc2[i].onoff {
							etc2[i].T--
							if etc2[i].T == 0 {
								switch etc2[i].numType {
								case 1, 2, 3:
									etc2[i].T = fps * 3
									if etc2[i].img == etc[133] {
										etc2[i].img = etc[132]
									} else if etc2[i].img == etc[135] {
										etc2[i].img = etc[134]
									}
									etc2[i].onoff = false
								case 4:
									etc2[i].T = fps * 30
									if etc2[i].img == etc[133] {
										etc2[i].img = etc[132]
									} else if etc2[i].img == etc[135] {
										etc2[i].img = etc[134]
									}
									etc2[i].onoff = false
								}
							}
						}
					case "flametrap": //FLAME TRAP
						rl.DrawTexturePro(imgs, etc2[i].img, etc2[i].rec, rl.Vector2Zero(), 0, rl.Fade(etc2[i].color, etc2[i].fade))
						if rl.CheckCollisionRecs(pl.crec, etc2[i].rec2) && !etc2[i].onoff && etc2[i].img.X == anm[2].X && tvT == 0 {
							rl.PlaySound(audfx[13])
							etc2[i].onoff = true
							if bootsT > 0 {
								admsg("boots save trap damage", rl.Green)
							} else {
								if pl.burnT == 0 && pl.dampT == 0 && icelollyT == 0 && pl.resFireT == 0 {
									if ovenglovenum > 0 {
										if Roll6() <= ovenglovenum {
											admsg("oven glove saves burn", rl.Green)
										} else {
											admsg("burning...", rl.Orange)
											pl.burnT += fps * 3
										}
									} else {
										admsg("burning...", rl.Orange)
										pl.burnT += fps * 3
									}
								} else if pl.burnT == 0 && pl.dampT != 0 && icelollyT == 0 && pl.resFireT == 0 {
									admsg("damp saves burn", rl.Green)
								} else if pl.burnT == 0 && pl.dampT == 0 && icelollyT != 0 && pl.resFireT == 0 {
									admsg("ice lolly saves burn", rl.Green)
								} else if pl.burnT == 0 && pl.dampT == 0 && icelollyT == 0 && pl.resFireT != 0 {
									admsg("resist fire saves burn", rl.Green)
								} else {
									if pl.hpT == 0 {
										hitPL(2)
									}
								}
							}
						}
						if frames%3 == 0 {
							if etc2[i].onoff && etc2[i].img.X < anm[2].X+anm[2].frames*anm[2].W {
								etc2[i].img.X += anm[2].W
								if etc2[i].img.X >= anm[2].X+anm[2].frames*anm[2].W {
									etc2[i].onoff = false
								}
							}
							if !etc2[i].onoff && etc2[i].img.X > anm[2].X {
								etc2[i].img.X -= anm[2].W
							}
						}
					case "spiketrap": //SPIKE TRAP
						rl.DrawTexturePro(imgs, etc2[i].img, etc2[i].rec, rl.Vector2Zero(), 0, rl.Fade(etc2[i].color, etc2[i].fade))
						if rl.CheckCollisionRecs(pl.crec, etc2[i].rec) && !etc2[i].onoff && etc2[i].img.X == anm[1].X && pl.enCollisT == 0 && tvT == 0 {
							rl.PlaySound(audfx[12])
							etc2[i].onoff = true
							if feather {
								if msgT == 0 {
									admsg("immune spikes > feather cushions", rl.White)
									msgT = fps
								}
							} else if bootsT > 0 {
								admsg("boots save trap damage", rl.Blue)
							} else {
								pl.enCollisT = fps
								if stats.dex > 1 {
									if Roll12() <= stats.dex {
										if msgT == 0 {
											admsg("dodged > dexterity", rl.Magenta)
											msgT = fps
										}
									} else {
										if pl.hpT == 0 {
											hitPL(1)
										}
									}
								} else {
									if pl.hpT == 0 {
										hitPL(1)
									}
								}
							}
						}
						if frames%3 == 0 {
							if etc2[i].onoff && etc2[i].img.X < anm[1].X+anm[1].frames*anm[1].W {
								etc2[i].img.X += anm[1].W
								if etc2[i].img.X >= anm[1].X+anm[1].frames*anm[1].W {
									etc2[i].onoff = false
								}
							}
							if !etc2[i].onoff && etc2[i].img.X > anm[1].X {
								etc2[i].img.X -= anm[1].W
							}
						}
					case "water": //WATER
						rl.DrawTexturePro(imgs, etc2[i].img2, etc2[i].rec2, rl.Vector2Zero(), 0, rl.Fade(etc2[i].color, etc2[i].fade)) //BLUE SPLAT IMG
						rec2 := etc2[i].rec                                                                                            //SMALLER REC FOR WATER ANIM
						rec2.X += b / 8
						rec2.Y += b / 8
						rec2.Width -= b / 4
						rec2.Height -= b / 4
						rl.DrawTexturePro(imgs, etc2[i].img, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.SkyBlue, RandF32(0.2, 0.7)))
						if frames%3 == 0 {
							etc2[i].img.X += anm[0].W
							if etc2[i].img.X > anm[0].X+anm[0].W*anm[0].frames {
								etc2[i].img.X = anm[0].X
							}
						}
						if rl.CheckCollisionRecs(pl.crec, etc2[i].rec) && pl.dampT == 0 && !umbrella {
							pl.dampT = fps * 2
							admsg("damp...", rl.Blue)
							rl.PlaySound(audfx[6])
							if toaster {
								zfx := xfx{}
								zfx.nm = "shockwave"
								zfx.img = anm[99].rec
								zfx.rec = pl.rec
								zfx.rec.X -= b5
								zfx.rec.Y -= b5
								zfx.rec.Width += b10
								zfx.rec.Height += b10
								fx = append(fx, zfx)
							}
						} else if rl.CheckCollisionRecs(pl.crec, etc2[i].rec) && pl.dampT == 0 && umbrella {
							if msgT == 0 {
								msgT = fps * 2
								admsg("umbrella saves damp", rl.Green)
								if toaster {
									zfx := xfx{}
									zfx.nm = "shockwave"
									zfx.img = anm[99].rec
									zfx.rec = pl.rec
									zfx.rec.X -= b5
									zfx.rec.Y -= b5
									zfx.rec.Width += b10
									zfx.rec.Height += b10
									fx = append(fx, zfx)
								}
							}
						}
						//TXT
						if rl.CheckCollisionPointRec(cursorV2cam, etc2[i].rec2) {
							toptx = "a puddle"
							toptxT = fps
						}
					}
					//DEBUG ETC
					if debug {
						rl.DrawRectangleLinesEx(etc2[i].rec, 2, rl.Orange)
						rl.DrawRectangleLinesEx(etc2[i].crec, 2, rl.Magenta)
						txtx := etc2[i].rec.ToInt32().X + 2
						txty := etc2[i].rec.ToInt32().Y + 2
						rl.DrawText(fmt.Sprint(etc2[i].nm), txtx-1, txty+1, tx, rl.Black)
						rl.DrawText(fmt.Sprint(etc2[i].nm), txtx, txty, tx, rl.White)
						rl.DrawCircleV(etc2[i].cnt, 4, rl.Red)
						if etc2[i].rec2.Width > 0 {
							rl.DrawRectangleLinesEx(etc2[i].rec2, 2, rl.White)
						}
					}
				} else {
					clear = true
				}
				if clear {
					Remove(2)
				}
			}
		}
		//WALLS
		for i := 0; i < len(walls); i++ {
			if rl.CheckCollisionRecs(walls[i].rec, drawRec) {
				if walls[i].dirX == 0 && walls[i].dirY == 0 {
					//BG REC
					rl.DrawRectangleRec(walls[i].rec, rl.Black)
					if psychedelicsT > 0 {
						//IMG REC
						rl.DrawTexturePro(imgs, walltile, walls[i].rec, rl.Vector2Zero(), 0, rl.Fade(walls[i].col2, walls[i].fade))
						//BLUR REC
						rl.DrawTexturePro(imgs, walltile, blrec(walls[i].rec, 0.2), rl.Vector2Zero(), 0, rl.Fade(walls[i].col2, 0.3))
					} else {
						//IMG REC
						rl.DrawTexturePro(imgs, walltile, walls[i].rec, rl.Vector2Zero(), 0, rl.Fade(walls[i].color, walls[i].fade))
						//BLUR REC
						rl.DrawTexturePro(imgs, walltile, blrec(walls[i].rec, 0.2), rl.Vector2Zero(), 0, rl.Fade(walls[i].color, 0.3))
					}
					if debug {
						rl.DrawRectangleLinesEx(walls[i].rec, 2, rl.Green)
					}
				}
			}
		}

		//MARK: DRAW PROJ ENEMY BELOW
		if len(projEn) > 0 {
			for i := 0; i < len(projEn); i++ {
				if !projEn[i].off && projEn[i].below {
					switch projEn[i].nm {
					case "reddevilFlame":
						rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 3), orgn(projEn[i].rec), projEn[i].ro, shcol())
						col := RandOrange()
						rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(col, projEn[i].fd))
						//BLUR
						rl.DrawTexturePro(imgs, projEn[i].img, brec(drec(projEn[i].rec), 3), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(col, RandF32(0.5, 0.25)))
						projEn[i].fd -= 0.005
						if projEn[i].fd <= 0 {
							projEn[i].off = true
						}
						if frames%4 == 0 {
							projEn[i].img.X += anm[169].W
							if projEn[i].img.X > anm[169].X+anm[169].frames*anm[169].W {
								projEn[i].img.X = anm[169].X
							}
						}
					case "mushLand":
						rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 5), orgn(projEn[i].rec), projEn[i].ro, shcol())
						rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.White)
						if frames%10 == 0 {
							projEn[i].onoff = !projEn[i].onoff
						}
						if projEn[i].onoff {
							cntr := projEn[i].cnt
							cntr.Y -= 2
							rl.DrawCircleV(cntr, 1, rl.Red)
							rl.DrawCircleGradient(int32(cntr.X), int32(cntr.Y), 8, DarkRed(), rl.Blank)
						}
						if rl.CheckCollisionRecs(pl.crec, projEn[i].crec) {
							zfx := xfx{}
							zfx.img = anm[57].rec
							zfx.cnt = pl.cnt
							siz := b5
							zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
							zfx.crec = zfx.rec
							zfx.crec.X += zfx.crec.Width / 8
							zfx.crec.Y += zfx.crec.Width / 8
							zfx.crec.Height -= zfx.crec.Height / 4
							zfx.crec.Width -= zfx.crec.Width / 4
							zfx.nm = "landmineExplod"
							fx = append(fx, zfx)
							hitPL(1)
							if pl.burnT == 0 {
								pl.burnT = fps * 3
								if msgT == 0 {
									admsg("burning...", rl.Orange)
								}
							}
							projEn[i].off = true
						}
					case "zomboSlime":
						rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 3), orgn(projEn[i].rec), projEn[i].ro, shcol())
						rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(RandGreen(), projEn[i].fd))
						projEn[i].fd -= 0.003
						if projEn[i].fd <= 0 {
							projEn[i].off = true
						}
						if rl.CheckCollisionRecs(pl.rec, projEn[i].rec) && pl.poisonT == 0 {
							pl.poisonT += fps * 3
						}
					case "yellowdinobull":
						rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 4), orgn(projEn[i].rec), projEn[i].ro, shcol())
						rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(projEn[i].col, projEn[i].fd))
						if frames%4 == 0 {
							projEn[i].img.X += anm[62].W
							if projEn[i].img.X > anm[62].X+anm[62].frames*anm[62].W {
								projEn[i].img.X = anm[62].X
							}
						}
						projEn[i].fd -= 0.01
						if projEn[i].fd <= 0 {
							projEn[i].off = true
						}
					}
					if debug {
						rl.DrawRectangleLinesEx(projEn[i].rec, 1, rl.Yellow)
						rl.DrawRectangleLinesEx(projEn[i].crec, 1, rl.Magenta)
					}
				}
			}
		}
		//MARK: DRAW PLAYER LIGHT CIRCLE
		if lightbulbnum > 0 && !pl.gameover {
			rad := float32(b2)
			rad += float32(lightbulbnum) * b / 3
			rl.DrawCircleGradient(int32(pl.cnt.X), int32(pl.cnt.Y), rad, rl.Fade(rl.SkyBlue, RandF32(0.3, 0.5)), rl.Blank)
			for j := 0; j < len(levels[levNum].enm); j++ {
				if rl.CheckCollisionPointCircle(levels[levNum].enm[j].cnt, pl.cnt, rad-rad/4) && levels[levNum].enm[j].stunT == 0 {
					levels[levNum].enm[j].stunT = fps * 2
					levels[levNum].enm[j].stunF = 0.9
					levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
					levels[levNum].enm[j].stunSiz = b / 4
				}
			}
		}
		//MARK: DRAW ETC LAYER ABOVE 1
		for i := 0; i < len(etc2); i++ {
			if rl.CheckCollisionRecs(etc2[i].rec, drawRec) {
				if !etc2[i].off {
					switch etc2[i].nm {
					case "teleporter": //TELEPORTER
						rl.DrawTexturePro(imgs, etc2[i].img, shrec(etc2[i].rec, 12), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, etc2[i].img, etc2[i].rec, rl.Vector2Zero(), 0, rl.White)
						if frames%4 == 0 {
							etc2[i].img.X += anm[88].W
							if etc2[i].img.X > anm[88].X+anm[88].W*anm[88].frames {
								etc2[i].img.X = anm[88].X
							}
						}
						//TXT
						if rl.CheckCollisionPointRec(cursorV2cam, etc2[i].crec) {
							toptx = "teleporter"
							toptxT = fps
						}
						//PLAYER COLLIS
						if rl.CheckCollisionRecs(pl.crec, etc2[i].crec) {
							found := false
							for j := 0; j < len(pl.invn); j++ {
								if pl.invn[j].nm == "teleporter crystal" {
									found = true
									teleporting = true
									xtx := int32(etc2[i].crec.X+etc2[i].crec.Width/2) - tx/4
									ytx := int32(etc2[i].crec.Y)
									if teleportPauseT > fps {
										rl.DrawText("2", xtx-2, ytx+2, tx2, rl.Black)
										rl.DrawText("2", xtx, ytx, tx2, rl.Yellow)
									} else if teleportPauseT > 0 && teleportPauseT < fps {
										rl.DrawText("1", xtx-2, ytx+2, tx2, rl.Black)
										rl.DrawText("1", xtx, ytx, tx2, rl.Yellow)
									}
									teleportPauseT--
									if teleportPauseT == 0 {
										rl.PlaySound(audfx[45])
										if teleportT == 0 {
											teleportT = fps / 2
											telBase = true
											admsg("bye bye", rl.Magenta)
											if pl.invn[j].numof > 1 {
												pl.invn[j].numof--
											} else {
												pl.invn[j] = xitm{}
											}
										}
									}
								}
							}
							if !found && !teleporting && msgT == 0 {
								admsg("no teleporter crystal", rl.Red)
								msgT = fps
							}
						} else {
							teleportPauseT = fps * 2
							teleporting = false
						}
					case "beartrap": //BEAR TRAP
						rl.DrawTexturePro(imgs, etc2[i].img, shrec(etc2[i].rec, 3), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, etc2[i].img, etc2[i].rec, rl.Vector2Zero(), 0, rl.White)
						if etc2[i].onoff && etc2[i].img.X < anm[86].X+anm[86].frames*anm[86].W {
							if frames%4 == 0 {
								etc2[i].img.X += anm[86].W
							}
						} else if etc2[i].onoff && etc2[i].img.X >= anm[86].X+anm[86].frames*anm[86].W {
							levels[levNum].etc[i].off = true
						}
						//TXT
						if rl.CheckCollisionPointRec(cursorV2cam, etc2[i].crec) {
							toptx = "bear trap"
							toptxT = fps
						}
					case "landmine": //PLAYER LANDMINE
						rl.DrawTexturePro(imgs, etc2[i].img, shrec(etc2[i].rec, 3), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, etc2[i].img, etc2[i].rec, rl.Vector2Zero(), 0, rl.White)
						//TXT
						if rl.CheckCollisionPointRec(cursorV2cam, etc2[i].crec) {
							toptx = "landmine"
							toptxT = fps
						}
						if frames%10 == 0 {
							etc2[i].onoff = !etc2[i].onoff
						}
						if etc2[i].onoff {
							cntr := etc2[i].cnt
							cntr.Y -= 2
							rl.DrawCircleV(cntr, 1, rl.Red)
							rl.DrawCircleGradient(int32(cntr.X), int32(cntr.Y), 8, DarkRed(), rl.Blank)
						}
					}
					//DEBUG ETC
					if debug {
						rl.DrawRectangleLinesEx(etc2[i].rec, 2, rl.Orange)
						rl.DrawRectangleLinesEx(etc2[i].crec, 2, rl.Magenta)
						txtx := etc2[i].rec.ToInt32().X + 2
						txty := etc2[i].rec.ToInt32().Y + 2
						rl.DrawText(fmt.Sprint(etc2[i].nm), txtx-1, txty+1, tx, rl.Black)
						rl.DrawText(fmt.Sprint(etc2[i].nm), txtx, txty, tx, rl.White)
						rl.DrawCircleV(etc2[i].cnt, 4, rl.Red)
						if etc2[i].rec2.Width > 0 {
							rl.DrawRectangleLinesEx(etc2[i].rec2, 2, rl.White)
						}
					}
				}
			}
		}
		//DRAW ETC CRATE SHADOWS
		for i := 0; i < len(etc2); i++ {
			if rl.CheckCollisionRecs(etc2[i].rec, drawRec) {
				if !etc2[i].off && etc2[i].nm == "crate" {
					rl.DrawTexturePro(imgs, etc2[i].img, shrec(etc2[i].rec, 5), rl.Vector2Zero(), 0, shcol())
				}
			}
		}
		//MARK: DRAW ETC ABOVE LAYER 2 CRATES
		for i := 0; i < len(etc2); i++ {
			clear := false
			if rl.CheckCollisionRecs(etc2[i].rec, drawRec) {
				if !etc2[i].off {
					switch etc2[i].nm {
					case "crate":
						rl.DrawTexturePro(imgs, etc2[i].img, shrec(etc2[i].rec, 5), rl.Vector2Zero(), 0, shcol())
						if etc2[i].hpT > 0 {
							if etc2[i].img == etc[2] { //HIT IMG OLD CRATE
								rl.DrawTexturePro(imgs, etc[6], etc2[i].rec, rl.Vector2Zero(), 0, RandColor())
							} else { //HIT IMG NEW CRATE
								rl.DrawTexturePro(imgs, etc[5], etc2[i].rec, rl.Vector2Zero(), 0, RandColor())
							}
						} else { //CRATE IMG
							rl.DrawTexturePro(imgs, etc2[i].img, etc2[i].rec, rl.Vector2Zero(), 0, rl.Fade(etc2[i].color, etc2[i].fade))
						}
						//TXT
						if rl.CheckCollisionPointRec(cursorV2cam, etc2[i].rec) {
							if etc2[i].img == etc[2] || etc2[i].img == etc[4] {
								toptx = "scrap crate"
								toptxT = fps
							} else {
								toptx = "loot crate"
								toptxT = fps
							}
						}
						//HIT TIMER
						if etc2[i].hpT > 0 {
							etc2[i].hpT--
						}
						if etc2[i].hp <= 0 {
							destroycrate(i)
							etc2[i].off = true
						}
						//MOVE CRATE TIMER
						if etc2[i].moveT > 0 {
							etc2[i].moveT--
							if checkRecWallsChestsEtcSolid(etc2[i].rec, i, 1) {
								etc2[i].rec.X += etc2[i].dirX
								etc2[i].rec.Y += etc2[i].dirY
								etc2[i].cnt = makecnt(etc2[i].rec)
							}
						} else {
							etc2[i].dirX = 0
							etc2[i].dirY = 0
						}
						//MARK: CHECK CRATE VS TRAP COLLIS
						for j := 0; j < len(etc2); j++ {
							if etc2[j].nm == "flametrap" || etc2[j].nm == "spiketrap" {
								if rl.CheckCollisionRecs(etc2[i].rec, etc2[j].rec) {
									if etc2[j].nm == "flametrap" && rl.CheckCollisionRecs(etc2[i].rec, etc2[j].rec2) && !etc2[j].onoff && etc2[j].img.X == anm[2].X {
										etc2[j].onoff = true
									}
									if rl.CheckCollisionRecs(etc2[i].rec, etc2[j].rec) && !etc2[j].onoff && etc2[j].img.X == anm[1].X {
										etc2[j].onoff = true
									}
									if etc2[i].img == etc[2] || etc2[i].img == etc[4] {
										if etc2[i].hpT == 0 {
											etc2[i].hpT = fps / 10
											etc2[i].hp--
										}
									}
								}
							}
						}
						//MARK:CHECK CRATE VS FIRE COLLIS
						if fireson {
							for j := 0; j < len(levels[levNum].enm); j++ {
								if levels[levNum].enm[j].nm == "fire" {
									if rl.CheckCollisionRecs(etc2[i].rec, levels[levNum].enm[j].crec) {
										if etc2[i].img == etc[2] || etc2[i].img == etc[4] {
											if etc2[i].hpT == 0 {
												etc2[i].hpT = fps / 10
												etc2[i].hp--
											}
										}
									}
								}
							}
						}
						//DEBUG ETC
						if debug {
							rl.DrawRectangleLinesEx(etc2[i].rec, 2, rl.Orange)
							txtx := etc2[i].rec.ToInt32().X + 2
							txty := etc2[i].rec.ToInt32().Y + 2
							rl.DrawText(fmt.Sprint(etc2[i].nm), txtx-1, txty+1, tx, rl.Black)
							rl.DrawText(fmt.Sprint(etc2[i].nm), txtx, txty, tx, rl.White)
							rl.DrawCircleV(etc2[i].cnt, 4, rl.Red)
							if etc2[i].rec2.Width > 0 {
								rl.DrawRectangleLinesEx(etc2[i].rec2, 2, rl.White)
							}
						}
					}
				} else {
					clear = true
				}
				if clear {
					Remove(2)
				}
			}
		}

		//MARK:DRAW ROLLO COMPANION
		if rollo {
			rl.DrawTexturePro(imgs, rollocomp.img, shrec(rollocomp.rec, 5), rl.Vector2Zero(), 0, shcol())
			rec2 := rollocomp.rec
			rec2.X += (rollocomp.dirX * 2) * -1
			rec2.Y += (rollocomp.dirY * 2) * -1
			rec2.X += rec2.Width / 16
			rec2.Y += rec2.Height / 16
			rec2.Width -= rec2.Width / 8
			rec2.Height -= rec2.Height / 8
			rl.DrawTexturePro(imgs, rollocomp.img, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.2))
			rec2.X += (rollocomp.dirX * 2) * -1
			rec2.Y += (rollocomp.dirY * 2) * -1
			rec2.X += rec2.Width / 16
			rec2.Y += rec2.Height / 16
			rec2.Width -= rec2.Width / 8
			rec2.Height -= rec2.Height / 8
			rl.DrawTexturePro(imgs, rollocomp.img, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.15))
			rec2.X += (rollocomp.dirX * 2) * -1
			rec2.Y += (rollocomp.dirY * 2) * -1
			rec2.X += rec2.Width / 16
			rec2.Y += rec2.Height / 16
			rec2.Width -= rec2.Width / 8
			rec2.Height -= rec2.Height / 8
			rl.DrawTexturePro(imgs, rollocomp.img, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.1))
			rec2.X += (rollocomp.dirX * 2) * -1
			rec2.Y += (rollocomp.dirY * 2) * -1
			rec2.X += rec2.Width / 16
			rec2.Y += rec2.Height / 16
			rec2.Width -= rec2.Width / 8
			rec2.Height -= rec2.Height / 8
			rl.DrawTexturePro(imgs, rollocomp.img, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.05))
			rl.DrawTexturePro(imgs, rollocomp.img, rollocomp.rec, rl.Vector2Zero(), 0, rl.White)
			if frames%2 == 0 {
				if rollocomp.lr {
					rollocomp.img.X -= anm[154].W
					if rollocomp.img.X < anm[154].X-anm[154].frames*anm[154].W {
						rollocomp.img.X = anm[154].X
					}
				} else {
					rollocomp.img.X += anm[153].W
					if rollocomp.img.X > anm[153].X+anm[153].frames*anm[153].W {
						rollocomp.img.X = anm[153].X
					}
				}
			}
		}

		//MARK: DRAW ITEMS
		if len(itm) > 0 {
			for i := 0; i < len(itm); i++ {
				if !itm[i].off {
					if rl.CheckCollisionRecs(itm[i].rec, drawRec) {
						///INVISIBLE
						if itm[i].invis {
							if stats.per > 1 {
								if rl.CheckCollisionRecs(pl.perrec, itm[i].rec) {
									if frames%int(fps*3) == 0 {
										if Roll6() <= stats.per {
											itm[i].invis = false
											zfx := xfx{}
											zfx.img = anm[108].rec
											zfx.rec = itm[i].rec
											zfx.rec.X -= b
											zfx.rec.Y -= b
											zfx.rec.Width += b2
											zfx.rec.Height += b2
											zfx.nm = "summonitem"
											fx = append(fx, zfx)
											admsg("invisible loot revealed > perception", rl.Magenta)
											//LUK
											if stats.luk > 1 {
												if Roll6() <= stats.luk {
													zitm := xitm{}
													zitm = crateitm[RandInt(0, len(crateitm))]
													zitm.rec = rl.NewRectangle(itm[i].cnt.X-zitm.rec.Width/2, itm[i].cnt.Y-zitm.rec.Height/2, zitm.rec.Width, zitm.rec.Height)
													zitm.rec = finddropside(zitm.rec, 1)
													if zitm.rec != blankRec {
														levels[levNum].itm = append(levels[levNum].itm, zitm)
													}
												}
											}
										}
									}
								}
							}
							if debug {
								rl.DrawCircleV(itm[i].cnt, 20, rl.Fade(RandColor(), 0.4))
								rl.DrawTexturePro(imgs, itm[i].img, itm[i].rec, rl.Vector2Zero(), 0, rl.White)
							}
						} else { //VISIBLE ITEMS
							rl.DrawTexturePro(imgs, itm[i].img, shrec(itm[i].rec, 5), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, itm[i].img, itm[i].rec, rl.Vector2Zero(), 0, rl.White)
							if debug {
								rl.DrawRectangleLinesEx(itm[i].rec, 1, rl.Yellow)
							}
							//TXT
							if rl.CheckCollisionPointRec(cursorV2cam, itm[i].rec) {
								toptx = itm[i].nm
								toptxT = fps
							}
							//TIMERS
							if itm[i].dropT > 0 {
								itm[i].dropT--
							}
							//MAP PIN ANIMATE
							if itm[i].nm == "map exit pin" {
								if frames%2 == 0 {
									itm[i].img.X += anm[175].W
									if itm[i].img.X > anm[175].X+anm[175].frames*anm[175].W {
										itm[i].img.X = anm[175].X
									}
								}
							}
							//CHEST PIN ANIMATE
							if itm[i].nm == "map chest pin" {
								if frames%2 == 0 {
									itm[i].img.X += anm[176].W
									if itm[i].img.X > anm[176].X+anm[176].frames*anm[176].W {
										itm[i].img.X = anm[176].X
									}
								}
							}
							//NOODLES
							if noodles {
								spd := b / 12
								cntr := makecnt(itm[i].rec)
								dirX := float32(0)
								dirY := float32(0)
								xdiff := AbsDiff(cntr.X, pl.cnt.X)
								ydiff := AbsDiff(cntr.Y, pl.cnt.Y)
								if xdiff > ydiff {
									dirX = spd
									dirY = ydiff / (xdiff / dirX)
								} else {
									dirY = spd
									dirX = xdiff / (ydiff / dirY)
								}
								if cntr.X > pl.cnt.X {
									dirX = -dirX
								}
								if cntr.Y > pl.cnt.Y {
									dirY = -dirY
								}
								checkrec := itm[i].rec
								checkrec.X += dirX
								canmove := checkRecWalls(checkrec)
								if canmove {
									canmove = checkRecSolid(checkrec)
								}
								if canmove {
									itm[i].rec = checkrec
								}
								checkrec = itm[i].rec
								checkrec.Y += dirY
								canmove = checkRecWalls(checkrec)
								if canmove {
									canmove = checkRecSolid(checkrec)
								}
								if canmove {
									itm[i].rec = checkrec
								}
							}
						}
					}
				}
			}

			//MARK:COLLECT ITEMS
			for i := 0; i < len(levels[levNum].itm); i++ {
				if !levels[levNum].itm[i].off && !levels[levNum].itm[i].invis {
					if rl.CheckCollisionRecs(pl.crec, levels[levNum].itm[i].rec) {
						if levels[levNum].itm[i].art {
							collectart(i)
						} else if levels[levNum].itm[i].dropT == 0 {
							collectinvn(i)
						}
					}
				}
			}
			//MARK:REMOVE ITEMS
			for i := 0; i < len(levels[levNum].itm); i++ {
				if levels[levNum].itm[i].off {
					levels[levNum].itm = RemoveItem(levels[levNum].itm, i)
				}
			}
		}
		//MARK: DRAW CHESTS
		if len(chests) > 0 {
			for i := 0; i < len(chests); i++ {
				if rl.CheckCollisionRecs(chests[i].rec, drawRec) {
					rl.DrawTexturePro(imgs, chests[i].img, shrec(chests[i].rec, 5), rl.Vector2Zero(), 0, shcol())
					rl.DrawTexturePro(imgs, chests[i].img, chests[i].rec, rl.Vector2Zero(), 0, rl.White)
					//PLAYER CHEST COLLIS
					if rl.CheckCollisionRecs(pl.carec, chests[i].crec) {
						if !chests[i].opn {
							chests[i].opn = true
							if msgT == 0 {
								admsg("@end level items goto base", rl.Magenta)
								msgT = fps
							}
						}
						inchest = true
					} else {
						if chests[i].opn {
							chests[i].opn = false
						}
						inchest = false
					}
					//TXT
					if rl.CheckCollisionPointRec(cursorV2cam, chests[i].rec) {
						toptx = "chest"
						toptxT = fps
					}
					//DEBUG
					if debug {
						rl.DrawRectangleLinesEx(chests[i].crec, 1, rl.Yellow)
					}
				}
			}
		}

		//MARK: DRAW WEAPONS
		if len(levels[levNum].weaps) > 0 {
			for i := 0; i < len(levels[levNum].weaps); i++ {
				if !levels[levNum].weaps[i].off {
					if levels[levNum].weaps[i].dropT > 0 {
						levels[levNum].weaps[i].dropT--
					}
					rl.DrawTexturePro(imgs, levels[levNum].weaps[i].img, shrec(levels[levNum].weaps[i].rec, 4), rl.Vector2Zero(), 0, shcol())
					rl.DrawTexturePro(imgs, levels[levNum].weaps[i].img, levels[levNum].weaps[i].rec, rl.Vector2Zero(), 0, rl.White)
					//TXT
					if rl.CheckCollisionPointRec(cursorV2cam, levels[levNum].weaps[i].rec) {
						toptx = levels[levNum].weaps[i].nm
						toptxT = fps
					}
					//MARK: COLLECT  WEAPONS
					if rl.CheckCollisionRecs(pl.crec, levels[levNum].weaps[i].rec) && !levels[levNum].weaps[i].off && levels[levNum].weaps[i].dropT == 0 {
						found := false
						if pl.wp2.nm == "" {
							rl.PlaySound(audfx[119])
							pl.wp2 = weap[levels[levNum].weaps[i].weapListNum]
							levels[levNum].weaps[i].off = true
							found = true
						} else if pl.wp1.nm == "" {
							rl.PlaySound(audfx[119])
							pl.wp1 = weap[levels[levNum].weaps[i].weapListNum]
							levels[levNum].weaps[i].off = true
							found = true
						} else {
							for j := 0; j < len(pl.weaps); j++ {
								if pl.weaps[j].nm == "" {
									rl.PlaySound(audfx[119])
									pl.weaps[j] = weap[levels[levNum].weaps[i].weapListNum]
									levels[levNum].weaps[i].off = true
									found = true
									break
								}
							}
							if found {
								if msgT == 0 {
									admsg("collected "+weap[levels[levNum].weaps[i].weapListNum].nm, rl.Green)
									msgT = fps
								}
							} else {
								dropweap(0, 1)
							}
						}

					}
					if debug {
						rl.DrawRectangleLinesEx(levels[levNum].weaps[i].rec, 2, rl.Magenta)
					}
				}
			}
		}

		//MARK: DRAW WEAPON CRATE
		if levels[levNum].weapcrate.on {
			rl.DrawTexturePro(imgs, levels[levNum].weapcrate.i.img, shrec(levels[levNum].weapcrate.i.rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, levels[levNum].weapcrate.i.img, levels[levNum].weapcrate.i.rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionRecs(pl.crec, levels[levNum].weapcrate.i.crec) && levels[levNum].weapcrate.on {
				zfx := xfx{}
				zfx.img = anm[181].rec
				zfx.rec = levels[levNum].weapcrate.i.rec
				zfx.rec.X -= b2
				zfx.rec.Y -= b2
				zfx.rec.Width += b4
				zfx.rec.Height += b4
				zfx.rec.Y -= b2
				zfx.nm = "weaponcrate"
				fx = append(fx, zfx)
				zweap := weap[levels[levNum].weapcrate.weapnum]
				zweap.weapListNum = levels[levNum].weapcrate.weapnum
				zweap.dropT = fps
				cntr := makecnt(levels[levNum].weapcrate.i.rec)
				zweap.rec = rl.NewRectangle(cntr.X-zweap.rec.Width/2, cntr.Y-zweap.rec.Height/2, zweap.rec.Width, zweap.rec.Height)
				rl.PlaySound(audfx[118])
				if zweap.nm == "raspberry" {
					zweap.rec.X -= be
					zweap.rec.Y -= be
					zweap.rec.Width += bq
					zweap.rec.Height += bq
				}
				levels[levNum].weaps = append(levels[levNum].weaps, zweap)
				levels[levNum].weapcrate.on = false
			}
			if debug {
				rl.DrawRectangleLinesEx(levels[levNum].weapcrate.i.rec, 2, rl.White)
				rl.DrawRectangleLinesEx(levels[levNum].weapcrate.i.crec, 2, rl.Magenta)
			}
		}

		//MARK: DRAW ENEMIES
		if len(enm) > 0 {

			upenm()

			clear := false
			for i := 0; i < len(enm); i++ {
				if rl.CheckCollisionRecs(enm[i].rec, drawRec) {
					if !enm[i].off {
						if rl.CheckCollisionPointRec(cursorV2cam, enm[i].crec) {
							toptx = enm[i].nm2
							toptxT = fps * 2
						}

						//JERSEY SPELL
						if enm[i].nm == "jersey" && enm[i].onoff {
							siz := b8
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].cnt.Y-siz/2, siz, siz)
							rec.Y += 7
							rec.X -= 2
							rl.DrawTexturePro(imgs, anm[172].rec, shrec(drec(rec), 5), orgn(rec), enm[i].ro2, shcol())
							rl.DrawTexturePro(imgs, anm[172].rec, drec(rec), orgn(rec), enm[i].ro2, rl.Fade(RandGreen(), 0.15))
							enm[i].ro2 += 5
							if frames%3 == 0 {
								anm[172].rec.X += anm[172].W
								if anm[172].rec.X > anm[172].X+anm[172].frames*anm[172].W {
									enm[i].onoff = false
									enm[i].atkT = int32(RandInt(int(fps), int(fps*3)))
									anm[172].rec.X = anm[172].X
								}
							}
							rec2 := rec
							rec2.X += rec.Width / 8
							rec2.Y += rec.Width / 8
							rec2.Width -= rec.Width / 4
							rec2.Height -= rec.Width / 4
							if rl.CheckCollisionRecs(pl.crec, rec2) && pl.poisonT == 0 {
								pl.poisonT += fps * 3
								admsg("posioned...", rl.Green)
							}
							if debug {
								rl.DrawRectangleLinesEx(rec2, 2, rl.Magenta)
								rl.DrawRectangleLinesEx(rec, 2, rl.Yellow)
							}
						}
						//ROBOT SHOCK
						if enm[i].nm == "robot" && enm[i].onoff {
							siz := b7
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].cnt.Y-siz/2, siz, siz)
							rec.Y += 7
							rec.X -= 2
							rl.DrawTexturePro(imgs, anm[168].rec, shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, anm[168].rec, rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.15))
							if frames%6 == 0 {
								anm[168].rec.X += anm[168].W
								if anm[168].rec.X > anm[168].X+anm[168].frames*anm[168].W {
									enm[i].onoff = false
									enm[i].atkT = int32(RandInt(int(fps), int(fps*3)))
									anm[168].rec.X = anm[168].X
								}
							}
							rec2 := rec
							rec2.X += rec.Width / 8
							rec2.Y += rec.Width / 8
							rec2.Width -= rec.Width / 4
							rec2.Height -= rec.Width / 4
							if rl.CheckCollisionRecs(pl.crec, rec2) && pl.freezeT == 0 && saltT == 0 {
								pl.freezeT = fps * 2
								admsg("frozen...", rl.Blue)
							} else if saltT > 0 {
								if msgT == 0 {
									admsg("salt saves freeze", rl.Green)
									msgT = fps
								}
							}
							if debug {
								rl.DrawRectangleLinesEx(rec2, 2, rl.Magenta)
								rl.DrawRectangleLinesEx(rec, 2, rl.Yellow)
							}
						}
						//HP HEART
						if enm[i].hpT > 0 && enm[i].hpY > enm[i].hpY2 {
							siz := be3
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].crec.Y-enm[i].hpY2, siz, siz)
							rl.DrawTexturePro(imgs, etc[29], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, etc[29], rec, rl.Vector2Zero(), 0, rl.White)
							enm[i].hpY2++
						}
						//BURN POISON BLEED ICONS
						if enm[i].burnT > 0 && enm[i].bleedT == 0 && enm[i].poisonT == 0 {
							siz := be3
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].crec.Y+enm[i].crec.Height+4, siz, siz)
							rl.DrawTexturePro(imgs, etc[79], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, etc[79], rec, rl.Vector2Zero(), 0, RandOrange())
						} else if enm[i].burnT > 0 && enm[i].bleedT > 0 && enm[i].poisonT == 0 {
							siz := be3
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].crec.Y+enm[i].crec.Height+4, siz, siz)
							rec.X -= siz
							rl.DrawTexturePro(imgs, etc[79], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, etc[79], rec, rl.Vector2Zero(), 0, RandOrange())
							rec.X += siz
							rl.DrawTexturePro(imgs, etc[80], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, etc[80], rec, rl.Vector2Zero(), 0, rl.White)
						} else if enm[i].burnT == 0 && enm[i].bleedT > 0 && enm[i].poisonT == 0 {
							siz := be3
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].crec.Y+enm[i].crec.Height+4, siz, siz)
							rl.DrawTexturePro(imgs, etc[80], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, etc[80], rec, rl.Vector2Zero(), 0, rl.White)
						} else if enm[i].burnT == 0 && enm[i].bleedT == 0 && enm[i].poisonT > 0 {
							siz := be3
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].crec.Y+enm[i].crec.Height+4, siz, siz)
							rl.DrawTexturePro(imgs, etc[81], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, etc[81], rec, rl.Vector2Zero(), 0, rl.White)
						} else if enm[i].burnT > 0 && enm[i].bleedT > 0 && enm[i].poisonT > 0 {
							siz := be3
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].crec.Y+enm[i].crec.Height+4, siz, siz)
							rec.X -= siz + siz/2
							rl.DrawTexturePro(imgs, etc[79], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, etc[79], rec, rl.Vector2Zero(), 0, RandOrange())
							rec.X += siz
							rl.DrawTexturePro(imgs, etc[80], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, etc[80], rec, rl.Vector2Zero(), 0, rl.White)
							rec.X += siz
							rl.DrawTexturePro(imgs, etc[81], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, etc[81], rec, rl.Vector2Zero(), 0, rl.White)
						} else if enm[i].burnT > 0 && enm[i].bleedT == 0 && enm[i].poisonT > 0 {
							siz := be3
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].crec.Y+enm[i].crec.Height+4, siz, siz)
							rec.X -= siz
							rl.DrawTexturePro(imgs, etc[79], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, etc[79], rec, rl.Vector2Zero(), 0, RandOrange())
							rec.X += siz
							rl.DrawTexturePro(imgs, etc[81], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, etc[81], rec, rl.Vector2Zero(), 0, rl.White)
						} else if enm[i].burnT == 0 && enm[i].bleedT > 0 && enm[i].poisonT > 0 {
							siz := be3
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].crec.Y+enm[i].crec.Height+4, siz, siz)
							rec.X -= siz
							rl.DrawTexturePro(imgs, etc[80], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, etc[80], rec, rl.Vector2Zero(), 0, RandOrange())
							rec.X += siz
							rl.DrawTexturePro(imgs, etc[81], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, etc[81], rec, rl.Vector2Zero(), 0, rl.White)
						}
						//IMG
						if !bosson {
							switch enm[i].nm {
							default:
								rl.DrawTexturePro(imgs, enm[i].img, shrec(drec(enm[i].rec), 5), orgn(enm[i].rec), enm[i].ro, shcol())
								if icecreamT > 0 || enm[i].freezeT > 0 || enm[i].oilT > 0 {
									rl.DrawTexturePro(imgs, enm[i].img, drec(enm[i].rec), orgn(enm[i].rec), enm[i].ro, RandCyan())
								} else {
									if enm[i].hpT > 0 {
										rl.DrawTexturePro(imgs, enm[i].img, drec(enm[i].rec), orgn(enm[i].rec), enm[i].ro, RandPink())
									} else {
										rl.DrawTexturePro(imgs, enm[i].img, drec(enm[i].rec), orgn(enm[i].rec), enm[i].ro, rl.White)
									}
								}
							case "blackdot":
								rl.DrawTexturePro(imgs, enm[i].img, shrec(drec(enm[i].rec), 4), orgn(enm[i].rec), enm[i].ro, shcol())
								if icecreamT > 0 || enm[i].freezeT > 0 || enm[i].oilT > 0 {
									rl.DrawTexturePro(imgs, enm[i].img, drec(enm[i].rec), orgn(enm[i].rec), enm[i].ro, RandCyan())
								} else {
									if enm[i].hpT > 0 {
										rl.DrawTexturePro(imgs, enm[i].img, drec(enm[i].rec), orgn(enm[i].rec), enm[i].ro, RandColor())
									} else {
										rl.DrawTexturePro(imgs, enm[i].img, drec(enm[i].rec), orgn(enm[i].rec), enm[i].ro, rl.White)
									}
								}
							case "balloon", "fly", "flamehead", "greenpig":
								rl.DrawTexturePro(imgs, enm[i].img, shrec(drec(enm[i].rec), 12), orgn(enm[i].rec), enm[i].ro, shcol())
								if icecreamT > 0 || enm[i].freezeT > 0 {
									rl.DrawTexturePro(imgs, enm[i].img, drec(enm[i].rec), orgn(enm[i].rec), enm[i].ro, RandCyan())
								} else {
									if enm[i].hpT > 0 {
										rl.DrawTexturePro(imgs, enm[i].img, drec(enm[i].rec), orgn(enm[i].rec), enm[i].ro, RandColor())
									} else {
										rl.DrawTexturePro(imgs, enm[i].img, drec(enm[i].rec), orgn(enm[i].rec), enm[i].ro, rl.White)
									}
								}
							case "ghost":
								rl.DrawTexturePro(imgs, enm[i].img, shrec(drec(enm[i].rec), 12), orgn(enm[i].rec), enm[i].ro, shcol())
								if icecreamT > 0 || enm[i].freezeT > 0 {
									rl.DrawTexturePro(imgs, enm[i].img, drec(enm[i].rec), orgn(enm[i].rec), enm[i].ro, rl.Fade(RandCyan(), RandF32(0.2, 0.5)))
								} else {
									if enm[i].hpT > 0 {
										rl.DrawTexturePro(imgs, enm[i].img, drec(enm[i].rec), orgn(enm[i].rec), enm[i].ro, rl.Fade(RandColor(), RandF32(0.2, 0.5)))
									} else {
										rl.DrawTexturePro(imgs, enm[i].img, drec(enm[i].rec), orgn(enm[i].rec), enm[i].ro, rl.Fade(rl.White, RandF32(0.2, 0.5)))
									}
								}
							}

							if debug {
								xtx := enm[i].crec.ToInt32().X
								ytx := enm[i].crec.ToInt32().Y - tx2
								rl.DrawText(fmt.Sprint(enm[i].hp), xtx, ytx, tx2, rl.Red)
							}
						}
						//MARK: ENEMY ANIM STUN
						//STUN IMG
						if enm[i].stunT > 0 {
							if enm[i].stunF > 0 {
								cntr := rl.NewVector2(enm[i].cnt.X, enm[i].stunY)
								rec3 := rl.NewRectangle(cntr.X-enm[i].stunSiz/2, cntr.Y-enm[i].stunSiz/2, enm[i].stunSiz, enm[i].stunSiz)
								rl.DrawTexturePro(imgs, etc[82], shrec(rec3, 12), rl.Vector2Zero(), 0, shcol())
								rl.DrawTexturePro(imgs, etc[82], rec3, rl.Vector2Zero(), 0, rl.Fade(rl.White, enm[i].stunF))
								enm[i].stunF -= 0.03
								enm[i].stunSiz += 0.5
								enm[i].stunY -= 2
							}
							//STUN STARS ANIM
							siz2 := b2
							rec4 := rl.NewRectangle(enm[i].cnt.X-siz2/2, enm[i].cnt.Y-siz2/2, siz2, siz2)
							rl.DrawTexturePro(imgs, anm[107].rec, shrec(rec4, 12), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, anm[107].rec, rec4, rl.Vector2Zero(), 0, rl.Fade(rl.Yellow, 0.7))
						}
						//MARK:UP ENEMY IMAGE ANIMS
						if !bosson {
							if icecreamT == 0 {
								switch enm[i].nm {
								case "spike":
									if frames%2 == 0 {
										enm[i].img.X += anm[184].W
										if enm[i].img.X > anm[184].X+anm[184].frames*anm[184].W {
											enm[i].img.X = anm[184].X
										}
									}
								case "jersey":
									if frames%4 == 0 {
										if enm[i].lr {
											enm[i].img.X -= anm[167].W
											if enm[i].img.X < anm[167].X-anm[167].frames*anm[167].W {
												enm[i].img.X = anm[167].X
											}
										} else {
											enm[i].img.X += anm[166].W
											if enm[i].img.X > anm[166].X+anm[166].frames*anm[166].W {
												enm[i].img.X = anm[166].X
											}
										}
									}
								case "bird":
									if frames%5 == 0 {
										if enm[i].lr {
											enm[i].img.X -= anm[165].W
											if enm[i].img.X < anm[165].X-anm[165].frames*anm[165].W {
												enm[i].img.X = anm[165].X
											}
										} else {
											enm[i].img.X += anm[164].W
											if enm[i].img.X > anm[164].X+anm[164].frames*anm[164].W {
												enm[i].img.X = anm[164].X
											}
										}
									}
								case "bush":
									if enm[i].idl {
										enm[i].img = etc[151]
									} else {
										if frames%5 == 0 {
											if enm[i].lr {
												enm[i].img.X -= anm[171].W
												if enm[i].img.X < anm[171].X-anm[171].frames*anm[171].W {
													enm[i].img.X = anm[171].X
												}
											} else {
												enm[i].img.X += anm[170].W
												if enm[i].img.X > anm[170].X+anm[170].frames*anm[170].W {
													enm[i].img.X = anm[170].X
												}
											}
										}
									}
								case "reddevil":
									if frames%5 == 0 {
										if enm[i].lr {
											enm[i].img.X -= anm[163].W
											if enm[i].img.X < anm[163].X-anm[163].frames*anm[163].W {
												enm[i].img.X = anm[163].X
											}
										} else {
											enm[i].img.X += anm[162].W
											if enm[i].img.X > anm[162].X+anm[162].frames*anm[162].W {
												enm[i].img.X = anm[162].X
											}
										}
									}
								case "greenpig":
									if frames%5 == 0 {
										if enm[i].lr {
											enm[i].img.X -= anm[159].W
											if enm[i].img.X < anm[159].X-anm[159].frames*anm[159].W {
												enm[i].img.X = anm[159].X
											}
										} else {
											enm[i].img.X += anm[158].W
											if enm[i].img.X > anm[158].X+anm[158].frames*anm[158].W {
												enm[i].img.X = anm[158].X
											}
										}
									}
								case "robot":
									if frames%3 == 0 {
										if enm[i].lr {
											enm[i].img.X -= anm[161].W
											if enm[i].img.X < anm[161].X-anm[161].frames*anm[161].W {
												enm[i].img.X = anm[161].X
											}
										} else {
											enm[i].img.X += anm[160].W
											if enm[i].img.X > anm[160].X+anm[160].frames*anm[160].W {
												enm[i].img.X = anm[160].X
											}
										}
									}
								case "carrot":
									if frames%6 == 0 {
										if enm[i].lr {
											enm[i].img.X -= anm[157].W
											if enm[i].img.X < anm[157].X-anm[157].frames*anm[157].W {
												enm[i].img.X = anm[157].X
											}
										} else {
											enm[i].img.X += anm[156].W
											if enm[i].img.X > anm[156].X+anm[156].frames*anm[156].W {
												enm[i].img.X = anm[156].X
											}
										}
									}
								case "redblob":
									if frames%4 == 0 {
										if enm[i].lr {
											enm[i].img.X -= anm[70].W
											if enm[i].img.X < anm[70].X-anm[70].frames*anm[70].W {
												enm[i].img.X = anm[70].X
											}
										} else {
											enm[i].img.X += anm[69].W
											if enm[i].img.X > anm[69].X+anm[69].frames*anm[69].W {
												enm[i].img.X = anm[69].X
											}
										}
									}
								case "skeleton":
									if frames%4 == 0 {
										if enm[i].lr {
											enm[i].img.X -= anm[68].W
											if enm[i].img.X < anm[68].X-anm[68].frames*anm[68].W {
												enm[i].img.X = anm[68].X
											}
										} else {
											enm[i].img.X += anm[67].W
											if enm[i].img.X > anm[67].X+anm[67].frames*anm[67].W {
												enm[i].img.X = anm[67].X
											}
										}
									}
								case "orange":
									if frames%3 == 0 {
										if enm[i].lr {
											enm[i].img.X -= anm[66].W
											if enm[i].img.X < anm[66].X-anm[66].frames*anm[66].W {
												enm[i].img.X = anm[66].X
											}
										} else {
											enm[i].img.X += anm[65].W
											if enm[i].img.X > anm[65].X+anm[65].frames*anm[65].W {
												enm[i].img.X = anm[65].X
											}
										}
									}
								case "flamehead":
									if frames%3 == 0 {
										if enm[i].lr {
											enm[i].img.X -= anm[64].W
											if enm[i].img.X < anm[64].X-anm[64].frames*anm[64].W {
												enm[i].img.X = anm[64].X
											}
										} else {
											enm[i].img.X += anm[63].W
											if enm[i].img.X > anm[63].X+anm[63].frames*anm[63].W {
												enm[i].img.X = anm[63].X
											}
										}
									}
								case "fire":
									if frames%3 == 0 {
										enm[i].img.X += anm[55].W
										if enm[i].img.X > anm[55].X+anm[55].frames*anm[55].W {
											enm[i].img.X = anm[55].X
										}
									}
								case "fly":
									if frames%4 == 0 {
										if enm[i].lr {
											enm[i].img.X -= anm[54].W
											if enm[i].img.X < anm[54].X-anm[54].frames*anm[54].W {
												enm[i].img.X = anm[54].X
											}
										} else {
											enm[i].img.X += anm[53].W
											if enm[i].img.X > anm[53].X+anm[53].frames*anm[53].W {
												enm[i].img.X = anm[53].X
											}
										}
									}
								case "worm":
									if frames%12 == 0 {
										if enm[i].lr {
											enm[i].img.X -= anm[52].W
											if enm[i].img.X < anm[52].X-anm[52].frames*anm[52].W {
												enm[i].img.X = anm[52].X
											}
										} else {
											enm[i].img.X += anm[51].W
											if enm[i].img.X > anm[51].X+anm[51].frames*anm[51].W {
												enm[i].img.X = anm[51].X
											}
										}
									}
								case "blackdot":
									if frames%5 == 0 {
										if enm[i].lr {
											enm[i].img.X -= anm[50].W
											if enm[i].img.X < anm[50].X-anm[50].frames*anm[50].W {
												enm[i].img.X = anm[50].X
											}
										} else {
											enm[i].img.X += anm[49].W
											if enm[i].img.X > anm[49].X+anm[49].frames*anm[49].W {
												enm[i].img.X = anm[49].X
											}
										}
									}
								case "yellowdino":
									if frames%4 == 0 {
										if enm[i].lr {
											enm[i].img.X -= anm[47].W
											if enm[i].img.X < anm[47].X-anm[47].frames*anm[47].W {
												enm[i].img.X = anm[47].X
											}
										} else {
											enm[i].img.X += anm[46].W
											if enm[i].img.X > anm[46].X+anm[46].frames*anm[46].W {
												enm[i].img.X = anm[46].X
											}
										}
									}
								case "greenplant":
									if enm[i].idlon {
										if frames%12 == 0 {
											enm[i].img.X += anm[45].W
											if enm[i].img.X > anm[45].X+anm[45].frames*anm[45].W {
												enm[i].img.X = anm[45].X
											}
										}
									} else {
										if frames%4 == 0 {
											if enm[i].lr {
												enm[i].img.X -= anm[44].W
												if enm[i].img.X < anm[44].X-anm[44].frames*anm[44].W {
													enm[i].img.X = anm[44].X
												}
											} else {
												enm[i].img.X += anm[43].W
												if enm[i].img.X > anm[43].X+anm[43].frames*anm[43].W {
													enm[i].img.X = anm[43].X
												}
											}
										}
									}
								case "pinkcart":
									if enm[i].idlon {
										if enm[i].img.X < anm[42].X {
											enm[i].img.X = anm[42].X
										}
										if frames%12 == 0 {
											enm[i].img.X += anm[42].W
											if enm[i].img.X > anm[42].X+anm[42].frames*anm[42].W {
												enm[i].img.X = anm[42].X
											}
										}
									} else {
										if frames%4 == 0 {
											if enm[i].lr {
												enm[i].img.X -= anm[41].W
												if enm[i].img.X < anm[41].X-anm[41].frames*anm[41].W {
													enm[i].img.X = anm[41].X
												}
											} else {
												enm[i].img.X += anm[40].W
												if enm[i].img.X > anm[40].X+anm[40].frames*anm[40].W {
													enm[i].img.X = anm[40].X
												}
											}
										}
									}
								case "crocodile":
									if enm[i].hpT > 0 {
										if enm[i].lr {
											enm[i].img = enm[i].hitImgL
										} else {
											enm[i].img = enm[i].hitImgR
										}
									} else {
										if enm[i].fast {
											if frames%2 == 0 {
												if enm[i].lr {
													enm[i].img.X -= anm[59].W
													if enm[i].img.X < anm[59].X-anm[59].frames*anm[59].W {
														enm[i].img.X = anm[59].X
													}
												} else {
													enm[i].img.X += anm[58].W
													if enm[i].img.X > anm[58].X+anm[58].frames*anm[58].W {
														enm[i].img.X = anm[58].X
													}
												}
											}
										} else {
											if frames%6 == 0 {
												if enm[i].lr {
													enm[i].img.Y = anm[39].rec.Y
													enm[i].img.X -= anm[39].W
													if enm[i].img.X < anm[39].X-anm[39].frames*anm[39].W {
														enm[i].img.X = anm[39].X
													}
												} else {
													enm[i].img.Y = anm[38].rec.Y
													enm[i].img.X += anm[38].W
													if enm[i].img.X > anm[38].X+anm[38].frames*anm[38].W {
														enm[i].img.X = anm[38].X
													}
												}
											}
										}
									}
								case "balloon":
									if frames%int(enm[i].animFrameT) == 0 {
										if enm[i].lr {
											enm[i].img.X -= anm[37].W
											if enm[i].img.X < anm[37].X-anm[37].frames*anm[37].W {
												enm[i].img.X = anm[37].X
											}
										} else {
											enm[i].img.X += anm[36].W
											if enm[i].img.X > anm[36].X+anm[36].frames*anm[36].W {
												enm[i].img.X = anm[36].X
											}
										}
										enm[i].animFrameT = RandInt32(12, 25)
									}
								case "redantenna":
									if enm[i].hpT > 0 {
										if enm[i].lr {
											enm[i].img = enm[i].hitImgL
										} else {
											enm[i].img = enm[i].hitImgR
										}
									} else {
										if frames%6 == 0 {
											if enm[i].lr {
												enm[i].img.X -= anm[35].W
												if enm[i].img.X < anm[35].X-anm[35].frames*anm[35].W {
													enm[i].img.X = anm[35].X
												}
											} else {
												enm[i].img.X += anm[34].W
												if enm[i].img.X > anm[34].X+anm[34].frames*anm[34].W {
													enm[i].img.X = anm[34].X
												}
											}
										}
									}
								case "ghost":
									if frames%6 == 0 {
										if enm[i].lr {
											enm[i].img.X -= anm[33].W
											if enm[i].img.X < anm[33].X-anm[33].frames*anm[33].W {
												enm[i].img.X = anm[33].X
											}
										} else {
											enm[i].img.X += anm[32].W
											if enm[i].img.X > anm[32].X+anm[32].frames*anm[32].W {
												enm[i].img.X = anm[32].X
											}
										}
									}
								case "redbomb":
									if enm[i].idlon {
										if frames%12 == 0 {
											enm[i].img.X += anm[31].W
											if enm[i].img.X > anm[31].X+anm[31].frames*anm[31].W {
												enm[i].img.X = anm[31].X
											}
										}
									} else {
										if frames%6 == 0 {
											if enm[i].lr {
												enm[i].img.X -= anm[30].W
												if enm[i].img.X < anm[30].X-anm[30].frames*anm[30].W {
													enm[i].img.X = anm[30].X
												}
											} else {
												enm[i].img.X += anm[29].W
												if enm[i].img.X > anm[29].X+anm[29].frames*anm[29].W {
													enm[i].img.X = anm[29].X
												}
											}
										}
									}
								case "redeye":
									if enm[i].idlon {
										if frames%12 == 0 {
											enm[i].img.X += anm[28].W
											if enm[i].img.X > anm[28].X+anm[28].frames*anm[28].W {
												enm[i].img.X = anm[28].X
											}
										}
									} else {
										if frames%6 == 0 {
											if enm[i].lr {
												enm[i].img.X -= anm[27].W
												if enm[i].img.X < anm[27].X-anm[27].frames*anm[27].W {
													enm[i].img.X = anm[27].X
												}
											} else {
												enm[i].img.X += anm[26].W
												if enm[i].img.X > anm[26].X+anm[26].frames*anm[26].W {
													enm[i].img.X = anm[26].X
												}
											}
										}
									}
								case "bluespike":
									if enm[i].idlon {
										if frames%12 == 0 {
											enm[i].img.X += anm[25].W
											if enm[i].img.X > anm[25].X+anm[25].frames*anm[25].W {
												enm[i].img.X = anm[25].X
											}
										}
									} else {
										if frames%6 == 0 {
											if enm[i].lr {
												enm[i].img.X -= anm[24].W
												if enm[i].img.X < anm[24].X-anm[24].frames*anm[24].W {
													enm[i].img.X = anm[24].X
												}
											} else {
												enm[i].img.X += anm[23].W
												if enm[i].img.X > anm[23].X+anm[23].frames*anm[23].W {
													enm[i].img.X = anm[23].X
												}
											}
										}
									}
								}
							}
							//DEBUG
							if debug {
								rl.DrawRectangleLinesEx(enm[i].rec, 1, rl.Red)
								rl.DrawRectangleLinesEx(enm[i].crec, 1, rl.Magenta)
								rl.DrawRectangleLinesEx(enm[i].carec, 1, rl.Green)
							}
						}
					} else {
						clear = true
					}
				}
				if clear {
					Remove(4)
				}
			}
		}

		//MARK: DRAW LIGHTNING
		if len(lightningEnm) > 1 && !bosson {
			if lightningCount > 0 {
				for i := 0; i < len(lightningEnm)-1; i++ {
					cnt1 := makecnt(levels[levNum].enm[lightningEnm[i]].crec)
					cnt2 := makecnt(levels[levNum].enm[lightningEnm[i+1]].crec)
					//rl.DrawLineV(cnt1,cnt2,rl.Blue)
					rl.DrawLineEx(cnt1, cnt2, RandF32(2, 5), rl.Fade(RandBlue(), RandF32(0.1, 0.4)))
					cnt1.X += RandF32(-5, 5)
					cnt1.Y += RandF32(-5, 5)
					cnt2.X += RandF32(-5, 5)
					cnt2.Y += RandF32(-5, 5)
					rl.DrawLineEx(cnt1, cnt2, RandF32(3, 7), rl.Fade(RandBlue(), RandF32(0.1, 0.4)))
					cnt1.X += RandF32(-5, 5)
					cnt1.Y += RandF32(-5, 5)
					cnt2.X += RandF32(-5, 5)
					cnt2.Y += RandF32(-5, 5)
					rl.DrawLineEx(cnt1, cnt2, RandF32(1, 3), rl.Fade(RandBlue(), RandF32(0.3, 0.7)))
					cnt1.X += RandF32(-5, 5)
					cnt1.Y += RandF32(-5, 5)
					cnt2.X += RandF32(-5, 5)
					cnt2.Y += RandF32(-5, 5)
					rl.DrawLineEx(cnt1, cnt2, RandF32(1, 3), rl.Fade(RandBlue(), RandF32(0.2, 0.5)))

				}
				lightningCount--
			} else {
				for i := 0; i < len(lightningEnm); i++ {
					if levels[levNum].enm[lightningEnm[i]].hpT == 0 {
						levels[levNum].enm[lightningEnm[i]].hp--
					}
					if levels[levNum].enm[lightningEnm[i]].hp <= 0 && !levels[levNum].enm[lightningEnm[i]].off {
						pl.xp += levels[levNum].enm[lightningEnm[i]].xp
						makeEnDeathFx(lightningEnm[i])
						levels[levNum].enm[lightningEnm[i]].off = true
					} else {
						rl.PlaySound(audfx[8])
						if !levels[levNum].enm[lightningEnm[i]].nodmg {
							levels[levNum].enm[lightningEnm[i]].hpT = fps
							levels[levNum].enm[lightningEnm[i]].hpY = bq3
							levels[levNum].enm[lightningEnm[i]].hpY2 = 0
							if bosson {
								levels[levNum].enm[i].hpY = b
								levels[levNum].enm[i].hpY2 = b / 2
							}
						}
					}
				}
				lightningEnm = nil
			}
		}

		//MARK: DRAW PROJ ENEMY ABOVE
		if len(projEn) > 0 {
			upprojEn()
			for i := 0; i < len(projEn); i++ {
				if rl.CheckCollisionRecs(projEn[i].rec, drawRec) {
					if !projEn[i].off && !projEn[i].below {
						switch projEn[i].nm {
						case "bushProj":
							rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 12), orgn(projEn[i].rec), projEn[i].ro, shcol())
							rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.White)
							projEn[i].ro += projEn[i].rospd
							if frames%3 == 0 {
								projEn[i].img.X += anm[173].W
								if projEn[i].img.X > anm[173].X+anm[173].frames*anm[173].W {
									projEn[i].img.X = anm[173].X
								}
							}
						case "birdProj":
							rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 12), orgn(projEn[i].rec), projEn[i].ro, shcol())
							rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.White)
							projEn[i].ro += projEn[i].rospd
						case "greenpigProj":
							rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 12), orgn(projEn[i].rec), projEn[i].ro, shcol())
							rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.White)
							if frames%3 == 0 {
								projEn[i].img.X += anm[132].W
								if projEn[i].img.X > anm[132].X+anm[132].frames*anm[132].W {
									projEn[i].img.X = anm[132].X
								}
							}
							if rl.CheckCollisionRecs(pl.crec, projEn[i].crec) && pl.poisonT == 0 {
								admsg("poisoned...", rl.Green)
								pl.poisonT += fps * 3
							}
						case "rolloProj":
							rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 12), orgn(projEn[i].rec), projEn[i].ro, shcol())
							rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(rl.White, RandF32(0.2, 0.5)))
							//BLUR
							rl.DrawTexturePro(imgs, projEn[i].img, brec(drec(projEn[i].rec), 7), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(rl.White, RandF32(0.05, 0.2)))
							if frames%2 == 0 {
								projEn[i].img.X += anm[155].W
								if projEn[i].img.X > anm[155].X+anm[155].frames*anm[155].W {
									projEn[i].img.X = anm[155].X
								}
							}
							projEn[i].ro += 4
						case "mushbossProj":
							rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 12), orgn(projEn[i].rec), projEn[i].ro, shcol())
							rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(rl.White, RandF32(0.4, 0.7)))
							if frames%2 == 0 {
								projEn[i].img.X += anm[152].W
								if projEn[i].img.X > anm[152].X+anm[152].frames*anm[152].W {
									projEn[i].img.X = anm[152].X
								}
							}
						case "battyProj":
							col := RandColor()
							rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 3), orgn(projEn[i].rec), projEn[i].ro, shcol())
							rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, col)
							//BLUR
							rl.DrawTexturePro(imgs, projEn[i].img, brec(drec(projEn[i].rec), 12), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(col, RandF32(0.05, 0.2)))
							if frames%2 == 0 {
								projEn[i].img.X += anm[147].W
								if projEn[i].img.X > anm[147].X+anm[147].frames*anm[147].W {
									projEn[i].img.X = anm[147].X
								}
							}
						case "zomboProj":
							rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 12), orgn(projEn[i].rec), projEn[i].ro, shcol())
							rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(rl.White, RandF32(0.2, 0.5)))
							//BLUR
							rl.DrawTexturePro(imgs, projEn[i].img, brec(drec(projEn[i].rec), 4), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(rl.White, RandF32(0.05, 0.2)))
							if frames%3 == 0 {
								projEn[i].img.X += anm[140].W
								if projEn[i].img.X > anm[140].X+anm[140].frames*anm[140].W {
									projEn[i].img.X = anm[140].X
								}
								projEn[i].rec.X -= 4
								projEn[i].rec.Y -= 4
								projEn[i].rec.Width += 8
								projEn[i].rec.Height += 8
								projEn[i].crec = projEn[i].rec
								projEn[i].crec.X += projEn[i].crec.Width / 4
								projEn[i].crec.Y += projEn[i].crec.Height / 4
								projEn[i].crec.Width = projEn[i].crec.Width / 2
								projEn[i].crec.Height = projEn[i].crec.Height / 2
							}
							projEn[i].ro += 4
						case "pigProj":
							rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 12), orgn(projEn[i].rec), projEn[i].ro, shcol())
							rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(rl.White, RandF32(0.4, 0.7)))
							if frames%3 == 0 {
								projEn[i].img.X += anm[135].W
								if projEn[i].img.X > anm[135].X+anm[135].frames*anm[135].W {
									projEn[i].img.X = anm[135].X
								}
							}
						case "spacemanProj":
							rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 12), orgn(projEn[i].rec), projEn[i].ro, shcol())
							rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(rl.White, RandF32(0.4, 0.7)))
							//BLUR
							rl.DrawTexturePro(imgs, projEn[i].img, brec(drec(projEn[i].rec), 4), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(rl.White, RandF32(0.1, 0.3)))
							if frames%3 == 0 {
								projEn[i].img.X += anm[131].W
								if projEn[i].img.X > anm[131].X+anm[131].frames*anm[131].W {
									projEn[i].img.X = anm[131].X
								}
							}
							projEn[i].ro += 4
						case "spinnaProj":
							rl.DrawTexturePro(imgs, projEn[i].img, shrec(projEn[i].rec, 12), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, projEn[i].img, projEn[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.4, 0.7)))
							//BLUR
							rl.DrawTexturePro(imgs, projEn[i].img, brec(projEn[i].rec, 12), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.1, 0.3)))
							rl.DrawTexturePro(imgs, projEn[i].img, brec(projEn[i].rec, 24), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.1, 0.3)))
							projEn[i].img.X += anm[123].W
							if projEn[i].img.X > anm[123].X+anm[123].frames*anm[123].W {
								projEn[i].img.X = anm[123].X
							}
						case "mrfrisbeeProj":
							rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 12), orgn(projEn[i].rec), projEn[i].ro, shcol())
							rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, RandYellow())
							if frames%2 == 0 {
								projEn[i].img.X += anm[116].W
								if projEn[i].img.X > anm[116].X+anm[116].frames*anm[116].W {
									projEn[i].img.X = anm[116].X
								}
							}
							projEn[i].ro += 4
						case "icemanProj":
							rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 12), orgn(projEn[i].rec), projEn[i].ro, shcol())
							rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(rl.White, 0.5))
						case "redblobbull":
							rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 12), orgn(projEn[i].rec), projEn[i].ro, shcol())
							rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(projEn[i].col, projEn[i].fd))
							if frames%5 == 0 {
								projEn[i].img.X += anm[71].W
								if projEn[i].img.X > anm[71].X+anm[71].frames*anm[71].W {
									projEn[i].img.X = anm[71].X
								}
							}
						case "greenplantbull":
							rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 12), orgn(projEn[i].rec), projEn[i].ro, shcol())
							rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(projEn[i].col, projEn[i].fd))
							if frames%2 == 0 {
								projEn[i].img.X += anm[61].W
								if projEn[i].img.X > anm[61].X+anm[61].frames*anm[61].W {
									projEn[i].img.X = anm[61].X
								}
							}
						case "pinkcartbull":
							rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 12), orgn(projEn[i].rec), projEn[i].ro, shcol())
							rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(projEn[i].col, RandF32(0.4, 0.7)))
							if frames%3 == 0 {
								projEn[i].img.X += anm[60].W
								if projEn[i].img.X > anm[60].X+anm[60].frames*anm[60].W {
									projEn[i].img.X = anm[60].X
								}
							}
						case "redantbull":
							rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 12), orgn(projEn[i].rec), projEn[i].ro, shcol())
							rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(projEn[i].col, projEn[i].fd))
							if frames%3 == 0 {
								projEn[i].img.X += anm[56].W
								if projEn[i].img.X > anm[56].X+anm[56].frames*anm[56].W {
									projEn[i].img.X = anm[56].X
								}
							}
						default: //NO ANIM IMG BULLET
							rl.DrawTexturePro(imgs, projEn[i].img, shrec(drec(projEn[i].rec), 12), orgn(projEn[i].rec), projEn[i].ro, shcol())
							rl.DrawTexturePro(imgs, projEn[i].img, drec(projEn[i].rec), orgn(projEn[i].rec), projEn[i].ro, rl.Fade(projEn[i].col, projEn[i].fd))
						}
						if debug {
							rl.DrawRectangleLinesEx(projEn[i].rec, 1, rl.Yellow)
							rl.DrawRectangleLinesEx(projEn[i].crec, 1, rl.Magenta)
						}
					}
				}
			}
		}
		//MARK: DRAW PROJ PLAYER
		if len(projPL) > 0 {
			upprojPL()
			for i := 0; i < len(projPL); i++ {
				if rl.CheckCollisionRecs(projPL[i].rec, drawRec) {
					if !projPL[i].off {
						switch projPL[i].nm {
						case "rolloProj":
							rl.DrawTexturePro(imgs, projPL[i].img, shrec(drec(projPL[i].rec), 12), orgn(projPL[i].rec), projPL[i].ro, shcol())
							rl.DrawTexturePro(imgs, projPL[i].img, drec(projPL[i].rec), orgn(projPL[i].rec), projPL[i].ro, rl.Fade(rl.White, RandF32(0.2, 0.5)))
							//BLUR
							rl.DrawTexturePro(imgs, projPL[i].img, brec(drec(projPL[i].rec), 7), orgn(projPL[i].rec), projPL[i].ro, rl.Fade(rl.White, RandF32(0.05, 0.2)))
							if frames%2 == 0 {
								projPL[i].img.X += anm[155].W
								if projPL[i].img.X > anm[155].X+anm[155].frames*anm[155].W {
									projPL[i].img.X = anm[155].X
								}
							}
							projPL[i].ro += 4
						case "battyProj":
							col := RandColor()
							rl.DrawTexturePro(imgs, projPL[i].img, shrec(drec(projPL[i].rec), 3), orgn(projPL[i].rec), projPL[i].ro, shcol())
							rl.DrawTexturePro(imgs, projPL[i].img, drec(projPL[i].rec), orgn(projPL[i].rec), projPL[i].ro, col)
							//BLUR
							rl.DrawTexturePro(imgs, projPL[i].img, brec(drec(projPL[i].rec), 12), orgn(projPL[i].rec), projPL[i].ro, rl.Fade(col, RandF32(0.05, 0.2)))
							if frames%2 == 0 {
								projPL[i].img.X += anm[147].W
								if projPL[i].img.X > anm[147].X+anm[147].frames*anm[147].W {
									projPL[i].img.X = anm[147].X
								}
							}
						case "pigProj":
							rl.DrawTexturePro(imgs, projPL[i].img, shrec(drec(projPL[i].rec), 12), orgn(projPL[i].rec), projPL[i].ro, shcol())
							rl.DrawTexturePro(imgs, projPL[i].img, drec(projPL[i].rec), orgn(projPL[i].rec), projPL[i].ro, rl.Fade(rl.White, RandF32(0.4, 0.7)))
							if frames%3 == 0 {
								projPL[i].img.X += anm[135].W
								if projPL[i].img.X > anm[135].X+anm[135].frames*anm[135].W {
									projPL[i].img.X = anm[135].X
								}
							}
						case "mrfrisbeeProj":
							rl.DrawTexturePro(imgs, projPL[i].img, shrec(drec(projPL[i].rec), 12), orgn(projPL[i].rec), projPL[i].ro, shcol())
							rl.DrawTexturePro(imgs, projPL[i].img, drec(projPL[i].rec), orgn(projPL[i].rec), projPL[i].ro, RandYellow())
							if frames%2 == 0 {
								projPL[i].img.X += anm[116].W
								if projPL[i].img.X > anm[116].X+anm[116].frames*anm[116].W {
									projPL[i].img.X = anm[116].X
								}
							}
							projPL[i].ro += 4
						case "fartfire":
							rl.DrawTexturePro(imgs, projPL[i].img, shrec(drec(projPL[i].rec), 12), orgn(projPL[i].rec), projPL[i].ro, shcol())
							rl.DrawTexturePro(imgs, projPL[i].img, drec(projPL[i].rec), orgn(projPL[i].rec), projPL[i].ro, rl.Fade(rl.White, RandF32(0.5, 0.7)))
							rl.DrawTexturePro(imgs, projPL[i].img, brec(drec(projPL[i].rec), 5), orgn(projPL[i].rec), projPL[i].ro, rl.Fade(rl.White, RandF32(0.1, 0.3)))
						case "mustard":
							rl.DrawTexturePro(imgs, projPL[i].img, shrec(drec(projPL[i].rec), 12), orgn(projPL[i].rec), projPL[i].ro, shcol())
							rl.DrawTexturePro(imgs, projPL[i].img, drec(projPL[i].rec), orgn(projPL[i].rec), projPL[i].ro, rl.Fade(rl.Orange, RandF32(0.4, 0.7)))
						case "popcornProj":
							rl.DrawTexturePro(imgs, projPL[i].img, drec(projPL[i].rec), orgn(projPL[i].rec), projPL[i].ro, shcol())
							rl.DrawTexturePro(imgs, projPL[i].img, drec(projPL[i].rec), orgn(projPL[i].rec), projPL[i].ro, rl.White)
							projPL[i].ro += projPL[i].rospd
						case "chickenProj":
							if projPL[i].direc {
								rl.DrawTexturePro(imgs, anm[103].rec, shrec(projPL[i].rec, 5), rl.Vector2Zero(), 0, shcol())
								rl.DrawTexturePro(imgs, anm[103].rec, projPL[i].rec, rl.Vector2Zero(), 0, rl.White)
							} else {
								rl.DrawTexturePro(imgs, anm[102].rec, shrec(projPL[i].rec, 5), rl.Vector2Zero(), 0, shcol())
								rl.DrawTexturePro(imgs, anm[102].rec, projPL[i].rec, rl.Vector2Zero(), 0, rl.White)
							}
							if eggsT == 0 {
								projPL[i].off = true
							}
							if debug {
								rl.DrawRectangleLinesEx(projPL[i].rec, 1, rl.Yellow)
								rl.DrawRectangleLinesEx(projPL[i].crec, 1, rl.Magenta)
							}
						case "beeProj":
							if projPL[i].direc {
								rl.DrawTexturePro(imgs, anm[101].rec, shrec(projPL[i].rec, 12), rl.Vector2Zero(), 0, shcol())
								rl.DrawTexturePro(imgs, anm[101].rec, projPL[i].rec, rl.Vector2Zero(), 0, rl.White)
							} else {
								rl.DrawTexturePro(imgs, anm[100].rec, shrec(projPL[i].rec, 12), rl.Vector2Zero(), 0, shcol())
								rl.DrawTexturePro(imgs, anm[100].rec, projPL[i].rec, rl.Vector2Zero(), 0, rl.White)
							}
							if honeycombT == 0 {
								projPL[i].off = true
							}
							if debug {
								rl.DrawRectangleLinesEx(projPL[i].rec, 1, rl.Yellow)
								rl.DrawRectangleLinesEx(projPL[i].crec, 1, rl.Magenta)
							}
						case "ladybugproj":
							rl.DrawTexturePro(imgs, projPL[i].img, shrec(drec(projPL[i].rec), 12), orgn(projPL[i].rec), projPL[i].ro, shcol())
							rl.DrawTexturePro(imgs, projPL[i].img, drec(projPL[i].rec), orgn(projPL[i].rec), projPL[i].ro, rl.Fade(projPL[i].col, projPL[i].fd))
							if frames%3 == 0 {
								projPL[i].img.X += anm[97].W
								if projPL[i].img.X > anm[97].X+anm[97].frames*anm[97].W {
									projPL[i].img.X = anm[97].X
								}
							}
							projPL[i].ro += 4
							if debug {
								rl.DrawRectangleLinesEx(projPL[i].rec, 1, rl.Red)
								rl.DrawRectangleLinesEx(projPL[i].crec, 1, rl.White)
								if projPL[i].carec.Width > 0 {
									rl.DrawRectangleLinesEx(projPL[i].carec, 1, rl.Magenta)
								}
							}
						case "frogProj":
							rl.DrawTexturePro(imgs, projPL[i].img, shrec(drec(projPL[i].rec), 5), orgn(projPL[i].rec), projPL[i].ro, shcol())
							rl.DrawTexturePro(imgs, projPL[i].img, drec(projPL[i].rec), orgn(projPL[i].rec), projPL[i].ro, rl.Fade(projPL[i].col, projPL[i].fd))
							if debug {
								rl.DrawRectangleLinesEx(projPL[i].rec, 1, rl.Red)
								rl.DrawRectangleLinesEx(projPL[i].crec, 1, rl.White)
								if projPL[i].carec.Width > 0 {
									rl.DrawRectangleLinesEx(projPL[i].carec, 1, rl.Magenta)
								}
							}
						default:
							rl.DrawTexturePro(imgs, projPL[i].img, shrec(drec(projPL[i].rec), 12), orgn(projPL[i].rec), projPL[i].ro, shcol())
							rl.DrawTexturePro(imgs, projPL[i].img, drec(projPL[i].rec), orgn(projPL[i].rec), projPL[i].ro, rl.Fade(projPL[i].col, projPL[i].fd))
							//WINDOW CLEANER
							if projPL[i].nm == "window cleaner" {
								rl.DrawTexturePro(imgs, projPL[i].img, brec(drec(projPL[i].rec), 10), orgn(projPL[i].rec), projPL[i].ro, rl.Fade(projPL[i].col, RandF32(0.5, 0.7)))
								rl.DrawTexturePro(imgs, projPL[i].img, brec(drec(projPL[i].rec), 20), orgn(projPL[i].rec), projPL[i].ro, rl.Fade(projPL[i].col, RandF32(0.2, 0.5)))
							}
							//FIREWORK
							if projPL[i].nm == "firework" {
								projPL[i].rec3 = projPL[i].rec
								switch projPL[i].ro {
								case 45:
									projPL[i].rec3.X -= projPL[i].rec3.Width
								case -135:
									projPL[i].rec3.X += projPL[i].rec3.Width
								case -45:
									projPL[i].rec3.Y += projPL[i].rec3.Width
								case 135:
									projPL[i].rec3.Y -= projPL[i].rec3.Width
								case 90:
									projPL[i].rec3.X -= projPL[i].rec3.Width
									projPL[i].rec3.Y -= projPL[i].rec3.Width
								case 270:
									projPL[i].rec3.X += projPL[i].rec3.Width
									projPL[i].rec3.Y += projPL[i].rec3.Width
								case 180:
									projPL[i].rec3.X += projPL[i].rec3.Width
									projPL[i].rec3.Y += projPL[i].rec3.Width
								case 0:
									projPL[i].rec3.X -= projPL[i].rec3.Width
									projPL[i].rec3.Y -= projPL[i].rec3.Width

								}
								rl.DrawTexturePro(imgs, projPL[i].rec2, drec(projPL[i].rec3), orgn(projPL[i].rec3), projPL[i].ro-225, rl.White)
								projPL[i].rec2.X += anm[201].W
								if projPL[i].rec2.X > anm[201].X+anm[201].frames*anm[201].W {
									projPL[i].rec2.X = anm[201].X
								}
							}
							//ROCKET
							if projPL[i].nm == "rocket" {
								rl.DrawTexturePro(imgs, projPL[i].rec2, drec(projPL[i].rec3), orgn(projPL[i].rec3), projPL[i].ro-270, rl.White)
								projPL[i].rec2.X += anm[201].W
								if projPL[i].rec2.X > anm[201].X+anm[201].frames*anm[201].W {
									projPL[i].rec2.X = anm[201].X
								}
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(projPL[i].rec, 1, rl.Red)
							rl.DrawRectangleLinesEx(projPL[i].crec, 1, rl.White)
							if projPL[i].carec.Width > 0 {
								rl.DrawRectangleLinesEx(projPL[i].carec, 1, rl.Magenta)
							}
						}
					}
				}
			}
		}
		for i := 0; i < len(etc2); i++ {
			switch etc2[i].nm {
			case "popcornturret":
				rl.DrawTexturePro(imgs, etc2[i].img, drec(shrec(etc2[i].rec, 5)), orgn(etc2[i].rec), etc2[i].ro, shcol())
				rl.DrawTexturePro(imgs, etc2[i].img, drec(etc2[i].rec), orgn(etc2[i].rec), etc2[i].ro, rl.White)
				etc2[i].moveT--
				if etc2[i].moveT == 0 {
					etc2[i].moveT = fps
					siz := be3
					zproj := xweap{}
					zproj.col = rl.White
					zproj.spd = 4
					zproj.dmg = 1
					zproj.fd = 1
					zproj.rospd = RandF32(5, 11)
					if FlipCoin() {
						zproj.rospd = -zproj.rospd
					}
					zproj.rec = rl.NewRectangle(etc2[i].cnt.X-siz/2, etc2[i].cnt.Y-siz/2, siz, siz)
					zproj.crec = zproj.rec
					zproj.img = etc[131]
					zproj.dirX = RandF32(-zproj.spd/2, zproj.spd/2)
					zproj.dirY = -zproj.spd
					zproj.bounce = 2
					if FlipCoin() {
						zproj.bounce = 3
					}
					zproj.nm = "popcornProj"
					projPL = append(projPL, zproj)
					zproj.dirX = RandF32(-zproj.spd/2, zproj.spd/2)
					projPL = append(projPL, zproj)
					zproj.dirX = RandF32(-zproj.spd/2, zproj.spd/2)
					projPL = append(projPL, zproj)
					if rl.CheckCollisionRecs(etc2[i].rec, drawRec) {
						rl.PlaySound(audfx[86])
					}
					if FlipCoin() {
						zproj.dirX = RandF32(-zproj.spd/2, zproj.spd/2)
						projPL = append(projPL, zproj)
						if rl.CheckCollisionRecs(etc2[i].rec, drawRec) {
							rl.PlaySound(audfx[86])
						}
					}
					if FlipCoin() {
						zproj.dirX = RandF32(-zproj.spd/2, zproj.spd/2)
						projPL = append(projPL, zproj)
						if rl.CheckCollisionRecs(etc2[i].rec, drawRec) {
							rl.PlaySound(audfx[86])
						}
					}
				}
				//TXT
				if rl.CheckCollisionPointRec(cursorV2cam, etc2[i].rec) {
					toptx = "popcorn turret"
					toptxT = fps
				}
			case "ladybugturret":
				rl.DrawTexturePro(imgs, etc2[i].img, drec(shrec(etc2[i].rec, 5)), orgn(etc2[i].rec), etc2[i].ro, shcol())
				rl.DrawTexturePro(imgs, etc2[i].img, drec(etc2[i].rec), orgn(etc2[i].rec), etc2[i].ro, rl.White)
				etc2[i].ro += 1.015
				etc2[i].moveT--
				if etc2[i].moveT == 0 {
					if rl.CheckCollisionRecs(etc2[i].rec, drawRec) {
						rl.PlaySound(audfx[85])
					}
					etc2[i].moveT = fps
					siz := b / 2
					zproj := xweap{}
					zproj.col = rl.White
					zproj.spd = 4
					zproj.dmg = 1
					zproj.fd = 1
					zproj.rec = rl.NewRectangle(etc2[i].cnt.X-siz/2, etc2[i].cnt.Y-siz/2, siz, siz)
					xdiff := AbsDiff(etc2[i].cnt.X, etc2[i].v2.X)
					ydiff := AbsDiff(etc2[i].cnt.Y, etc2[i].v2.Y)
					if xdiff > ydiff {
						zproj.dirX = zproj.spd
						zproj.dirY = ydiff / (xdiff / zproj.dirX)
					} else {
						zproj.dirY = zproj.spd
						zproj.dirX = xdiff / (ydiff / zproj.dirY)
					}
					if etc2[i].cnt.X > etc2[i].v2.X {
						zproj.dirX = -zproj.dirX
					}
					if etc2[i].cnt.Y > etc2[i].v2.Y {
						zproj.dirY = -zproj.dirY
					}
					zproj.crec = zproj.rec
					zproj.img = anm[97].rec
					zproj.bounce = 2
					if FlipCoin() {
						zproj.bounce = 3
					}
					zproj.nm = "ladybugproj"
					projPL = append(projPL, zproj)
				}
				etc2[i].angl = etc2[i].angl * (math.Pi / 180)
				newx := float32(math.Cos(float64(etc2[i].angl)))*(etc2[i].v2.X-etc2[i].cnt.X) - float32(math.Sin(float64(etc2[i].angl)))*(etc2[i].v2.Y-etc2[i].cnt.Y) + etc2[i].cnt.X
				newy := float32(math.Sin(float64(etc2[i].angl)))*(etc2[i].v2.X-etc2[i].cnt.X) + float32(math.Cos(float64(etc2[i].angl)))*(etc2[i].v2.Y-etc2[i].cnt.Y) + etc2[i].cnt.Y
				etc2[i].v2 = rl.NewVector2(newx, newy)
				etc2[i].angl++
				if etc2[i].angl >= 360 {
					etc2[i].angl = 0
				}
				//TXT
				if rl.CheckCollisionPointRec(cursorV2cam, etc2[i].rec) {
					toptx = "ladybug turret"
					toptxT = fps
				}
			}
		}
		//MARK: DRAW PLAYER PROJ LAYER ABOVE
		if len(projPL) > 0 {
			for i := 0; i < len(projPL); i++ {
				if rl.CheckCollisionRecs(projPL[i].rec, drawRec) {
					if projPL[i].nm == "poisongas" {
						rl.DrawTexturePro(imgs, projPL[i].img, shrec(drec(projPL[i].rec), 12), orgn(projPL[i].rec), projPL[i].ro, shcol())
						rl.DrawTexturePro(imgs, projPL[i].img, drec(projPL[i].rec), orgn(projPL[i].rec), projPL[i].ro, rl.Fade(RandGreen(), RandF32(0.7, 1.1)))
						if debug {
							rl.DrawRectangleLinesEx(projPL[i].rec, 1, rl.Red)
							rl.DrawRectangleLinesEx(projPL[i].crec, 1, rl.White)
						}
						projPL[i].ro += projPL[i].rospd
						if frames%4 == 0 {
							if projPL[i].nm == "poisongas" {
								projPL[i].img.X += anm[76].W
								if projPL[i].img.X > anm[76].X+anm[76].frames*anm[76].W {
									projPL[i].img.X = anm[76].X
								}
							}
						}
					}
				}
			}
		}
		//WALLS
		for i := 0; i < len(walls); i++ {
			//MOVE BLOCK SHADOW REC
			if walls[i].dirX != 0 || walls[i].dirY != 0 {
				rl.DrawTexturePro(imgs, walltile, shrec(walls[i].rec, 4), rl.Vector2Zero(), 0, shcol())
				//SPIKES
				if walls[i].spikes {
					//MARK:MOVE BLOK SPIKES
					if walls[i].onoff {
						walls[i].spikerecs[0].Y++ //TOP SPIKE
						walls[i].spikerecs[1].X-- //RIGHT SPIKE
						walls[i].spikerecs[2].Y-- //DOWN SPIKE
						walls[i].spikerecs[3].X++ //LEFT SPIKE
						if walls[i].spikerecs[0].Y >= walls[i].rec.Y {
							walls[i].spikerecs[0].Y = walls[i].rec.Y
							walls[i].onoff = false
						}
						if walls[i].spikerecs[1].X < walls[i].rec.X+walls[i].rec.Width-walls[i].spikerecs[1].Width {
							walls[i].spikerecs[1].X = walls[i].rec.X + walls[i].rec.Width - walls[i].spikerecs[1].Width
						}
						if walls[i].spikerecs[2].Y < walls[i].rec.Y+walls[i].rec.Height-walls[i].spikerecs[1].Height {
							walls[i].spikerecs[2].Y = walls[i].rec.Y + walls[i].rec.Height - walls[i].spikerecs[1].Height
						}
						if walls[i].spikerecs[3].X > walls[i].rec.X {
							walls[i].spikerecs[3].X = walls[i].rec.X
						}
					} else {
						walls[i].spikerecs[0].Y-- //TOP SPIKE
						walls[i].spikerecs[1].X++ //RIGHT SPIKE
						walls[i].spikerecs[2].Y++ //DOWN SPIKE
						walls[i].spikerecs[3].X-- //LEFT SPIKE
						if walls[i].spikerecs[0].Y <= walls[i].rec.Y-walls[i].spikerecs[0].Height {
							walls[i].spikerecs[0].Y = walls[i].rec.Y - walls[i].spikerecs[0].Height
							walls[i].onoff = true
						}
						if walls[i].spikerecs[1].X > walls[i].rec.X+walls[i].rec.Width {
							walls[i].spikerecs[1].X = walls[i].rec.X + walls[i].rec.Width
						}
						if walls[i].spikerecs[2].Y > walls[i].rec.Y+walls[i].rec.Height {
							walls[i].spikerecs[2].Y = walls[i].rec.Y + walls[i].rec.Height
						}
						if walls[i].spikerecs[3].X < walls[i].rec.X-walls[i].spikerecs[3].Width {
							walls[i].spikerecs[3].X = walls[i].rec.X - walls[i].spikerecs[3].Width
						}
					}

					for j := 0; j < len(walls[i].spikerecs); j++ {
						if walls[i].onoff {
							if walls[i].spikerecs[0].Y > walls[i].rec.Y {
								walls[i].spikerecs[0].Y--
							}
							if walls[i].spikerecs[1].X < walls[i].rec.X+walls[i].rec.Width-walls[i].spikerecs[1].Width {
								walls[i].spikerecs[1].X++
							}
							if walls[i].spikerecs[2].Y < walls[i].rec.Y-walls[i].spikerecs[2].Height {
								walls[i].spikerecs[2].Y++
							}
							if walls[i].spikerecs[3].X > walls[i].rec.X {
								walls[i].spikerecs[3].X--
							}
						} else {
							if walls[i].spikerecs[0].Y < walls[i].rec.Y-walls[i].spikerecs[0].Height {
								walls[i].spikerecs[0].Y++
							}
							if walls[i].spikerecs[1].X > walls[i].rec.X+walls[i].rec.Width {
								walls[i].spikerecs[1].X--
							}
							if walls[i].spikerecs[2].Y > walls[i].rec.Y+walls[i].rec.Height {
								walls[i].spikerecs[2].Y--
							}
							if walls[i].spikerecs[3].X < walls[i].rec.X-walls[i].spikerecs[3].Width {
								walls[i].spikerecs[3].X++
							}
						}

					}

					for j := 0; j < len(walls[i].spikerecs); j++ {
						rl.DrawTexturePro(imgs, etc[0], shrec(drec(walls[i].spikerecs[j]), 7), orgn(walls[i].spikerecs[j]), float32(j)*90, shcol())
						if psychedelicsT > 0 {
							rl.DrawTexturePro(imgs, etc[0], drec(walls[i].spikerecs[j]), orgn(walls[i].spikerecs[j]), float32(j)*90, walls[i].col2)
						} else {
							rl.DrawTexturePro(imgs, etc[0], drec(walls[i].spikerecs[j]), orgn(walls[i].spikerecs[j]), float32(j)*90, rl.White)
						}

						//CHECK PL SPIKE COLLIS
						if rl.CheckCollisionRecs(pl.crec, walls[i].spikerecs[j]) && pl.enCollisT == 0 {
							if feather {
								if msgT == 0 {
									admsg("immune spikes > feather cushions", rl.White)
									msgT = fps
								}
							} else {
								pl.enCollisT = fps
								if stats.dex > 1 {
									if Roll12() <= stats.dex {
										if msgT == 0 {
											admsg("dodged > dexterity", rl.Magenta)
											msgT = fps
										}
									} else {
										if pl.hpT == 0 {
											hitPL(1)
										}
									}
								} else {
									if pl.hpT == 0 {
										hitPL(1)
									}
								}
							}
						}
					}
				}
				//BG REC
				rl.DrawRectangleRec(walls[i].rec, rl.Black)
				//IMG REC
				if psychedelicsT > 0 {
					rl.DrawTexturePro(imgs, walltile, walls[i].rec, rl.Vector2Zero(), 0, rl.Fade(walls[i].col2, walls[i].fade))
				} else {
					rl.DrawTexturePro(imgs, walltile, walls[i].rec, rl.Vector2Zero(), 0, rl.Fade(walls[i].color, walls[i].fade))
				}

				//BLUR REC
				rl.DrawTexturePro(imgs, walltile, blrec(walls[i].rec, 0.2), rl.Vector2Zero(), 0, rl.Fade(walls[i].color, 0.3))
				if debug {
					rl.DrawRectangleLinesEx(walls[i].rec, 2, rl.Green)
				}
				//MARK:MOVE BLOKS
				if tvT == 0 {
					if walls[i].dirX != 0 {
						if checkmoveblok(walls[i], i) {
							walls[i].rec.X += walls[i].dirX + delta
							for j := 0; j < len(walls[i].spikerecs); j++ {
								walls[i].spikerecs[j].X += walls[i].dirX + delta
							}
						} else {
							walls[i].dirX = walls[i].dirX * -1
						}
					}
					if walls[i].dirY != 0 {
						if checkmoveblok(walls[i], i) {
							walls[i].rec.Y += walls[i].dirY + delta
							for j := 0; j < len(walls[i].spikerecs); j++ {
								walls[i].spikerecs[j].Y += walls[i].dirY + delta
							}
						} else {
							walls[i].dirY = walls[i].dirY * -1
						}
					}
				}
			}
		}
		//MARK: DRAW FX LAYER ABOVE
		if len(fx) > 0 {
			clear := false
			for i := 0; i < len(fx); i++ {
				if !fx[i].off && !fx[i].below {
					switch fx[i].nm {
					case "redWeapEnd":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandRed(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if fx[i].img.X < anm[179].X+anm[179].frames*anm[179].W {
								fx[i].img.X += anm[179].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "greenWeapEnd":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandGreen(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if fx[i].img.X < anm[179].X+anm[179].frames*anm[179].W {
								fx[i].img.X += anm[179].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "brownWeapEnd":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandBrown(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if fx[i].img.X < anm[179].X+anm[179].frames*anm[179].W {
								fx[i].img.X += anm[179].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "blueWeapEnd":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandBlue(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if fx[i].img.X < anm[179].X+anm[179].frames*anm[179].W {
								fx[i].img.X += anm[179].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "orangeWeapEnd":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandOrange(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if fx[i].img.X < anm[179].X+anm[179].frames*anm[179].W {
								fx[i].img.X += anm[179].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "greyWeapEnd":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandGrey(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if fx[i].img.X < anm[179].X+anm[179].frames*anm[179].W {
								fx[i].img.X += anm[179].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "pinkWeapEnd":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandPink(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if fx[i].img.X < anm[179].X+anm[179].frames*anm[179].W {
								fx[i].img.X += anm[179].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "yellowWeapEnd":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandYellow(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if fx[i].img.X < anm[179].X+anm[179].frames*anm[179].W {
								fx[i].img.X += anm[179].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "ringoffire":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(drec(fx[i].rec), 20), orgn(fx[i].rec), fx[i].ro, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, drec(fx[i].rec), orgn(fx[i].rec), fx[i].ro, rl.Fade(rl.White, RandF32(0.5, 0.7)))
						rl.DrawTexturePro(imgs, fx[i].img, brec(drec(fx[i].rec), 5), orgn(fx[i].rec), fx[i].ro, rl.Fade(rl.White, RandF32(0.3, 0.5)))
						rl.DrawTexturePro(imgs, fx[i].img, brec(drec(fx[i].rec), 12), orgn(fx[i].rec), fx[i].ro, rl.Fade(rl.White, RandF32(0.1, 0.3)))
						if frames%2 == 0 {
							if fx[i].img.X < anm[202].X+anm[202].frames*anm[202].W {
								fx[i].img.X += anm[202].W
							} else {
								fx[i].img.X = anm[202].X
							}

							if fx[i].rec.Width < b10*2 {
								fx[i].rec.X -= 5
								fx[i].rec.Y -= 5
								fx[i].rec.Width += 10
								fx[i].rec.Height += 10
							} else {
								fx[i].off = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, fx[i].rec) {
								if !levels[levNum].enm[j].nodmg {
									if levels[levNum].enm[j].nm == "flamehead" || levels[levNum].enm[j].nm == "ghost" || levels[levNum].enm[j].nm == "yellowdino" || levels[levNum].enm[j].nm == "reddevil" {
										if msgT == 0 {
											admsg("immune to burn", rl.Yellow)
											msgT = fps
										}
									} else {
										if levels[levNum].enm[j].burnT <= 0 {
											levels[levNum].enm[j].burnT = fps * 3
										}
									}
								}
							}
						}

						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "icecrystal":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(drec(fx[i].rec), 20), orgn(fx[i].rec), fx[i].ro, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, drec(fx[i].rec), orgn(fx[i].rec), fx[i].ro, rl.Fade(RandBlue(), RandF32(0.1, 0.2)))
						fx[i].ro += 12
						if frames%3 == 0 {
							if fx[i].rec.Width < b10 {
								fx[i].rec.X -= 4
								fx[i].rec.Y -= 4
								fx[i].rec.Width += 8
								fx[i].rec.Height += 8
							} else {
								fx[i].off = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, fx[i].rec) {
								if !levels[levNum].enm[j].nodmg {
									if levels[levNum].enm[j].freezeT == 0 {
										levels[levNum].enm[j].freezeT = fps * 3
									}
								}
							}
						}

						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "rollodthfx":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						col := RandYellow()
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.2, 0.5)))
						rl.DrawTexturePro(imgs, fx[i].img, brec(fx[i].rec, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))

						if frames%2 == 0 {
							if fx[i].img.X < anm[197].X+anm[197].frames*anm[197].W {
								fx[i].img.X += anm[197].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "musheedthfx":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						col := RandRed()
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.5, 0.7)))
						rl.DrawTexturePro(imgs, fx[i].img, brec(fx[i].rec, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))

						if frames%2 == 0 {
							if fx[i].img.X < anm[196].X+anm[196].frames*anm[196].W {
								fx[i].img.X += anm[196].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "battydthfx":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						col := RandRed()
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.5, 0.7)))
						rl.DrawTexturePro(imgs, fx[i].img, brec(fx[i].rec, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))

						if frames%2 == 0 {
							if fx[i].img.X < anm[195].X+anm[195].frames*anm[195].W {
								fx[i].img.X += anm[195].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "zombodthfx":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						col := RandGreen()
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.5, 0.7)))
						rl.DrawTexturePro(imgs, fx[i].img, brec(fx[i].rec, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))
						if frames%2 == 0 {
							if fx[i].img.X < anm[194].X+anm[194].frames*anm[194].W {
								fx[i].img.X += anm[194].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "pyrodthfx":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						col := RandOrange()
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.5, 0.7)))
						rl.DrawTexturePro(imgs, fx[i].img, brec(fx[i].rec, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))
						if frames%2 == 0 {
							if fx[i].img.X < anm[193].X+anm[193].frames*anm[193].W {
								fx[i].img.X += anm[193].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "spzmandthfx":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						col := RandColor()
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.5, 0.7)))
						rl.DrawTexturePro(imgs, fx[i].img, brec(fx[i].rec, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))
						if frames%2 == 0 {
							if fx[i].img.X < anm[192].X+anm[192].frames*anm[192].W {
								fx[i].img.X += anm[192].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "spinnadthfx":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						col := RandColor()
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.5, 0.7)))
						rl.DrawTexturePro(imgs, fx[i].img, brec(fx[i].rec, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))
						if frames%2 == 0 {
							if fx[i].img.X < anm[191].X+anm[191].frames*anm[191].W {
								fx[i].img.X += anm[191].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "frisbeedthfx":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						col := RandYellow()
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.2, 0.5)))
						rl.DrawTexturePro(imgs, fx[i].img, brec(fx[i].rec, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))
						if frames%2 == 0 {
							if fx[i].img.X < anm[190].X+anm[190].frames*anm[190].W {
								fx[i].img.X += anm[190].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "icedthfx":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						col := RandBlue()
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.2, 0.5)))
						rl.DrawTexturePro(imgs, fx[i].img, brec(fx[i].rec, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))
						if frames%2 == 0 {
							if fx[i].img.X < anm[189].X+anm[189].frames*anm[189].W {
								fx[i].img.X += anm[189].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "potionfx":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
						if frames%3 == 0 {
							if fx[i].img.X < anm[188].X+anm[188].frames*anm[188].W {
								fx[i].img.X += anm[188].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "scrollfx":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
						if frames%3 == 0 {
							if fx[i].img.X < anm[186].X+anm[186].frames*anm[186].W {
								fx[i].img.X += anm[186].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}
					case "weaponcrate":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandOrange(), RandF32(0.4, 0.7)))
						if frames%5 == 0 {
							if fx[i].img.X < anm[181].X+anm[181].frames*anm[181].W {
								fx[i].img.X += anm[181].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
					case "switchfx":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if fx[i].img.X < anm[180].X+anm[180].frames*anm[180].W {
								fx[i].img.X += anm[180].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}

					case "fryingShock":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.2, 0.4)))
						if frames%3 == 0 {
							if fx[i].img.X < anm[178].X+anm[178].frames*anm[178].W {
								fx[i].img.X += anm[178].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Magenta)
						}

						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, fx[i].rec) {
								if !levels[levNum].enm[j].nodmg {
									if levels[levNum].enm[j].stunT == 0 {
										if levels[levNum].enm[j].stunT == 0 {
											levels[levNum].enm[j].stunT = fps * 2
											levels[levNum].enm[j].stunF = 0.9
											levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
											levels[levNum].enm[j].stunSiz = b / 4
										}
									}
								}
							}
						}
					case "landmineExplod":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.4, 0.7)))
						if frames%3 == 0 {
							if fx[i].img.X < anm[57].X+anm[57].frames*anm[57].W {
								fx[i].img.X += anm[57].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
					case "icemanchange":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 20), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.2, 0.5)))
						if frames%3 == 0 {
							if fx[i].img.X < anm[109].X+anm[109].frames*anm[109].W {
								fx[i].img.X += anm[109].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						if rl.CheckCollisionRecs(pl.rec, fx[i].rec) && pl.freezeT == 0 && saltT == 0 {
							pl.freezeT = fps * 2
						} else if saltT > 0 {
							if msgT == 0 {
								admsg("salt saves freeze", rl.Green)
								msgT = fps
							}
						}
					case "summonitem":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 5), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.4, 0.7)))
						if frames%4 == 0 {
							if fx[i].img.X < anm[108].X+anm[108].frames*anm[108].W {
								fx[i].img.X += anm[108].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
					case "bombExplode":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 12), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandOrange(), RandF32(0.4, 0.7)))
						if frames%2 == 0 {
							if fx[i].img.X < anm[106].X+anm[106].frames*anm[106].W {
								fx[i].img.X += anm[106].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, fx[i].rec) {
								if !levels[levNum].enm[j].nodmg {
									if levels[levNum].enm[j].hpT == 0 {
										levels[levNum].enm[j].hp -= 3
										if levels[levNum].enm[j].hp <= 0 && !levels[levNum].enm[j].off {
											pl.xp += levels[levNum].enm[j].xp
											makeEnDeathFx(j)
											levels[levNum].enm[j].off = true
										} else {
											levels[levNum].enm[j].hpT = fps
											levels[levNum].enm[j].hpY = bq3
											levels[levNum].enm[j].hpY2 = 0
											if bosson {
												levels[levNum].enm[j].hpY = b
												levels[levNum].enm[j].hpY2 = b / 2
											}
											if levels[levNum].enm[j].nm == "crocodile" || levels[levNum].enm[j].nm == "redantenna" {
												levels[levNum].enm[j].stunT = fps * 2
												levels[levNum].enm[j].stunF = 0.9
												levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
												levels[levNum].enm[j].stunSiz = b / 4
											}
											if levels[levNum].enm[j].nm == "flamehead" || levels[levNum].enm[j].nm == "ghost" || levels[levNum].enm[j].nm == "yellowdino" || levels[levNum].enm[j].nm == "reddevil" {
												if msgT == 0 {
													admsg("immune to burn", rl.Yellow)
													msgT = fps
												}
											} else {
												if levels[levNum].enm[j].burnT <= 0 {
													levels[levNum].enm[j].burnT = fps * 3
												}
											}
										}
									}

								}
							}
						}
					case "chickenExplode":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 12), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.2, 0.5)))
						if frames%4 == 0 {
							if fx[i].img.X < anm[104].X+anm[104].frames*anm[104].W {
								fx[i].img.X += anm[104].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, fx[i].crec) {
								if !levels[levNum].enm[j].nodmg {
									if levels[levNum].enm[j].hpT == 0 {
										levels[levNum].enm[j].hp -= 1
										if levels[levNum].enm[j].hp <= 0 && !levels[levNum].enm[j].off {
											pl.xp += levels[levNum].enm[j].xp
											makeEnDeathFx(j)
											levels[levNum].enm[j].off = true
										} else {
											levels[levNum].enm[j].hpT = fps
											levels[levNum].enm[j].hpY = bq3
											levels[levNum].enm[j].hpY2 = 0
											if bosson {
												levels[levNum].enm[j].hpY = b
												levels[levNum].enm[j].hpY2 = b / 2
											}
										}
										if levels[levNum].enm[j].nm == "crocodile" || levels[levNum].enm[j].nm == "redantenna" {
											levels[levNum].enm[j].stunT = fps * 2
											levels[levNum].enm[j].stunF = 0.9
											levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
											levels[levNum].enm[j].stunSiz = b / 4
										}
									}
									if levels[levNum].enm[j].nm == "flamehead" || levels[levNum].enm[j].nm == "ghost" || levels[levNum].enm[j].nm == "yellowdino" || levels[levNum].enm[j].nm == "reddevil" {
										if msgT == 0 {
											admsg("immune to burn", rl.Yellow)
											msgT = fps
										}
									} else {
										if levels[levNum].enm[j].burnT <= 0 {
											levels[levNum].enm[j].burnT = fps * 3
										}
									}
								}
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Yellow)
							rl.DrawRectangleLinesEx(fx[i].crec, 2, rl.Magenta)
						}
					case "shockwave":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 12), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.2, 0.5)))
						if frames%4 == 0 {
							if fx[i].img.X < anm[99].X+anm[99].frames*anm[99].W {
								fx[i].img.X += anm[99].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, fx[i].rec) {
								if !levels[levNum].enm[j].nodmg {
									if levels[levNum].enm[j].stunT == 0 {
										levels[levNum].enm[j].stunT = fps * 2
										levels[levNum].enm[j].stunF = 0.9
										levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
										levels[levNum].enm[j].stunSiz = b / 4
									}
									if levels[levNum].enm[j].hpT == 0 {
										levels[levNum].enm[j].hp -= 1
										if levels[levNum].enm[j].hp <= 0 && !levels[levNum].enm[j].off {
											pl.xp += levels[levNum].enm[j].xp
											makeEnDeathFx(j)
											levels[levNum].enm[j].off = true
										} else {
											levels[levNum].enm[j].hpT = fps
											levels[levNum].enm[j].hpY = bq3
											levels[levNum].enm[j].hpY2 = 0
											if bosson {
												levels[levNum].enm[j].hpY = b
												levels[levNum].enm[j].hpY2 = b / 2
											}
										}
										if levels[levNum].enm[j].nm == "crocodile" || levels[levNum].enm[j].nm == "redantenna" {
											levels[levNum].enm[j].stunT = fps * 2
											levels[levNum].enm[j].stunF = 0.9
											levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
											levels[levNum].enm[j].stunSiz = b / 4
										}
									}
								}
							}
						}
					case "cloaksparks":
						for j := 0; j < len(fx[i].recs2); j++ {
							rl.DrawTexturePro(imgs, fx[i].img, fx[i].recs2[j], rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, fx[i].img, fx[i].recs2[j], rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.2, 0.4)))
							if debug {
								rl.DrawRectangleLinesEx(fx[i].recs2[j], 2, rl.Yellow)
								rl.DrawRectangleLinesEx(fx[i].crecs[j], 2, rl.Magenta)
							}
							for k := 0; k < len(levels[levNum].enm); k++ {
								if rl.CheckCollisionRecs(levels[levNum].enm[k].crec, fx[i].crecs[j]) {
									if !levels[levNum].enm[k].nodmg {
										if levels[levNum].enm[k].hpT == 0 {
											levels[levNum].enm[k].hp--
											if levels[levNum].enm[k].hp <= 0 && !levels[levNum].enm[k].off {
												pl.xp += levels[levNum].enm[k].xp
												makeEnDeathFx(k)
												levels[levNum].enm[k].off = true
											} else {
												levels[levNum].enm[k].hpT = fps
												levels[levNum].enm[k].hpY = bq3
												levels[levNum].enm[k].hpY2 = 0
												if bosson {
													levels[levNum].enm[k].hpY = b
													levels[levNum].enm[k].hpY2 = b / 2
												}
											}
											if levels[levNum].enm[k].nm == "crocodile" || levels[levNum].enm[k].nm == "redantenna" {
												levels[levNum].enm[k].stunT = fps
												levels[levNum].enm[k].stunF = 0.9
												levels[levNum].enm[k].stunY = levels[levNum].enm[k].cnt.Y
												levels[levNum].enm[k].stunSiz = b / 4
											}
										}
									}
								}
							}
						}
						if frames%4 == 0 {
							fx[i].img.X += anm[96].W
							if fx[i].img.X > anm[96].X+anm[96].frames*anm[96].W {
								fx[i].img.X = anm[96].X
							}
						}
						if cloakT == 0 {
							fx[i].off = true
							clear = true
						}
					case "beetrootExplode":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 12), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandRed(), RandF32(0.4, 0.7)))
						if frames%4 == 0 {
							if fx[i].img.X < anm[95].X+anm[95].frames*anm[95].W {
								fx[i].img.X += anm[95].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, fx[i].rec) {
								if !levels[levNum].enm[j].nodmg {
									if levels[levNum].enm[j].stunT == 0 {
										levels[levNum].enm[j].stunT = fps * 2
										levels[levNum].enm[j].stunF = 0.9
										levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
										levels[levNum].enm[j].stunSiz = b / 4
									}
									if levels[levNum].enm[j].hpT == 0 {
										levels[levNum].enm[j].hp -= 3
										if levels[levNum].enm[j].hp <= 0 && !levels[levNum].enm[j].off {
											pl.xp += levels[levNum].enm[j].xp
											makeEnDeathFx(j)
											levels[levNum].enm[j].off = true
										} else {
											levels[levNum].enm[j].hpT = fps
											levels[levNum].enm[j].hpY = bq3
											levels[levNum].enm[j].hpY2 = 0
											if bosson {
												levels[levNum].enm[j].hpY = b
												levels[levNum].enm[j].hpY2 = b / 2
											}
										}
										if levels[levNum].enm[j].nm == "crocodile" || levels[levNum].enm[j].nm == "redantenna" {
											levels[levNum].enm[j].stunT = fps * 2
											levels[levNum].enm[j].stunF = 0.9
											levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
											levels[levNum].enm[j].stunSiz = b / 4
										}
									}
								}
							}
						}
						if beetrootT == 0 {
							fx[i].off = true
							clear = true
						}
					case "beetroot":
						siz := bq3
						for j := 0; j < len(fx[i].v2); j++ {
							rec := rl.NewRectangle(fx[i].v22[j].X-siz/2, fx[i].v22[j].Y-siz/2, siz, siz)
							if fx[i].v22[j].Y < fx[i].v2[j].Y {
								rl.DrawTexturePro(imgs, fx[i].img, shrec(rec, 12), rl.Vector2Zero(), 0, shcol())
								rl.DrawTexturePro(imgs, fx[i].img, rec, rl.Vector2Zero(), 0, rl.White)
								fx[i].v22[j].Y += b / 2
							} else {
								if !fx[i].onoff[j] {
									fx[i].onoff[j] = true
									zfx := xfx{}
									zfx.img = anm[95].rec
									zfx.rec = fx[i].recs2[j]
									zfx.nm = "beetrootExplode"
									fx = append(fx, zfx)
								}
							}
						}
						if beetrootT == 0 {
							fx[i].off = true
							clear = true
						}
					case "belt":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 5), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.White)
						if frames%4 == 0 {
							if fx[i].img.X < anm[94].X+anm[94].frames*anm[94].W {
								fx[i].img.X += anm[94].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, fx[i].rec) {
								if !levels[levNum].enm[j].nodmg {
									if levels[levNum].enm[j].hpT == 0 {
										levels[levNum].enm[j].hp -= 1
										if levels[levNum].enm[j].hp <= 0 && !levels[levNum].enm[j].off {
											pl.xp += levels[levNum].enm[j].xp
											makeEnDeathFx(j)
											levels[levNum].enm[j].off = true
										} else {
											levels[levNum].enm[j].hpT = fps
											levels[levNum].enm[j].hpY = bq3
											levels[levNum].enm[j].hpY2 = 0
											if bosson {
												levels[levNum].enm[j].hpY = b
												levels[levNum].enm[j].hpY2 = b / 2
											}
										}
										if levels[levNum].enm[j].nm == "crocodile" || levels[levNum].enm[j].nm == "redantenna" {
											levels[levNum].enm[j].stunT = fps * 2
											levels[levNum].enm[j].stunF = 0.9
											levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
											levels[levNum].enm[j].stunSiz = b / 4
										}
										if levels[levNum].enm[j].nm == "flamehead" || levels[levNum].enm[j].nm == "skeleton" || levels[levNum].enm[j].nm == "ghost" || levels[levNum].enm[j].nm == "robot" {
											if msgT == 0 {
												admsg("immune to bleed", rl.Yellow)
												msgT = fps
											}
										} else {
											levels[levNum].enm[j].bleed++
											levels[levNum].enm[j].bleedT = fps * 2
										}
									}
								}
							}
						}
					case "frisbee":
						rl.DrawTexturePro(imgs, fx[i].img, drec(shrec(fx[i].rec, 18)), orgn(fx[i].rec), fx[i].ro, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, drec(fx[i].rec), orgn(fx[i].rec), fx[i].ro, rl.Fade(RandColor(), RandF32(0.7, 0.9)))
						if frames%4 == 0 {
							fx[i].img.X += anm[93].W
							if fx[i].img.X > anm[93].X+anm[93].frames*anm[93].W {
								fx[i].img.X = anm[93].X
							}
						}
						fx[i].ro += 8
						if frisbeeT == 0 {
							fx[i].off = true
							clear = true
						}
						checkV2 := fx[i].cnt
						checkV2.X += fx[i].dirX
						checkV2.Y += fx[i].dirY
						if checkV2Walls(checkV2) {
							fx[i].cnt = checkV2
							fx[i].rec = rl.NewRectangle(fx[i].cnt.X-fx[i].rec.Width/2, fx[i].cnt.Y-fx[i].rec.Height/2, fx[i].rec.Width, fx[i].rec.Height)
							fx[i].crec = fx[i].rec
							fx[i].crec.X += fx[i].crec.Width / 8
							fx[i].crec.Y += fx[i].crec.Width / 8
							fx[i].crec.Width -= fx[i].crec.Width / 4
							fx[i].crec.Height -= fx[i].crec.Width / 4
						} else {
							countbreak := 100
							for {
								fx[i].dirX = RandF32(-fx[i].spd, fx[i].spd)
								fx[i].dirY = RandF32(-fx[i].spd, fx[i].spd)
								if Abs(fx[i].dirX) > 2 || Abs(fx[i].dirY) > 2 {
									break
								}
								countbreak--
								if countbreak == 0 {
									break
								}
							}
						}
						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, fx[i].crec) {
								if !levels[levNum].enm[j].nodmg {
									if levels[levNum].enm[j].hpT == 0 {
										levels[levNum].enm[j].hp -= 1
										if levels[levNum].enm[j].hp <= 0 && !levels[levNum].enm[j].off {
											pl.xp += levels[levNum].enm[j].xp
											makeEnDeathFx(j)
											levels[levNum].enm[j].off = true
										} else {
											levels[levNum].enm[j].hpT = fps
											levels[levNum].enm[j].hpY = bq3
											levels[levNum].enm[j].hpY2 = 0
											if bosson {
												levels[levNum].enm[j].hpY = b
												levels[levNum].enm[j].hpY2 = b / 2
											}
										}
										if levels[levNum].enm[j].nm == "crocodile" || levels[levNum].enm[j].nm == "redantenna" {
											levels[levNum].enm[j].stunT = fps * 2
											levels[levNum].enm[j].stunF = 0.9
											levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
											levels[levNum].enm[j].stunSiz = b / 4
										}
									}
									if levels[levNum].enm[j].stunT == 0 {
										levels[levNum].enm[j].stunT = fps * 2
										levels[levNum].enm[j].stunF = 0.9
										levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
										levels[levNum].enm[j].stunSiz = b / 4
									}
								}
							}
						}
					case "purplerain":
						for j := 0; j < len(fx[i].recs2); j++ {
							rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].recs2[j], 5), rl.Vector2Zero(), 0, shcol())
							rl.DrawTexturePro(imgs, fx[i].img, fx[i].recs2[j], rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.5, 0.7)))
							if debug {
								rl.DrawRectangleLinesEx(fx[i].recs2[j], 2, rl.Magenta)
							}
							for k := 0; k < len(levels[levNum].enm); k++ {
								if rl.CheckCollisionRecs(levels[levNum].enm[k].crec, fx[i].recs2[j]) {
									if !levels[levNum].enm[k].nodmg {
										if levels[levNum].enm[k].hpT == 0 {
											levels[levNum].enm[k].hp -= 1
											if levels[levNum].enm[k].hp <= 0 && !levels[levNum].enm[k].off {
												pl.xp += levels[levNum].enm[k].xp
												makeEnDeathFx(j)
												levels[levNum].enm[k].off = true
											} else {
												levels[levNum].enm[k].hpT = fps
												levels[levNum].enm[k].hpY = bq3
												levels[levNum].enm[k].hpY2 = 0
												if bosson {
													levels[levNum].enm[k].hpY = b
													levels[levNum].enm[k].hpY2 = b / 2
												}
											}
											if levels[levNum].enm[k].nm == "crocodile" || levels[levNum].enm[k].nm == "redantenna" {
												levels[levNum].enm[k].stunT = fps
												levels[levNum].enm[k].stunF = 0.9
												levels[levNum].enm[k].stunY = levels[levNum].enm[k].cnt.Y
												levels[levNum].enm[k].stunSiz = b / 4
											}
										}
									}
								}
							}
						}
						if frames%3 == 0 {
							fx[i].img.X += anm[92].W
							if fx[i].img.X > anm[92].X+anm[92].frames*anm[92].W {
								fx[i].img.X = anm[92].X
							}
						}
						if purplerainT == 0 {
							fx[i].off = true
							clear = true
						}
					case "tesla":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 18), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.1, 0.3)))
						if frames%4 == 0 {
							fx[i].img.X += anm[91].W
							if fx[i].img.X > anm[91].X+anm[91].frames*anm[91].W {
								fx[i].img.X = anm[91].X
							}
						}
						if teslaT == 0 {
							fx[i].off = true
							clear = true
						}
						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, fx[i].rec) {
								if !levels[levNum].enm[j].nodmg {
									if levels[levNum].enm[j].stunT == 0 {
										levels[levNum].enm[j].stunT = fps * 2
										levels[levNum].enm[j].stunF = 0.9
										levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
										levels[levNum].enm[j].stunSiz = b / 4
									}
									if levels[levNum].enm[j].hpT == 0 {
										levels[levNum].enm[j].hp -= 1
										if levels[levNum].enm[j].hp <= 0 && !levels[levNum].enm[j].off {
											pl.xp += levels[levNum].enm[j].xp
											makeEnDeathFx(j)
											levels[levNum].enm[j].off = true
										} else {
											levels[levNum].enm[j].hpT = fps
											levels[levNum].enm[j].hpY = bq3
											levels[levNum].enm[j].hpY2 = 0
											if bosson {
												levels[levNum].enm[j].hpY = b
												levels[levNum].enm[j].hpY2 = b / 2
											}
										}
										if levels[levNum].enm[j].nm == "crocodile" || levels[levNum].enm[j].nm == "redantenna" {
											levels[levNum].enm[j].stunT = fps * 2
											levels[levNum].enm[j].stunF = 0.9
											levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
											levels[levNum].enm[j].stunSiz = b / 4
										}
									}
								}
							}
						}
					case "tornado":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 18), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.2, 0.4)))
						if frames%4 == 0 {
							fx[i].img.X += anm[90].W
							if fx[i].img.X > anm[90].X+anm[90].frames*anm[90].W {
								fx[i].img.X = anm[90].X
							}
						}
						if quailT == 0 {
							fx[i].off = true
							clear = true
						}
						checkV2 := fx[i].cnt
						checkV2.X += fx[i].dirX
						checkV2.Y += fx[i].dirY
						if checkV2Walls(checkV2) {
							fx[i].cnt = checkV2
							fx[i].rec = rl.NewRectangle(fx[i].cnt.X-fx[i].rec.Width/2, fx[i].cnt.Y-fx[i].rec.Height/2, fx[i].rec.Width, fx[i].rec.Height)
							fx[i].crec = fx[i].rec
							fx[i].crec.X += fx[i].crec.Width / 4
							fx[i].crec.Width = fx[i].crec.Width - fx[i].crec.Width/2
						} else {
							countbreak := 100
							for {
								fx[i].dirX = RandF32(-fx[i].spd, fx[i].spd)
								fx[i].dirY = RandF32(-fx[i].spd, fx[i].spd)
								if Abs(fx[i].dirX) > 1 || Abs(fx[i].dirY) > 1 {
									break
								}
								countbreak--
								if countbreak == 0 {
									break
								}
							}
						}
						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, fx[i].crec) {
								if !levels[levNum].enm[j].nodmg {
									if levels[levNum].enm[j].stunT == 0 {
										levels[levNum].enm[j].stunT = fps * 2
										levels[levNum].enm[j].stunF = 0.9
										levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
										levels[levNum].enm[j].stunSiz = b / 4
									}
								}
							}
						}
					case "thorns":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 12), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(RandRed(), 0.4))
						if frames%4 == 0 {
							if fx[i].img.X < anm[89].X+anm[89].frames*anm[89].W {
								fx[i].img.X += anm[89].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
					case "beartrap":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 12), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.4))
						if frames%6 == 0 {
							if fx[i].img.X < anm[87].X+anm[87].frames*anm[87].W {
								fx[i].img.X += anm[87].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
					case "gascanExplode":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 5), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.7))
						if frames%4 == 0 {
							if fx[i].img.X < anm[57].X+anm[57].frames*anm[57].W {
								fx[i].img.X += anm[57].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enm); j++ {
							if rl.CheckCollisionRecs(fx[i].rec, levels[levNum].enm[j].crec) {
								if levels[levNum].enm[j].nm == "flamehead" || levels[levNum].enm[j].nm == "ghost" || levels[levNum].enm[j].nm == "yellowdino" || levels[levNum].enm[j].nm == "reddevil" {
									if msgT == 0 {
										admsg("immune to burn", rl.Yellow)
										msgT = fps
									}
								} else {
									if levels[levNum].enm[j].burnT <= 0 {
										levels[levNum].enm[j].burnT = fps * 3
									}
								}
							}
						}
					case "frogexit":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 5), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.7))
						if frames%4 == 0 {
							if fx[i].img.X < anm[82].X+anm[82].frames*anm[82].W {
								fx[i].img.X += anm[82].W
							} else {
								fx[i].off = true
								clear = true
							}
						}
					case "balloonexplode":
						rl.DrawTexturePro(imgs, fx[i].img, shrec(fx[i].rec, 5), rl.Vector2Zero(), 0, shcol())
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.5))
						if frames%4 == 0 {
							fx[i].img.X += anm[57].W
							if fx[i].img.X > anm[57].X+anm[57].frames*anm[57].W {
								fx[i].img.X = anm[57].X
							}
						}
						if fx[i].T > 0 {
							fx[i].T--
						} else {
							fx[i].off = true
							clear = true
						}
						if rl.CheckCollisionRecs(pl.crec, fx[i].rec) && pl.hpT == 0 {
							pl.hpT = fps
							hitPL(2)
							if pl.burnT == 0 && pl.dampT == 0 && icelollyT == 0 && pl.resFireT == 0 {
								if ovenglovenum > 0 {
									if Roll6() <= ovenglovenum {
										admsg("oven glove saves burn", rl.Green)
									} else {
										admsg("burning...", rl.Orange)
										pl.burnT += fps * 3
									}
								} else {
									admsg("burning...", rl.Orange)
									pl.burnT += fps * 3
								}
							} else if pl.burnT == 0 && pl.dampT != 0 && icelollyT == 0 && pl.resFireT == 0 {
								admsg("damp saves burn", rl.Green)
							} else if pl.burnT == 0 && pl.dampT == 0 && icelollyT != 0 && pl.resFireT == 0 {
								admsg("ice lolly saves burn", rl.Green)
							} else if pl.burnT == 0 && pl.dampT == 0 && icelollyT == 0 && pl.resFireT != 0 {
								admsg("resist fire saves burn", rl.Green)
							}
						}
					case "enm":
						for j := 0; j < len(fx[i].circs); j++ {
							rl.DrawCircleV(fx[i].circs[j].cnt, fx[i].circs[j].rad, rl.Fade(fx[i].circs[j].col, fx[i].circs[j].fd))
							fx[i].circs[j].fd -= 0.03
							fx[i].circs[j].cnt.X += fx[i].circs[j].dirX
							fx[i].circs[j].cnt.Y += fx[i].circs[j].dirY
						}
						if fx[i].T > 0 {
							fx[i].T--
						} else {
							fx[i].off = true
							clear = true
						}
					case "desCrate":
						for j := 0; j < len(fx[i].recs); j++ {
							rl.DrawRectangleRec(fx[i].recs[j].rec, rl.Fade(fx[i].recs[j].col, fx[i].recs[j].fd))
							fx[i].recs[j].fd -= 0.03
							fx[i].recs[j].rec.X += fx[i].recs[j].dirX
							fx[i].recs[j].rec.Y += fx[i].recs[j].dirY
						}
						if fx[i].T > 0 {
							fx[i].T--
						} else {
							fx[i].off = true
							clear = true
						}
					case "plblood":
						rl.DrawTexturePro(imgs, fx[i].img, fx[i].rec, rl.Vector2Zero(), 0, rl.Fade(fx[i].col, fx[i].fade))
						if fx[i].fade > 0 {
							fx[i].fade -= 0.02
						} else {
							fx[i].off = true
							clear = true
						}
					}
					if debug {
						rl.DrawRectangleLinesEx(fx[i].rec, 2, rl.Yellow)
						rl.DrawRectangleLinesEx(fx[i].crec, 2, rl.Magenta)
						txtx := fx[i].rec.ToInt32().X + 2
						txty := fx[i].rec.ToInt32().Y + 2
						rl.DrawText(fmt.Sprint(fx[i].nm), txtx, txty, tx, rl.White)
					}
				}
			}
			if clear {
				Remove(1)
			}
		}
		if debug && !bosson {
			//DEBUG ROOM RECS
			for i := 0; i < len(lev); i++ {
				rl.DrawRectangleRec(lev[i], rl.Fade(rl.Green, 0.1))
				rl.DrawRectangleLinesEx(lev[i], 4, rl.Fade(rl.Green, 0.5))
				x := int32(lev[i].X) + 8
				y := int32(lev[i].Y) + 8
				rl.DrawText("num "+fmt.Sprint(inf[i].num), x, y, tx2, rl.Black)
				y += tx2
				rl.DrawText("conec "+fmt.Sprint(dbg[i].conecRoom), x, y, tx2, rl.Black)
				y += tx2
				rl.DrawText("side "+fmt.Sprint(dbg[i].side), x, y, tx2, rl.Black)
				rl.DrawCircleV(inf[i].cnt, 4, rl.Red)
			}
			//DEBUG DOOR RECS
			for i := 0; i < len(doors); i++ {
				rl.DrawRectangleLinesEx(doors[i], 4, rl.Fade(rl.Red, 0.5))
				x := int32(doors[i].X) + 8
				y := int32(doors[i].Y) + 8
				rl.DrawText(fmt.Sprint(levels[levNum].doornums[i]), x-2, y+2, tx2, rl.Black)
				rl.DrawText(fmt.Sprint(levels[levNum].doornums[i]), x, y, tx2, rl.White)
			}
			//MARK: DEBUG INNER REC DRAW REC
			rl.DrawRectangleLinesEx(screenBordRec, 2, rl.Orange)
			rl.DrawRectangleLinesEx(inRec, 2, rl.White)
			rl.DrawRectangleLinesEx(drawRec, 2, rl.Magenta)
		}

		//MARK: DRAW BOSS
		if bosson && len(levels[levNum].enm) > 0 {
			if !levels[levNum].enm[0].off {
				switch bossnum {
				case 9: //ROLLO
					rec2 := boss.rec
					rec2.X += (boss.dirX * 2) * -1
					rec2.Y += (boss.dirY * 2) * -1
					rec2.X += rec2.Width / 16
					rec2.Y += rec2.Height / 16
					rec2.Width -= rec2.Width / 8
					rec2.Height -= rec2.Height / 8
					rl.DrawTexturePro(imgs, boss.img, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.2))
					rec2.X += (boss.dirX * 2) * -1
					rec2.Y += (boss.dirY * 2) * -1
					rec2.X += rec2.Width / 16
					rec2.Y += rec2.Height / 16
					rec2.Width -= rec2.Width / 8
					rec2.Height -= rec2.Height / 8
					rl.DrawTexturePro(imgs, boss.img, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.15))
					rec2.X += (boss.dirX * 2) * -1
					rec2.Y += (boss.dirY * 2) * -1
					rec2.X += rec2.Width / 16
					rec2.Y += rec2.Height / 16
					rec2.Width -= rec2.Width / 8
					rec2.Height -= rec2.Height / 8
					rl.DrawTexturePro(imgs, boss.img, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.1))
					rec2.X += (boss.dirX * 2) * -1
					rec2.Y += (boss.dirY * 2) * -1
					rec2.X += rec2.Width / 16
					rec2.Y += rec2.Height / 16
					rec2.Width -= rec2.Width / 8
					rec2.Height -= rec2.Height / 8
					rl.DrawTexturePro(imgs, boss.img, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.05))
					if boss.hpT == 0 {
						rl.DrawTexturePro(imgs, boss.img, boss.rec, rl.Vector2Zero(), 0, rl.White)
					} else {
						rl.DrawTexturePro(imgs, boss.img, boss.rec, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
					}
				case 5, 7: //PYRO PIG BATTY
					rl.DrawTexturePro(imgs, boss.img, shrec(boss.rec, 17), rl.Vector2Zero(), 0, shcol())
					if boss.hpT == 0 {
						rl.DrawTexturePro(imgs, boss.img, boss.rec, rl.Vector2Zero(), 0, rl.White)
					} else {
						rl.DrawTexturePro(imgs, boss.img, boss.rec, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
					}
				case 2, 3, 4, 6, 8: //MR FRISBEE SPINNA SPACEMAN ZOMBO MUSHEE
					rl.DrawTexturePro(imgs, boss.img, shrec(boss.rec, 7), rl.Vector2Zero(), 0, shcol())
					if boss.hpT == 0 {
						rl.DrawTexturePro(imgs, boss.img, boss.rec, rl.Vector2Zero(), 0, rl.White)
					} else {
						rl.DrawTexturePro(imgs, boss.img, boss.rec, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
					}
				case 1: //ICEMAN
					switch boss.state {
					case 3: //WALK L
						rl.DrawTexturePro(bossWALKL, boss.img, shrec(boss.rec, 7), rl.Vector2Zero(), 0, shcol())
						if boss.hpT == 0 {
							rl.DrawTexturePro(bossWALKL, boss.img, boss.rec, rl.Vector2Zero(), 0, rl.White)
						} else {
							rl.DrawTexturePro(bossWALKL, boss.img, boss.rec, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
						}
					case 2: //WALK R
						rl.DrawTexturePro(bossWALKR, boss.img, shrec(boss.rec, 7), rl.Vector2Zero(), 0, shcol())
						if boss.hpT == 0 {
							rl.DrawTexturePro(bossWALKR, boss.img, boss.rec, rl.Vector2Zero(), 0, rl.White)
						} else {
							rl.DrawTexturePro(bossWALKR, boss.img, boss.rec, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
						}
					case 1: //ATK
						rl.DrawTexturePro(bossATK, boss.img, shrec(boss.rec, 7), rl.Vector2Zero(), 0, shcol())
						if boss.hpT == 0 {
							rl.DrawTexturePro(bossATK, boss.img, boss.rec, rl.Vector2Zero(), 0, rl.White)
						} else {
							rl.DrawTexturePro(bossATK, boss.img, boss.rec, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
						}
					case 0: //IDLE
						rl.DrawTexturePro(bossIDL, boss.img, shrec(boss.rec, 7), rl.Vector2Zero(), 0, shcol())
						if boss.hpT == 0 {
							rl.DrawTexturePro(bossIDL, boss.img, boss.rec, rl.Vector2Zero(), 0, rl.White)
						} else {
							rl.DrawTexturePro(bossIDL, boss.img, boss.rec, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
						}
					}
				}
				if debug {
					rl.DrawRectangleLinesEx(boss.rec, 2, rl.Yellow)
					rl.DrawRectangleLinesEx(boss.crec, 2, rl.Magenta)
					rl.DrawRectangleLinesEx(boss.carec, 2, rl.Red)
					rl.DrawCircleV(boss.cnt, 4, rl.Red)
				}
			}
		}

		//MARK:DRAW PLAYER
		if !pl.gameover {
			//SPINNA
			if spinnaT2 > 0 {
				spinnaT2--
				siz := b5
				rec := rl.NewRectangle(pl.cnt.X-siz/2, pl.cnt.Y-siz/2, siz, siz)
				rl.DrawTexturePro(imgs, pl.bosseffectrec, shrec(rec, 12), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, pl.bosseffectrec, rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.2, 0.4)))
				rl.DrawTexturePro(imgs, pl.bosseffectrec, brec(rec, 12), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.05, 0.1)))
				rl.DrawTexturePro(imgs, pl.bosseffectrec, brec(rec, 24), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.05, 0.1)))
				if frames%3 == 0 {
					pl.bosseffectrec.X += anm[123].W
					if pl.bosseffectrec.X > anm[123].X+anm[123].frames*anm[123].W {
						pl.bosseffectrec.X = anm[123].X
					}
				}
				if spinnaT2 == 1 {
					spinnaT = fps * 7
				}

				rec2 := rec
				rec2.Y += rec2.Height / 4
				rec2.Height = rec2.Height / 2
				if debug {
					rl.DrawRectangleLinesEx(rec2, 2, rl.Yellow)
				}

				for j := 0; j < len(levels[levNum].enm); j++ {
					if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, rec2) {
						if !levels[levNum].enm[j].nodmg {
							if levels[levNum].enm[j].hpT == 0 {
								levels[levNum].enm[j].hp -= 2
								if levels[levNum].enm[j].hp <= 0 && !levels[levNum].enm[j].off {
									pl.xp += levels[levNum].enm[j].xp
									makeEnDeathFx(j)
									levels[levNum].enm[j].off = true
								} else {
									levels[levNum].enm[j].hpT = fps
									levels[levNum].enm[j].hpY = bq3
									levels[levNum].enm[j].hpY2 = 0
									if bosson {
										levels[levNum].enm[j].hpY = b
										levels[levNum].enm[j].hpY2 = b / 2
									}
									if levels[levNum].enm[j].nm == "crocodile" || levels[levNum].enm[j].nm == "redantenna" {
										levels[levNum].enm[j].stunT = fps * 2
										levels[levNum].enm[j].stunF = 0.9
										levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
										levels[levNum].enm[j].stunSiz = b / 4
									}
								}
							}

						}
					}
				}
			}

			//NINJA STAR
			if ninjanum > 0 {
				radians := pl.angl3 * math.Pi / 180.0
				newX := pl.cnt.X + b3*float32(math.Cos(float64(radians)))
				newY := pl.cnt.Y + b3*float32(math.Sin(float64(radians)))
				pl.angl3 += 4
				pl.v3 = rl.NewVector2(newX, newY)
				siz := b / 2
				rec2 := rl.NewRectangle(pl.v3.X-siz/2, pl.v3.Y-siz/2, siz, siz)
				rl.DrawTexturePro(imgs, etc[115], shrec(rec2, 12), orgn(rec2), pl.ro, shcol())
				rl.DrawTexturePro(imgs, etc[115], drec(rec2), orgn(rec2), pl.ro, rl.White)
				pl.ro += 20
				rec3 := rl.Rectangle{}
				if ninjanum == 2 {
					radians := pl.angl4 * math.Pi / 180.0
					newX := pl.cnt.X + b3*float32(math.Cos(float64(radians)))
					newY := pl.cnt.Y + b3*float32(math.Sin(float64(radians)))
					pl.angl4 -= 4
					pl.v4 = rl.NewVector2(newX, newY)
					siz := b / 2
					rec3 = rl.NewRectangle(pl.v4.X-siz/2, pl.v4.Y-siz/2, siz, siz)
					rl.DrawTexturePro(imgs, etc[115], shrec(rec3, 12), orgn(rec2), pl.ro, shcol())
					rl.DrawTexturePro(imgs, etc[115], drec(rec3), orgn(rec2), pl.ro, rl.White)
				}
				for j := 0; j < len(levels[levNum].enm); j++ {
					if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, rec2) && !levels[levNum].enm[j].nodmg && levels[levNum].enm[j].hpT == 0 {
						if levels[levNum].enm[j].hpT == 0 {
							levels[levNum].enm[j].hp -= 1
							if levels[levNum].enm[j].hp <= 0 && !levels[levNum].enm[j].off {
								pl.xp += levels[levNum].enm[j].xp
								makeEnDeathFx(j)
								levels[levNum].enm[j].off = true
							} else {
								levels[levNum].enm[j].hpT = fps
								levels[levNum].enm[j].hpY = bq3
								levels[levNum].enm[j].hpY2 = 0
								if bosson {
									levels[levNum].enm[j].hpY = b
									levels[levNum].enm[j].hpY2 = b / 2
								}
							}
							if levels[levNum].enm[j].nm == "crocodile" || levels[levNum].enm[j].nm == "redantenna" {
								levels[levNum].enm[j].stunT = fps * 2
								levels[levNum].enm[j].stunF = 0.9
								levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
								levels[levNum].enm[j].stunSiz = b / 4
							}
						}
					}
					if ninjanum == 2 {
						if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, rec3) && !levels[levNum].enm[j].nodmg && levels[levNum].enm[j].hpT == 0 {
							levels[levNum].enm[j].hp -= 1
							if levels[levNum].enm[j].hp <= 0 && !levels[levNum].enm[j].off {
								pl.xp += levels[levNum].enm[j].xp
								makeEnDeathFx(j)
								levels[levNum].enm[j].off = true
							} else {
								levels[levNum].enm[j].hpT = fps
								levels[levNum].enm[j].hpY = bq3
								levels[levNum].enm[j].hpY2 = 0
								if bosson {
									levels[levNum].enm[j].hpY = b
									levels[levNum].enm[j].hpY2 = b / 2
								}
							}
							if levels[levNum].enm[j].nm == "crocodile" || levels[levNum].enm[j].nm == "redantenna" {
								levels[levNum].enm[j].stunT = fps * 2
								levels[levNum].enm[j].stunF = 0.9
								levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
								levels[levNum].enm[j].stunSiz = b / 4
							}
						}
					}
				}
			}
			//TEA
			if teanum > 0 {
				radians := pl.angl * math.Pi / 180.0
				newX := pl.cnt.X + b2*float32(math.Cos(float64(radians)))
				newY := pl.cnt.Y + b2*float32(math.Sin(float64(radians)))
				pl.angl += 5
				pl.v1 = rl.NewVector2(newX, newY)
				siz := b / 2
				rec2 := rl.NewRectangle(pl.v1.X-siz/2, pl.v1.Y-siz/2, siz, siz)
				rl.DrawTexturePro(imgs, etc[129], shrec(rec2, 12), orgn(rec2), pl.ro, shcol())
				rl.DrawTexturePro(imgs, etc[129], drec(rec2), orgn(rec2), pl.ro, rl.White)
				pl.ro += 10
				rec3 := rl.Rectangle{}
				if teanum == 2 {
					radians := pl.angl2 * math.Pi / 180.0
					newX := pl.cnt.X + b4*float32(math.Cos(float64(radians)))
					newY := pl.cnt.Y + b4*float32(math.Sin(float64(radians)))
					pl.angl2 -= 5
					pl.v2 = rl.NewVector2(newX, newY)
					siz := b / 2
					rec3 = rl.NewRectangle(pl.v2.X-siz/2, pl.v2.Y-siz/2, siz, siz)
					rl.DrawTexturePro(imgs, etc[129], shrec(rec3, 12), orgn(rec3), pl.ro, shcol())
					rl.DrawTexturePro(imgs, etc[129], drec(rec3), orgn(rec3), pl.ro, rl.White)
				}
				for j := 0; j < len(levels[levNum].enm); j++ {
					if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, rec2) {
						if !levels[levNum].enm[j].nodmg {
							if levels[levNum].enm[j].stunT == 0 {
								levels[levNum].enm[j].stunT = fps * 2
								levels[levNum].enm[j].stunF = 0.9
								levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
								levels[levNum].enm[j].stunSiz = b / 4
							}
						}
					}
					if teanum == 2 {
						if rl.CheckCollisionRecs(levels[levNum].enm[j].crec, rec3) {
							if !levels[levNum].enm[j].nodmg {
								if levels[levNum].enm[j].stunT == 0 {
									levels[levNum].enm[j].stunT = fps * 2
									levels[levNum].enm[j].stunF = 0.9
									levels[levNum].enm[j].stunY = levels[levNum].enm[j].cnt.Y
									levels[levNum].enm[j].stunSiz = b / 4
								}
							}
						}
					}
				}
			}
			if reviveT > 0 {
				rec2 := pl.rec
				rec2.X -= b2
				rec2.Y -= b2
				rec2.Width += b4
				rec2.Height += b4
				rl.DrawTexturePro(imgs, anm[85].rec, rec2, rl.Vector2Zero(), 0, rl.Fade(RandColor(), 0.7))
				if frames%6 == 0 {
					anm[85].rec.X += anm[85].W
					if anm[85].rec.X > anm[85].X+anm[85].frames*anm[85].W {
						anm[85].rec.X = anm[85].X
					}
				}
			} else if teleportT > 0 {
				rec2 := pl.rec
				rec2.X -= b
				rec2.Y -= b
				rec2.Width += b2
				rec2.Height += b2
				rl.DrawTexturePro(imgs, anm[83].rec, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.7))
				if frames%6 == 0 {
					anm[83].rec.X += anm[83].W
					if anm[83].rec.X > anm[83].X+anm[83].frames*anm[83].W {
						anm[83].rec.X = anm[83].X
					}
				}
			} else {
				//VINE
				if vineon {
					siz := b / 2
					x := pl.cnt.X - (siz/8)*5
					y := pl.crec.Y - siz
					for y > 0 {
						rec := rl.NewRectangle(x, y, siz, siz)
						rl.DrawTexturePro(imgs, etc[128], rec, rl.Vector2Zero(), 0, rl.White)
						y -= siz
					}
				}
				rec2 := pl.rec //INCREASE SIZE OF PLAYER DRAW IMAGE
				rec2.X -= b / 8
				rec2.Y -= b / 5
				rec2.Width += b / 4
				rec2.Height += b / 4
				//INFLICT
				if inflictT > 0 {
					rec3 := rec2
					rec3.X -= b
					rec3.Y -= b + be5
					rec3.Width += b2
					rec3.Height += b2
					rl.DrawTexturePro(imgs, anm[84].rec, shrec(rec3, 5), rl.Vector2Zero(), 0, shcol())
					rl.DrawTexturePro(imgs, anm[84].rec, rec3, rl.Vector2Zero(), 0, rl.Fade(RandRed(), 0.7))
					if frames%6 == 0 {
						anm[84].rec.X += anm[84].W
						if anm[84].rec.X > anm[84].X+anm[84].frames*anm[84].W {
							anm[84].rec.X = anm[84].X
						}
					}
				}
				//TURTLE
				if turtleT > 0 {
					rec3 := rec2
					rec3.X -= b / 2
					rec3.Y -= b / 2
					rec3.Width += b
					rec3.Height += b
					rl.DrawTexturePro(imgs, anm[75].rec, shrec(rec3, 5), rl.Vector2Zero(), 0, shcol())
					rl.DrawTexturePro(imgs, anm[75].rec, rec3, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.4))
					if frames%6 == 0 {
						anm[75].rec.X += anm[75].W
						if anm[75].rec.X > anm[75].X+anm[75].frames*anm[75].W {
							anm[75].rec.X = anm[75].X
						}
					}
				}
				//ARMOR SHIELD
				if pl.armorT > 0 {
					rec3 := rec2
					rec3.X -= b / 2
					rec3.Y -= b / 2
					rec3.Width += b
					rec3.Height += b
					rl.DrawTexturePro(imgs, anm[77].rec, shrec(rec3, 5), rl.Vector2Zero(), 0, shcol())
					rl.DrawTexturePro(imgs, anm[77].rec, rec3, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.4))
					if frames%6 == 0 {
						anm[77].rec.X += anm[77].W
						if anm[77].rec.X > anm[77].X+anm[77].frames*anm[77].W {
							anm[77].rec.X = anm[77].X
						}
					}
				}
				//SHADOW
				rl.DrawTexturePro(imgs, pl.anim[pl.aninum].rec, shrec(rec2, 3), rl.Vector2Zero(), 0, shcol())
				//BURN SMOKE
				if pl.burnT > 0 {
					rec3 := rec2
					rec3.Width = rec3.Width / 2
					rec3.Height = rec3.Height / 2
					rec3.Y = rec2.Y - rec3.Height
					rec3.Y += 7
					rec3.X = pl.cnt.X - rec3.Width/2
					if pl.direc {
						rec3.X += 1
					} else {
						rec3.X -= 1
					}
					rl.DrawTexturePro(imgs, anm[3].rec, rec3, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.2))
					if frames%5 == 0 {
						anm[3].rec.X += anm[3].W
						if anm[3].rec.X > anm[3].X+anm[3].frames*anm[3].W {
							anm[3].rec.X = anm[3].X
						}
					}
				}
				//POISON BUBBLES
				if pl.poisonT > 0 {
					rec3 := rec2
					rec3.Width = rec3.Width / 2
					rec3.Height = rec3.Height / 2
					rec3.Y = rec2.Y - rec3.Height
					rec3.Y += 2
					rec3.X = pl.cnt.X - rec3.Width/2
					if pl.direc {
						rec3.X += 1
					} else {
						rec3.X -= 1
					}
					rl.DrawTexturePro(imgs, anm[174].rec, rec3, rl.Vector2Zero(), 0, rl.Fade(RandGreen(), 0.5))
					if frames%3 == 0 {
						anm[174].rec.X += anm[174].W
						if anm[174].rec.X > anm[174].X+anm[174].frames*anm[173].W {
							anm[174].rec.X = anm[174].X
						}
					}
				}
				//IMG
				//MIRROR
				if mirror {
					planimnum2 := pl.aninum
					switch planimnum2 {
					case 0:
						planimnum2 = 1
					case 2:
						planimnum2 = 3
					case 7:
						planimnum2 = 8
					case 1:
						planimnum2 = 0
					case 3:
						planimnum2 = 2
					case 8:
						planimnum2 = 7
					case 5:
						planimnum2 = 6
					case 6:
						planimnum2 = 5
					}
					rec4 := rec2
					if pl.direc {
						rec4.X += rec4.Width / 2
					} else {
						rec4.X -= rec4.Width / 2
					}
					rl.DrawTexturePro(imgs, pl.anim[planimnum2].rec, rec4, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.2))
				}
				if pl.burnT > 0 {
					rl.DrawTexturePro(imgs, pl.anim[pl.aninum].rec, rec2, rl.Vector2Zero(), 0, RandOrange())
				} else if pl.poisonT > 0 {
					rl.DrawTexturePro(imgs, pl.anim[pl.aninum].rec, rec2, rl.Vector2Zero(), 0, rl.Lime)
				} else if pl.hpT > 0 {
					rl.DrawTexturePro(imgs, pl.anim[pl.aninum].rec, rec2, rl.Vector2Zero(), 0, RandColor())
				} else if pl.dampT > 0 {
					rl.DrawTexturePro(imgs, pl.anim[pl.aninum].rec, rec2, rl.Vector2Zero(), 0, RandCyan())
				} else if pl.invisT > 0 {
					rl.DrawTexturePro(imgs, pl.anim[pl.aninum].rec, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.2, 0.4)))
				} else {
					rl.DrawTexturePro(imgs, pl.anim[pl.aninum].rec, rec2, rl.Vector2Zero(), 0, rl.White)
				}
				//ICE CUBE
				if pl.freezeT > 0 {
					rec3 := rec2
					rec3.X -= b / 2
					rec3.Y -= b / 2
					rec3.Width += b
					rec3.Height += b
					rl.DrawTexturePro(imgs, etc[149], rec3, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.1, 0.2)))
					blurrec := rec3
					blurrec.X += RandF32(-4, 4)
					blurrec.Y += RandF32(-4, 4)
					rl.DrawTexturePro(imgs, etc[149], blurrec, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.05, 0.1)))
				}
				//DEBUG
				if debug {
					rl.DrawRectangleLinesEx(pl.rec, 1, rl.Yellow)
					rl.DrawRectangleLinesEx(pl.crec, 1, rl.Magenta)
					rl.DrawRectangleLinesEx(pl.carec, 1, rl.Green)
					rl.DrawRectangleLinesEx(pl.perrec, 1, rl.Blue)
					rl.DrawCircleV(pl.cnt, 2, RandColor())
				}
				if frames%7 == 0 { //IDLE ANIM
					pl.anim[0].rec.X += pl.anim[0].W
					if pl.anim[0].rec.X > pl.anim[0].X+pl.anim[0].frames*pl.anim[0].W {
						pl.anim[0].rec.X = pl.anim[0].X
					}
					pl.anim[1].rec.X -= pl.anim[1].W
					if pl.anim[1].rec.X < pl.anim[1].X-pl.anim[1].frames*pl.anim[1].W {
						pl.anim[1].rec.X = pl.anim[1].X
					}
				}
				if frames%3 == 0 { //RUN PUSH ANIM
					pl.anim[4].rec.X += pl.anim[4].W
					if pl.anim[4].rec.X > pl.anim[4].X+pl.anim[4].frames*pl.anim[4].W {
						pl.anim[4].rec.X = pl.anim[4].X
					}
					pl.anim[2].rec.X += pl.anim[2].W
					if pl.anim[2].rec.X > pl.anim[2].X+pl.anim[2].frames*pl.anim[2].W {
						pl.anim[2].rec.X = pl.anim[2].X
					}
					pl.anim[3].rec.X -= pl.anim[3].W
					if pl.anim[3].rec.X < pl.anim[3].X-pl.anim[3].frames*pl.anim[3].W {
						pl.anim[3].rec.X = pl.anim[3].X
					}
					pl.anim[7].rec.X += pl.anim[7].W
					if pl.anim[7].rec.X > pl.anim[7].X+pl.anim[7].frames*pl.anim[7].W {
						pl.anim[7].rec.X = pl.anim[7].X
					}
					pl.anim[8].rec.X -= pl.anim[8].W
					if pl.anim[8].rec.X < pl.anim[8].X-pl.anim[8].frames*pl.anim[8].W {
						pl.anim[8].rec.X = pl.anim[8].X
					}
					if frames%3 == 0 { //ATK ANIM
						pl.anim[5].rec.X += pl.anim[5].W
						if pl.anim[5].rec.X > pl.anim[5].X+pl.anim[5].frames*pl.anim[5].W {
							pl.anim[5].rec.X = pl.anim[5].X
						}
						pl.anim[6].rec.X -= pl.anim[6].W
						if pl.anim[6].rec.X < pl.anim[6].X-pl.anim[6].frames*pl.anim[6].W {
							pl.anim[6].rec.X = pl.anim[6].X
						}
					}
				}
			}
		}
		//MARK:DRAW BAT COMPANION
		if batty {
			rl.DrawTexturePro(imgs, batcomp.img, shrec(batcomp.rec, 12), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, batcomp.img, batcomp.rec, rl.Vector2Zero(), 0, rl.White)
			if frames%2 == 0 {
				if batcomp.lr {
					batcomp.img.X -= anm[142].W
					if batcomp.img.X < anm[142].X-anm[142].frames*anm[142].W {
						batcomp.img.X = anm[142].X
					}
				} else {
					batcomp.img.X += anm[141].W
					if batcomp.img.X > anm[141].X+anm[141].frames*anm[141].W {
						batcomp.img.X = anm[141].X
					}
				}
			}
		}

		//MARK: CHEST LAYER ABOVE SLOTS ANIM MOUSE INP
		if len(chests) > 0 {
			for i := 0; i < len(chests); i++ {
				if chests[i].opn {
					if !chests[i].aud {
						rl.PlaySound(audfx[3])
						chests[i].aud = true
					}
					//OPEN ANIM
					if chests[i].img.X < anm[4].X+anm[4].W*anm[4].frames {
						if frames%6 == 0 {
							chests[i].img.X += anm[4].W
						}
					} else {
						x := chests[i].cnt.X
						y := chests[i].crec.Y + chests[i].crec.Height
						y += 4
						siz := be5
						if xxl {
							siz = bq3
						}
						wid := float32(chests[i].slots) * (siz + 2)
						x -= wid / 2
						//CHECK IN SLOTS REC
						checkslotsrec := rl.NewRectangle(x, y, wid, siz)
						if rl.CheckCollisionPointRec(cursorV2cam, checkslotsrec) {
							inchestslot = true
						} else {
							inchestslot = false
						}
						for j := 0; j < chests[i].slots; j++ {
							rec := rl.NewRectangle(x, y, siz, siz)
							//MOUSE INP
							if rl.CheckCollisionPointRec(cursorV2cam, rec) {
								rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.7))
								if chests[i].itm[j].nm != "" {
									toptx = chests[i].itm[j].nm
									toptxT = fps
									if inpL && !chests[i].itm[j].off && clickT == 0 {
										clickT = fps / 8
										collectfromchest(i, j)
									}
								}
							} else {
								rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
							}
							//IMG SLOT
							rl.DrawRectangleLinesEx(rec, 1, rl.White)
							if chests[i].itm[j].nm != "" {
								rl.DrawTexturePro(imgs, chests[i].itm[j].img, rec, rl.Vector2Zero(), 0, rl.White)
							}
							x += siz + 2
						}
					}
				} else {
					inchestslot = false
					if chests[i].aud {
						rl.PlaySound(audfx[5])
						chests[i].aud = false
					}
					//CLOSE ANIM
					if chests[i].img.X > anm[4].X {
						if frames%6 == 0 {
							chests[i].img.X -= anm[4].W
						}
					}
				}
			}
		}
	}

}

func drawquickslots() { //MARK:DRAW QUICK SLOTS
	siz := b + bq3
	if med {
		siz = b
	}
	spc := float32(4)
	if xxl {
		siz = b4
		spc = 8
	}
	x := siz / 4
	y := scrHF32 - (siz + siz/4)
	//CHECK IN QUICK SLOTS REC
	W := x + float32(len(pl.quik))*(siz+spc)
	H := siz
	checkInQuick := rl.NewRectangle(x, y, W, H)
	if rl.CheckCollisionPointRec(cursorV2, checkInQuick) {
		inquick = true
	} else {
		inquick = false
	}
	//DRAW QUICK
	xorig := x
	txs := tx2
	if med {
		txs = tx
	}
	if xxl {
		txs = tx4
	}
	for i := 0; i < len(pl.quik); i++ {
		//BG REC
		rec := rl.NewRectangle(x, y, siz, siz)
		if rl.CheckCollisionPointRec(cursorV2, rec) {
			rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.3))
			if pl.quik[i].nm != "" {
				//TXT
				if charscr {
					xtx := int32(xorig)
					ytx := int32(rec.Y) - (txs + 8)
					if mouseoff {
						rl.DrawText("a move to inventory / x use", xtx, ytx, txs, rl.White)
					} else {
						rl.DrawText("left click move to inventory / right click use", xtx, ytx, txs, rl.White)
					}
					ytx -= txs + tx/4
					rl.DrawText(pl.quik[i].nm, xtx, ytx, txs, rl.White)
				} else {
					toptx = pl.quik[i].nm
					if pl.quik[i].coolT > 0 && pl.quik[i].coolT > fps/2 {
						toptx = toptx + " > cooldown " + fmt.Sprint(pl.quik[i].coolT/fps)
					}
					toptxT = fps
				}
				if inpL {
					if inchest && !charscr { //MOVE ITEM TO CHEST
						canmove, num := checkChestSlots()
						if canmove {
							levels[levNum].chst[0].itm[num] = pl.quik[i]
							pl.quik[i] = xitm{}
							rl.PlaySound(audfx[7])
						} else {
							admsg("no free chest slots", rl.Red)
						}
					} else if !charscr {
						if pl.quik[i].coolT > 0 {
							rl.PlaySound(audfx[43])
							admsg("currently active", rl.Yellow)
						} else {
							useitm(i, 1)
						}
					}
				}
				if inpR && !inchest && !charscr { //DROP ITEM
					dropitm(i, 1)
				} else if inpR && charscr && !baseon { //USE ITEM
					useitm(i, 1)
				}
				if inpL && charscr { //MOVE TO INVN
					if nxInvnNum != blankint {
						movequik2invn(i)
						rl.PlaySound(audfx[18])
					} else {
						admsg("inventory full > drop, stack or use", rl.Red)
					}
				}
			}
		} else {
			rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
		}
		//BORDER REC
		rl.DrawRectangleLinesEx(rec, 2, rl.Fade(rl.White, 0.7))
		//DRAW ITEM
		if pl.quik[i].nm != "" {
			rl.DrawTexturePro(imgs, pl.quik[i].img, rec, rl.Vector2Zero(), 0, rl.White)
			if pl.quik[i].coolT > 0 {
				rl.DrawRectangleRec(rec, rl.Fade(RandRed(), 0.3))
			}
			if pl.quik[i].numof > 1 {
				txlen := rl.MeasureText(fmt.Sprint(pl.quik[i].numof), txs)
				xtx := int32(rec.X+rec.Width) - txlen
				ytx := int32(rec.Y+rec.Height) - txs
				rl.DrawText(fmt.Sprint(pl.quik[i].numof), xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(fmt.Sprint(pl.quik[i].numof), xtx-1, ytx+1, txs, rl.Black)
				rl.DrawText(fmt.Sprint(pl.quik[i].numof), xtx, ytx, txs, rl.Yellow)
			}
		}
		x += siz + spc
	}
}
func drawweapslots() { //MARK:DRAW WEAPON SLOTS XP
	siz := b + bq3
	if med {
		siz = b
	}
	spc := float32(4)
	if xxl {
		siz = b4
		spc = 8
	}

	x := scrWF32 - ((siz + spc) * 2)
	x -= siz / 4
	y := scrHF32 - (siz + siz/4)

	//CHECK IN INVEN REC
	W := x + (siz+spc)*2
	H := siz
	checkinquickRec := rl.NewRectangle(x, y, W, H)
	if rl.CheckCollisionPointRec(cursorV2, checkinquickRec) {
		inweapslots = true
	} else {
		inweapslots = false
	}
	//SWAP WEAPONS
	txs := tx2
	if xxl {
		txs = tx4
	}
	if med {
		txs = tx
	}
	if charscr {
		rec2 := rl.NewRectangle(x, y, siz, siz)
		rec2.X -= siz + spc
		rl.DrawTexturePro(imgs, etc[198], rec2, rl.Vector2Zero(), 0, rl.White)
		if rl.CheckCollisionPointRec(cursorV2, rec2) || rl.CheckCollisionPointRec(gameCursor, rec2) {
			txt := "swap weapons"
			xtx := rec2.ToInt32().X
			ytx := int32(rec2.Y) - (txs + 8)
			rl.DrawText(txt, xtx, ytx, txs, rl.White)
			if inpL && clickT == 0 {
				clickT = fps / 4
				weapHold := pl.wp1
				pl.wp1 = pl.wp2
				pl.wp2 = weapHold
			}
		}
	}
	//DRAW WEAP SLOTS
	for i := 0; i < 2; i++ {
		//BG REC
		rec := rl.NewRectangle(x, y, siz, siz)

		if rl.CheckCollisionPointRec(cursorV2, rec) {
			rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.3))
			if i == 0 {
				if pl.wp1.nm != "" {
					toptx = pl.wp1.nm
					toptxT = fps
					if charscr {
						txt := pl.wp1.nm + " > level " + fmt.Sprint(pl.wp1.level)
						txtlen := rl.MeasureText(txt, txs)
						xtx := scrW32 - (txtlen + txs)
						ytx := int32(rec.Y) - (txs + 8)
						rl.DrawText(txt, xtx, ytx, txs, rl.White)
						if inpL {
							if len(pl.weaps) > 0 {
								if pl.wp2.nm == "" {
									disTxt1 = "you must have one"
									disTxt2 = "weapon equipped"
									invDisTxtT = fps * 2
								} else {
									found := false
									for j := 0; j < len(pl.weaps); j++ {
										if pl.weaps[j].nm == "" {
											pl.weaps[j] = pl.wp1
											pl.wp1 = xweap{}
											found = true
											break
										}
									}
									if !found {
										lastWeap := pl.weaps[len(pl.weaps)-1]
										var newWeaps []xweap
										newWeaps = append(newWeaps, xweap{})
										for j := 0; j < len(pl.weaps)-1; j++ {
											newWeaps = append(newWeaps, pl.weaps[j])
										}
										newWeaps[0] = pl.wp1
										pl.weaps = newWeaps
										pl.wp1 = lastWeap
									}
								}
							} else {
								if msgT == 0 {
									admsg("no weapon storage", rl.Red)
									msgT = fps
								}
							}
						}
					}
				}
			} else {
				if pl.wp2.nm != "" {
					toptx = pl.wp2.nm
					toptxT = fps
					if charscr {
						txt := pl.wp2.nm + " > level " + fmt.Sprint(pl.wp2.level)
						txtlen := rl.MeasureText(txt, txs)
						xtx := scrW32 - (txtlen + txs)
						ytx := int32(rec.Y) - txs
						rl.DrawText(txt, xtx, ytx, txs, rl.White)
						if inpL {
							if len(pl.weaps) > 0 {
								if pl.wp1.nm == "" {
									disTxt1 = "you must have one"
									disTxt2 = "weapon equipped"
									invDisTxtT = fps * 2
								} else {
									found := false
									for j := 0; j < len(pl.weaps); j++ {
										if pl.weaps[j].nm == "" {
											pl.weaps[j] = pl.wp2
											pl.wp2 = xweap{}
											found = true
											break
										}
									}
									if !found {
										lastWeap := pl.weaps[len(pl.weaps)-1]
										var newWeaps []xweap
										newWeaps = append(newWeaps, xweap{})
										for j := 0; j < len(pl.weaps)-1; j++ {
											newWeaps = append(newWeaps, pl.weaps[j])
										}
										newWeaps[0] = pl.wp2
										pl.weaps = newWeaps
										pl.wp2 = lastWeap
									}
								}
							} else {
								if msgT == 0 {
									admsg("no weapon storage", rl.Red)
									msgT = fps
								}
							}
						}
					}
				}
			}
		} else {
			rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
		}
		//BORDER REC
		rl.DrawRectangleLinesEx(rec, 2, rl.Fade(rl.White, 0.7))
		//DRAW ITEM
		if i == 0 {
			if pl.wp1.nm != "" {
				//WEAP IMG
				rl.DrawTexturePro(imgs, pl.wp1.img, rec, rl.Vector2Zero(), 0, rl.White)
				//BONUS STARS
				if pl.wp1.spec1 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
				if pl.wp1.spec2 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					if pl.wp1.spec1 != 0 {
						rec3.X -= (siz / 12) * 9
					}
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
			}
		} else {
			if pl.wp2.nm != "" {
				rl.DrawTexturePro(imgs, pl.wp2.img, rec, rl.Vector2Zero(), 0, rl.White)
				//BONUS STARS
				if pl.wp2.spec1 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
				if pl.wp2.spec2 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					if pl.wp2.spec1 != 0 {
						rec3.X -= (siz / 12) * 9
					}
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
			}
		}
		x += siz + spc
	}
}
func drawartifacts() { //MARK:DRAW ARTIFACTS

	siz := b
	if xl {
		siz = b + b/2
	}
	if med {
		siz = b
	}
	if xxl {
		siz = b3
	}
	x, y := siz/4, siz/4
	xorig := x
	spc := float32(7)
	if med {
		spc = 4
	}
	txs := tx2
	if xxl {
		txs = tx4
	}
	if med {
		txs = tx
	}

	y2 := y
	count := 0
	for i := 0; i < len(pl.art); i++ {
		y2 += siz + spc
		count++
		if y2 >= scrHF32-siz*4 {
			break
		}
	}
	countdiff := 0
	checkcount := false
	if count < len(pl.art) {
		checkcount = true
		countdiff = len(pl.art) - count
	}

	for i := 0; i < len(pl.art); i++ {
		if pl.art[i].nm == "ring of vine" {
			vineRingArtNum = i
		}
		rec := rl.NewRectangle(x, y, siz, siz)
		rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
		if pl.art[i].off {
			rl.DrawTexturePro(imgs, pl.art[i].img, rec, rl.Vector2Zero(), 0, rl.DarkGray)
		} else {
			rl.DrawTexturePro(imgs, pl.art[i].img, rec, rl.Vector2Zero(), 0, rl.White)
		}
		if rl.CheckCollisionPointRec(cursorV2, rec) {
			xtx := int32(rec.X+rec.Width) + txs
			if x == xorig && checkcount && i < countdiff {
				xtx += int32(siz + spc)

			}
			ytx := int32(rec.Y+rec.Height/2) - txs/2
			txt := fmt.Sprint(pl.art[i].nm) + " > " + fmt.Sprint(pl.art[i].des)
			if pl.art[i].off {
				txt = txt + " > depleted"
			}
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
		}
		if pl.art[i].numof > 1 {
			txs2 := tx3
			if med || lrg {
				txs2 = tx2
			}
			xtx := int32(rec.X+rec.Width) - txs2/3
			ytx := int32(rec.Y+rec.Height) - txs2
			rl.DrawText(fmt.Sprint(pl.art[i].numof), xtx-3, ytx+3, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(pl.art[i].numof), xtx-1, ytx+1, txs2, rl.White)
			rl.DrawText(fmt.Sprint(pl.art[i].numof), xtx, ytx, txs2, rl.Yellow)
		}
		y += siz + spc

		if y >= scrHF32-siz*4 {
			y = siz / 4
			x += siz + spc
		}
	}
}
func drawinvhints() { //MARK:DRAW INVEN HINTS
	xtx := tx
	ytx := tx
	spc := tx / 2
	txs := tx2
	if xxl {
		txs = tx4
	}
	if mouseoff {
		rl.DrawText("X inventory item menu", xtx, ytx, txs, rl.White)
		ytx += txs + spc
		rl.DrawText("A move quick slot items", xtx, ytx, txs, rl.White)
	} else {
		rl.DrawText("right click inventory item menu", xtx, ytx, txs, rl.White)
		ytx += txs + spc
		rl.DrawText("left click move quick slot items", xtx, ytx, txs, rl.White)
	}
}

func drawnocam() { //MARK:DRAW NO CAM

	//GAMEPAD DEBUG
	if debug {
		rl.DrawText("0,0 "+fmt.Sprint(rl.GetGamepadAxisMovement(0, 0)), 400, 10, 20, rl.White)
		rl.DrawText("0,1 "+fmt.Sprint(rl.GetGamepadAxisMovement(0, 1)), 400, 30, 20, rl.White)
		rl.DrawText("0,2 "+fmt.Sprint(rl.GetGamepadAxisMovement(0, 2)), 400, 50, 20, rl.White)
		rl.DrawText("0,3 "+fmt.Sprint(rl.GetGamepadAxisMovement(0, 3)), 400, 70, 20, rl.White)
		rl.DrawText("0,4 "+fmt.Sprint(rl.GetGamepadAxisMovement(0, 4)), 400, 90, 20, rl.White)
		rl.DrawText("0,5 "+fmt.Sprint(rl.GetGamepadAxisMovement(0, 5)), 400, 110, 20, rl.White)
		rl.DrawText("pressed "+fmt.Sprint(rl.GetGamepadButtonPressed()), 400, 130, 20, rl.White)
	}

	//INTRO
	if intro {
		drawIntro()
	} else if startScreen {
		drawStartScreen()
	} else if gameover {
		drawgameover()
	} else if endgame {
		drawendgame()
	}
	//BORDER RECS TO HIDE SHADER EDGES
	rec := rl.NewRectangle(0, 0, scrWF32, 3)
	rl.DrawRectangleRec(rec, rl.Black)
	rec.Y += scrHF32 - 3
	rl.DrawRectangleRec(rec, rl.Black)
	rec = rl.NewRectangle(0, 0, 3, scrHF32)
	rl.DrawRectangleRec(rec, rl.Black)
	rec.X += scrWF32 - 3
	rl.DrawRectangleRec(rec, rl.Black)
	//OTHER SCREENS
	if charscr {
		drawcharscr()
	} else if helpon {
		drawhelp()
	} else if options {
		drawOptions()
	} else if baseon {
		drawBase()
	}
	//MARK: DRAW BOSS NAME TXT BOSS HP
	if bosson && !gameover && !endgame && !credits {
		//NAME
		txs := tx7
		if xxl {
			txs = tx8
		}
		if lrg {
			txs = tx5
		}
		if med {
			txs = tx4
		}
		txtlen := rl.MeasureText(boss.nm, txs)
		y := int32(bq)
		x := scrW32 - (txtlen + int32(b/2))
		rl.DrawText(boss.nm, x-4, y+4, txs, rl.Yellow)
		rl.DrawText(boss.nm, x-3, y+3, txs, rl.Black)
		rl.DrawText(boss.nm, x-2, y+2, txs, rl.Magenta)
		rl.DrawText(boss.nm, x-1, y+1, txs, rl.Black)
		rl.DrawText(boss.nm, x, y, txs, rl.White)
		//HP BARS
		siz := float32(4)
		spc := float32(1)
		heig := b
		wid := (siz + spc) * float32(boss.hpmax)
		y2 := float32(txs + tx2)
		x2 := scrWF32 - bq - wid
		rec := rl.NewRectangle(x2, y2, siz, heig)
		if len(levels[levNum].enm) > 0 {
			for i := 0; i < levels[levNum].enm[0].hpmax; i++ {
				rl.DrawRectangleRec(rec, rl.Fade(rl.DarkGray, 0.2))
				rec.X += siz + spc
			}
			rec = rl.NewRectangle(x2, y2, siz, heig)
			for i := 0; i < levels[levNum].enm[0].hp; i++ {
				rl.DrawRectangleRec(rec, rl.Fade(DarkRed(), 0.7))
				rec.X += siz + spc
			}
		}
	}
	//GAME SCREEN
	//QUICKSLOTS
	if !pause || charscr {
		if !gameover {
			drawquickslots()
			drawweapslots()
		}
	}
	if !pause && !gameover {
		//MARK: DRAW STATUS EFFECTS
		y2 := sideY
		siz := b2
		txs := tx3
		if xxl {
			y2 += b2
			txs = tx4
			siz = b3
		}
		if med {
			siz = b
			y2 -= b
			txs = tx2
		}
		rec := rl.NewRectangle(scrWF32-(siz+siz/4), y2, siz, siz)
		if saltT > 0 {
			rl.DrawTexturePro(imgs, etc[186], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[186], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "immune to freeze > " + fmt.Sprint(saltT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(saltT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if fartT > 0 {
			rl.DrawTexturePro(imgs, etc[184], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[184], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "fart fireballs > " + fmt.Sprint(fartT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(fartT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if psychedelicsT > 0 {
			rl.DrawTexturePro(imgs, etc[182], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[182], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "rainbows > " + fmt.Sprint(psychedelicsT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(psychedelicsT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if bootsT > 0 {
			rl.DrawTexturePro(imgs, etc[183], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[183], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "no floor trap damage > " + fmt.Sprint(bootsT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(bootsT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if gasT > 0 {
			rl.DrawTexturePro(imgs, etc[79], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[79], rec, rl.Vector2Zero(), 0, RandOrange())
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "inflict burn > " + fmt.Sprint(gasT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(gasT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if bloodT > 0 {
			rl.DrawTexturePro(imgs, etc[80], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[80], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "inflict bleed > " + fmt.Sprint(bloodT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(bloodT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if icecreamT > 0 {
			rl.DrawTexturePro(imgs, etc[65], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[65], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "frozen > " + fmt.Sprint(icecreamT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(icecreamT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if pistolT > 0 {
			rl.DrawTexturePro(imgs, etc[59], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[59], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := " faster attack speed > " + fmt.Sprint(pistolT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(pistolT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if icelollyT > 0 {
			rl.DrawTexturePro(imgs, etc[73], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[73], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "chilly > " + fmt.Sprint(icelollyT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(icelollyT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if watchT > 0 {
			rl.DrawTexturePro(imgs, etc[56], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[56], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "slower enemy move time > " + fmt.Sprint(watchT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(watchT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if slugT > 0 {
			rl.DrawTexturePro(imgs, etc[58], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[58], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "slug pee > " + fmt.Sprint(slugT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(slugT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if pl.resFireT > 0 {
			rl.DrawTexturePro(imgs, etc[84], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[84], rec, rl.Vector2Zero(), 0, RandOrange())
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "resist fire > " + fmt.Sprint(pl.resFireT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(pl.resFireT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if pl.resPoisT > 0 {
			rl.DrawTexturePro(imgs, etc[85], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[85], rec, rl.Vector2Zero(), 0, RandGreen())
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "resist poison > " + fmt.Sprint(pl.resPoisT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(pl.resPoisT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if pl.invisT > 0 {
			rl.DrawTexturePro(imgs, etc[86], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[86], rec, rl.Vector2Zero(), 0, RandCyan())
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "invisible > " + fmt.Sprint(pl.invisT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(pl.invisT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if pl.armorT > 0 {
			rl.DrawTexturePro(imgs, etc[87], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[87], rec, rl.Vector2Zero(), 0, RandCyan())
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "armor > " + fmt.Sprint(pl.armorT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(pl.armorT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if intangibleT > 0 {
			rl.DrawTexturePro(imgs, etc[88], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[88], rec, rl.Vector2Zero(), 0, RandColor())
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "intangible > " + fmt.Sprint(intangibleT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(intangibleT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if powerT > 0 {
			rl.DrawTexturePro(imgs, etc[89], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[89], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "max stats > " + fmt.Sprint(powerT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(powerT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if orangeT > 0 {
			rl.DrawTexturePro(imgs, etc[116], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[116], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "health regeneration > " + fmt.Sprint(orangeT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(orangeT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if tvT > 0 {
			rl.DrawTexturePro(imgs, etc[117], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[117], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "paused > " + fmt.Sprint(tvT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(tvT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if lollipopT > 0 {
			rl.DrawTexturePro(imgs, etc[119], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[119], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "mana regeneration > " + fmt.Sprint(lollipopT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(lollipopT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if steroidsT > 0 {
			rl.DrawTexturePro(imgs, etc[24], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[24], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "max strength > " + fmt.Sprint(steroidsT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(steroidsT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if turtleT > 0 {
			rl.DrawTexturePro(imgs, etc[60], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[60], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "turtle shield > " + fmt.Sprint(turtleT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(turtleT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if sodaT > 0 {
			rl.DrawTexturePro(imgs, etc[62], shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[62], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "faster movement > " + fmt.Sprint(sodaT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(sodaT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		//MARK: DRAW HP MANA
		siz = b + be3
		if med {
			siz = b
		}
		if xl {
			siz = b2
		}
		if xxl {
			siz = b4
		}
		spc := float32(4)
		x2 := scrWF32 / 2
		y2 = scrHF32 - (siz + siz/4)
		wid := (siz + spc) * float32(pl.hpmax+pl.manamax)
		x2 -= wid / 2
		xorig := x2
		x3 := x2
		//HP MAX
		for i := 0; i < pl.hpmax; i++ {
			rec := rl.NewRectangle(x2, y2, siz, siz)
			if med {
				rl.DrawTexturePro(imgs, etc[32], shrec(rec, 3), rl.Vector2Zero(), 0, rl.Fade(rl.Magenta, 0.7))
			} else if xxl {
				rl.DrawTexturePro(imgs, etc[32], shrec(rec, 12), rl.Vector2Zero(), 0, rl.Fade(rl.Magenta, 0.7))
			} else if xl {
				rl.DrawTexturePro(imgs, etc[32], shrec(rec, 7), rl.Vector2Zero(), 0, rl.Fade(rl.Magenta, 0.7))
			} else {
				rl.DrawTexturePro(imgs, etc[32], shrec(rec, 5), rl.Vector2Zero(), 0, rl.Fade(rl.Magenta, 0.7))
			}
			rl.DrawTexturePro(imgs, etc[32], rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.7))
			x2 += siz + spc
		}
		//SHRIMP
		if shrimpnum > 0 {
			for i := 0; i < shrimpnum; i++ {
				rec := rl.NewRectangle(x2, y2, siz, siz)
				rl.DrawTexturePro(imgs, etc[57], shrec(rec, 7), rl.Vector2Zero(), 0, shcol())
				rl.DrawTexturePro(imgs, etc[57], rec, rl.Vector2Zero(), 0, rl.White)
				x2 += siz + spc
			}
		}
		x3 = x2 + spc*2
		//HP
		x2 = xorig
		for i := 0; i < pl.hp; i++ {
			rec := rl.NewRectangle(x2, y2, siz, siz)
			rl.DrawTexturePro(imgs, etc[32], rec, rl.Vector2Zero(), 0, rl.Fade(BrightYellow(), RandF32(0.8, 1.1)))
			x2 += siz + spc
		}
		//MANA
		xorig = x3
		for i := 0; i < pl.manamax; i++ {
			rec := rl.NewRectangle(x3, y2, siz, siz)
			if med {
				rl.DrawTexturePro(imgs, etc[83], shrec(rec, 3), rl.Vector2Zero(), 0, rl.Fade(rl.Magenta, 0.7))
			} else {
				rl.DrawTexturePro(imgs, etc[83], shrec(rec, 5), rl.Vector2Zero(), 0, rl.Fade(rl.Magenta, 0.7))
			}
			rl.DrawTexturePro(imgs, etc[83], rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.7))
			x3 += siz + spc
		}
		x3 = xorig
		for i := 0; i < pl.mana; i++ {
			rec := rl.NewRectangle(x3, y2, siz, siz)
			if med {
				rl.DrawTexturePro(imgs, etc[83], shrec(rec, 3), rl.Vector2Zero(), 0, rl.Fade(rl.DarkBlue, 0.7))
			} else {
				rl.DrawTexturePro(imgs, etc[83], shrec(rec, 5), rl.Vector2Zero(), 0, rl.Fade(rl.DarkBlue, 0.7))
			}
			rl.DrawTexturePro(imgs, etc[83], rec, rl.Vector2Zero(), 0, rl.Fade(RandCyan(), RandF32(0.8, 1.1)))
			x3 += siz + spc
		}
		//ARTIFACTS
		if len(pl.art) > 0 {
			drawartifacts()
		}

		//SAVE ANIMATION
		if saveT > 0 {
			siz2 := b3
			if med {
				siz2 = b2
			}
			cntr := rl.NewVector2(scrWF32/2, scrHF32)
			rec3 := rl.NewRectangle(cntr.X-siz2/2, b, siz2, siz2)
			rl.DrawTexturePro(imgs, anm[198].rec, shrec(rec3, 12), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, anm[198].rec, rec3, rl.Vector2Zero(), 0, rl.White)
			if frames%5 == 0 {
				anm[198].rec.X += anm[198].W
				if anm[198].rec.X > anm[198].X+anm[198].frames*anm[198].W {
					anm[198].rec.X = anm[198].X
				}
			}
			saveT--
		} else {
			//TOP INFO

			if toptxT > 0 && !options && !charscr {
				siz := tx3
				if med {
					siz = tx2
				}
				if xxl {
					siz = tx6
				}
				txlen := rl.MeasureText(toptx, siz)
				cntr := rl.NewVector2(scrWF32/2, scrHF32/2)
				x := int32(cntr.X) - txlen/2
				y := int32(b / 4)
				txrec := rl.NewRectangle(float32(x-8), float32(y-4), float32(txlen+16), float32(siz+8))
				rl.DrawRectangleRec(txrec, rl.Fade(rl.Black, 0.7))
				rl.DrawText(toptx, x-2, y+2, siz, rl.Black)
				rl.DrawText(toptx, x, y, siz, rl.White)
			}
		}
		//TV PAUSE TEXT
		if tvT > 0 {
			txt := "paused"
			siz := tx10 * 2
			txlen := rl.MeasureText(txt, siz)
			xtx := int32(cnt.X) - txlen/2
			ytx := int32(cnt.Y)
			ytx += pl.rec.ToInt32().Height
			rl.DrawText(txt, xtx, ytx, siz, rl.Fade(RandColor(), 0.2))
		}
	}
	//CURSOR
	if debug {
		rl.ShowCursor()
	} else {
		rl.HideCursor()
	}
	if !intro {
		siz := b + b/2
		if med {
			siz = b
		}
		cursorRec := rl.NewRectangle(cursorV2.X-siz/2, cursorV2.Y-siz/2, siz, siz)
		rl.DrawTexturePro(imgs, etc[7], shrec(drec(cursorRec), 17), orgn(cursorRec), curRo, shcol())
		rl.DrawTexturePro(imgs, etc[7], drec(cursorRec), orgn(cursorRec), curRo, RandColor())
		curRo++
	}
	//PIXELS
	if pixels && !baseon {
		num := 150
		max := float32(3)
		if med {
			max = 2
		} else if xxl {
			max = 7
		}
		min := float32(1)
		if xxl {
			min = 3
		}
		for num > 0 {
			siz := RandF32(min, max)
			rec := rl.NewRectangle(RandF32(0, scrWF32), RandF32(0, scrHF32), siz, siz)
			rl.DrawRectangleRec(rec, rl.Black)
			num--
		}
	}
	//SCAN
	if scanlines {
		for i := 0; i < len(scan); i++ {
			v2 := scan[i]
			v2.X += scrWF32
			if xxl {
				rl.DrawLineV(scan[i], v2, rl.Fade(rl.Black, 0.45))
			} else if lrg {
				rl.DrawLineV(scan[i], v2, rl.Fade(rl.Black, 0.15))
			} else if med {
				rl.DrawLineV(scan[i], v2, rl.Fade(rl.Black, 0.15))
			} else {
				rl.DrawLineV(scan[i], v2, rl.Fade(rl.Black, 0.55))
			}

			if frames%3 == 0 {
				scan[i].Y++
				if scan[i].Y > scrHF32+scanlineSpc*2 {
					scan[i].Y = -scanlineSpc + 1
				}
			}
		}
	}
}
func drawminimap() { //MARK:DRAW MINIMAP
	camMap.Offset.X = scrWF32 - scrWF32/8
	camMap.Offset.Y = 12

	if med {
		camMap.Offset.X = scrWF32 - scrWF32/7.5
		camMap.Offset.Y = 24
	}
	if xl {
		camMap.Offset.X = scrWF32 - scrWF32/7.5
		camMap.Offset.Y = -b / 2
	}
	if xxl {
		camMap.Offset.X = scrWF32 - scrWF32/6.5
		camMap.Offset.Y = -b3
	}
	rl.BeginMode2D(camMap)
	for i := 0; i < len(levels[levNum].recs); i++ {
		if plroom == i {
			rl.DrawRectangleRec(levels[levNum].recs[i], rl.Fade(rl.Yellow, 0.4))
			rl.DrawRectangleLinesEx(levels[levNum].recs[i], 8, rl.Yellow)
		} else {
			if mappin && i == exitRoomNum {
				rl.DrawRectangleRec(levels[levNum].recs[i], rl.Fade(rl.Magenta, 0.4))
				rl.DrawRectangleLinesEx(levels[levNum].recs[i], 8, rl.Magenta)
			} else if chestpin && i == chestRoomNum {
				rl.DrawRectangleRec(levels[levNum].recs[i], rl.Fade(rl.Blue, 0.4))
				rl.DrawRectangleLinesEx(levels[levNum].recs[i], 8, rl.Blue)
			} else {
				if levels[levNum].inf[i].vis {
					rl.DrawRectangleRec(levels[levNum].recs[i], rl.Fade(rl.Green, 0.4))
					rl.DrawRectangleLinesEx(levels[levNum].recs[i], 8, rl.Green)
				} else {
					rl.DrawRectangleRec(levels[levNum].recs[i], rl.Fade(rl.Red, 0.4))
					rl.DrawRectangleLinesEx(levels[levNum].recs[i], 8, rl.Red)
				}
			}
		}
	}
	rl.EndMode2D()
}
func drawnoRender() { //MARK:DRAW NO RENDER
	//SIDEBAR
	if !baseon && !options && !intro && !startScreen && !gameover && !endgame && !helpon {
		drawsidebar()
	}
	//MINI MAP
	if !bosson && !baseon && !options && !intro && !startScreen && !treasureroom && !gameover && !endgame && !helpon {
		drawminimap()
	}
	//INVEN HINTS
	if charscr {
		drawinvhints()
	}

	if debug {
		drawDebug()
	}
}
func drawsidebar() { //MARK:DRAW SIDE BAR MESSAGES DRAW TIMER
	//MSG
	y := int32(120)

	if xxl {
		y = int32(250)
	}
	if xl {
		y = int32(200)
	}
	if treasureroom {
		y = 16
	} else if bosson {
		y = 150
	}
	txs := tx2
	if med {
		txs = tx
	}
	if xxl {
		txs = tx4
	}
	if len(msg) > 0 {
		count := 0
		for i := len(msg) - 1; i > 0; i-- {
			txlen := rl.MeasureText(msg[i].txt, txs)
			x := scrW32 - (txlen + txs)
			rl.DrawText(msg[i].txt, x-1, y+1, txs, rl.Black)
			rl.DrawText(msg[i].txt, x, y, txs, msg[i].col)
			y += txs
			count++
			if count == 10 {
				break
			}
		}
	}
	y += txs
	//TIMER
	secs := fmt.Sprint(levSecs)
	mins := fmt.Sprint(levMins)
	if levSecs == 0 {
		secs = "00"
	} else if levSecs < 10 {
		secs = "0" + secs
	}
	if levMins == 0 {
		mins = "00"
	} else if levMins < 10 {
		mins = "0" + mins
	}
	txt := mins + ":" + secs
	if !bosson && !treasureroom {
		txt = "level " + fmt.Sprint(levNumDis) + " >> " + txt
	}
	txlen := rl.MeasureText(txt, txs)
	x := scrW32 - (txlen + txs)
	rl.DrawText(txt, x-2, y+2, txs, rl.Black)
	rl.DrawText(txt, x, y, txs, RandColor())
	y += txs + tx
	sideY = float32(y) + b2 + b/2
	//ENEMIES REMAIN
	if !bosson {
		if levels[levNum].enNum > 0 {
			if levels[levNum].enNum == 1 {
				txt = "1 enemy remains"
			} else {
				txt = fmt.Sprint(levels[levNum].enNum) + " enemies remain"
			}
		} else {
			txt = "cleared > +100xp @ end level"
		}
		txlen = rl.MeasureText(txt, txs)
		x = scrW32 - (txlen + txs)
		rl.DrawText(txt, x-2, y+2, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, RandColor())
	}
	//XP
	ytx := y + (txs + tx/2) + 2
	if bosson {
		ytx -= txs
	}
	xtx := scrW32
	txt = fmt.Sprint(pl.xp) + " xp"
	if pl.xp == 0 {
		txt = "zero xp"
	}
	txtlen := rl.MeasureText(txt, txs*2)
	xtx -= txtlen + txs
	rl.DrawText(txt, xtx-2, ytx+2, txs*2, rl.Black)
	rl.DrawText(txt, xtx, ytx, txs*2, RandColor())

}

func drawcharscr() { //MARK:DRAW INVENTORY CHARACTER SCREEN

	for i := 0; i < len(bgpix); i++ {
		rec := rl.NewRectangle(bgpix[i].v2.X, bgpix[i].v2.Y, bgpix[i].siz, bgpix[i].siz)
		rl.DrawRectangleRec(rec, rl.Fade(bgpix[i].col, bgpix[i].fd))
		bgpix[i].v2.X += bgpix[i].dirX
		bgpix[i].v2.Y += bgpix[i].dirY

		if bgpix[i].v2.X < 0 {
			bgpix[i].v2.X = scrWF32
		}
		if bgpix[i].v2.X > scrWF32 {
			bgpix[i].v2.X = 0
		}
		if bgpix[i].v2.Y < 0 {
			bgpix[i].v2.Y = scrHF32
		}
		if bgpix[i].v2.Y > scrHF32 {
			bgpix[i].v2.Y = 0
		}

		if bgpix[i].fd > 0 {
			bgpix[i].fd -= 0.005
		} else {
			bgpix[i].fd = RandF32(0.5, 1)
		}
	}
	if cantmoveT > 0 {
		cantmoveT--
	}
	if invDisTxtT > 0 {
		invDisTxtT--
	}
	if invInfoT > 0 {
		invInfoT--
	}

	rl.BeginMode2D(camInven) //CHANGE ZOOM FOR SCREEN RES
	rl.DrawRectangleRec(optionsRec, rl.Fade(rl.Magenta, 0.9))
	cursorV2camInven = rl.GetScreenToWorld2D(cursorV2, camInven)
	//DRAW INVEN
	bgtxrec := rl.NewRectangle(optionsRec.X, optionsRec.Y+b/2, optionsRec.Width, b2+b/4)
	rl.DrawRectangleRec(bgtxrec, rl.Orange)
	rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
	rl.DrawText(">> inventory", optionsRec.ToInt32().X+tx3-1, bgtxrec.ToInt32().Y+9, tx5, rl.Black)
	rl.DrawText(">> inventory", optionsRec.ToInt32().X+tx3, bgtxrec.ToInt32().Y+8, tx5, rl.Black)
	//CLOSE REC
	siz2 := bgtxrec.Height
	closerec := rl.NewRectangle(optionsRec.X+optionsRec.Width-siz2, bgtxrec.Y, siz2, siz2)
	closerec.X += 16
	closerec.Y += 16
	closerec.Width -= 32
	closerec.Height -= 32
	v1 := rl.NewVector2(closerec.X, closerec.Y)
	v1.X += 8
	v1.Y += 8
	v2 := v1
	v2.X += closerec.Width - 16
	v3 := v2
	v3.Y += closerec.Width - 16
	v4 := v3
	v4.X -= closerec.Width - 16
	if rl.CheckCollisionPointRec(cursorV2camInven, closerec) {
		rl.DrawRectangleRec(closerec, DarkRed())
		rl.DrawLineEx(v1, v3, 4, rl.Black)
		rl.DrawLineEx(v2, v4, 4, rl.Black)
		if invInfoT == 0 {
			if clickT == 0 {
				if inpL {
					rl.PlaySound(audfx[41])
					if !baseon {
						pause = false
					}
					inMenuOn = false
					charscr = false
				}
			}
		}
	} else {
		rl.DrawRectangleRec(closerec, rl.Black)
		rl.DrawLineEx(v1, v3, 4, rl.Orange)
		rl.DrawLineEx(v2, v4, 4, rl.Orange)
	}

	if rl.IsGamepadButtonPressed(0, 6) {
		rl.PlaySound(audfx[41])
		if !baseon {
			pause = false
		}
		inMenuOn = false
		charscr = false
	}
	x := optionsRec.X
	x += 14
	xorig := x
	y := b3 + bq
	siz := b2
	spc := float32(4)
	diff := invMax - len(pl.invn)
	for i := 0; i < len(pl.invn); i++ {

		if pl.invn[i].nm == "map" && pl.invn[i].notquick && baseon {
			pl.invn[i].notquick = false
		} else if pl.invn[i].nm == "map" && !pl.invn[i].notquick && !baseon {
			pl.invn[i].notquick = true
		}

		rec := rl.NewRectangle(x, y, siz, siz)
		if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
			rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.7))
		} else {
			rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
		}
		rl.DrawRectangleLinesEx(rec, 4, rl.Fade(rl.Purple, 0.7))
		if pl.invn[i].nm != "" {
			rl.DrawTexturePro(imgs, pl.invn[i].img, shrec(rec, 5), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, pl.invn[i].img, rec, rl.Vector2Zero(), 0, rl.White)
			//NUMOF TXT
			if pl.invn[i].numof > 1 {
				txlen := rl.MeasureText(fmt.Sprint(pl.invn[i].numof), tx2)
				xtx := int32(rec.X+rec.Width) - txlen
				ytx := int32(rec.Y+rec.Height) - tx2
				rl.DrawText(fmt.Sprint(pl.invn[i].numof), xtx-2, ytx+2, tx2, rl.Black)
				rl.DrawText(fmt.Sprint(pl.invn[i].numof), xtx-1, ytx+1, tx2, rl.Black)
				rl.DrawText(fmt.Sprint(pl.invn[i].numof), xtx, ytx, tx2, rl.Yellow)
			}
			if rl.CheckCollisionPointRec(cursorV2camInven, rec) && !inMenuOn && clickT == 0 {
				disTxt1 = pl.invn[i].nm
				disTxt2 = pl.invn[i].des
				if cantmoveT > 0 {
					disTxt1 = "cannot be used"
					disTxt2 = "in quick slots"
				}
				invDisTxtT = fps * 2
				//MOVE TO QUIK
				if inpL && nxQuikNum != blankint && !pl.invn[i].notquick && pl.invn[i].nm != "map" && !pl.invn[i].art && clickT == 0 {
					clickT = fps / 4
					found, numSame := checkQuikSameItm(pl.invn[i])
					if found {
						pl.quik[numSame].numof++
					} else {
						pl.quik[nxQuikNum] = pl.invn[i]
						pl.invn[i] = xitm{}
					}
					rl.PlaySound(audfx[18])
				} else if inpL && nxQuikNum != blankint && pl.invn[i].notquick && !pl.invn[i].art && clickT == 0 && cantmoveT == 0 {
					cantmoveT = fps * 2
				} else if inpL && nxQuikNum != blankint && !pl.invn[i].notquick && pl.invn[i].art && clickT == 0 && cantmoveT == 0 {
					cantmoveT = fps * 2
				}
				//MENU
				if clickT == 0 {
					if inpR && !inMenuOn {
						rl.PlaySound(audfx[44])
						clickT = fps / 4
						inMenuOn = true
						siz2 := (siz + spc) * 2
						siz2 -= spc
						inMenuRec = rl.NewRectangle(rec.X+rec.Width+spc, rec.Y, siz2, siz2+siz+spc)
						if inchest {
							inMenuRec.Height += siz / 2
						}
						if cursorV2.X > cnt.X+siz2 {
							inMenuRec.X -= siz2 + siz + spc
						}
						inMenuItm = i
					}
				}
			}
		}
		x += siz + spc
		if x+siz+spc >= optionsRec.X+optionsRec.Width {
			x = xorig
			y += siz + spc
		}
	}
	//DRAW LOCKED INVEN
	if diff > 0 {
		for i := 0; i < diff; i++ {
			rec := rl.NewRectangle(x, y, siz, siz)
			rl.DrawRectangleRec(rec, rl.DarkPurple)
			rl.DrawRectangleLinesEx(rec, 4, rl.Fade(rl.Purple, 0.7))
			rec.X += 4
			rec.Y += 4
			rec.Width -= 8
			rec.Height -= 8
			rl.DrawTexturePro(imgs, etc[46], shrec(rec, 4), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[46], rec, rl.Vector2Zero(), 0, rl.White)
			x += siz + spc
			if x+siz+spc >= optionsRec.X+optionsRec.Width {
				x = xorig
				y += siz + spc
			}
		}
	}
	//WEAPON SLOTS
	y += b / 2
	diff = pl.weapmax - len(pl.weaps)
	for i := 0; i < len(pl.weaps); i++ {
		rec := rl.NewRectangle(x, y, siz, siz)
		if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
			rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.7))
			if pl.weaps[i].nm != "" {
				disTxt1 = pl.weaps[i].nm + " > level " + fmt.Sprint(pl.weaps[i].level)
				disTxt2 = "right click for menu"
				invDisTxtT = fps * 2
			}
			//MENU
			if clickT == 0 {
				if inpR && !inWeapMenuOn {
					clickT = fps / 4
					inWeapMenuOn = true
					siz2 := (siz + spc) * 2
					siz2 -= spc
					inMenuRec = rl.NewRectangle(rec.X+rec.Width+spc, rec.Y, siz2, siz2+siz/2)
					if cursorV2.X > cnt.X+siz2 {
						inMenuRec.X -= siz2 + siz + spc
					}
					inMenuItm = i
				}
			}
		} else {
			rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
		}
		rl.DrawRectangleLinesEx(rec, 4, rl.Fade(rl.Gold, 0.7))
		if pl.weaps[i].nm != "" {
			rl.DrawTexturePro(imgs, pl.weaps[i].img, shrec(rec, 7), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, pl.weaps[i].img, rec, rl.Vector2Zero(), 0, rl.White)
			//BONUS STARS
			if pl.weaps[i].spec1 != 0 {
				siz := be7
				rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
				rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
				rec3.X += 4
				rec3.Y += 4
				rec3.Width -= 8
				rec3.Height -= 8
				rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
			}
			if pl.weaps[i].spec2 != 0 {
				siz := be7
				rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
				if pl.weaps[i].spec1 != 0 {
					rec3.X -= (siz / 12) * 9
				}
				rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.Black)
				rec3.X += 4
				rec3.Y += 4
				rec3.Width -= 8
				rec3.Height -= 8
				rl.DrawTexturePro(imgs, etc[181], rec3, rl.Vector2Zero(), 0, rl.White)
			}
		}
		x += siz + spc
	}
	if diff > 0 {
		for i := 0; i < diff; i++ {
			rec := rl.NewRectangle(x, y, siz, siz)
			rl.DrawRectangleRec(rec, rl.DarkPurple)
			rl.DrawRectangleLinesEx(rec, 4, rl.Fade(rl.Gold, 0.7))
			rec.X += 4
			rec.Y += 4
			rec.Width -= 8
			rec.Height -= 8
			rl.DrawTexturePro(imgs, etc[46], shrec(rec, 4), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, etc[46], rec, rl.Vector2Zero(), 0, rl.White)
			x += siz + spc
		}
	}
	ytx := int32(y) + tx/2
	xtx := int32(x) + tx
	rl.DrawText("<< weapons", xtx-1, ytx+1, tx5, rl.Black)
	rl.DrawText("<< weapons", xtx, ytx, tx5, rl.Black)

	//STACK
	y += siz + be5
	rec2 := rl.NewRectangle(cnt.X-(b4+b/8), y, b4, b+b/2)
	if rl.CheckCollisionPointRec(cursorV2camInven, rec2) {
		rl.DrawRectangleRec(rec2, DarkRed())
		rl.DrawRectangleLinesEx(rec2, 4, rl.Black)
		txt := "stack"
		txs := tx3
		txlen := rl.MeasureText(txt, txs)
		ytx := rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
		xtx := rec2.ToInt32().X + rec2.ToInt32().Width/2 - txlen/2
		rl.DrawText(txt, xtx, ytx, txs, rl.White)
		if clickT == 0 {
			if inpL {
				rl.PlaySound(audfx[44])
				clickT = fps / 4
				stack()
			}
		}
	} else {
		rl.DrawRectangleRec(rec2, rl.Orange)
		rl.DrawRectangleLinesEx(rec2, 4, rl.Black)
		txt := "stack"
		txs := tx3
		txlen := rl.MeasureText(txt, txs)
		ytx := rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
		xtx := rec2.ToInt32().X + rec2.ToInt32().Width/2 - txlen/2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)
	}
	//PACK
	rec2.X += rec2.Width + b/4
	if rl.CheckCollisionPointRec(cursorV2camInven, rec2) {
		rl.DrawRectangleRec(rec2, DarkRed())
		rl.DrawRectangleLinesEx(rec2, 4, rl.Black)
		txt := "pack"
		txs := tx3
		txlen := rl.MeasureText(txt, txs)
		ytx := rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
		xtx := rec2.ToInt32().X + rec2.ToInt32().Width/2 - txlen/2
		rl.DrawText(txt, xtx, ytx, txs, rl.White)
		if clickT == 0 {
			if inpL {
				rl.PlaySound(audfx[44])
				clickT = fps / 4
				pack()
			}
		}
	} else {
		rl.DrawRectangleRec(rec2, rl.Orange)
		rl.DrawRectangleLinesEx(rec2, 4, rl.Black)
		txt := "pack"
		txs := tx3
		txlen := rl.MeasureText(txt, txs)
		ytx := rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
		xtx := rec2.ToInt32().X + rec2.ToInt32().Width/2 - txlen/2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)
	}
	//INVEN MOUSE OVER DISPLAY TXT
	if invDisTxtT > 0 {
		y = rec2.Y + rec2.Height
		ytx := int32(y + be)
		txs := tx4
		spc2 := tx
		txlen := rl.MeasureText(disTxt1, txs)
		xtx := int32(cnt.X) - txlen/2
		rl.DrawText(disTxt1, xtx-3, ytx+3, txs, rl.DarkPurple)
		rl.DrawText(disTxt1, xtx-3, ytx+3, txs, rl.Black)
		rl.DrawText(disTxt1, xtx, ytx, txs, rl.White)
		ytx += txs + spc2
		txlen = rl.MeasureText(disTxt2, txs)
		xtx = int32(cnt.X) - txlen/2
		rl.DrawText(disTxt2, xtx-3, ytx+3, txs, rl.DarkPurple)
		rl.DrawText(disTxt2, xtx-3, ytx+3, txs, rl.Black)
		rl.DrawText(disTxt2, xtx, ytx, txs, rl.White)
	}
	y = rec2.Y + rec2.Height + b3 + bq
	//MARK: DRAW STATS
	bgtxrec = rl.NewRectangle(optionsRec.X, y, optionsRec.Width, b10)
	rl.DrawRectangleRec(bgtxrec, rl.Black)
	rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Orange)
	rl.DrawText(">> stats", optionsRec.ToInt32().X+tx3, bgtxrec.ToInt32().Y+tx, tx5, rl.Orange)
	x = optionsRec.X
	x += b / 4
	xtx = int32(x + b)
	ytx = int32(y + b2 + bq)
	txs := tx3
	spc2 := tx
	txt := "perception > " + fmt.Sprint(stats.per) + " > discover secrets+"
	txlen := rl.MeasureText(txt, txs)
	xtx = int32(cnt.X) - txlen/2
	rl.DrawText(txt, xtx, ytx, txs, rl.Orange)
	ytx += txs + spc2
	txt = "critical > " + fmt.Sprint(stats.crit) + " > x2 damage chance+"
	txlen = rl.MeasureText(txt, txs)
	xtx = int32(cnt.X) - txlen/2
	rl.DrawText(txt, xtx, ytx, txs, rl.Orange)
	ytx += txs + spc2
	txt = "dexterity > " + fmt.Sprint(stats.dex) + " > dodge chance+"
	txlen = rl.MeasureText(txt, txs)
	xtx = int32(cnt.X) - txlen/2
	rl.DrawText(txt, xtx, ytx, txs, rl.Orange)
	ytx += txs + spc2
	txt = "intelligence > " + fmt.Sprint(stats.int) + " > magic power+"
	txlen = rl.MeasureText(txt, txs)
	xtx = int32(cnt.X) - txlen/2
	rl.DrawText(txt, xtx, ytx, txs, rl.Orange)
	ytx += txs + spc2
	txt = "luck > " + fmt.Sprint(stats.luk) + " > find more loot+"
	txlen = rl.MeasureText(txt, txs)
	xtx = int32(cnt.X) - txlen/2
	rl.DrawText(txt, xtx, ytx, txs, rl.Orange)
	ytx += txs + spc2
	txt = "strength > " + fmt.Sprint(stats.str) + " > damage+"
	txlen = rl.MeasureText(txt, txs)
	xtx = int32(cnt.X) - txlen/2
	rl.DrawText(txt, xtx, ytx, txs, rl.Orange)
	//MARK: DRAW WEAPON MENU
	if inWeapMenuOn {
		rl.DrawRectangleRec(inMenuRec, rl.Magenta)
		rl.DrawRectangleRec(inMenuRec, rl.Fade(rl.Black, 0.7))
		rl.DrawRectangleLinesEx(inMenuRec, 4, rl.Fade(rl.Purple, 0.7))
		if !rl.CheckCollisionPointRec(cursorV2camInven, inMenuRec) {
			inMenuExitT++
			if inMenuExitT >= (fps/3)*2 {
				inMenuExitT = 0
				inWeapMenuOn = false
			}
		} else {
			inMenuExitT = 0
		}
		xtx := int32(inMenuRec.X) + 12
		ytx := int32(inMenuRec.Y) + 12
		txs := tx3
		txrecy := float32(ytx) - 2
		for i := 0; i < 4; i++ {
			txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
			if rl.CheckCollisionPointRec(cursorV2camInven, txrec) {
				rl.DrawRectangleRec(txrec, RandColor())
				if inpL {
					switch i {
					case 0: //MOVE TO SLOT 1
						if pl.wp1.nm == "" {
							pl.wp1 = pl.weaps[inMenuItm]
							pl.weaps[inMenuItm] = xweap{}
							inWeapMenuOn = false
						} else {
							changeWeap := pl.wp1
							pl.wp1 = pl.weaps[inMenuItm]
							pl.weaps[inMenuItm] = changeWeap
							inWeapMenuOn = false
						}
					case 1: //MOVE TO SLOT 2
						if pl.wp2.nm == "" {
							pl.wp2 = pl.weaps[inMenuItm]
							pl.weaps[inMenuItm] = xweap{}
							inWeapMenuOn = false
						} else {
							changeWeap := pl.wp2
							pl.wp2 = pl.weaps[inMenuItm]
							pl.weaps[inMenuItm] = changeWeap
							inWeapMenuOn = false
						}
					case 2: //INFO
						invInfoT = fps
						invenInfo = true
						weapInfon = true
						inWeapMenuOn = false
					case 3: //DROP
						if !baseon {
							dropweap(inMenuItm, 0)
							inWeapMenuOn = false
						} else {
							disTxt1 = "cannot drop"
							disTxt2 = "items at camp"
							invDisTxtT = fps * 2
						}
					}
				}
			}
			txrecy += txrec.Height
		}
		rl.DrawText("slot 1", xtx, ytx, txs, rl.Black)
		ytx += txs + 4
		rl.DrawText("slot 2", xtx, ytx, txs, rl.Black)
		ytx += txs + 4
		rl.DrawText("info", xtx, ytx, txs, rl.Black)
		ytx += txs + 4
		rl.DrawText("drop", xtx, ytx, txs, rl.Black)
	}

	if clickT == 0 {
		if inpR {
			clickT = fps / 3
			inWeapMenuOn = false
		}
	}

	//MARK: DRAW INVEN MENU
	if inMenuOn {
		rl.DrawRectangleRec(inMenuRec, rl.Magenta)
		rl.DrawRectangleRec(inMenuRec, rl.Fade(rl.Black, 0.7))
		rl.DrawRectangleLinesEx(inMenuRec, 4, rl.Fade(rl.Purple, 0.7))
		if !rl.CheckCollisionPointRec(cursorV2camInven, inMenuRec) {
			inMenuExitT++
			if inMenuExitT >= (fps/3)*2 {
				inMenuExitT = 0
				inMenuOn = false
			}
		} else {
			inMenuExitT = 0
		}
		xtx := int32(inMenuRec.X) + 12
		ytx := int32(inMenuRec.Y) + 12
		txs := tx3
		txrecy := float32(ytx) - 2
		if pl.invn[inMenuItm].notquick { //COMPONENTS MENU
			if pl.invn[inMenuItm].numof > 1 {
				checkNum := 4
				if inchest {
					checkNum = 5
				}
				for i := 0; i < checkNum; i++ {
					txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
					if rl.CheckCollisionPointRec(cursorV2camInven, txrec) {
						rl.DrawRectangleRec(txrec, RandColor())
						if inpL {
							switch i {
							case 0: //DROP
								if !baseon {
									rl.PlaySound(audfx[40])
									dropitm(inMenuItm, 0)
									inMenuOn = false
								} else {
									rl.PlaySound(audfx[43])
									disTxt1 = "cannot drop"
									disTxt2 = "items at camp"
									invDisTxtT = fps * 2
									inMenuOn = false
								}
							case 1: //INFO
								rl.PlaySound(audfx[40])
								invInfoT = fps
								invenInfo = true
								inMenuOn = false
							case 2: //SCRAP
								rl.PlaySound(audfx[40])
								num := pl.invn[inMenuItm].numof
								pl.invn[inMenuItm] = xitm{}
								pl.invn[inMenuItm].nm = ""
								found := false
								for j := 0; j < len(pl.invn); j++ {
									if j != inMenuItm {
										if pl.invn[j].nm == "scrap" {
											pl.invn[j].numof += num
											found = true
											break
										}
									}
								}
								if !found {
									pl.invn[inMenuItm] = itmlist[43]
									pl.invn[inMenuItm].numof = num
								}
								inMenuOn = false
							case 3: //SPLIT
								rl.PlaySound(audfx[40])
								if nxInvnNum != blankint {
									num1, num2 := 0, 0
									if pl.invn[inMenuItm].numof%2 == 0 {
										num1 = pl.invn[inMenuItm].numof / 2
										num2 = num1
									} else {
										num2 = pl.invn[inMenuItm].numof / 2
										num1 = num2 + 1
									}
									newItm := pl.invn[inMenuItm]
									newItm.numof = num1
									pl.invn[inMenuItm].numof = num2
									pl.invn[nxInvnNum] = newItm
									findnxinvnum()
								} else {
									rl.PlaySound(audfx[43])
									admsg("no free inventory slots", rl.Red)
								}
								inMenuOn = false
							case 4: //MOVE TO CHEST
								found := false
								for j := 0; j < len(levels[levNum].chst[0].itm); j++ {
									if levels[levNum].chst[0].itm[j].nm == pl.invn[inMenuItm].nm {
										levels[levNum].chst[0].itm[j].numof += pl.invn[inMenuItm].numof
										pl.invn[inMenuItm] = xitm{}
										found = true
										inMenuOn = false
										break
									}
								}
								if !found {
									canmove, num := checkChestSlots()
									if canmove {
										rl.PlaySound(audfx[40])
										levels[levNum].chst[0].itm[num] = pl.invn[inMenuItm]
										pl.invn[inMenuItm] = xitm{}
										inMenuOn = false
									} else {
										rl.PlaySound(audfx[43])
										admsg("no free chest slots", rl.Red)
										inMenuOn = false
									}
								}
							}
						}
					}
					txrecy += txrec.Height
				}
				rl.DrawText("drop", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("info", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("scrap", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("split", xtx, ytx, txs, rl.Black)
				if inchest {
					ytx += txs + 4
					rl.DrawText("> chest", xtx, ytx, txs, rl.Black)
				}
			} else {
				checkNum := 3
				if inchest {
					checkNum = 4
				}
				for i := 0; i < checkNum; i++ {
					txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
					if rl.CheckCollisionPointRec(cursorV2camInven, txrec) {
						rl.DrawRectangleRec(txrec, RandColor())
						if inpL {
							switch i {
							case 0: //DROP
								if !baseon {
									rl.PlaySound(audfx[40])
									dropitm(inMenuItm, 0)
									inMenuOn = false
								} else {
									rl.PlaySound(audfx[43])
									disTxt1 = "cannot drop"
									disTxt2 = "items at camp"
									invDisTxtT = fps * 2
									inMenuOn = false
								}
							case 1: //INFO
								rl.PlaySound(audfx[40])
								invInfoT = fps
								invenInfo = true
								inMenuOn = false
							case 2: //SCRAP
								rl.PlaySound(audfx[40])
								num := pl.invn[inMenuItm].numof
								pl.invn[inMenuItm] = xitm{}
								pl.invn[inMenuItm].nm = ""
								found := false
								for j := 0; j < len(pl.invn); j++ {
									if j != inMenuItm {
										if pl.invn[j].nm == "scrap" {
											pl.invn[j].numof += num
											found = true
											break
										}
									}
								}
								if !found {
									pl.invn[inMenuItm] = itmlist[43]
									pl.invn[inMenuItm].numof = num
								}
								inMenuOn = false
							case 3: //MOVE TO CHEST
								found := false
								for j := 0; j < len(levels[levNum].chst[0].itm); j++ {
									if levels[levNum].chst[0].itm[j].nm == pl.invn[inMenuItm].nm {
										levels[levNum].chst[0].itm[j].numof += pl.invn[inMenuItm].numof
										pl.invn[inMenuItm] = xitm{}
										found = true
										inMenuOn = false
										break
									}
								}
								if !found {
									canmove, num := checkChestSlots()
									if canmove {
										rl.PlaySound(audfx[40])
										levels[levNum].chst[0].itm[num] = pl.invn[inMenuItm]
										pl.invn[inMenuItm] = xitm{}
										inMenuOn = false
									} else {
										rl.PlaySound(audfx[43])
										admsg("no free chest slots", rl.Red)
										inMenuOn = false
									}
								}
							}
						}
					}
					txrecy += txrec.Height
				}
				rl.DrawText("drop", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("info", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("scrap", xtx, ytx, txs, rl.Black)
				if inchest {
					ytx += txs + 4
					rl.DrawText("> chest", xtx, ytx, txs, rl.Black)
				}
			}
		} else { //OTHER ITEMS MENU
			if pl.invn[inMenuItm].numof > 1 {
				checkNum := 5
				if inchest {
					checkNum = 6
				}
				for i := 0; i < checkNum; i++ {
					txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
					if rl.CheckCollisionPointRec(cursorV2camInven, txrec) {
						rl.DrawRectangleRec(txrec, RandColor())
						if inpL {
							switch i {
							case 0: //USE
								if pl.invn[inMenuItm].nm == "map" && !treasureroom {
									rl.PlaySound(audfx[40])
									treasureroom = true
									if pl.invn[inMenuItm].numof > 1 {
										pl.invn[inMenuItm].numof--
									} else {
										pl.invn[inMenuItm] = xitm{}
									}
									inMenuOn = false
								} else if pl.invn[inMenuItm].nm == "map" && treasureroom {
									rl.PlaySound(audfx[43])
									disTxt1 = "treasure map is"
									disTxt2 = "already active"
									invDisTxtT = fps * 2
									inMenuOn = false
								} else {
									if !baseon {
										rl.PlaySound(audfx[40])
										useitm(inMenuItm, 0)
										inMenuOn = false
									} else {
										rl.PlaySound(audfx[43])
										disTxt1 = "cannot use"
										disTxt2 = "items at camp"
										invDisTxtT = fps * 2
										inMenuOn = false
									}
								}
							case 1: //DROP
								if !baseon {
									rl.PlaySound(audfx[40])
									dropitm(inMenuItm, 0)
								} else {
									rl.PlaySound(audfx[43])
									disTxt1 = "cannot drop"
									disTxt2 = "items at camp"
									invDisTxtT = fps * 2
								}
								inMenuOn = false
							case 2: //INFO
								rl.PlaySound(audfx[40])
								invInfoT = fps
								invenInfo = true
								inMenuOn = false
							case 3: //SCRAP
								rl.PlaySound(audfx[40])
								num := pl.invn[inMenuItm].numof
								pl.invn[inMenuItm] = xitm{}
								pl.invn[inMenuItm].nm = ""
								found := false
								for j := 0; j < len(pl.invn); j++ {
									if j != inMenuItm {
										if pl.invn[j].nm == "scrap" {
											pl.invn[j].numof += num
											found = true
											break
										}
									}
								}
								if !found {
									pl.invn[inMenuItm] = itmlist[43]
									pl.invn[inMenuItm].numof = num
								}
								inMenuOn = false
							case 4: //SPLIT
								if nxInvnNum != blankint {
									rl.PlaySound(audfx[40])
									num1, num2 := 0, 0
									if pl.invn[inMenuItm].numof%2 == 0 {
										num1 = pl.invn[inMenuItm].numof / 2
										num2 = num1
									} else {
										num2 = pl.invn[inMenuItm].numof / 2
										num1 = num2 + 1
									}
									newItm := pl.invn[inMenuItm]
									newItm.numof = num1
									pl.invn[inMenuItm].numof = num2
									pl.invn[nxInvnNum] = newItm
									findnxinvnum()
									inMenuOn = false
								} else {
									inMenuOn = false
									rl.PlaySound(audfx[43])
									admsg("no free inventory slots", rl.Red)
								}
							case 5: //MOVE TO CHEST
								found := false
								for j := 0; j < len(levels[levNum].chst[0].itm); j++ {
									if levels[levNum].chst[0].itm[j].nm == pl.invn[inMenuItm].nm {
										levels[levNum].chst[0].itm[j].numof += pl.invn[inMenuItm].numof
										pl.invn[inMenuItm] = xitm{}
										found = true
										inMenuOn = false
										break
									}
								}
								if !found {
									canmove, num := checkChestSlots()
									if canmove {
										rl.PlaySound(audfx[40])
										levels[levNum].chst[0].itm[num] = pl.invn[inMenuItm]
										pl.invn[inMenuItm] = xitm{}
										inMenuOn = false
									} else {
										rl.PlaySound(audfx[43])
										admsg("no free chest slots", rl.Red)
										inMenuOn = false
									}
								}
							}
						}
					}
					txrecy += txrec.Height
				}
				rl.DrawText("use", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("drop", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("info", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("scrap", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("split", xtx, ytx, txs, rl.Black)
				if inchest {
					ytx += txs + 4
					rl.DrawText("> chest", xtx, ytx, txs, rl.Black)
				}
			} else {
				checkNum := 4
				if inchest {
					checkNum = 5
				}
				for i := 0; i < checkNum; i++ {
					txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
					if rl.CheckCollisionPointRec(cursorV2camInven, txrec) {
						rl.DrawRectangleRec(txrec, RandColor())
						if inpL {
							switch i {
							case 0: //USE
								if pl.invn[inMenuItm].nm == "map" && !treasureroom {
									rl.PlaySound(audfx[40])
									treasureroom = true
									if pl.invn[inMenuItm].numof > 1 {
										pl.invn[inMenuItm].numof--
									} else {
										pl.invn[inMenuItm] = xitm{}
									}
									inMenuOn = false
								} else if pl.invn[inMenuItm].nm == "map" && treasureroom {
									rl.PlaySound(audfx[43])
									disTxt1 = "treasure map is"
									disTxt2 = "already active"
									invDisTxtT = fps * 2
									inMenuOn = false
								} else {
									if !baseon {
										rl.PlaySound(audfx[40])
										useitm(inMenuItm, 0)
										inMenuOn = false
									} else {
										rl.PlaySound(audfx[43])
										disTxt1 = "cannot use"
										disTxt2 = "items at camp"
										invDisTxtT = fps * 2
										inMenuOn = false
									}
								}
							case 1: //DROP
								if !baseon {
									rl.PlaySound(audfx[40])
									dropitm(inMenuItm, 0)
									inMenuOn = false
								} else {
									rl.PlaySound(audfx[43])
									disTxt1 = "cannot drop"
									disTxt2 = "items at camp"
									invDisTxtT = fps * 2
									inMenuOn = false
								}
							case 2: //INFO
								rl.PlaySound(audfx[40])
								invInfoT = fps
								invenInfo = true
								inMenuOn = false
							case 3: //SCRAP
								rl.PlaySound(audfx[40])
								num := pl.invn[inMenuItm].numof
								pl.invn[inMenuItm] = xitm{}
								pl.invn[inMenuItm].nm = ""
								found := false
								for j := 0; j < len(pl.invn); j++ {
									if j != inMenuItm {
										if pl.invn[j].nm == "scrap" {
											pl.invn[j].numof += num
											found = true
											break
										}
									}
								}
								if !found {
									pl.invn[inMenuItm] = itmlist[43]
									pl.invn[inMenuItm].numof = num
								}
								inMenuOn = false
							case 4: //MOVE TO CHEST
								found := false
								for j := 0; j < len(levels[levNum].chst[0].itm); j++ {
									if levels[levNum].chst[0].itm[j].nm == pl.invn[inMenuItm].nm {
										levels[levNum].chst[0].itm[j].numof += pl.invn[inMenuItm].numof
										pl.invn[inMenuItm] = xitm{}
										found = true
										inMenuOn = false
										break
									}
								}
								if !found {
									canmove, num := checkChestSlots()
									if canmove {
										rl.PlaySound(audfx[40])
										levels[levNum].chst[0].itm[num] = pl.invn[inMenuItm]
										pl.invn[inMenuItm] = xitm{}
										inMenuOn = false
									} else {
										rl.PlaySound(audfx[43])
										admsg("no free chest slots", rl.Red)
										inMenuOn = false
									}
								}
							}
						}
					}
					txrecy += txrec.Height
				}
				rl.DrawText("use", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("drop", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("info", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("scrap", xtx, ytx, txs, rl.Black)
				if inchest {
					ytx += txs + 4
					rl.DrawText("> chest", xtx, ytx, txs, rl.Black)
				}
			}
		}
		if clickT == 0 {
			if inpR {
				clickT = fps / 3
				inMenuOn = false
			}
		}
	}
	//MARK: DRAW INVEN INFO
	if invenInfo {

		invInfoT++
		if invInfoT > fps*2 {
			invInfoT = fps
		}
		//BG REC
		rl.DrawRectangleRec(optionsRec, rl.Magenta)
		bgtxrec := rl.NewRectangle(optionsRec.X, optionsRec.Y+b/2, optionsRec.Width, b2+b/4)
		rl.DrawRectangleRec(bgtxrec, rl.Orange)
		rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
		closeY := bgtxrec.Y
		closeH := bgtxrec.Height
		//IMG
		irec := rl.NewRectangle(optionsRec.X+optionsRec.Width/4, b3+b/2, optionsRec.Width/2, optionsRec.Width/2)
		rl.DrawRectangleRec(irec, rl.Fade(rl.Black, 0.8))
		rl.DrawRectangleLinesEx(irec, 8, rl.Black)
		irec.X += b
		irec.Y += b
		irec.Width -= b2
		irec.Height -= b2
		if weapInfon {
			rl.DrawTexturePro(imgs, pl.weaps[inMenuItm].img, shrec(irec, 8), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, pl.weaps[inMenuItm].img, irec, rl.Vector2Zero(), 0, rl.White)
		} else {
			rl.DrawTexturePro(imgs, pl.invn[inMenuItm].img, shrec(irec, 8), rl.Vector2Zero(), 0, shcol())
			rl.DrawTexturePro(imgs, pl.invn[inMenuItm].img, irec, rl.Vector2Zero(), 0, rl.White)
		}
		//TITLE TX
		txs := tx4
		if weapInfon {
			txlen := rl.MeasureText(pl.weaps[inMenuItm].nm, txs)
			xtx := int32(cnt.X) - txlen/2
			ytx := bgtxrec.ToInt32().Y + bgtxrec.ToInt32().Height/2 - txs/2
			rl.DrawText(pl.weaps[inMenuItm].nm, xtx, ytx, txs, rl.Black)
		} else {
			txlen := rl.MeasureText(pl.invn[inMenuItm].nm, txs)
			xtx := int32(cnt.X) - txlen/2
			ytx := bgtxrec.ToInt32().Y + bgtxrec.ToInt32().Height/2 - txs/2
			rl.DrawText(pl.invn[inMenuItm].nm, xtx, ytx, txs, rl.Black)
		}

		//DESC
		txs = tx4
		if weapInfon {
			txlen = rl.MeasureText(pl.weaps[inMenuItm].des, txs)
			xtx = int32(cnt.X) - txlen/2
			ytx = irec.ToInt32().Y + irec.ToInt32().Height + tx6
			bgtxrec.Y = float32(ytx) - 4
			bgtxrec.Height = float32(txs) + 12
			rl.DrawRectangleRec(bgtxrec, rl.Orange)
			rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
			rl.DrawText(pl.weaps[inMenuItm].des, xtx, ytx, txs, rl.Black)
		} else {
			txlen = rl.MeasureText(pl.invn[inMenuItm].des, txs)
			xtx = int32(cnt.X) - txlen/2
			ytx = irec.ToInt32().Y + irec.ToInt32().Height + tx6
			bgtxrec.Y = float32(ytx) - 4
			bgtxrec.Height = float32(txs) + 12
			rl.DrawRectangleRec(bgtxrec, rl.Orange)
			rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
			rl.DrawText(pl.invn[inMenuItm].des, xtx, ytx, txs, rl.Black)
		}

		bgtxrec = rl.NewRectangle(optionsRec.X, bgtxrec.Y+bgtxrec.Height+b/2, optionsRec.Width, b10+b/2)
		rl.DrawRectangleRec(bgtxrec, rl.Black)
		rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Orange)
		rl.DrawText(">> more info...", optionsRec.ToInt32().X+tx3, bgtxrec.ToInt32().Y+tx, tx5, rl.Orange)

		//SEE DRAW NO RENDER FOR OTHER TXT

		txs = tx2
		ytx = int32(bgtxrec.Y) + tx5

		//DESC
		if weapInfon {
			if pl.weaps[inMenuItm].des2 != "" {
				txlen := rl.MeasureText(pl.weaps[inMenuItm].des2, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += tx5
				rl.DrawText(pl.weaps[inMenuItm].des2, xtx, ytx, txs, rl.Yellow)
			}
			if pl.weaps[inMenuItm].des3 != "" {
				txlen := rl.MeasureText(pl.weaps[inMenuItm].des3, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(pl.weaps[inMenuItm].des3, xtx, ytx, txs, rl.Yellow)
			}
			if pl.weaps[inMenuItm].des4 != "" {
				txlen := rl.MeasureText(pl.weaps[inMenuItm].des4, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(pl.weaps[inMenuItm].des4, xtx, ytx, txs, rl.Yellow)
			}
			if pl.weaps[inMenuItm].des5 != "" {
				txlen := rl.MeasureText(pl.weaps[inMenuItm].des5, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(pl.weaps[inMenuItm].des5, xtx, ytx, txs, rl.Yellow)
			}
			if pl.weaps[inMenuItm].des6 != "" {
				txlen := rl.MeasureText(pl.weaps[inMenuItm].des6, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(pl.weaps[inMenuItm].des6, xtx, ytx, txs, rl.Yellow)
			}
			if pl.weaps[inMenuItm].des7 != "" {
				txt2 := "dmg > " + fmt.Sprint(pl.weaps[inMenuItm].dmg)
				if pl.weaps[inMenuItm].spec1 != 0 {
					switch pl.weaps[inMenuItm].spec1 {
					case 1:
						txt2 = txt2 + " +lightning"
					case 2:
						txt2 = txt2 + " +arrows"
					case 3:
						txt2 = txt2 + " +fireworks"
					case 4:
						txt2 = txt2 + " +turret"
					case 5:
						txt2 = txt2 + " +bomb"
					case 6:
						txt2 = txt2 + " +rocket"
					case 7:
						txt2 = txt2 + " +attack speed"
					case 8:
						txt2 = txt2 + " +potion"
					case 9:
						txt2 = txt2 + " +double xp"
					case 10:
						txt2 = txt2 + " +ring of fire"
					case 11:
						txt2 = txt2 + " +sludge geyser"
					}
				}
				if pl.weaps[inMenuItm].spec2 != 0 {
					switch pl.weaps[inMenuItm].spec2 {
					case 1:
						txt2 = txt2 + " +lightning"
					case 2:
						txt2 = txt2 + " +arrows"
					case 3:
						txt2 = txt2 + " +fireworks"
					case 4:
						txt2 = txt2 + " +turret"
					case 5:
						txt2 = txt2 + " +bomb"
					case 6:
						txt2 = txt2 + " +rocket"
					case 7:
						txt2 = txt2 + " +attack speed"
					case 8:
						txt2 = txt2 + " +potion"
					case 9:
						txt2 = txt2 + " +double xp"
					case 10:
						txt2 = txt2 + " +ring of fire"
					case 11:
						txt2 = txt2 + " +sludge geyser"
					}
				}
				txlen := rl.MeasureText(txt2, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(txt2, xtx, ytx, txs, rl.Yellow)
			}
		} else {
			if pl.invn[inMenuItm].des2 != "" {
				txlen := rl.MeasureText(pl.invn[inMenuItm].des2, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(pl.invn[inMenuItm].des2, xtx, ytx, txs, rl.Yellow)
			}
			if pl.invn[inMenuItm].des3 != "" {
				txlen := rl.MeasureText(pl.invn[inMenuItm].des3, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(pl.invn[inMenuItm].des3, xtx, ytx, txs, rl.Yellow)
			}
			if pl.invn[inMenuItm].des4 != "" {
				txlen := rl.MeasureText(pl.invn[inMenuItm].des4, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(pl.invn[inMenuItm].des4, xtx, ytx, txs, rl.Yellow)
			}
			if pl.invn[inMenuItm].des5 != "" {
				txlen := rl.MeasureText(pl.invn[inMenuItm].des5, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(pl.invn[inMenuItm].des5, xtx, ytx, txs, rl.Yellow)
			}
			if pl.invn[inMenuItm].des6 != "" {
				txlen := rl.MeasureText(pl.invn[inMenuItm].des6, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(pl.invn[inMenuItm].des6, xtx, ytx, txs, rl.Yellow)
			}
			if pl.invn[inMenuItm].des7 != "" {
				txlen := rl.MeasureText(pl.invn[inMenuItm].des7, txs)
				xtx := int32(cnt.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(pl.invn[inMenuItm].des7, xtx, ytx, txs, rl.Yellow)
			}
		}

		//EXIT
		if inpR {
			invenInfo = false
			weapInfon = false
			inMenuOn = false
			inWeapMenuOn = false
		}
		//CLOSE REC
		siz2 := closeH
		closerec := rl.NewRectangle(optionsRec.X+optionsRec.Width-siz2, closeY, siz2, siz2)
		closerec.X += 16
		closerec.Y += 16
		closerec.Width -= 32
		closerec.Height -= 32
		v1 := rl.NewVector2(closerec.X, closerec.Y)
		v1.X += 8
		v1.Y += 8
		v2 := v1
		v2.X += closerec.Width - 16
		v3 := v2
		v3.Y += closerec.Width - 16
		v4 := v3
		v4.X -= closerec.Width - 16
		if rl.CheckCollisionPointRec(cursorV2camInven, closerec) {
			rl.DrawRectangleRec(closerec, DarkRed())
			rl.DrawLineEx(v1, v3, 4, rl.Black)
			rl.DrawLineEx(v2, v4, 4, rl.Black)
			if clickT == 0 {
				if inpL {
					rl.PlaySound(audfx[41])
					clickT = fps / 4
					invInfoT = fps / 2
					weapInfon = false
					invenInfo = false
					inMenuOn = false
					inWeapMenuOn = false
				}
			}
		} else {
			rl.DrawRectangleRec(closerec, rl.Black)
			rl.DrawLineEx(v1, v3, 4, rl.Orange)
			rl.DrawLineEx(v2, v4, 4, rl.Orange)
		}
	}
	if rl.IsGamepadButtonPressed(0, 6) {
		rl.PlaySound(audfx[41])
		clickT = fps / 4
		invInfoT = fps / 2
		weapInfon = false
		invenInfo = false
		inMenuOn = false
		inWeapMenuOn = false
	}
	rl.EndMode2D()
}
func drawDebug() { //MARK:DRAW DEBUG
	siderec := rl.NewRectangle(0, 0, 300, scrHF32)
	rl.DrawRectangleRec(siderec, rl.Fade(DarkRed(), 0.3))
	txtX, txtY := tx, tx
	rl.DrawText("levels[levNum].enm[0].dirX"+" "+fmt.Sprint(levels[levNum].enm[0].dirX), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("levels[levNum].enm[0].dirY"+" "+fmt.Sprint(levels[levNum].enm[0].dirY), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("tvT"+" "+fmt.Sprint(tvT), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("bosson"+" "+fmt.Sprint(bosson), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("xxl"+" "+fmt.Sprint(xxl), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("xl"+" "+fmt.Sprint(xl), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("lrg"+" "+fmt.Sprint(lrg), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("med"+" "+fmt.Sprint(med), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("camBoss.Zoom"+" "+fmt.Sprint(camBoss.Zoom), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("camBase.Zoom"+" "+fmt.Sprint(camBase.Zoom), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("cam2.Zoom"+" "+fmt.Sprint(cam2.Zoom), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("camInven.Zoom"+" "+fmt.Sprint(camInven.Zoom), txtX, txtY, tx, rl.White)
	txtY += tx
	txt2 := fmt.Sprintf("%.2f", stickMov)
	txt2 = strings.TrimLeft(txt2, "0.")
	rl.DrawText("stickMov"+" "+txt2, txtX, txtY, tx, rl.White)
	txtY += tx
	if len(levels[levNum].enm) > 0 {
		rl.DrawText("len(levels[levNum].enm)"+" "+fmt.Sprint(len(levels[levNum].enm)), txtX, txtY, tx, rl.White)
		txtY += tx
	}
	rl.DrawText("scrWF32"+" "+fmt.Sprint(scrWF32), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("scrHF32"+" "+fmt.Sprint(scrHF32), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("poisongasCount"+" "+fmt.Sprint(poisongasCount), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("maxWeapDmg"+" "+fmt.Sprint(maxWeapDmg), txtX, txtY, tx, rl.White)
	txtY += tx

	rl.DrawFPS(int32(b/4), scrH32-int32(b))

	rl.DrawCircleV(cnt, 8, RandColor())
}

// MARK: CHECK CHECK CHECK CHECK CHECK CHECK CHECK CHECK CHECK CHECK CHECK CHECK CHECK CHECK
func checkV2chest(v2 rl.Vector2) bool { //MARK: CHECK V2 IN CHEST
	canadd := true
	if rl.CheckCollisionPointRec(v2, levels[levNum].chst[0].rec) {
		canadd = false
	}
	return canadd
}
func checkmovemouse() bool { //MARK: CHECK MOVE MOUSE
	canmove := true
	checkrec := base.mouse.rec
	checkrec.X += base.mouse.dirX
	checkrec.Y += base.mouse.dirY
	for i := 0; i < len(base.crec); i++ {
		if rl.CheckCollisionRecs(checkrec, base.crec[i]) {
			canmove = false
		}
	}
	v1 := rl.NewVector2(checkrec.X, checkrec.Y)
	v2 := v1
	v2.X += checkrec.Width
	v3 := v2
	v3.Y += checkrec.Height
	v4 := v3
	v4.X -= checkrec.Width
	if !rl.CheckCollisionPointRec(v1, baseBordRec) || !rl.CheckCollisionPointRec(v2, baseBordRec) || !rl.CheckCollisionPointRec(v3, baseBordRec) || !rl.CheckCollisionPointRec(v4, baseBordRec) {
		canmove = false
	}
	return canmove
}
func checkWeapWeap(rec rl.Rectangle) bool { //MARK: CHECK WEAP VS WEAP
	canadd := true
	for i := 0; i < len(levels[levNum].weaps); i++ {
		if rl.CheckCollisionRecs(rec, levels[levNum].weaps[i].rec) {
			canadd = false
		}
	}
	return canadd
}
func checkRecEtc(rec rl.Rectangle) bool { //MARK: CHECK ETC VS ETC
	canadd := true
	for i := 0; i < len(levels[levNum].etc); i++ {
		if rl.CheckCollisionRecs(rec, levels[levNum].etc[i].rec) {
			canadd = false
		}
	}
	return canadd
}
func checkRecDoors(rec rl.Rectangle) bool { //MARK: CHECK REC DOORS
	canadd := true
	for i := 0; i < len(levels[levNum].doors); i++ {
		if rl.CheckCollisionRecs(rec, levels[levNum].doors[i]) {
			canadd = false
		}
	}
	return canadd
}
func checkRecSolid(rec rl.Rectangle) bool { //MARK: CHECK REC VS ETC SOLID
	canadd := true
	for i := 0; i < len(levels[levNum].etc); i++ {
		if levels[levNum].etc[i].solid {
			if rl.CheckCollisionRecs(rec, levels[levNum].etc[i].rec) {
				canadd = false
				break
			}
		}
	}
	return canadd
}
func checkV2water(v2 rl.Vector2) bool { //MARK: CHECK V2 WATER
	canadd := true
	for i := 0; i < len(levels[levNum].etc); i++ {
		if levels[levNum].etc[i].nm == "water" {
			if rl.CheckCollisionPointRec(v2, levels[levNum].etc[i].rec2) {
				canadd = false
				break
			}
		}
	}
	return canadd
}
func checkV2inRooms(v2 rl.Vector2) bool { //MARK: CHECK V2 IS IN ROOM RECS
	canadd := false
	for i := 0; i < len(levels[levNum].recs); i++ {
		if rl.CheckCollisionPointRec(v2, levels[levNum].recs[i]) {
			canadd = true
			break
		}
	}
	return canadd
}
func checkV2Walls(v2 rl.Vector2) bool { //MARK: CHECK V2 WALLS
	canadd := true
	for i := 0; i < len(levels[levNum].walls); i++ {
		if rl.CheckCollisionPointRec(v2, levels[levNum].walls[i].rec) {
			canadd = false
			break
		}
	}
	return canadd
}
func checkV2WallsLev(v2 rl.Vector2, lev x1scr) bool { //MARK: CHECK V2 WALLS X1SCR LEV
	canadd := true
	for i := 0; i < len(lev.walls); i++ {
		if rl.CheckCollisionPointRec(v2, lev.walls[i].rec) {
			canadd = false
			break
		}
	}
	return canadd
}
func checkMoveEnm(num int) bool { //MARK: CHECK MOVE ENEMY
	canmove := true
	if levels[levNum].enm[num].nm == "bird" || levels[levNum].enm[num].nm == "fly" || levels[levNum].enm[num].nm == "balloon" {
		v2 := levels[levNum].enm[num].cnt
		v2.X += levels[levNum].enm[num].dirX + delta
		v2.Y += levels[levNum].enm[num].dirY + delta
		canmove2 := false
		for i := 0; i < len(levels[levNum].recs); i++ {
			if rl.CheckCollisionPointRec(v2, levels[levNum].recs[i]) {
				canmove2 = true
			}
		}
		canmove = canmove2
	} else {
		rec := levels[levNum].enm[num].crec
		rec.X += levels[levNum].enm[num].dirX + delta
		rec.Y += levels[levNum].enm[num].dirY + delta
		if canmove && !levels[levNum].enm[num].fly {
			canmove, _ = checkRecEtcSolid(rec)
		}
		if canmove {
			canmove = checkRecWalls(rec)
		}
	}
	return canmove
}
func checkArtSameItm(itm xitm) (found bool, numSame int) { //MARK:CHECK ART SAME ITM
	numSame = 0
	found = false
	for i := 0; i < len(pl.art); i++ {
		if pl.art[i].nm == itm.nm {
			found = true
			numSame = i
			break
		}
	}
	return found, numSame
}
func checkInvnSameItm(itm xitm) (found bool, numSame int) { //MARK:CHECK INVN SAME ITM
	numSame = 0
	found = false
	for i := 0; i < len(pl.invn); i++ {
		if pl.invn[i].nm == itm.nm {
			found = true
			numSame = i
			break
		}
	}
	return found, numSame
}
func checkQuikSameItm(itm xitm) (found bool, numSame int) { //MARK:CHECK QUIK SAME ITM
	numSame = 0
	found = false
	for i := 0; i < len(pl.quik); i++ {
		if pl.quik[i].nm == itm.nm {
			found = true
			numSame = i
			break
		}
	}
	return found, numSame
}
func checkRecWalls(rec rl.Rectangle) bool { //MARK:CHECK REC VS WALLS
	canadd := true
	for i := 0; i < len(levels[levNum].walls); i++ {
		if rl.CheckCollisionRecs(rec, levels[levNum].walls[i].rec) {
			canadd = false
			break
		}
	}
	return canadd
}
func checkItemItem(rec rl.Rectangle) bool { //MARK:CHECK REC VS ITEM
	canadd := true
	for i := 0; i < len(levels[levNum].itm); i++ {
		if rl.CheckCollisionRecs(rec, levels[levNum].itm[i].rec) {
			canadd = false
			break
		}
	}
	return canadd
}
func checkChestSlots() (bool, int) { //MARK:CHECK CHEST SLOTS
	found := false
	num := 0
	for i := 0; i < len(levels[levNum].chst[0].itm); i++ {
		if levels[levNum].chst[0].itm[i].nm == "" {
			found = true
			num = i
			break
		}
	}
	return found, num
}
func checkRecWallsChestsEtcSolid(rec rl.Rectangle, num int, numType int) bool {
	//NUMTYPE 1 = ETC
	canmove := true
	//WALLS
	for i := 0; i < len(levels[levNum].walls); i++ {
		if rl.CheckCollisionRecs(rec, levels[levNum].walls[i].rec) {
			canmove = false
		}
	}
	//ETC
	if canmove {
		for i := 0; i < len(levels[levNum].etc); i++ {
			if numType == 1 { //CHECK VS SELF ETC
				if i != num {
					if levels[levNum].etc[i].solid {
						if rl.CheckCollisionRecs(rec, levels[levNum].etc[i].rec) {
							canmove = false
						}
					}
				}
			} else {
				if levels[levNum].etc[i].solid {
					if rl.CheckCollisionRecs(rec, levels[levNum].etc[i].rec) {
						canmove = false
					}
				}
			}
			if !canmove {
				break
			}
		}
	}
	//CHESTS
	if canmove {
		for i := 0; i < len(levels[levNum].chst); i++ {
			if rl.CheckCollisionRecs(rec, levels[levNum].chst[i].crec) {
				canmove = false
			}
			if !canmove {
				break
			}
		}
	}
	return canmove
}
func checkRecChests(rec rl.Rectangle) bool { //MARK:CHECK REC VS CHESTS
	canmove := true
	for i := 0; i < len(levels[levNum].chst); i++ {
		if rl.CheckCollisionRecs(rec, levels[levNum].chst[i].crec) {
			canmove = false
		}
		if !canmove {
			break
		}
	}
	return canmove
}
func checkRecEtcSolid(rec rl.Rectangle) (canmove bool, num int) { //MARK:CHECK NON-ETC REC VS ETC SOLID RECS
	canmove = true
	for i := 0; i < len(levels[levNum].etc); i++ {
		if levels[levNum].etc[i].solid {
			if rl.CheckCollisionRecs(rec, levels[levNum].etc[i].rec) {
				canmove = false
				num = i
			}
		}
		if !canmove {
			break
		}
	}
	return canmove, num
}
func checkRecPlayer(rec rl.Rectangle) bool { //MARK:CHECK PLAYER VS REC
	canadd := true
	if rl.CheckCollisionRecs(rec, pl.rec) {
		canadd = false
	}
	return canadd
}
func checkmoveblok(blok xtile, num int) bool { //MARK:CHECK MOVE BLOK
	canmove := true
	checkrec := blok.rec
	checkrec.X += blok.dirX
	checkrec.Y += blok.dirY
	for i := 0; i < len(levels[levNum].walls); i++ {
		if i != num {
			if rl.CheckCollisionRecs(checkrec, levels[levNum].walls[i].rec) {
				canmove = false
			}
		}
	}
	//CHECK VS CHESTS
	if canmove {
		canmove = checkRecChests(checkrec)
	}
	//CHECK VS ETC SOLID
	if canmove {
		canmove, _ = checkRecEtcSolid(checkrec)
	}
	if canmove {
		if rl.CheckCollisionRecs(checkrec, pl.crec) {
			canmove = false
		}
	}
	return canmove
}
func checkRecMoveWalls(rec rl.Rectangle, dirX, dirY float32) bool { //MARK:CHECK REC MOVE WALL COLLIS
	canmove := true
	rec.X += dirX
	rec.Y += dirY
	for i := 0; i < len(levels[levNum].walls); i++ {
		if rl.CheckCollisionRecs(rec, levels[levNum].walls[i].rec) {
			canmove = false
		}
	}
	return canmove
}
func checkplayermoveBase(direc int) bool { //MARK:CHECK PLAYER MOVE BASE
	canmove := true
	checkrec := pl2.crec
	switch direc {
	case 1: //UP
		checkrec.Y -= pl2.spd
	case 2: //RIGHT
		checkrec.X += pl2.spd
	case 3: //DOWN
		checkrec.Y += pl2.spd
	case 4: //LEFT
		checkrec.X -= pl2.spd
	}
	for i := 0; i < len(base.crec); i++ {
		if rl.CheckCollisionRecs(checkrec, base.crec[i]) {
			canmove = false
		}
	}
	if canmove {
		v1 := rl.NewVector2(checkrec.X, checkrec.Y)
		v2 := v1
		v2.X += checkrec.Width
		v3 := v2
		v3.Y += checkrec.Height
		v4 := v3
		v4.X -= checkrec.Width
		if !rl.CheckCollisionPointRec(v1, baseBordRec) || !rl.CheckCollisionPointRec(v2, baseBordRec) || !rl.CheckCollisionPointRec(v3, baseBordRec) || !rl.CheckCollisionPointRec(v4, baseBordRec) {
			canmove = false
		}
	}
	return canmove
}
func checkplayermove(direc int) bool { //MARK:CHECK PLAYER MOVE
	canmove := true
	if intangibleT == 0 {
		checkrec := pl.crec
		switch direc {
		case 1: //UP
			checkrec.Y -= pl.spd + delta
		case 2: //RIGHT
			checkrec.X += pl.spd + delta
		case 3: //DOWN
			checkrec.Y += pl.spd + delta
		case 4: //LEFT
			checkrec.X -= pl.spd + delta
		}
		for i := 0; i < len(levels[levNum].walls); i++ {
			if rl.CheckCollisionRecs(checkrec, levels[levNum].walls[i].rec) {
				canmove = false
			}
		}
		if canmove {
			numEtc := 0
			canmove, numEtc = checkRecEtcSolid(checkrec)
			if !canmove {
				if levels[levNum].etc[numEtc].nm == "crate" {
					pushcrate(numEtc, direc)
				}
			}
		}
		if bosson {
			if rl.CheckCollisionRecs(checkrec, boss.crec) {
				canmove = false
			}
		}
	} else {
		checkV2 := pl.cnt
		switch direc {
		case 1: //UP
			checkV2.Y -= pl.spd + delta
		case 2: //RIGHT
			checkV2.X += pl.spd + delta
		case 3: //DOWN
			checkV2.Y += pl.spd + delta
		case 4: //LEFT
			checkV2.X -= pl.spd + delta
		}
		canmove = false
		for i := 0; i < len(levels[levNum].recs); i++ {
			if rl.CheckCollisionPointRec(checkV2, levels[levNum].recs[i]) {
				canmove = true
			}
		}
	}
	return canmove
}
func checkaddtilerec(rec rl.Rectangle, lev x1scr) bool { //MARK:CHECK TILE REC WALL RECS
	canadd := true
	for i := 0; i < len(lev.walls); i++ {
		if rl.CheckCollisionRecs(rec, lev.walls[i].rec) {
			canadd = false
		}
	}
	if canadd {
		for i := 0; i < len(lev.recs); i++ {
			if rl.CheckCollisionRecs(rec, lev.recs[i]) && lev.inf[i].wallsadded {
				canadd = false
			}
		}
	}
	return canadd
}
func checkaddetc(rec rl.Rectangle, lev x1scr) bool {
	canadd := true
	for i := 0; i < len(lev.etc); i++ {
		if rl.CheckCollisionRecs(rec, lev.etc[i].rec) {
			canadd = false
		}
	}
	return canadd
}
func checkaddtilerecInner(rec rl.Rectangle, lev x1scr) bool { //MARK:CHECK ADD INNER TILE
	canadd := true
	for i := 0; i < len(lev.walls); i++ {
		if rl.CheckCollisionRecs(rec, lev.walls[i].rec) {
			canadd = false
		}
	}
	if canadd {
		if rl.CheckCollisionRecs(rec, pl.rec) {
			canadd = false
		}
	}
	return canadd
}
func checkrecaddto1scr(rec rl.Rectangle, recs []rl.Rectangle) bool { //MARK:CHECK REC ADD TO 1SCR
	canadd := true
	for i := 0; i < len(recs); i++ {
		if rl.CheckCollisionRecs(rec, recs[i]) {
			canadd = false
		}
	}
	if canadd {
		v1 := rl.NewVector2(rec.X, rec.Y)
		v2 := v1
		v2.X += rec.Width
		v3 := v2
		v3.Y += rec.Height
		v4 := v1
		v4.Y += rec.Height
		if !rl.CheckCollisionPointRec(v1, inRec) || !rl.CheckCollisionPointRec(v2, inRec) || !rl.CheckCollisionPointRec(v3, inRec) || !rl.CheckCollisionPointRec(v4, inRec) {
			canadd = false
		}
	}
	return canadd
}

// MARK: FIND FIND FIND FIND FIND FIND FIND FIND FIND FIND FIND FIND FIND FIND FIND FIND FIND
func findranrecpos(rec rl.Rectangle) (rl.Rectangle, bool) { //MARK: FIND RANDOM REC POSITION
	found := false
	countbreak := 100
	for {
		choose := levels[levNum].recs[RandInt(0, len(levels[levNum].recs))]
		x := choose.X + b/2
		y := choose.Y + b/2
		x2 := (x + choose.Width) - (b + rec.Width)
		y2 := (y + choose.Height) - (b + rec.Height)

		x = RandF32(x, x2)
		y = RandF32(y, y2)

		rec.X = x
		rec.Y = y

		if checkRecSolid(rec) && checkRecWalls(rec) {
			found = true
		}

		countbreak--
		if countbreak == 0 || found {
			break
		}
	}

	return rec, found
}
func findnextstoreslotnum() { //MARK: FIND NEXT STORE ITEM SLOT
	nxStoreNum = blankint
	for i := 0; i < len(storeItm); i++ {
		if storeItm[i].nm == "" {
			nxStoreNum = i
			break
		}
	}
}
func finddropside(rec rl.Rectangle, msgonoff int) rl.Rectangle { //MARK: FIND EMPTY DROP POSITION NEXT TO RECTANGLE
	count := 0
	for {
		checkrec := rec
		switch count {
		case 0:
			checkrec.X -= checkrec.Width
		case 1:
			checkrec.X -= checkrec.Width
			checkrec.Y -= checkrec.Width
		case 2:
			checkrec.Y -= checkrec.Width
		case 3:
			checkrec.X += checkrec.Width
			checkrec.Y -= checkrec.Width
		case 4:
			checkrec.X += checkrec.Width
		case 5:
			checkrec.X += checkrec.Width
			checkrec.Y += checkrec.Width
		case 6:
			checkrec.Y += checkrec.Width
		case 7:
			checkrec.X -= checkrec.Width
			checkrec.Y += checkrec.Width
		}
		canadd := checkRecWalls(checkrec)
		if canadd {
			rec = checkrec
			zfx := xfx{}
			zfx.img = anm[108].rec
			zfx.rec = checkrec
			zfx.rec.X -= b
			zfx.rec.Y -= b
			zfx.rec.Width += b2
			zfx.rec.Height += b2
			zfx.nm = "summonitem"
			fx = append(fx, zfx)
			if msgonoff == 1 {
				admsg("extra loot drop > luck", rl.Magenta)
			}
			break
		}
		count++
		if count > 7 {
			rec = rl.Rectangle{}
			break
		}
	}
	return rec
}
func findnxinvnum() { //MARK: FIND NEXT INVEN NUM
	nxInvnNum = blankint
	for i := 0; i < len(pl.invn); i++ {
		if pl.invn[i].nm == "" {
			nxInvnNum = i
		}
	}
}
func findRanCntinRoom(rec rl.Rectangle) rl.Vector2 { //MARK: FIND RANDOM CENTER IN ROOM
	cntr := rl.Vector2{}
	countbreak := 1000
	for {
		x := rec.X + b/2
		y := rec.Y + b/2
		x += RandF32(0, rec.Width-b)
		y += RandF32(0, rec.Height-b)
		cntr = rl.NewVector2(x, y)
		if checkV2Walls(cntr) {
			break
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	return cntr
}
func findRanCnt() rl.Vector2 { //MARK: FIND RANDOM CENTER
	cntr := rl.Vector2{}
	choose := RandInt(0, len(levels[levNum].recs))
	countbreak := 1000
	for {
		x := levels[levNum].recs[choose].X + b
		y := levels[levNum].recs[choose].Y + b
		x += RandF32(0, levels[levNum].recs[choose].Width-b2)
		y += RandF32(0, levels[levNum].recs[choose].Height-b2)
		cntr = rl.NewVector2(x, y)
		if checkV2Walls(cntr) {
			break
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	return cntr
}
func findRanCntLev(lev x1scr) rl.Vector2 { //MARK: FIND RANDOM CENTER X1SCR LEV
	cntr := rl.Vector2{}
	choose := RandInt(0, len(lev.recs))
	countbreak := 1000
	for {
		x := lev.recs[choose].X + b
		y := lev.recs[choose].Y + b
		x += RandF32(0, lev.recs[choose].Width-b2)
		y += RandF32(0, lev.recs[choose].Height-b2)
		cntr = rl.NewVector2(x, y)
		if checkV2WallsLev(cntr, lev) {
			break
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	return cntr
}
func findRanCntLevTreasureRoom(lev x1scr) rl.Vector2 { //MARK: FIND RANDOM CENTER TREASURE ROOM
	cntr := rl.Vector2{}
	choose := RandInt(0, len(lev.recs))
	if Roll6() > 3 {
		choose = 0
	}
	countbreak := 1000
	for {
		x := lev.recs[choose].X + b
		y := lev.recs[choose].Y + b
		x += RandF32(0, lev.recs[choose].Width-b2)
		y += RandF32(0, lev.recs[choose].Height-b2)
		cntr = rl.NewVector2(x, y)
		if checkV2WallsLev(cntr, lev) {
			break
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	return cntr
}
func findSpdXY(startV2, destV2 rl.Vector2, spd float32) (x, y float32) { //MARK: FIND DIRX DIRY FOR 2X V2
	xdiff := AbsDiff(destV2.X, startV2.X)
	ydiff := AbsDiff(destV2.Y, startV2.Y)
	if xdiff > ydiff {
		x = spd
		y = ydiff / (xdiff / x)
	} else {
		y = spd
		x = xdiff / (ydiff / y)
	}
	if startV2.X > destV2.X {
		x = -x
	}
	if startV2.Y > destV2.Y {
		y = -y
	}
	return x, y
}

// MARK: ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC
func foundsameart(nm string) (int, bool) { //MARK: FOUND SAME ARTIFACT
	found := false
	num := 0
	if len(pl.art) > 0 {
		for i := 0; i > len(pl.art); i++ {
			if pl.art[i].nm == nm {
				found = true
				num = i
				break
			}
		}
	}

	return num, found
}
func pushcrate(num, direc int) { //MARK: PUSH CRATE
	checkrec := levels[levNum].etc[num].rec
	switch direc {
	case 1:
		checkrec.Y -= pl.spd * 2
	case 2:
		checkrec.X += pl.spd * 2
	case 3:
		checkrec.Y += pl.spd * 2
	case 4:
		checkrec.X -= pl.spd * 2
	}
	if checkRecWallsChestsEtcSolid(checkrec, num, 1) {
		levels[levNum].etc[num].moveT = 2
		pl.push = true
		pl.pushT = fps / 4
		switch direc {
		case 1:
			levels[levNum].etc[num].dirY = -pl.spd
		case 2:
			levels[levNum].etc[num].dirX = pl.spd
		case 3:
			levels[levNum].etc[num].dirY = pl.spd
		case 4:
			levels[levNum].etc[num].dirX = -pl.spd
		}
	}
}
func Reset() { //MARK: NEW GAME RESET

	levNumDis = 0

	bosskillist = nil

	base = xbas{}
	pl = xplayer{}

	weapstandon = true
	scopeon = false
	drillon = false
	telBase = false
	telCntr = false
	medikiton = false
	vineon = false
	vineon2 = false
	vineRing = false
	thornson = false
	twin = false
	tesla = false
	purplerain = false
	frisbee = false
	mirror = false
	toxic = false
	feather = false
	cloak = false
	toaster = false
	noodles = false
	mappin = false
	chestpin = false
	umbrella = false
	treasureroom = false
	icecrystal = false
	mrfrisbee = false
	spinna = false
	pyroball = false
	zombiehead = false
	batty = false
	landmine = false
	rollo = false
	shrimpnum = 0
	basketballnum = 0
	broccolinum = 0
	garlicnum = 0
	tenderisernum = 0
	cleavernum = 0
	deathbottlenum = 0
	gascannum = 0
	beartrapnum = 0
	toiletpapernum = 0
	teslacount = 0
	purpleraincount = 0
	frisbeecount = 0
	beltnum = 0
	beltAtk = 0
	throwingknifenum = 0
	magicianshatnum = 0
	pearlnum = 0
	lightbulbnum = 0
	mugnum = 0
	teanum = 0
	ninjanum = 0
	ovenglovenum = 0
	poisongasCount = 0
	medikitnum = 0
	sneakersnum = 0
	weaponcasenum = 0
	spacehelmetnum = 0
	zombienum = 0
	candycanenum = 0
	flamingonum = 0
	gasmasknum = 0
	watchT = 0
	scopeT = 0
	slugT = 0
	pistolT = 0
	turtleT = 0
	sodaT = 0
	icecreamT = 0
	gasT = 0
	bloodT = 0
	icelollyT = 0
	intangibleT = 0
	teleportT = 0
	inflictT = 0
	powerT = 0
	steroidsT = 0
	reviveT = 0
	beartrapT = 0
	quailT = 0
	teslaT = 0
	purplerainT = 0
	frisbeeT = 0
	beetrootT = 0
	cloakT = 0
	flamingoT = 0
	orangeT = 0
	tvT = 0
	lollipopT = 0
	honeycombT = 0
	eggsT = 0
	gasmaskT = 0
	psychedelicsT = 0
	bootsT = 0
	fartT = 0
	teleportPauseT = 0
	exitPauseT = 0
	saltT = 0
	icecrystalT = 0
	mrfrisbeeT = 0
	spinnaT = 0
	spinnaT2 = 0
	pyroballT = 0
	landmineT = 0

	for i := 0; i < len(itmlist); i++ {
		itmlist[i].unlok = false
	}

	itmlist[2].unlok = true
	itmlist[5].unlok = true
	itmlist[8].unlok = true
	itmlist[11].unlok = true
	itmlist[43].unlok = true

	upunlocks()

	makeplayer()
	makebase()
	if storeunlocked {
		for i := 0; i < len(base.nm); i++ {
			if base.nm[i] == "store room" {
				base.unlock[i] = true
			}
		}
	}
	makelevel()

	rl.StopMusicStream(music[currentMusic])
	currentMusic = 2
	rl.PlayMusicStream(music[currentMusic])

}
func clearsave(num int) { //MARK: CLEAR SAVE FILE

	switch num {
	case 1:
		f, err := os.Create("save/1s.ave")
		if err != nil {
			fmt.Println(err)
			return
		}
		savelist := "777777777"
		f.WriteString(savelist)
		save1 = false
	case 2:
		f, err := os.Create("save/2s.ave")
		if err != nil {
			fmt.Println(err)
			return
		}
		savelist := "777777777"
		f.WriteString(savelist)
		save2 = false
	case 3:
		f, err := os.Create("save/3s.ave")
		if err != nil {
			fmt.Println(err)
			return
		}
		savelist := "777777777"
		f.WriteString(savelist)
		save3 = false
	}

}
func savestore() { //MARK: SAVE STORE ROOM

	switch currentSave {
	case 1:
		f, err := os.Create("save/1s.ave")
		if err != nil {
			fmt.Println(err)
			return
		}
		savelist := ""
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].nm != "" {
				savelist += fmt.Sprint(storeItm[i].listNum) + ","
				savelist += fmt.Sprint(storeItm[i].numof) + ","
			}
		}
		f.WriteString(savelist)
	case 2:
		f, err := os.Create("save/2s.ave")
		if err != nil {
			fmt.Println(err)
			return
		}
		savelist := ""
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].nm != "" {
				savelist += fmt.Sprint(storeItm[i].listNum) + ","
				savelist += fmt.Sprint(storeItm[i].numof) + ","
			}
		}
		f.WriteString(savelist)
	case 3:
		f, err := os.Create("save/3s.ave")
		if err != nil {
			fmt.Println(err)
			return
		}
		savelist := ""
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].nm != "" {
				savelist += fmt.Sprint(storeItm[i].listNum) + ","
				savelist += fmt.Sprint(storeItm[i].numof) + ","
			}
		}
		f.WriteString(savelist)
	}

}
func ReadSaves() { //MARK: READ SAVES

	contents, err := os.ReadFile("save/1s.ave")
	if err != nil {
		fmt.Println("File reading error", err)
		return
	}
	saveitms := strings.Split(string(contents), ",")

	num, _ := strconv.Atoi(saveitms[0])
	if num == blankint {
		save1 = false
	} else {
		save1 = true
	}

	if save1 {
		savestore1 = nil
		for i := 0; i < len(saveitms)-1; i++ {
			num2, _ := strconv.Atoi(saveitms[i])
			num3, _ := strconv.Atoi(saveitms[i+1])
			zitm := itmlist[num2]
			zitm.numof = num3
			savestore1 = append(savestore1, zitm)
			i++
		}
	}

	contents, err = os.ReadFile("save/2s.ave")
	if err != nil {
		fmt.Println("File reading error", err)
		return
	}
	saveitms = strings.Split(string(contents), ",")

	num, _ = strconv.Atoi(saveitms[0])
	if num == blankint {
		save2 = false
	} else {
		save2 = true
	}

	if save2 {
		savestore2 = nil
		for i := 0; i < len(saveitms)-1; i++ {
			num2, _ := strconv.Atoi(saveitms[i])
			num3, _ := strconv.Atoi(saveitms[i+1])
			zitm := itmlist[num2]
			zitm.numof = num3
			savestore2 = append(savestore2, zitm)
			i++
		}
	}

	contents, err = os.ReadFile("save/3s.ave")
	if err != nil {
		fmt.Println("File reading error", err)
		return
	}
	saveitms = strings.Split(string(contents), ",")

	num, _ = strconv.Atoi(saveitms[0])
	if num == blankint {
		save3 = false
	} else {
		save3 = true
	}

	if save3 {
		savestore3 = nil
		for i := 0; i < len(saveitms)-1; i++ {
			num2, _ := strconv.Atoi(saveitms[i])
			num3, _ := strconv.Atoi(saveitms[i+1])
			zitm := itmlist[num2]
			zitm.numof = num3
			savestore3 = append(savestore3, zitm)
			i++
		}
	}

}
func projEnmCollis(num, enNum int) { //MARK: PLAYER PROJ ENEMY COLLIS

	if !levels[levNum].enm[enNum].nodmg {
		nohpT := false
		switch projPL[num].nm {
		case "frogProj":
			if !levels[levNum].enm[enNum].fly {
				levels[levNum].enm[enNum].hp -= projPL[num].dmg
				if levels[levNum].enm[enNum].nm == "crocodile" || levels[levNum].enm[enNum].nm == "redantenna" {
					levels[levNum].enm[enNum].stunT = fps
					levels[levNum].enm[enNum].stunF = 0.9
					levels[levNum].enm[enNum].stunY = levels[levNum].enm[enNum].cnt.Y
					levels[levNum].enm[enNum].stunSiz = b / 4
				}
			} else {
				nohpT = true
			}
		case "poisongas":
			if levels[levNum].enm[enNum].nm == "flamehead" || levels[levNum].enm[enNum].nm == "skeleton" || levels[levNum].enm[enNum].nm == "ghost" {
				if msgT == 0 {
					admsg("immune to poison", rl.Yellow)
					msgT = fps
				}
			} else {
				if levels[levNum].enm[enNum].poisonT == 0 {
					levels[levNum].enm[enNum].poisonT = fps * 3
				}
			}
		default:
			if levels[levNum].enm[enNum].nm == "bush" && levels[levNum].enm[enNum].idl {
				if msgT == 0 {
					admsg("immune - disguised as rock", rl.Yellow)
					msgT = fps
				}
			} else {
				levels[levNum].enm[enNum].hp -= projPL[num].dmg + (stats.str - 1)
				if cleavernum > 0 && projPL[num].nm != "splinter" {
					if Roll6() <= cleavernum {
						zproj := projPL[num]
						countbreak := 20
						for {
							zproj.dirX = RandF32(-zproj.spd, zproj.spd)
							zproj.dirY = RandF32(-zproj.spd, zproj.spd)
							if Abs(zproj.dirX) > zproj.spd/2 || Abs(zproj.dirY) > zproj.spd/2 {
								//CHANGE RO
								if projPL[num].nm == "bunch of carrots" || projPL[num].nm == "drawing pin" || projPL[num].nm == "fork" || projPL[num].nm == "french fries" {
									cntr := makecnt(projPL[num].rec)
									cntr2 := cntr
									cntr2.X += zproj.dirX * 5
									cntr2.Y += zproj.dirY * 5
									if projPL[num].nm == "bunch of carrots" || projPL[num].nm == "french fries" {
										zproj.ro = AngleBetweenTwoPoints(cntr, cntr2) - 90
									} else {
										zproj.ro = AngleBetweenTwoPoints(cntr, cntr2) + 45
									}
								}
								break
							}
							countbreak--
							if countbreak == 0 {
								break
							}
						}
						zproj.crec = zproj.rec
						zproj.bounce += basketballnum
						projPL = append(projPL, zproj)
						zproj = projPL[num]
						countbreak = 20
						for {
							zproj.dirX = RandF32(-zproj.spd, zproj.spd)
							zproj.dirY = RandF32(-zproj.spd, zproj.spd)
							if Abs(zproj.dirX) > zproj.spd/2 || Abs(zproj.dirY) > zproj.spd/2 {
								//CHANGE RO
								if projPL[num].nm == "bunch of carrots" || projPL[num].nm == "drawing pin" || projPL[num].nm == "fork" || projPL[num].nm == "french fries" {
									cntr := makecnt(projPL[num].rec)
									cntr2 := cntr
									cntr2.X += zproj.dirX * 5
									cntr2.Y += zproj.dirY * 5
									if projPL[num].nm == "bunch of carrots" || projPL[num].nm == "french fries" {
										zproj.ro = AngleBetweenTwoPoints(cntr, cntr2) - 90
									} else {
										zproj.ro = AngleBetweenTwoPoints(cntr, cntr2) + 45
									}
								}
								break
							}
							countbreak--
							if countbreak == 0 {
								break
							}
						}
						zproj.crec = zproj.rec
						zproj.bounce += basketballnum
						projPL = append(projPL, zproj)
					}
				}
				//DRAWING PIN
				if projPL[num].nm == "drawing pin" {
					levels[levNum].enm[enNum].freezeT += fps * 2
				}
				//FART FIRE
				if projPL[num].nm == "fartfire" || projPL[num].nm == "pigProj" {
					if levels[levNum].enm[enNum].nm == "flamehead" || levels[levNum].enm[enNum].nm == "yellowdino" || levels[levNum].enm[enNum].nm == "ghost" || levels[levNum].enm[enNum].nm == "reddevil" {
						if msgT == 0 {
							admsg("immune to burn", rl.Yellow)
							msgT = fps
						}
					} else {
						levels[levNum].enm[enNum].burnT = fps * 3
					}
				}
				//MAGNIFYING GLASS
				if projPL[num].nm == "magnifying glass" && !levels[levNum].enm[enNum].xl {
					levels[levNum].enm[enNum].xl = true
					W := levels[levNum].enm[enNum].rec.Width * 1.5
					H := levels[levNum].enm[enNum].rec.Height * 1.5
					levels[levNum].enm[enNum].rec = rl.NewRectangle(levels[levNum].enm[enNum].cnt.X-W/2, levels[levNum].enm[enNum].cnt.Y-H/2, W, H)

				}
				//CHILLI FLAME
				if projPL[num].nm == "chilli" {
					num2 := RandInt(3, 7)
					countbreak := 100
					for num2 > 0 {
						cntr := makecnt(projPL[num].rec)
						cntr.X += RandF32(-b2, b2)
						cntr.Y += RandF32(-b2, b2)
						if checkV2Walls(cntr) && checkV2inRooms(cntr) {
							rl.PlaySound(audfx[120])
							zfx := xfx{}
							zfx.nm = "flamingoflame"
							zfx.fade = 0.8
							siz := b + b/2
							zfx.img = anm[98].rec
							zfx.rec = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
							zfx.crec = zfx.rec
							zfx.crec.X += zfx.crec.Width / 8
							zfx.crec.Y += zfx.crec.Height / 8
							zfx.crec.Width -= zfx.crec.Width / 4
							zfx.crec.Height -= zfx.crec.Height / 4
							zfx.T = fps * 3
							zfx.below = true
							fx = append(fx, zfx)
							num2--
						}
						countbreak--
						if countbreak == 0 {
							break
						}
					}
				}
				//MINT ICE CREAM
				if projPL[num].nm == "mint ice cream" {
					siz := b5
					zfx := xfx{}
					zfx.img = splat[RandInt(0, len(splat))]
					zfx.nm = "icecream"
					zfx.cnt = levels[levNum].enm[enNum].cnt
					zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
					zfx.crec = zfx.rec
					zfx.crec.X += zfx.crec.Width / 8
					zfx.crec.Y += zfx.crec.Height / 8
					zfx.crec.Width -= zfx.crec.Width / 4
					zfx.crec.Height -= zfx.crec.Height / 4
					zfx.fade = 0.7
					zfx.below = true
					fx = append(fx, zfx)
				}
				//STUN
				if tenderisernum > 0 && levels[levNum].enm[enNum].stunT == 0 {
					if Roll6() <= tenderisernum {
						levels[levNum].enm[enNum].stunT = fps
						levels[levNum].enm[enNum].stunF = 0.9
						levels[levNum].enm[enNum].stunY = levels[levNum].enm[enNum].cnt.Y
						levels[levNum].enm[enNum].stunSiz = b / 4
					}
				}
				//POISON GAS
				if broccolinum > 0 {
					if Roll6() <= broccolinum {
						zproj := xweap{}
						zproj.T = fps * 5
						siz := b4
						zproj.rec = rl.NewRectangle(levels[levNum].enm[enNum].cnt.X-siz/2, levels[levNum].enm[enNum].cnt.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.crec.X += zproj.crec.Width / 4
						zproj.crec.Y += zproj.crec.Height / 4
						zproj.crec.Width = zproj.crec.Width / 2
						zproj.crec.Height = zproj.crec.Height / 2
						zproj.img = anm[76].rec
						zproj.cnt = makecnt(zproj.rec)
						zproj.fd = 1
						zproj.col = rl.White
						zproj.rospd = RandF32(2, 4)
						if FlipCoin() {
							zproj.rospd = -zproj.rospd
						}
						zproj.dmg = 1
						zproj.spd = 4
						zproj.dirX = RandF32(-zproj.spd, zproj.spd)
						zproj.dirY = RandF32(-zproj.spd, zproj.spd)
						zproj.nm = "poisongas"
						projPL = append(projPL, zproj)
					}
				}
				//BLEED
				if bloodT > 0 {
					if levels[levNum].enm[enNum].nm == "flamehead" || levels[levNum].enm[enNum].nm == "skeleton" || levels[levNum].enm[enNum].nm == "ghost" || levels[levNum].enm[enNum].nm == "robot" {
						if msgT == 0 {
							admsg("immune to bleed", rl.Yellow)
							msgT = fps
						}
					} else {
						levels[levNum].enm[enNum].bleed++
						levels[levNum].enm[enNum].bleedT = fps * 2
					}
				}
				//GAS
				if gasT > 0 {
					if levels[levNum].enm[enNum].nm == "flamehead" || levels[levNum].enm[enNum].nm == "yellowdino" || levels[levNum].enm[enNum].nm == "ghost" || levels[levNum].enm[enNum].nm == "reddevil" {
						if msgT == 0 {
							admsg("immune to burn", rl.Yellow)
							msgT = fps
						}
					} else {
						levels[levNum].enm[enNum].burnT = fps * 3
					}
				}
				//CRIT
				if stats.crit > 0 {
					if Roll6() <= stats.crit {
						levels[levNum].enm[enNum].hp -= projPL[num].dmg + (stats.str - 1)
						if msgT == 0 {
							admsg("critical hit x2 damage", rl.Magenta)
							msgT = fps
						}
					}
				}

				if levels[levNum].enm[enNum].nm == "crocodile" || levels[levNum].enm[enNum].nm == "redantenna" {
					levels[levNum].enm[enNum].stunT = fps
					levels[levNum].enm[enNum].stunF = 0.9
					levels[levNum].enm[enNum].stunY = levels[levNum].enm[enNum].cnt.Y
					levels[levNum].enm[enNum].stunSiz = b / 4
				}
				if levels[levNum].enm[enNum].nm == "spzman" {
					levels[levNum].enm[enNum].moveChangeT = 0
					levels[levNum].enm[enNum].state = 2
					if boss.lr {
						boss.img = anm[129].rec
					} else {
						boss.img = anm[128].rec
					}
				}
			}
		}

		if !nohpT {
			if projPL[num].nm != "frogProj" && projPL[num].nm != "chickenProj" && projPL[num].nm != "poisongas" {
				//SPLINTERS
				if projPL[num].nm == "rolling pin" {
					siz := be3
					spd := float32(7)
					zproj := xweap{}
					zproj.img = etc[162]
					zproj.dmg = 1
					zproj.cnt = levels[levNum].enm[enNum].cnt
					zproj.rec = rl.NewRectangle(zproj.cnt.X-siz/2, zproj.cnt.Y-siz/2, siz, siz)
					zproj.crec = zproj.rec
					zproj.cnt = makecnt(zproj.rec)
					zproj.fd = 1
					zproj.col = rl.White
					zproj.nm = "splinter"
					zproj.dirY = -spd
					zproj.ro -= 90
					projPL = append(projPL, zproj)
					zproj.ro += 180
					zproj.dirY = spd
					projPL = append(projPL, zproj)
					zproj.ro = 0
					zproj.dirY = 0
					zproj.dirX = spd
					projPL = append(projPL, zproj)
					zproj.ro = 180
					zproj.dirX = -spd
					projPL = append(projPL, zproj)
					zproj.ro = -45
					zproj.dirX = spd
					zproj.dirY = -spd
					projPL = append(projPL, zproj)
					zproj.ro = 45
					zproj.dirX = spd
					zproj.dirY = spd
					projPL = append(projPL, zproj)
					zproj.ro = -135
					zproj.dirX = -spd
					zproj.dirY = -spd
					projPL = append(projPL, zproj)
					zproj.ro = 135
					zproj.dirX = -spd
					zproj.dirY = spd
					projPL = append(projPL, zproj)

					levels[levNum].enm[enNum].stunT = fps
					levels[levNum].enm[enNum].stunF = 0.9
					levels[levNum].enm[enNum].stunY = levels[levNum].enm[enNum].cnt.Y
					levels[levNum].enm[enNum].stunSiz = b / 4
				}
				//FRYING PAN SHOCK
				if projPL[num].nm == "frying pan" {
					rl.PlaySound(audfx[105])
					zfx := xfx{}
					zfx.nm = "fryingShock"
					zfx.rec = projPL[num].rec
					zfx.rec.X -= b4
					zfx.rec.Y -= b4
					zfx.rec.Width += b8
					zfx.rec.Height += b8
					zfx.img = anm[178].rec
					fx = append(fx, zfx)
				}
				//RUBBER DUCK BOUNCE
				if projPL[num].nm == "rubber duck" {
					projPL[num].collisT = fps / 8
					countbreak := 100
					for {
						projPL[num].dirX = RandF32(-projPL[num].spd, projPL[num].spd)
						projPL[num].dirY = RandF32(-projPL[num].spd, projPL[num].spd)
						if Abs(projPL[num].dirX) > projPL[num].spd/2 && Abs(projPL[num].dirY) > projPL[num].dirY/2 {
							break
						}
						countbreak--
						if countbreak == 0 {
							break
						}
					}
				} else {
					if projPL[num].nm == "pineapple" {
						zfx := xfx{}
						zfx.img = anm[179].rec
						zfx.rec = projPL[num].rec
						zfx.nm = "pineapple"
						fx = append(fx, zfx)
					}
				}
				projPL[num].off = true
			}
		}
		if levels[levNum].enm[enNum].hp <= 0 && !levels[levNum].enm[enNum].off && !bosson {
			pl.xp += levels[levNum].enm[enNum].xp
			if projPL[num].xp {
				pl.xp += levels[levNum].enm[enNum].xp
			}
			makeEnDeathFx(enNum)
			levels[levNum].enm[enNum].off = true
			//HOT SOUP
			if projPL[num].nm == "hot soup" {
				siz := b8
				zfx := xfx{}
				zfx.img = splat[RandInt(0, len(splat))]
				zfx.nm = "hotsoup"
				zfx.cnt = levels[levNum].enm[enNum].cnt
				zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
				zfx.crec = zfx.rec
				zfx.crec.X += zfx.crec.Width / 8
				zfx.crec.Y += zfx.crec.Height / 8
				zfx.crec.Width -= zfx.crec.Width / 4
				zfx.crec.Height -= zfx.crec.Height / 4
				zfx.fade = 1
				zfx.below = true
				fx = append(fx, zfx)
			}
			//FRENCH FRIES
			if projPL[num].nm == "french fries" {
				siz := b7
				zfx := xfx{}
				zfx.img = splat[RandInt(0, len(splat))]
				zfx.nm = "frenchfries"
				zfx.cnt = levels[levNum].enm[enNum].cnt
				zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
				zfx.crec = zfx.rec
				zfx.crec.X += zfx.crec.Width / 8
				zfx.crec.Y += zfx.crec.Height / 8
				zfx.crec.Width -= zfx.crec.Width / 4
				zfx.crec.Height -= zfx.crec.Height / 4
				zfx.fade = 1
				zfx.below = true
				fx = append(fx, zfx)
			}

			//SLUDGE GEYSER
			if projPL[num].sludgegeyser {
				if Roll12() > 9 {
					rl.PlaySound(audfx[113])
					siz := b3
					zfx := xfx{}
					zfx.below = true
					zfx.nm = "sludgegeyser"
					zfx.img = anm[203].rec
					num := RandInt(15, 21)
					for num > 0 {
						cntr := findRanCnt()
						zfx.rec = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
						fx = append(fx, zfx)
						num--
					}
				}
			}
			//RING OF FIRE
			if projPL[num].ringoffire {
				if Roll12() > 9 {
					rl.PlaySound(audfx[112])
					siz := b2
					zfx := xfx{}
					zfx.nm = "ringoffire"
					zfx.rec = rl.NewRectangle(levels[levNum].enm[enNum].cnt.X-siz/2, levels[levNum].enm[enNum].cnt.Y-siz/2, siz, siz)
					zfx.img = anm[202].rec
					fx = append(fx, zfx)
				}
			}
			//POTION
			if projPL[num].potion {
				if Roll12() > 9 {
					rl.PlaySound(audfx[110])
					zitm := itmlist[RandInt(0, 18)]
					siz := zitm.rec.Width
					zitm.rec = rl.NewRectangle(levels[levNum].enm[enNum].cnt.X-siz/2, levels[levNum].enm[enNum].cnt.Y-siz/2, siz, siz)
					levels[levNum].itm = append(levels[levNum].itm, zitm)
				}
			}
			//BOMB
			if projPL[num].bomb {
				if Roll12() > 9 {
					rl.PlaySound(audfx[110])
					siz := bq3
					zfx := xfx{}
					zfx.img = etc[123]
					zfx.rec = rl.NewRectangle(levels[levNum].enm[enNum].cnt.X-siz/2, levels[levNum].enm[enNum].cnt.Y-siz/2, siz, siz)
					zfx.nm = "bomb"
					zfx.T = fps * 3
					zfx.below = true
					fx = append(fx, zfx)
				}
			}
			//TURRET
			if projPL[num].turret {
				if Roll12() > 9 {
					rl.PlaySound(audfx[110])
					if FlipCoin() {
						siz := bq3
						ztile := xtile{}
						ztile.img = etc[112]
						ztile.rec = rl.NewRectangle(levels[levNum].enm[enNum].cnt.X-siz/2, levels[levNum].enm[enNum].cnt.Y-siz/2, siz, siz)
						ztile.nm = "ladybugturret"
						ztile.cnt = makecnt(ztile.rec)
						ztile.v2 = ztile.cnt
						ztile.v2.X += b
						ztile.v2.Y -= b
						ztile.angl = 0
						ztile.moveT = fps
						ztile.ro = 0
						levels[levNum].etc = append(levels[levNum].etc, ztile)
					} else {
						siz := bq3
						ztile := xtile{}
						ztile.img = etc[122]
						ztile.rec = rl.NewRectangle(levels[levNum].enm[enNum].cnt.X-siz/2, levels[levNum].enm[enNum].cnt.Y-siz/2, siz, siz)
						ztile.nm = "popcornturret"
						ztile.cnt = makecnt(ztile.rec)
						ztile.v2 = ztile.cnt
						ztile.v2.X += b
						ztile.v2.Y -= b
						ztile.moveT = fps
						levels[levNum].etc = append(levels[levNum].etc, ztile)
					}
				}
			}

		} else {
			rl.PlaySound(audfx[8])
			if !levels[levNum].enm[enNum].nodmg && !nohpT {
				levels[levNum].enm[enNum].hpT = fps
				levels[levNum].enm[enNum].hpY = bq3
				levels[levNum].enm[enNum].hpY2 = 0
				if bosson {
					levels[levNum].enm[enNum].hpY = b
					levels[levNum].enm[enNum].hpY2 = b / 2
				}
			}
			//LIGHTNING
			if projPL[num].lightning && !bosson {
				rl.PlaySound(audfx[107])
				lightningEnm = nil
				checkrec := rl.NewRectangle(pl.cnt.X-b10, pl.cnt.Y-b10, b10*2, b10*2)
				for i := 0; i < len(levels[levNum].enm); i++ {
					if rl.CheckCollisionPointRec(levels[levNum].enm[i].cnt, checkrec) {
						lightningEnm = append(lightningEnm, i)
					}
				}
				lightningCount = fps / 3
			}
		}
	}

}

func oplr(num, nummax int, x, y float32) int { //MARK: OPTIONS LEFT RIGHT

	siz := b + be
	rec := rl.NewRectangle(x, y, siz, siz)
	rec.X -= siz
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		rl.DrawRectangleRec(rec, RandColor())
	} else {
		rl.DrawRectangleRec(rec, rl.Blue)
	}
	rl.DrawRectangleLinesEx(rec, 3, rl.Black)
	txs := tx3
	txt := "<<"
	txlen := rl.MeasureText(txt, txs)
	xtx := rec.ToInt32().X + rec.ToInt32().Width/2 - txlen/2
	cntr := makecnt(rec)
	ytx := int32(cntr.Y) - txs/2
	ytx += 1
	rl.DrawText(txt, xtx, ytx, txs, rl.Black)
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		if inpL {
			if num > 0 {
				num--
			} else if num == 0 {
				num = nummax
			}
		}
	}
	rec.X += siz
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		rl.DrawRectangleRec(rec, RandColor())
	} else {
		rl.DrawRectangleRec(rec, rl.Blue)
	}
	rl.DrawRectangleLinesEx(rec, 3, rl.Black)
	txt = ">>"
	txlen = rl.MeasureText(txt, txs)
	xtx = rec.ToInt32().X + rec.ToInt32().Width/2 - txlen/2
	cntr = makecnt(rec)
	ytx = int32(cntr.Y) - txs/2
	ytx += 1
	rl.DrawText(txt, xtx, ytx, txs, rl.Black)
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		if inpL {
			if num < nummax {
				num++
			} else if num == nummax {
				num = 0
			}
		}
	}

	return num
}
func opadj(num, nummax int, x, y float32, xl bool, numtype int) int { //MARK: OPTIONS ADJUST

	siz := b + be
	rec := rl.NewRectangle(x, y, siz, siz)
	rec.X -= siz * 2
	if xl {
		rec.X -= siz / 4
	}
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		rl.DrawRectangleRec(rec, RandColor())
	} else {
		rl.DrawRectangleRec(rec, rl.Blue)
	}
	rl.DrawRectangleLinesEx(rec, 3, rl.Black)
	txs := tx3
	txt := "<<"
	txlen := rl.MeasureText(txt, txs)
	xtx := rec.ToInt32().X + rec.ToInt32().Width/2 - txlen/2
	cntr := makecnt(rec)
	ytx := int32(cntr.Y) - txs/2
	ytx += 1
	rl.DrawText(txt, xtx, ytx, txs, rl.Black)
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		if inpL {
			rl.PlaySound(audfx[44])
			if num > 0 {
				num--
			}
			if numtype == 1 {
				if stickMov > 0 {
					stickMov -= 0.01
				}
			} else if numtype == 2 {
				if deadZ > 0 {
					deadZ -= 0.01
				}
			}
		}
	}

	rec.X += siz
	if xl {
		rec.Width += siz / 2
	}
	rl.DrawRectangleRec(rec, rl.Pink)
	rl.DrawRectangleLinesEx(rec, 3, rl.Black)
	txt = fmt.Sprint(num)
	txlen = rl.MeasureText(txt, txs)
	xtx = rec.ToInt32().X + rec.ToInt32().Width/2 - txlen/2
	cntr = makecnt(rec)
	ytx = int32(cntr.Y) - txs/2
	ytx += 1
	rl.DrawText(txt, xtx, ytx, txs, rl.Black)

	rec.X += rec.Width
	if xl {
		rec.Width -= siz / 2
	}
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		rl.DrawRectangleRec(rec, RandColor())
	} else {
		rl.DrawRectangleRec(rec, rl.Blue)
	}
	rl.DrawRectangleLinesEx(rec, 3, rl.Black)
	txt = ">>"
	txlen = rl.MeasureText(txt, txs)
	xtx = rec.ToInt32().X + rec.ToInt32().Width/2 - txlen/2
	cntr = makecnt(rec)
	ytx = int32(cntr.Y) - txs/2
	ytx += 1
	rl.DrawText(txt, xtx, ytx, txs, rl.Black)
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		if inpL {
			rl.PlaySound(audfx[44])
			if num < nummax {
				num++
			}
			if numtype == 1 {
				if stickMov < 0.99 {
					stickMov += 0.01
				}
			} else if numtype == 2 {
				if deadZ < 0.99 {
					deadZ += 0.01
				}
			}
		}
	}

	return num
}
func opswch(x, y float32, opt bool) { //MARK: OPTIONS SWITCH

	siz := b + be
	rec := rl.NewRectangle(x, y, siz, siz)
	rl.DrawRectangleRec(rec, rl.Blue)
	rl.DrawRectangleLinesEx(rec, 3, rl.Black)

	rec.X += 7
	rec.Y += 7
	rec.Width -= 14
	rec.Height -= 14
	if opt {
		rl.DrawRectangleRec(rec, DarkRed())
	} else {
		rl.DrawRectangleRec(rec, rl.Black)
	}
	rl.DrawRectangleLinesEx(rec, 2, rl.White)

}
func movestoreitm(num int) bool { //MARK: MOVE STORE ITEM

	found := false

	if storeItm[num].numof > 1 && storeItm[num].art {

		max := false
		num3 := storeItm[num].numof

		switch storeItm[num].nm {
		//NON BOSS ARTIFACTS MUST ALSO BE ADDED TO COLLECT FROM CHEST

		case "rollo":
			if !rollo {
				rollo = true
				num3--
				max = true
				pl.hpmax += 1
				pl.hp += 1
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "landmine":
			if !landmine {
				landmine = true
				num3--
				max = true
				landmineT = fps * 7
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "batty":
			if !batty {
				batty = true
				num3--
				max = true
				pl.hpmax += 1
				pl.hp += 1
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "zombie head":
			if !zombiehead {
				zombiehead = true
				zombienum = 2
				if pl.hp == pl.hpmax {
					pl.hp--
				}
				pl.hpmax -= 1
				num3--
				max = true
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "pyroball":
			if !pyroball {
				pyroball = true
				num3--
				max = true
				pyroballT = fps * 7
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "space helmet":
			if spacehelmetnum == spacehelmetmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+spacehelmetnum <= spacehelmetmax {
					spacehelmetnum += num3
					for j := 0; j < num3; j++ {
						for i := 0; i < len(itmlist); i++ {
							if !itmlist[i].nocrate {
								if itmlist[i].cost >= 35 {
									itmlist[i].cost -= 25
								}
							}
						}
					}
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}

				} else if num3+spacehelmetnum > spacehelmetmax {
					max = true
					diff := spacehelmetmax - spacehelmetnum
					for j := 0; j < diff; j++ {
						for i := 0; i < len(itmlist); i++ {
							if !itmlist[i].nocrate {
								if itmlist[i].cost >= 35 {
									itmlist[i].cost -= 25
								}
							}
						}
					}
					num3 = (num3 + spacehelmetnum) - spacehelmetmax
					spacehelmetnum = spacehelmetmax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
			if spacehelmetnum < spacehelmetmax {
				spacehelmetnum++
				for i := 0; i < len(itmlist); i++ {
					if !itmlist[i].nocrate {
						if itmlist[i].cost >= 35 {
							itmlist[i].cost -= 25
						}
					}
				}
			} else {
				max = true
			}
		case "spinna":
			if !spinna {
				spinna = true
				num3--
				max = true
				spinnaT = fps * 7
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "mr frisbee's frisbee":
			if !mrfrisbee {
				mrfrisbee = true
				num3--
				max = true
				mrfrisbeeT = fps * 7
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "ice crystal":
			if !icecrystal {
				icecrystal = true
				num3--
				max = true
				icecrystalT = fps * 7
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}

		case "weapon case":
			if weaponcasenum == weaponcasemax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+weaponcasenum <= weaponcasemax {
					for i := 0; i < num3; i++ {
						pl.weaps = append(pl.weaps, xweap{})
						weaponcasenum++
					}
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+weaponcasenum > weaponcasemax {
					max = true
					diff := int(weaponcasemax - weaponcasenum)
					num3 = (num3 + weaponcasenum) - weaponcasemax
					weaponcasenum = weaponcasemax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "umbrella":
			if !umbrella {
				umbrella = true
				num3--
				max = true
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "map chest pin":
			if !chestpin {
				chestpin = true
				num3--
				max = true
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "map exit pin":
			if !mappin {
				mappin = true
				num3--
				max = true
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "gas mask":
			if gasmasknum == gasmaskmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+int(gasmasknum) <= int(gasmaskmax) {
					gasmasknum += int32(num3)
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+int(gasmasknum) > int(gasmaskmax) {
					max = true
					diff := int(gasmaskmax - gasmasknum)
					num3 = (num3 + int(gasmasknum)) - int(gasmaskmax)
					gasmasknum = gasmaskmax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
				if gasmaskT == 0 {
					gasmaskT = fps*8 - (gasmasknum * fps)
				}
			}
		case "noodles":
			if !noodles {
				noodles = true
				num3--
				max = true
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "oven glove":
			if ovenglovenum == ovenglovemax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+ovenglovenum <= ovenglovemax {
					ovenglovenum += num3
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+ovenglovenum > ovenglovemax {
					max = true
					diff := int(ovenglovemax - ovenglovenum)
					num3 = (num3 + ovenglovenum) - ovenglovemax
					ovenglovenum = ovenglovemax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "toaster":
			if !toaster {
				toaster = true
				num3--
				max = true
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "ninja star":
			if ninjanum == ninjamax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+ninjanum <= ninjamax {
					ninjanum += num3
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+ninjanum > ninjamax {
					max = true
					diff := int(ninjamax - ninjanum)
					num3 = (num3 + ninjanum) - ninjamax
					ninjanum = ninjamax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "flamingo":
			if flamingonum == flamingomax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+int(flamingonum) <= int(flamingomax) {
					flamingonum += int32(num3)
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+int(flamingonum) > int(flamingomax) {
					max = true
					diff := int(flamingomax - flamingonum)
					num3 = (num3 + int(flamingonum)) - int(flamingomax)
					flamingonum = flamingomax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
				if flamingoT == 0 {
					flamingoT = (fps + fps/2) / flamingonum
				}
			}
		case "mug of tea":
			if teanum == teamax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+teanum <= teamax {
					teanum += num3
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+teanum > teamax {
					max = true
					diff := int(teamax - teanum)
					num3 = (num3 + teanum) - teamax
					teanum = teamax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "cloak of sparks":
			if !cloak {
				cloak = true
				num3--
				max = true
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "feather":
			if !feather {
				feather = true
				num3--
				max = true
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "mugging":
			if mugnum == mugmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+mugnum <= mugmax {
					mugnum += num3
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+mugnum > mugmax {
					max = true
					diff := int(mugmax - mugnum)
					num3 = (num3 + mugnum) - mugmax
					mugnum = mugmax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "lightbulb":
			if lightbulbnum == lightbulbmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+lightbulbnum <= lightbulbmax {
					lightbulbnum += num3
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+lightbulbnum > lightbulbmax {
					max = true
					diff := int(lightbulbmax - lightbulbnum)
					num3 = (num3 + mugnum) - lightbulbmax
					lightbulbnum = lightbulbmax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "candy cane":
			if candycanenum == candycanemax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+int(candycanenum) <= int(candycanemax) {
					candycanenum += int32(num3)
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+int(candycanenum) > int(candycanemax) {
					max = true
					diff := int(candycanemax - candycanenum)
					num3 = (num3 + int(candycanenum)) - int(candycanemax)
					candycanenum = candycanemax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "pearl":
			if pearlnum == pearlmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+pearlnum <= pearlmax {
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
					pearlnum += num3
					pl.hpmax += num3
					pl.hp += num3
				} else if num3+pearlnum > pearlmax {
					max = true
					diff := pearlmax - pearlnum
					num3 = (num3 + pearlnum) - pearlmax
					pearlnum = pearlmax
					pl.hpmax += diff
					pl.hp += diff
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "magicians hat":
			if magicianshatnum == magicianshatmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+magicianshatnum <= magicianshatmax {
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
					magicianshatnum += num3
					pl.manamax += num3
					pl.mana += num3
				} else if num3+magicianshatnum > magicianshatmax {
					max = true
					diff := magicianshatmax - magicianshatnum
					num3 = (num3 + magicianshatnum) - magicianshatmax
					magicianshatnum = magicianshatmax
					pl.manamax += diff
					pl.mana += diff
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "throwing knife":
			if throwingknifenum == throwingknifemax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+throwingknifenum <= throwingknifemax {
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
					throwingknifenum += num3
				} else if num3+throwingknifenum > throwingknifemax {
					max = true
					diff := throwingknifemax - throwingknifenum
					num3 = (num3 + throwingknifenum) - throwingknifemax
					throwingknifenum = throwingknifemax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "toxic sludge":
			if !toxic {
				toxic = true
				num3--
				max = true
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "mirror":
			if !mirror {
				mirror = true
				num3--
				max = true
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "belt of whipping":
			if beltnum == beltmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+beltnum <= beltmax {
					beltnum += num3
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+beltnum > beltmax {
					max = true
					diff := beltmax - beltnum
					num3 = (num3 + beltnum) - beltmax
					beltnum = beltmax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "amulet of disc":
			if !frisbee {
				frisbee = true
				num3--
				max = true
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "amulet of purple rain":
			if !purplerain {
				purplerain = true
				num3--
				max = true
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "tesla coil":
			if !tesla {
				tesla = true
				num3--
				max = true
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "ring of twin":
			if !twin {
				twin = true
				num3--
				max = true
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "ring of thorns":
			if !thornson {
				thornson = true
				num3--
				max = true
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "ring of vine":
			if !vineRing {
				vineRing = true
				if pl.hp == 1 {
					pl.hp = 2
				}
				num3--
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
				max = true
			} else {
				max = true
			}
		case "toilet paper":
			if toiletpapernum == toiletpapermax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+toiletpapernum <= toiletpapermax {
					toiletpapernum += num3
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+toiletpapernum > toiletpapermax {
					max = true
					diff := toiletpapermax - toiletpapernum
					num3 = (num3 + toiletpapernum) - toiletpapermax
					toiletpapernum = toiletpapermax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "bear trap":
			if beartrapnum == beartrapmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+beartrapnum <= beartrapmax {
					beartrapnum += num3
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+beartrapnum > beartrapmax {
					max = true
					diff := beartrapmax - beartrapnum
					num3 = (num3 + beartrapnum) - beartrapmax
					beartrapnum = beartrapmax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
				beartrapT = (fps * 12) - (int32(beartrapnum*2) * fps)
			}
		case "basketball sneakers":
			if stats.dex == 5 {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+stats.dex <= 5 {
					stats.dex += num3
					stats.dex2 = stats.dex
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+stats.dex > 5 {
					max = true
					diff := 5 - stats.dex
					num3 = (num3 + stats.dex) - 5
					stats.dex = 5
					stats.dex2 = stats.dex
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "dumbbell":
			if stats.str == 5 {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+stats.str <= 5 {
					stats.str += num3
					stats.str2 = stats.str
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+stats.str > 5 {
					max = true
					diff := 5 - stats.str
					num3 = (num3 + stats.str) - 5
					stats.str = 5
					stats.str2 = stats.str
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "dice":
			if stats.luk == 5 {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+stats.luk <= 5 {
					stats.luk += num3
					stats.luk2 = stats.luk
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+stats.luk > 5 {
					max = true
					diff := 5 - stats.luk
					num3 = (num3 + stats.luk) - 5
					stats.luk = 5
					stats.luk2 = stats.luk
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "eyeball":
			if stats.per == 5 {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+stats.per <= 5 {
					stats.per += num3
					stats.per2 = stats.per
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+stats.per > 5 {
					max = true
					diff := 5 - stats.per
					num3 = (num3 + stats.per) - 5
					stats.per = 5
					stats.per2 = stats.per
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "brain":
			if stats.int == 5 {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+stats.int <= 5 {
					stats.int += num3
					stats.int2 = stats.int
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+stats.int > 5 {
					max = true
					diff := 5 - stats.int
					num3 = (num3 + stats.int) - 5
					stats.int = 5
					stats.int2 = stats.int
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "medikit":
			if medikitnum == medikitmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+medikitnum <= medikitmax {
					medikitnum += num3
					beartrapnum += num3
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+medikitnum > medikitmax {
					max = true
					diff := medikitmax - medikitnum
					num3 = (num3 + medikitnum) - medikitmax
					medikitnum = medikitmax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "backpack":
			if len(pl.invn) == invMax {
				max = true
				admsg("inventory max", rl.Red)
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+len(pl.invn) <= invMax {
					for i := 0; i < num3; i++ {
						pl.invn = append(pl.invn, xitm{})
					}
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+len(pl.invn) > invMax {
					max = true
					admsg("inventory max", rl.Red)
					diff := invMax - len(pl.invn)
					for i := 0; i < diff; i++ {
						pl.invn = append(pl.invn, xitm{})
					}
					num3 = (num3 + len(pl.invn)) - invMax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "gas can":
			if gascannum == gascanmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+gascannum <= gascanmax {
					gascannum += num3
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+gascannum > gascanmax {
					max = true
					diff := gascanmax - gascannum
					num3 = (num3 + gascannum) - gascanmax
					gascannum = gascanmax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "bottle of death":
			if deathbottlenum == deathbottlemax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+deathbottlenum <= deathbottlemax {
					deathbottlenum += num3
					gascannum += num3
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+deathbottlenum > deathbottlemax {
					max = true
					diff := deathbottlemax - deathbottlenum
					num3 = (num3 + deathbottlenum) - deathbottlemax
					deathbottlenum = deathbottlemax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "cleaver":
			if cleavernum == cleavermax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+cleavernum <= cleavermax {
					cleavernum += num3
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+cleavernum > cleavermax {
					max = true
					diff := cleavermax - cleavernum
					num3 = (num3 + cleavernum) - cleavermax
					cleavernum = cleavermax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "tenderiser":
			if tenderisernum == tenderisermax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+tenderisernum <= tenderisermax {
					tenderisernum += num3
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+tenderisernum > tenderisermax {
					max = true
					diff := tenderisermax - tenderisernum
					num3 = (num3 + tenderisernum) - tenderisermax
					tenderisernum = tenderisermax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "garlic":
			if garlicnum == garlicmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+garlicnum <= garlicmax {
					garlicnum += num3
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+garlicnum > garlicmax {
					max = true
					diff := garlicmax - garlicnum
					num3 = (num3 + garlicnum) - garlicmax
					garlicnum = garlicmax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "drill":
			if !drillon {
				drillon = true
				num3--
				max = true
				storeItm[num].numof = 1
				pl.art = append(pl.art, storeItm[num])
			} else {
				max = true
			}
		case "broccoli":
			if broccolinum == broccolimax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+broccolinum <= broccolimax {
					broccolinum += num3
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+broccolinum > broccolimax {
					max = true
					diff := broccolimax - broccolinum
					num3 = (num3 + broccolinum) - broccolimax
					broccolinum = broccolimax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "basketball":
			if basketballnum == basketballmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+basketballnum <= basketballmax {
					basketballnum += num3
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+basketballnum > basketballmax {
					max = true
					diff := basketballmax - basketballnum
					num3 = (num3 + basketballnum) - basketballmax
					basketballnum = basketballmax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "sunglasses":
			if stats.crit == stats.crit2 {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+stats.crit <= stats.crit2 {
					stats.crit += num3
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+stats.crit > stats.crit2 {
					max = true
					diff := stats.crit2 - stats.crit
					num3 = (num3 + stats.crit) - stats.crit2
					stats.crit = stats.crit2
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}
		case "sneakers":
			if sneakersnum == sneakersmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].nm)
				if num3+sneakersnum <= sneakersmax {
					sneakersnum += num3
					if pl.spd2 < pl.spdmax {
						pl.spd2 += float32(num3)
						if pl.spd2 > pl.spdmax {
							pl.spd2 = pl.spdmax
						}
						pl.spd = pl.spd2
					}
					if foundArt {
						pl.art[numArtSame].numof += num3
					} else {
						pl.art = append(pl.art, storeItm[num])
					}
				} else if num3+sneakersnum > sneakersmax {
					max = true
					diff := sneakersmax - sneakersnum
					pl.spd2 = pl.spdmax
					pl.spd = pl.spd2
					num3 = (num3 + sneakersnum) - sneakersmax
					sneakersnum = sneakersmax
					if foundArt {
						pl.art[numArtSame].numof += diff
					} else {
						pl.art = append(pl.art, storeItm[num])
						pl.art[len(pl.art)-1].numof = diff
					}
				}
			}

		}

		if max {
			rl.PlaySound(audfx[121])
			if msgT == 0 {
				admsg("artifact > "+storeItm[num].nm+" > max", rl.Red)
			}
			found = false
			for i := 0; i < len(pl.invn); i++ {
				if pl.invn[i].nm == storeItm[num].nm {
					pl.invn[i].numof += num3
					if msgT == 0 {
						admsg("in backpack > store for next run", rl.Magenta)
						msgT = fps
					}
					storeItm[num] = xitm{}
					storeItm[num].off = true
					found = true
				}
			}
			if !found {
				if nxInvnNum != blankint {
					pl.invn[nxInvnNum] = storeItm[num]
					pl.invn[nxInvnNum].numof = num3
					findnxinvnum()
					if msgT == 0 {
						admsg("in backpack > store for next run", rl.Magenta)
						msgT = fps
					}
					storeItm[num] = xitm{}
					storeItm[num].off = true
				} else {
					if msgT == 0 {
						admsg("inventory full > drop, stack or use", rl.Red)
						msgT = fps
					}
				}
			}
			msgT = fps / 2
		} else {
			rl.PlaySound(audfx[74])
			found, numSame := checkArtSameItm(storeItm[num])
			if found {
				pl.art[numSame].numof += num3
			} else {
				storeItm[num].numof = num3
				pl.art = append(pl.art, storeItm[num])
			}
			admsg("collected artifact "+storeItm[num].nm, rl.Magenta)
			storeItm[num] = xitm{}
			storeItm[num].off = true
		}

	} else {

		found = false
		empty := blankint
		for i := 0; i < len(pl.invn); i++ {
			if empty == blankint {
				if pl.invn[i].nm == "" {
					empty = i
				}
			}
			if pl.invn[i].nm == storeItm[num].nm {
				pl.invn[i].numof += storeItm[num].numof
				storeItm[num] = xitm{}
				found = true
				break
			}
		}
		if !found && !storeItm[num].notquick && !storeItm[num].art {
			for i := 0; i < len(pl.quik); i++ {
				if pl.quik[i].nm == storeItm[num].nm {
					pl.quik[i].numof += storeItm[num].numof
					storeItm[num] = xitm{}
					found = true
					break
				}
			}
		}
		if !found && !storeItm[num].notquick && !storeItm[num].art {
			for i := 0; i < len(pl.quik); i++ {
				if pl.quik[i].nm == "" {
					pl.quik[i] = storeItm[num]
					storeItm[num] = xitm{}
					found = true
					break
				}
			}
		}
		if !found && empty != blankint {
			pl.invn[empty] = storeItm[num]
			storeItm[num] = xitm{}
			found = true
		}

	}

	upInvenClearArt()

	return found
}

func useitm(num, inven0quik1 int) { //MARK: USE ITEM
	audnum := 0
	itnm := ""
	remove := true
	if inven0quik1 == 0 {
		itnm = pl.invn[num].nm
	} else {
		itnm = pl.quik[num].nm
	}
	switch itnm {
	case "salt":
		if saltT == 0 {
			rl.PlaySound(audfx[102])
			saltT = fps * 30
			if inven0quik1 == 0 {
				pl.invn[num].coolT = fps * 90
			} else {
				pl.quik[num].coolT = fps * 90
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "fart gas":
		if fartT == 0 {
			rl.PlaySound(audfx[97])
			fartT = fps * 30
			if inven0quik1 == 0 {
				pl.invn[num].coolT = fps * 90
			} else {
				pl.quik[num].coolT = fps * 90
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "boots":
		if bootsT == 0 {
			rl.PlaySound(audfx[96])
			bootsT = fps * 30
			if inven0quik1 == 0 {
				pl.invn[num].coolT = fps * 60
			} else {
				pl.quik[num].coolT = fps * 60
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "psychedelics":
		if psychedelicsT == 0 {
			rl.PlaySound(audfx[95])
			psychedelicsT = fps * 60
			if inven0quik1 == 0 {
				pl.invn[num].coolT = fps * 60
			} else {
				pl.quik[num].coolT = fps * 60
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "bomb":
		rl.PlaySound(audfx[93])
		zfx := xfx{}
		zfx.img = etc[123]
		zfx.rec = pl.rec
		zfx.nm = "bomb"
		zfx.T = fps * 3
		zfx.below = true
		fx = append(fx, zfx)
	case "popcorn":
		rl.PlaySound(audfx[87])
		siz := bq3
		ztile := xtile{}
		ztile.img = etc[122]
		ztile.rec = rl.NewRectangle(pl.cnt.X-siz/2, pl.cnt.Y-siz/2, siz, siz)
		ztile.nm = "popcornturret"
		ztile.cnt = makecnt(ztile.rec)
		ztile.v2 = ztile.cnt
		ztile.v2.X += b
		ztile.v2.Y -= b
		ztile.moveT = fps
		levels[levNum].etc = append(levels[levNum].etc, ztile)
	case "fried eggs":
		if eggsT == 0 {
			rl.PlaySound(audfx[92])
			eggsT = fps * 60
			admsg("chicky boom boom", rl.Yellow)
			zproj := xweap{}
			zproj.moveT = fps * 2
			siz := b
			zproj.rec = rl.NewRectangle(pl.cnt.X-siz/2, pl.cnt.Y-siz/2, siz, siz)
			zproj.crec = zproj.rec
			zproj.img = anm[102].rec
			zproj.cnt = makecnt(zproj.rec)
			zproj.fd = 1
			zproj.col = rl.White
			zproj.dmg = 0
			zproj.spd = 2
			zproj.dirX = RandF32(-zproj.spd, zproj.spd)
			zproj.dirY = RandF32(-zproj.spd, zproj.spd)
			zproj.nm = "chickenProj"
			projPL = append(projPL, zproj)
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "honeycomb":
		if honeycombT == 0 {
			rl.PlaySound(audfx[91])
			honeycombT = fps * 60
			admsg("buzzy bees", rl.Yellow)
			zproj := xweap{}
			zproj.moveT = fps / 2
			siz := b / 2
			zproj.rec = rl.NewRectangle(pl.cnt.X-siz/2, pl.cnt.Y-siz/2, siz, siz)
			zproj.crec = zproj.rec
			zproj.img = anm[100].rec
			zproj.cnt = makecnt(zproj.rec)
			zproj.fd = 1
			zproj.col = rl.White
			zproj.dmg = 5
			zproj.spd = 2
			zproj.dirX = RandF32(-zproj.spd, zproj.spd)
			zproj.dirY = RandF32(-zproj.spd, zproj.spd)
			zproj.nm = "beeProj"
			for i := 0; i < 20; i++ {
				projPL = append(projPL, zproj)
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "lollipop":
		if lollipopT == 0 {
			rl.PlaySound(audfx[90])
			lollipopT = fps * 30
			admsg("mana regeneration", rl.Green)
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "television":
		if tvT == 0 {
			rl.PlaySound(audfx[89])
			tvT = fps * 10
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
		}
	case "orange slice":
		if orangeT == 0 {
			rl.PlaySound(audfx[88])
			orangeT = fps * 30
			admsg("health regeneration", rl.Green)
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "ladybug":
		rl.PlaySound(audfx[84])
		siz := bq3
		ztile := xtile{}
		ztile.img = etc[112]
		ztile.rec = rl.NewRectangle(pl.cnt.X-siz/2, pl.cnt.Y-siz/2, siz, siz)
		ztile.nm = "ladybugturret"
		ztile.cnt = makecnt(ztile.rec)
		ztile.v2 = ztile.cnt
		ztile.v2.X += b
		ztile.v2.Y -= b
		ztile.angl = 0
		ztile.moveT = fps
		ztile.ro = 0
		levels[levNum].etc = append(levels[levNum].etc, ztile)
	case "beetroot":
		if beetrootT == 0 {
			rl.PlaySound(audfx[83])
			beetrootT = fps * 3
			num2 := 20
			zfx := xfx{}
			zfx.nm = "beetroot"
			zfx.img = etc[104]
			countbreak := 100
			siz := b4
			for num2 > 0 {
				v2 := pl.cnt
				v2.X += RandF32(-b10, b10)
				v2.Y += RandF32(-b10, b10)
				if checkV2inRooms(v2) {
					zfx.v2 = append(zfx.v2, v2)
					zfx.recs2 = append(zfx.recs2, rl.NewRectangle(v2.X-siz/2, v2.Y-siz/2, siz, siz))
					v2.Y -= inRec.Height
					zfx.v22 = append(zfx.v22, v2)
					zfx.onoff = append(zfx.onoff, false)
					num2--
				}
				countbreak--
				if countbreak == 0 {
					break
				}
			}
			fx = append(fx, zfx)
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "quail egg":
		if quailT == 0 {
			rl.PlaySound(audfx[82])
			admsg("a blustery day", rl.Yellow)
			quailT = fps * 30
			zfx := xfx{}
			zfx.nm = "tornado"
			zfx.img = anm[90].rec
			zfx.rec = pl.rec
			zfx.rec.X -= b
			zfx.rec.Y -= b
			zfx.rec.Width += b2
			zfx.rec.Height += b2
			zfx.crec = zfx.rec
			zfx.crec.X += zfx.crec.Width / 4
			zfx.crec.Width = zfx.crec.Width - zfx.crec.Width/2
			zfx.spd = 3
			countbreak := 100
			for {
				zfx.dirX = RandF32(-zfx.spd, zfx.spd)
				zfx.dirY = RandF32(-zfx.spd, zfx.spd)
				if Abs(zfx.dirX) > 1 || Abs(zfx.dirY) > 1 {
					break
				}
				countbreak--
				if countbreak == 0 {
					break
				}
			}
			zfx.cnt = makecnt(zfx.rec)
			fx = append(fx, zfx)
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "steroids":
		if steroidsT == 0 {
			rl.PlaySound(audfx[75])
			admsg("rambo returns", rl.Yellow)
			steroidsT = fps * 30
			stats.str2 = stats.str
			stats.str = 5
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "scroll of power":
		canspell := false
		if inven0quik1 == 0 {
			if pl.mana >= pl.invn[num].mana {
				pl.mana -= pl.invn[num].mana
				canspell = true
			}
		} else {
			if pl.mana >= pl.quik[num].mana {
				pl.mana -= pl.quik[num].mana
				canspell = true
			}
		}
		if canspell {
			rl.PlaySound(audfx[72])
			admsg("i got the power", rl.Yellow)
			powerT = fps * 30
			stats.dex2 = stats.dex
			stats.int2 = stats.int
			stats.luk2 = stats.luk
			stats.per2 = stats.per
			stats.str2 = stats.str
			stats.dex = 5
			stats.int = 5
			stats.luk = 5
			stats.per = 5
			stats.str = 5

			zfx := xfx{}
			zfx.img = anm[186].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "scrollfx"
			fx = append(fx, zfx)
		} else {
			rl.PlaySound(audfx[43])
			admsg("not enough mana", rl.Red)
			remove = false
		}
	case "scroll of inflict":
		canspell := false
		if inven0quik1 == 0 {
			if pl.mana >= pl.invn[num].mana {
				pl.mana -= pl.invn[num].mana
				canspell = true
			}
		} else {
			if pl.mana >= pl.quik[num].mana {
				pl.mana -= pl.quik[num].mana
				canspell = true
			}
		}
		if canspell {
			rl.PlaySound(audfx[71])
			admsg("take that you nasty beasts", rl.Yellow)
			inflictT = fps / 2
			for i := 0; i < len(levels[levNum].enm); i++ {
				if !levels[levNum].enm[i].nodmg {
					levels[levNum].enm[i].hp -= stats.int
				}
				if levels[levNum].enm[i].hp <= 0 && !levels[levNum].enm[i].off {
					pl.xp += levels[levNum].enm[i].xp
					makeEnDeathFx(i)
					levels[levNum].enm[i].off = true
				} else {
					if !levels[levNum].enm[i].nodmg {
						levels[levNum].enm[i].hpT = fps
						levels[levNum].enm[i].hpY = bq3
						levels[levNum].enm[i].hpY2 = 0
						if bosson {
							levels[levNum].enm[i].hpY = b
							levels[levNum].enm[i].hpY2 = b / 2
						}
					}
				}
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("not enough mana", rl.Red)
			remove = false
		}
	case "scroll of beginning":
		canspell := false
		if inven0quik1 == 0 {
			if pl.mana >= pl.invn[num].mana {
				pl.mana -= pl.invn[num].mana
				canspell = true
			}
		} else {
			if pl.mana >= pl.quik[num].mana {
				pl.mana -= pl.quik[num].mana
				canspell = true
			}
		}
		if canspell {
			rl.PlaySound(audfx[70])
			zfx := xfx{}
			zfx.img = anm[186].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "scrollfx"
			fx = append(fx, zfx)

			admsg("back to the beginning", rl.Yellow)
			teleportT = fps / 2
			telCntr = true
		} else {
			rl.PlaySound(audfx[43])
			admsg("not enough mana", rl.Red)
			remove = false
		}
	case "scroll of home":
		canspell := false
		if inven0quik1 == 0 {
			if pl.mana >= pl.invn[num].mana {
				pl.mana -= pl.invn[num].mana
				canspell = true
			}
		} else {
			if pl.mana >= pl.quik[num].mana {
				pl.mana -= pl.quik[num].mana
				canspell = true
			}
		}
		if canspell {
			rl.PlaySound(audfx[69])
			zfx := xfx{}
			zfx.img = anm[186].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "scrollfx"
			fx = append(fx, zfx)

			admsg("bye bye", rl.Yellow)
			teleportT = fps / 2
			telBase = true
		} else {
			rl.PlaySound(audfx[43])
			admsg("not enough mana", rl.Red)
			remove = false
		}
	case "scroll of detection":
		canspell := false
		if inven0quik1 == 0 {
			if pl.mana >= pl.invn[num].mana {
				pl.mana -= pl.invn[num].mana
				canspell = true
			}
		} else {
			if pl.mana >= pl.quik[num].mana {
				pl.mana -= pl.quik[num].mana
				canspell = true
			}
		}
		if canspell {
			zfx := xfx{}
			zfx.img = anm[186].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "scrollfx"
			fx = append(fx, zfx)

			admsg("abracadabra", rl.Yellow)
			for i := 0; i < len(levels[levNum].itm); i++ {
				if levels[levNum].itm[i].invis {
					levels[levNum].itm[i].invis = false
					zfx := xfx{}
					zfx.img = anm[108].rec
					zfx.rec = levels[levNum].itm[i].rec
					zfx.rec.X -= b
					zfx.rec.Y -= b
					zfx.rec.Width += b2
					zfx.rec.Height += b2
					zfx.nm = "summonitem"
					fx = append(fx, zfx)
					admsg("invisible loot revealed", rl.Magenta)
				}
			}
			rl.PlaySound(audfx[39])
		} else {
			rl.PlaySound(audfx[43])
			admsg("not enough mana", rl.Red)
			remove = false
		}
	case "scroll of intangibility":
		canspell := false
		if inven0quik1 == 0 {
			if pl.mana >= pl.invn[num].mana {
				pl.mana -= pl.invn[num].mana
				canspell = true
			}
		} else {
			if pl.mana >= pl.quik[num].mana {
				pl.mana -= pl.quik[num].mana
				canspell = true
			}
		}
		if canspell {
			rl.PlaySound(audfx[68])
			zfx := xfx{}
			zfx.img = anm[186].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "scrollfx"
			fx = append(fx, zfx)

			admsg("idclip", rl.Yellow)
			intangibleT = fps * 30
			if stats.int > 1 {
				diff := stats.int - 1
				for diff > 0 {
					diff--
					intangibleT += fps * 5
				}
				admsg("spell improved > intelligence", rl.Magenta)
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("not enough mana", rl.Red)
			remove = false
		}
	case "scroll of frogs":
		canspell := false
		if inven0quik1 == 0 {
			if pl.mana >= pl.invn[num].mana {
				pl.mana -= pl.invn[num].mana
				canspell = true
			}
		} else {
			if pl.mana >= pl.quik[num].mana {
				pl.mana -= pl.quik[num].mana
				canspell = true
			}
		}
		if canspell {
			rl.PlaySound(audfx[67])
			zfx := xfx{}
			zfx.img = anm[186].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "scrollfx"
			fx = append(fx, zfx)

			admsg("reign in frogs", rl.Yellow)
			zproj := xweap{}
			zproj.T = fps * 120
			zproj.moveT = fps / 6
			siz = b + b/2
			zproj.rec = rl.NewRectangle(pl.cnt.X-siz/2, pl.cnt.Y-siz/2, siz, siz)
			zproj.crec = zproj.rec
			zproj.crec.X += zproj.crec.Width / 4
			zproj.crec.Y += zproj.crec.Height / 4
			zproj.crec.Width = zproj.crec.Width / 2
			zproj.crec.Height = zproj.crec.Height / 2
			zproj.img = anm[78].rec
			zproj.cnt = makecnt(zproj.rec)
			zproj.fd = 1
			zproj.col = rl.White
			zproj.dmg = 5
			zproj.spd = 2
			zproj.nm = "frogProj"
			for i := 0; i < stats.int*4; i++ {
				projPL = append(projPL, zproj)
			}
			if stats.int > 1 {
				admsg("spell improved > intelligence", rl.Magenta)
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("not enough mana", rl.Red)
			remove = false
		}
	case "scroll of poison gas":
		canspell := false
		if inven0quik1 == 0 {
			if pl.mana >= pl.invn[num].mana {
				pl.mana -= pl.invn[num].mana
				canspell = true
			}
		} else {
			if pl.mana >= pl.quik[num].mana {
				pl.mana -= pl.quik[num].mana
				canspell = true
			}
		}
		if canspell {
			rl.PlaySound(audfx[66])
			zfx := xfx{}
			zfx.img = anm[186].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "scrollfx"
			fx = append(fx, zfx)

			admsg("excuse me i farted", rl.Yellow)
			zproj := xweap{}
			zproj.T = fps * 30
			siz = b4
			zproj.rec = rl.NewRectangle(pl.cnt.X-siz/2, pl.cnt.Y-siz/2, siz, siz)
			zproj.crec = zproj.rec
			zproj.crec.X += zproj.crec.Width / 4
			zproj.crec.Y += zproj.crec.Height / 4
			zproj.crec.Width = zproj.crec.Width / 2
			zproj.crec.Height = zproj.crec.Height / 2
			zproj.img = anm[76].rec
			zproj.cnt = makecnt(zproj.rec)
			zproj.fd = 1
			zproj.col = rl.White
			zproj.rospd = RandF32(2, 4)
			if FlipCoin() {
				zproj.rospd = -zproj.rospd
			}
			zproj.dmg = 1
			zproj.spd = 4
			zproj.dirX = RandF32(-zproj.spd, zproj.spd)
			zproj.dirY = RandF32(-zproj.spd, zproj.spd)
			zproj.nm = "poisongas"
			projPL = append(projPL, zproj)
			if stats.int > 1 {
				for i := 1; i < stats.int; i++ {
					zproj.dirX = RandF32(-zproj.spd, zproj.spd)
					zproj.dirY = RandF32(-zproj.spd, zproj.spd)
					projPL = append(projPL, zproj)
				}
				admsg("spell improved > intelligence", rl.Magenta)
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("not enough mana", rl.Red)
			remove = false
		}
	case "armor potion quarter":
		if pl.armorT == 0 {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			pl.armorT = fps * 15
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "armor potion half":
		if pl.armorT == 0 {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			pl.armorT = fps * 30
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "armor potion full":
		if pl.armorT == 0 {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			pl.armorT = fps * 60
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "invisibility quarter":
		if pl.invisT == 0 {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			pl.invisT = fps * 30
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "invisibility half":
		if pl.invisT == 0 {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			pl.invisT = fps * 60
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "invisibility full":
		if pl.invisT == 0 {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			pl.invisT = fps * 90
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "resist poison quarter":
		if pl.resPoisT == 0 {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			if pl.poisonT > 0 {
				pl.poisonT = 0
				admsg("poison cured", rl.Green)
			}
			pl.resPoisT = fps * 30
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "resist poison half":
		if pl.resPoisT == 0 {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			if pl.poisonT > 0 {
				pl.poisonT = 0
				admsg("poison cured", rl.Green)
			}
			pl.resPoisT = fps * 60
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "resist poison full":
		if pl.resPoisT == 0 {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			if pl.poisonT > 0 {
				pl.poisonT = 0
				admsg("poison cured", rl.Green)
			}
			pl.resPoisT = fps * 120
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "resist fire quarter":
		if pl.resFireT == 0 {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			if pl.burnT > 0 {
				pl.burnT = 0
				admsg("flames extinguished", rl.Yellow)
			}
			pl.burnT = 0
			pl.resFireT = fps * 30
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "resist fire half":
		if pl.resFireT == 0 {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			if pl.burnT > 0 {
				pl.burnT = 0
				admsg("flames extinguished", rl.Green)
			}
			pl.resFireT = fps * 60
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "resist fire full":
		if pl.resFireT == 0 {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			if pl.burnT > 0 {
				pl.burnT = 0
				admsg("flames extinguished", rl.Green)
			}
			pl.resFireT = fps * 120
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "mana potion quarter":
		if pl.mana < pl.manamax {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			pl.mana += 1
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("mana already full", rl.Red)
			remove = false
		}
	case "mana potion half":
		if pl.mana < pl.manamax {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			pl.mana += 2
			if pl.mana > pl.manamax {
				pl.mana = pl.manamax
			}
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("mana already full", rl.Red)
			remove = false
		}
	case "mana potion full":
		if pl.mana < pl.manamax {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			pl.mana = pl.manamax
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("mana already full", rl.Red)
			remove = false
		}
	case "hp potion quarter":
		if pl.hp < pl.hpmax {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			pl.hp += 1
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("hp already full", rl.Red)
			remove = false
		}
	case "hp potion half":
		if pl.hp < pl.hpmax {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			pl.hp += 3
			if pl.hp > pl.hpmax {
				pl.hp = pl.hpmax
			}
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("hp already full", rl.Red)
			remove = false
		}
	case "hp potion full":
		if pl.hp < pl.hpmax {
			zfx := xfx{}
			zfx.img = anm[188].rec
			siz := b4
			zfx.cnt = pl.cnt
			zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
			zfx.nm = "potionfx"
			fx = append(fx, zfx)
			pl.hp = pl.hpmax
			pl.poisonT = 0
			pl.burnT = 0
			pl.freezeT = 0
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("hp already full", rl.Red)
			remove = false
		}
	case "ice lolly":
		if icelollyT == 0 {
			rl.PlaySound(audfx[81])
			pl.burnT = 0
			admsg("cool like a brussel sprout", rl.Yellow)
			icelollyT = fps * 15
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "jar of blood":
		if bloodT == 0 {
			admsg("count dracula", rl.Yellow)
			bloodT = fps * 30
			for i := 0; i < len(levels[levNum].enm); i++ {
				levels[levNum].enm[i].bleed = 0
			}
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "jar of gas":
		if gasT == 0 {
			admsg("burn baby burn", rl.Yellow)
			gasT = fps * 30
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "ice cream":
		if icecreamT == 0 {
			rl.PlaySound(audfx[80])
			admsg("use the opportunity", rl.Yellow)
			icecreamT = fps * 10
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "soda":
		if sodaT == 0 {
			admsg("boosted", rl.Yellow)
			sodaT = fps * 30
			if pl.hp < pl.hpmax {
				pl.hp++
			}
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "turtle":
		if turtleT == 0 {
			rl.PlaySound(audfx[79])
			admsg("TMNT", rl.Yellow)
			turtleT = fps * 15
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "pistol":
		if pistolT == 0 {
			rl.PlaySound(audfx[78])
			admsg("attack, attack, attack!", rl.Yellow)
			pistolT = fps * 30
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "flask of slug pee":
		if slugT == 0 {
			admsg("run like the wind", rl.Yellow)
			slugT = fps * 30
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
		audnum = 1
	case "shrimp":
		if shrimpnum == 0 {
			rl.PlaySound(audfx[77])
			admsg("+3 shrimp shells", rl.Yellow)
			shrimpnum = 3
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "watch":
		rl.PlaySound(audfx[76])
		admsg("hurry up while you can", rl.Yellow)
		watchT = fps * 30
		if inven0quik1 == 0 {
			pl.invn[num].coolT = fps * 60
		} else {
			pl.quik[num].coolT = fps * 60
		}

	case "long range scope":
		rl.PlaySound(audfx[73])
		admsg("enjoy the view", rl.Yellow)
		cam2Zorig = cam2.Zoom
		scopeZmax = cam2.Zoom - scopeZ
		if scopeZmax < 0.5 {
			scopeZmax = 0.5
		}
		scopeon = true
		scopeT = fps
		if inven0quik1 == 0 {
			pl.invn[num].coolT = fps * 10
		} else {
			pl.quik[num].coolT = fps * 10
		}
	}
	//REMOVE FROM QUIK OR INVEN

	if remove {
		if itnm != "long range scope" && itnm != "watch" && itnm != "psychedelics" && itnm != "boots" && itnm != "fart gas" && itnm != "salt" {
			if inven0quik1 == 0 {
				if pl.invn[num].numof > 1 {
					pl.invn[num].numof--
				} else {
					pl.invn[num] = xitm{}
				}
			} else {
				if pl.quik[num].numof > 1 {
					pl.quik[num].numof--
				} else {
					pl.quik[num] = xitm{}
				}
			}
		}
		switch audnum {
		case 1:
			rl.PlaySound(audfx[16])
		}
	}
}
func brec(rec rl.Rectangle, dist float32) rl.Rectangle { //MARK: MAKE BLUR REC
	rec.X += RandF32(-dist, dist)
	rec.Y += RandF32(-dist, dist)
	return rec
}
func packStore() { //MARK: PACK STORE
	invCopy := make([]xitm, len(storeItm))
	copy(invCopy, storeItm)
	for i := 0; i < len(storeItm); i++ {
		storeItm[i] = xitm{}
	}
	count := 0
	for i := 0; i < len(invCopy); i++ {
		if invCopy[i].nm != "" {
			storeItm[count] = invCopy[i]
			count++
		}
	}
}
func pack() { //MARK: PACK
	invCopy := make([]xitm, len(pl.invn))
	copy(invCopy, pl.invn)
	for i := 0; i < len(pl.invn); i++ {
		pl.invn[i] = xitm{}
	}
	count := 0
	for i := 0; i < len(invCopy); i++ {
		if invCopy[i].nm != "" {
			pl.invn[count] = invCopy[i]
			count++
		}
	}
	findnxinvnum()
}
func stackStore() { //MARK: STACK STORE
	found := false
	countbreak := 100
	for {
		for i := 0; i < len(storeItm); i++ {
			for j := 0; j < len(storeItm); j++ {
				if i != j {
					if storeItm[i].nm == storeItm[j].nm {
						found = true
					}
				}
			}
		}
		if found {
			for i := 0; i < len(storeItm); i++ {
				for j := 0; j < len(storeItm); j++ {
					if i != j {
						if storeItm[i].nm == storeItm[j].nm && !storeItm[j].off {
							storeItm[j].off = true
							storeItm[i].numof += storeItm[j].numof
							storeItm[j].numof = 0
							storeItm[j].nm = ""
						}
					}
				}
			}
			found = false
			for i := 0; i < len(storeItm); i++ {
				if storeItm[i].off {
					storeItm[i] = xitm{}
				}
			}
		}
		countbreak--
		if countbreak == 0 || !found {
			break
		}
	}
}
func stack() { //MARK: STACK
	found := false
	countbreak := 100
	for {
		for i := 0; i < len(pl.invn); i++ {
			for j := 0; j < len(pl.invn); j++ {
				if i != j {
					if pl.invn[i].nm == pl.invn[j].nm {
						found = true
					}
				}
			}
		}
		if found {
			for i := 0; i < len(pl.invn); i++ {
				for j := 0; j < len(pl.invn); j++ {
					if i != j {
						if pl.invn[i].nm == pl.invn[j].nm && !pl.invn[j].off {
							pl.invn[j].off = true
							pl.invn[i].numof += pl.invn[j].numof
							pl.invn[j].numof = 0
							pl.invn[j].nm = ""
						}
					}
				}
			}
			found = false
			for i := 0; i < len(pl.invn); i++ {
				if pl.invn[i].off {
					pl.invn[i] = xitm{}
				}
			}
		}
		countbreak--
		if countbreak == 0 || !found {
			break
		}
	}

	findnxinvnum()
}
func cleardoorblocks(lev x1scr) x1scr { //MARK: CLEAR DOOR BLOCKS
	clear := false
	for i := 0; i < len(lev.walls); i++ {
		for j := 0; j < len(lev.doors); j++ {
			if rl.CheckCollisionRecs(lev.doors[j], lev.walls[i].rec) {
				lev.walls[i].off = true
				clear = true
			}
		}
	}
	if clear {
		for i := 0; i < len(lev.walls); i++ {
			if lev.walls[i].off {
				lev.walls = RemoveTile(lev.walls, i)
			}
		}
	}
	return lev
}
func movequik2invn(num int) { //MARK: MOVE QUIK TO INVN
	found, numSame := checkInvnSameItm(pl.quik[num])
	if found {
		pl.invn[numSame].numof++
	} else {
		pl.invn[nxInvnNum] = pl.quik[num]
		findnxinvnum()
	}
	pl.quik[num] = xitm{}
}
func collectfromchest(chestnum, itemnum int) { //MARK: COLLECT FROM CHEST
	didnotadd := false
	if levels[levNum].chst[0].itm[itemnum].nm == "xp update" {
		rl.PlaySound(audfx[103])
		num4 := RandInt(200, 401)
		pl.xp += num4
		levels[levNum].chst[0].itm[itemnum] = xitm{}
		levels[levNum].chst[0].itm[itemnum].off = true
		admsg(fmt.Sprint(num4)+" xp added", rl.Green)
	} else {
		if levels[levNum].chst[0].itm[itemnum].art {

			if levels[levNum].chst[0].itm[itemnum].numof > 1 {

				max := false
				num3 := levels[levNum].chst[0].itm[itemnum].numof

				switch levels[levNum].chst[0].itm[itemnum].nm {
				//NON BOSS ARTIFACTS MUST ALSO BE ADDED TO COLLECT FROM CHEST

				case "rollo":
					if !rollo {
						rollo = true
						num3--
						max = true
						pl.hpmax += 1
						pl.hp += 1
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "landmine":
					if !landmine {
						landmine = true
						num3--
						max = true
						landmineT = fps * 7
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "batty":
					if !batty {
						batty = true
						num3--
						max = true
						pl.hpmax += 1
						pl.hp += 1
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "zombie head":
					if !zombiehead {
						zombiehead = true
						zombienum = 2
						if pl.hp == pl.hpmax {
							pl.hp--
						}
						pl.hpmax -= 1
						num3--
						max = true
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "pyroball":
					if !pyroball {
						pyroball = true
						num3--
						max = true
						pyroballT = fps * 7
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "space helmet":
					if spacehelmetnum == spacehelmetmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+spacehelmetnum <= spacehelmetmax {
							spacehelmetnum += num3
							for j := 0; j < num3; j++ {
								for i := 0; i < len(itmlist); i++ {
									if !itmlist[i].nocrate {
										if itmlist[i].cost >= 35 {
											itmlist[i].cost -= 25
										}
									}
								}
							}
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}

						} else if num3+spacehelmetnum > spacehelmetmax {
							max = true
							diff := spacehelmetmax - spacehelmetnum
							for j := 0; j < diff; j++ {
								for i := 0; i < len(itmlist); i++ {
									if !itmlist[i].nocrate {
										if itmlist[i].cost >= 35 {
											itmlist[i].cost -= 25
										}
									}
								}
							}
							num3 = (num3 + spacehelmetnum) - spacehelmetmax
							spacehelmetnum = spacehelmetmax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
					if spacehelmetnum < spacehelmetmax {
						spacehelmetnum++
						for i := 0; i < len(itmlist); i++ {
							if !itmlist[i].nocrate {
								if itmlist[i].cost >= 35 {
									itmlist[i].cost -= 25
								}
							}
						}
					} else {
						max = true
					}
				case "spinna":
					if !spinna {
						spinna = true
						num3--
						max = true
						spinnaT = fps * 7
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "mr frisbee's frisbee":
					if !mrfrisbee {
						mrfrisbee = true
						num3--
						max = true
						mrfrisbeeT = fps * 7
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "ice crystal":
					if !icecrystal {
						icecrystal = true
						num3--
						max = true
						icecrystalT = fps * 7
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}

				case "weapon case":
					if weaponcasenum == weaponcasemax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+weaponcasenum <= weaponcasemax {
							for i := 0; i < num3; i++ {
								pl.weaps = append(pl.weaps, xweap{})
								weaponcasenum++
							}
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+weaponcasenum > weaponcasemax {
							max = true
							diff := int(weaponcasemax - weaponcasenum)
							num3 = (num3 + weaponcasenum) - weaponcasemax
							weaponcasenum = weaponcasemax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "umbrella":
					if !umbrella {
						umbrella = true
						num3--
						max = true
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "map chest pin":
					if !chestpin {
						chestpin = true
						num3--
						max = true
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "map exit pin":
					if !mappin {
						mappin = true
						num3--
						max = true
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "gas mask":
					if gasmasknum == gasmaskmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+int(gasmasknum) <= int(gasmaskmax) {
							gasmasknum += int32(num3)
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+int(gasmasknum) > int(gasmaskmax) {
							max = true
							diff := int(gasmaskmax - gasmasknum)
							num3 = (num3 + int(gasmasknum)) - int(gasmaskmax)
							gasmasknum = gasmaskmax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
						if gasmaskT == 0 {
							gasmaskT = fps*8 - (gasmasknum * fps)
						}
					}
				case "noodles":
					if !noodles {
						noodles = true
						num3--
						max = true
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "oven glove":
					if ovenglovenum == ovenglovemax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+ovenglovenum <= ovenglovemax {
							ovenglovenum += num3
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+ovenglovenum > ovenglovemax {
							max = true
							diff := int(ovenglovemax - ovenglovenum)
							num3 = (num3 + ovenglovenum) - ovenglovemax
							ovenglovenum = ovenglovemax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "toaster":
					if !toaster {
						toaster = true
						num3--
						max = true
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "ninja star":
					if ninjanum == ninjamax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+ninjanum <= ninjamax {
							ninjanum += num3
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+ninjanum > ninjamax {
							max = true
							diff := int(ninjamax - ninjanum)
							num3 = (num3 + ninjanum) - ninjamax
							ninjanum = ninjamax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "flamingo":
					if flamingonum == flamingomax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+int(flamingonum) <= int(flamingomax) {
							flamingonum += int32(num3)
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+int(flamingonum) > int(flamingomax) {
							max = true
							diff := int(flamingomax - flamingonum)
							num3 = (num3 + int(flamingonum)) - int(flamingomax)
							flamingonum = flamingomax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
						if flamingoT == 0 {
							flamingoT = (fps + fps/2) / flamingonum
						}
					}
				case "mug of tea":
					if teanum == teamax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+teanum <= teamax {
							teanum += num3
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+teanum > teamax {
							max = true
							diff := int(teamax - teanum)
							num3 = (num3 + teanum) - teamax
							teanum = teamax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "cloak of sparks":
					if !cloak {
						cloak = true
						num3--
						max = true
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "feather":
					if !feather {
						feather = true
						num3--
						max = true
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "mugging":
					if mugnum == mugmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+mugnum <= mugmax {
							mugnum += num3
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+mugnum > mugmax {
							max = true
							diff := int(mugmax - mugnum)
							num3 = (num3 + mugnum) - mugmax
							mugnum = mugmax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "lightbulb":
					if lightbulbnum == lightbulbmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+lightbulbnum <= lightbulbmax {
							lightbulbnum += num3
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+lightbulbnum > lightbulbmax {
							max = true
							diff := int(lightbulbmax - lightbulbnum)
							num3 = (num3 + mugnum) - lightbulbmax
							lightbulbnum = lightbulbmax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "candy cane":
					if candycanenum == candycanemax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+int(candycanenum) <= int(candycanemax) {
							candycanenum += int32(num3)
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+int(candycanenum) > int(candycanemax) {
							max = true
							diff := int(candycanemax - candycanenum)
							num3 = (num3 + int(candycanenum)) - int(candycanemax)
							candycanenum = candycanemax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "pearl":
					if pearlnum == pearlmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+pearlnum <= pearlmax {
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
							pearlnum += num3
							pl.hpmax += num3
							pl.hp += num3
						} else if num3+pearlnum > pearlmax {
							max = true
							diff := pearlmax - pearlnum
							num3 = (num3 + pearlnum) - pearlmax
							pearlnum = pearlmax
							pl.hpmax += diff
							pl.hp += diff
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "magicians hat":
					if magicianshatnum == magicianshatmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+magicianshatnum <= magicianshatmax {
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
							magicianshatnum += num3
							pl.manamax += num3
							pl.mana += num3
						} else if num3+magicianshatnum > magicianshatmax {
							max = true
							diff := magicianshatmax - magicianshatnum
							num3 = (num3 + magicianshatnum) - magicianshatmax
							magicianshatnum = magicianshatmax
							pl.manamax += diff
							pl.mana += diff
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "throwing knife":
					if throwingknifenum == throwingknifemax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+throwingknifenum <= throwingknifemax {
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
							throwingknifenum += num3
						} else if num3+throwingknifenum > throwingknifemax {
							max = true
							diff := throwingknifemax - throwingknifenum
							num3 = (num3 + throwingknifenum) - throwingknifemax
							throwingknifenum = throwingknifemax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "toxic sludge":
					if !toxic {
						toxic = true
						num3--
						max = true
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "mirror":
					if !mirror {
						mirror = true
						num3--
						max = true
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "belt of whipping":
					if beltnum == beltmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+beltnum <= beltmax {
							beltnum += num3
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+beltnum > beltmax {
							max = true
							diff := beltmax - beltnum
							num3 = (num3 + beltnum) - beltmax
							beltnum = beltmax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "amulet of disc":
					if !frisbee {
						frisbee = true
						num3--
						max = true
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "amulet of purple rain":
					if !purplerain {
						purplerain = true
						num3--
						max = true
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "tesla coil":
					if !tesla {
						tesla = true
						num3--
						max = true
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "ring of twin":
					if !twin {
						twin = true
						num3--
						max = true
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "ring of thorns":
					if !thornson {
						thornson = true
						num3--
						max = true
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "ring of vine":
					if !vineRing {
						vineRing = true
						if pl.hp == 1 {
							pl.hp = 2
						}
						num3--
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
						max = true
					} else {
						max = true
					}
				case "toilet paper":
					if toiletpapernum == toiletpapermax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+toiletpapernum <= toiletpapermax {
							toiletpapernum += num3
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+toiletpapernum > toiletpapermax {
							max = true
							diff := toiletpapermax - toiletpapernum
							num3 = (num3 + toiletpapernum) - toiletpapermax
							toiletpapernum = toiletpapermax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "bear trap":
					if beartrapnum == beartrapmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+beartrapnum <= beartrapmax {
							beartrapnum += num3
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+beartrapnum > beartrapmax {
							max = true
							diff := beartrapmax - beartrapnum
							num3 = (num3 + beartrapnum) - beartrapmax
							beartrapnum = beartrapmax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
						beartrapT = (fps * 12) - (int32(beartrapnum*2) * fps)
					}
				case "basketball sneakers":
					if stats.dex == 5 {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+stats.dex <= 5 {
							stats.dex += num3
							stats.dex2 = stats.dex
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+stats.dex > 5 {
							max = true
							diff := 5 - stats.dex
							num3 = (num3 + stats.dex) - 5
							stats.dex = 5
							stats.dex2 = stats.dex
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "dumbbell":
					if stats.str == 5 {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+stats.str <= 5 {
							stats.str += num3
							stats.str2 = stats.str
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+stats.str > 5 {
							max = true
							diff := 5 - stats.str
							num3 = (num3 + stats.str) - 5
							stats.str = 5
							stats.str2 = stats.str
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "dice":
					if stats.luk == 5 {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+stats.luk <= 5 {
							stats.luk += num3
							stats.luk2 = stats.luk
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+stats.luk > 5 {
							max = true
							diff := 5 - stats.luk
							num3 = (num3 + stats.luk) - 5
							stats.luk = 5
							stats.luk2 = stats.luk
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "eyeball":
					if stats.per == 5 {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+stats.per <= 5 {
							stats.per += num3
							stats.per2 = stats.per
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+stats.per > 5 {
							max = true
							diff := 5 - stats.per
							num3 = (num3 + stats.per) - 5
							stats.per = 5
							stats.per2 = stats.per
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "brain":
					if stats.int == 5 {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+stats.int <= 5 {
							stats.int += num3
							stats.int2 = stats.int
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+stats.int > 5 {
							max = true
							diff := 5 - stats.int
							num3 = (num3 + stats.int) - 5
							stats.int = 5
							stats.int2 = stats.int
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "medikit":
					if medikitnum == medikitmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+medikitnum <= medikitmax {
							medikitnum += num3
							beartrapnum += num3
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+medikitnum > medikitmax {
							max = true
							diff := medikitmax - medikitnum
							num3 = (num3 + medikitnum) - medikitmax
							medikitnum = medikitmax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "backpack":
					if len(pl.invn) == invMax {
						max = true
						admsg("inventory max", rl.Red)
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+len(pl.invn) <= invMax {
							for i := 0; i < num3; i++ {
								pl.invn = append(pl.invn, xitm{})
							}
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+len(pl.invn) > invMax {
							max = true
							admsg("inventory max", rl.Red)
							diff := invMax - len(pl.invn)
							for i := 0; i < diff; i++ {
								pl.invn = append(pl.invn, xitm{})
							}
							num3 = (num3 + len(pl.invn)) - invMax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "gas can":
					if gascannum == gascanmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+gascannum <= gascanmax {
							gascannum += num3
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+gascannum > gascanmax {
							max = true
							diff := gascanmax - gascannum
							num3 = (num3 + gascannum) - gascanmax
							gascannum = gascanmax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "bottle of death":
					if deathbottlenum == deathbottlemax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+deathbottlenum <= deathbottlemax {
							deathbottlenum += num3
							gascannum += num3
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+deathbottlenum > deathbottlemax {
							max = true
							diff := deathbottlemax - deathbottlenum
							num3 = (num3 + deathbottlenum) - deathbottlemax
							deathbottlenum = deathbottlemax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "cleaver":
					if cleavernum == cleavermax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+cleavernum <= cleavermax {
							cleavernum += num3
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+cleavernum > cleavermax {
							max = true
							diff := cleavermax - cleavernum
							num3 = (num3 + cleavernum) - cleavermax
							cleavernum = cleavermax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "tenderiser":
					if tenderisernum == tenderisermax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+tenderisernum <= tenderisermax {
							tenderisernum += num3
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+tenderisernum > tenderisermax {
							max = true
							diff := tenderisermax - tenderisernum
							num3 = (num3 + tenderisernum) - tenderisermax
							tenderisernum = tenderisermax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "garlic":
					if garlicnum == garlicmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+garlicnum <= garlicmax {
							garlicnum += num3
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+garlicnum > garlicmax {
							max = true
							diff := garlicmax - garlicnum
							num3 = (num3 + garlicnum) - garlicmax
							garlicnum = garlicmax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "drill":
					if !drillon {
						drillon = true
						num3--
						max = true
						levels[levNum].chst[0].itm[itemnum].numof = 1
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					} else {
						max = true
					}
				case "broccoli":
					if broccolinum == broccolimax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+broccolinum <= broccolimax {
							broccolinum += num3
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+broccolinum > broccolimax {
							max = true
							diff := broccolimax - broccolinum
							num3 = (num3 + broccolinum) - broccolimax
							broccolinum = broccolimax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "basketball":
					if basketballnum == basketballmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+basketballnum <= basketballmax {
							basketballnum += num3
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+basketballnum > basketballmax {
							max = true
							diff := basketballmax - basketballnum
							num3 = (num3 + basketballnum) - basketballmax
							basketballnum = basketballmax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "sunglasses":
					if stats.crit == stats.crit2 {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+stats.crit <= stats.crit2 {
							stats.crit += num3
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+stats.crit > stats.crit2 {
							max = true
							diff := stats.crit2 - stats.crit
							num3 = (num3 + stats.crit) - stats.crit2
							stats.crit = stats.crit2
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}
				case "sneakers":
					if sneakersnum == sneakersmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chst[0].itm[itemnum].nm)
						if num3+sneakersnum <= sneakersmax {
							sneakersnum += num3
							if pl.spd2 < pl.spdmax {
								pl.spd2 += float32(num3)
								if pl.spd2 > pl.spdmax {
									pl.spd2 = pl.spdmax
								}
								pl.spd = pl.spd2
							}
							if foundArt {
								pl.art[numArtSame].numof += num3
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
							}
						} else if num3+sneakersnum > sneakersmax {
							max = true
							diff := sneakersmax - sneakersnum
							pl.spd2 = pl.spdmax
							pl.spd = pl.spd2
							num3 = (num3 + sneakersnum) - sneakersmax
							sneakersnum = sneakersmax
							if foundArt {
								pl.art[numArtSame].numof += diff
							} else {
								pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
								pl.art[len(pl.art)-1].numof = diff
							}
						}
					}

				}

				if max {
					rl.PlaySound(audfx[121])
					if msgT == 0 {
						admsg("artifact > "+levels[levNum].chst[0].itm[itemnum].nm+" > max", rl.Red)
					}
					found := false
					for i := 0; i < len(pl.invn); i++ {
						if pl.invn[i].nm == levels[levNum].chst[0].itm[itemnum].nm {
							pl.invn[i].numof += num3
							if msgT == 0 {
								admsg("in backpack > store for next run", rl.Magenta)
								msgT = fps
							}
							levels[levNum].chst[0].itm[itemnum] = xitm{}
							levels[levNum].chst[0].itm[itemnum].off = true
							found = true
						}
					}
					if !found {
						if nxInvnNum != blankint {
							pl.invn[nxInvnNum] = levels[levNum].chst[0].itm[itemnum]
							pl.invn[nxInvnNum].numof = num3
							findnxinvnum()
							if msgT == 0 {
								admsg("in backpack > store for next run", rl.Magenta)
								msgT = fps
							}
							levels[levNum].chst[0].itm[itemnum] = xitm{}
							levels[levNum].chst[0].itm[itemnum].off = true
						} else {
							if msgT == 0 {
								admsg("inventory full > drop, stack or use", rl.Red)
								msgT = fps
							}
						}
					}
					msgT = fps / 2
				} else {
					rl.PlaySound(audfx[74])
					found, numSame := checkArtSameItm(levels[levNum].chst[0].itm[itemnum])
					if found {
						pl.art[numSame].numof += num3
					} else {
						levels[levNum].chst[0].itm[itemnum].numof = num3
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					}
					admsg("collected artifact "+levels[levNum].chst[0].itm[itemnum].nm, rl.Magenta)
					levels[levNum].chst[0].itm[itemnum] = xitm{}
					levels[levNum].chst[0].itm[itemnum].off = true
				}

			} else {

				max := false
				switch levels[levNum].chst[0].itm[itemnum].nm {
				case "rollo":
					if !rollo {
						rollo = true
						pl.hpmax += 1
						pl.hp += 1
					} else {
						max = true
					}
				case "landmine":
					if !landmine {
						landmine = true
						landmineT = fps * 7
					} else {
						max = true
					}
				case "batty":
					if !batty {
						batty = true
						pl.hpmax += 1
						pl.hp += 1
					} else {
						max = true
					}
				case "zombie head":
					if !zombiehead {
						zombiehead = true
						zombienum = 2
						if pl.hp == pl.hpmax {
							pl.hp--
						}
						pl.hpmax -= 1
					} else {
						max = true
					}
				case "pyroball":
					if !pyroball {
						pyroball = true
						pyroballT = fps * 7
					} else {
						max = true
					}
				case "space helmet":
					if spacehelmetnum < spacehelmetmax {
						spacehelmetnum++
						for i := 0; i < len(itmlist); i++ {
							if !itmlist[i].nocrate {
								if itmlist[i].cost >= 35 {
									itmlist[i].cost -= 25
								}
							}
						}
					} else {
						max = true
					}
				case "spinna":
					if !spinna {
						spinna = true
						spinnaT = fps * 7
					} else {
						max = true
					}
				case "mr frisbee's frisbee":
					if !mrfrisbee {
						mrfrisbee = true
						mrfrisbeeT = fps * 7
					} else {
						max = true
					}
				case "ice crystal":
					if !icecrystal {
						icecrystal = true
						icecrystalT = fps * 5
					} else {
						max = true
					}

				//NON BOSS ARTIFACTS MUST ALSO BE ADDED TO COLLECT FROM INVEN FOR DROP ARTIFACT
				case "weapon case":
					if weaponcasenum < weaponcasemax {
						pl.weaps = append(pl.weaps, xweap{})
						weaponcasenum++
					} else {
						max = true
					}
				case "umbrella":
					if !umbrella {
						umbrella = true
					} else {
						max = true
					}
				case "map chest pin":
					if !chestpin {
						chestpin = true
					} else {
						max = true
					}
				case "map exit pin":
					if !mappin {
						mappin = true
					} else {
						max = true
					}
				case "gas mask":
					if gasmasknum < gasmaskmax {
						gasmasknum++
						if gasmaskT == 0 {
							gasmaskT = fps*8 - (gasmasknum * fps)
						}
					} else {
						max = true
					}
				case "noodles":
					if !noodles {
						noodles = true
					} else {
						max = true
					}
				case "oven glove":
					if ovenglovenum < ovenglovemax {
						ovenglovenum++
					} else {
						max = true
					}
				case "toaster":
					if !toaster {
						toaster = true
					} else {
						max = true
					}
				case "ninja star":
					if ninjanum < ninjamax {
						ninjanum++
					} else {
						max = true
					}
				case "flamingo":
					if flamingonum < flamingomax {
						flamingonum++
						if flamingoT == 0 {
							flamingoT = (fps + fps/2) / flamingonum
						}
					} else {
						max = true
					}
				case "mug of tea":
					if teanum < teamax {
						teanum++
					} else {
						max = true
					}
				case "cloak of sparks":
					if !cloak {
						cloak = true
					} else {
						max = true
					}
				case "feather":
					if !feather {
						feather = true
					} else {
						max = true
					}
				case "mugging":
					if mugnum < mugmax {
						mugnum++
					} else {
						max = true
					}
				case "lightbulb":
					if lightbulbnum < lightbulbmax {
						lightbulbnum++
					} else {
						max = true
					}
				case "candy cane":
					if candycanenum < candycanemax {
						candycanenum++
					} else {
						max = true
					}
				case "pearl":
					if pearlnum < pearlmax {
						pearlnum++
						pl.hpmax++
						pl.hp++
					} else {
						max = true
					}
				case "magicians hat":
					if magicianshatnum < magicianshatmax {
						magicianshatnum++
						pl.manamax++
						pl.mana++
					} else {
						max = true
					}
				case "throwing knife":
					if throwingknifenum < throwingknifemax {
						throwingknifenum++
					} else {
						max = true
					}
				case "toxic sludge":
					if !toxic {
						toxic = true
					} else {
						max = true
					}
				case "mirror":
					if !mirror {
						mirror = true
					} else {
						max = true
					}
				case "belt of whipping":
					if beltnum < beltmax {
						beltnum++
					} else {
						max = true
					}
				case "amulet of disc":
					if !frisbee {
						frisbee = true
					} else {
						max = true
					}
				case "amulet of purple rain":
					if !purplerain {
						purplerain = true
					} else {
						max = true
					}
				case "tesla coil":
					if !tesla {
						tesla = true
					} else {
						max = true
					}
				case "ring of twin":
					if !twin {
						twin = true
					} else {
						max = true
					}
				case "ring of thorns":
					if !thornson {
						thornson = true
					} else {
						max = true
					}
				case "ring of vine":
					if !vineRing {
						vineRing = true
						if pl.hp == 1 {
							pl.hp = 2
						}
					} else {
						max = true
					}
				case "toilet paper":
					if toiletpapernum < toiletpapermax {
						toiletpapernum++
					} else {
						max = true
					}
				case "bear trap":
					if beartrapnum < beartrapmax {
						beartrapnum++
						beartrapT = (fps * 12) - (int32(beartrapnum*2) * fps)
					} else {
						max = true
					}
				case "basketball sneakers":
					if stats.dex < 5 {
						stats.dex++
						stats.dex2 = stats.dex
					} else {
						max = true
					}
				case "dumbbell":
					if stats.str < 5 {
						stats.str++
						stats.str2 = stats.str
					} else {
						max = true
					}
				case "dice":
					if stats.luk < 5 {
						stats.luk++
						stats.luk2 = stats.luk
					} else {
						max = true
					}
				case "eyeball":
					if stats.per < 5 {
						stats.per++
						stats.per2 = stats.per
					} else {
						max = true
					}
				case "brain":
					if stats.int < 5 {
						stats.int++
						stats.int2 = stats.int
					} else {
						max = true
					}
				case "medikit":
					if medikitnum < medikitmax {
						medikiton = true
					} else {
						max = true
					}
				case "backpack":
					if len(pl.invn) < invMax {
						pl.invn = append(pl.invn, xitm{})
					} else {
						max = true
						admsg("inventory max", rl.Red)
					}
				case "gas can":
					if gascannum < gascanmax {
						gascannum++
					} else {
						max = true
					}
				case "bottle of death":
					if deathbottlenum < deathbottlemax {
						deathbottlenum++
					} else {
						max = true
					}
				case "cleaver":
					if cleavernum < cleavermax {
						cleavernum++
					} else {
						max = true
					}
				case "tenderiser":
					if tenderisernum < tenderisermax {
						tenderisernum++
					} else {
						max = true
					}
				case "garlic":
					if garlicnum < garlicmax {
						garlicnum++
					} else {
						max = true
					}
				case "drill":
					if !drillon {
						drillon = true
					} else {
						max = true
					}
				case "broccoli":
					if broccolinum < broccolimax {
						broccolinum++
					} else {
						max = true
					}
				case "basketball":
					if basketballnum < basketballmax {
						basketballnum++
					} else {
						max = true
					}
				case "sunglasses":
					if stats.crit < stats.crit2 {
						stats.crit++
					} else {
						max = true
					}
				case "sneakers":
					if sneakersnum < sneakersmax {
						sneakersnum++
						if pl.spd2 < pl.spdmax {
							pl.spd2++
							pl.spd = pl.spd2
						}
					} else {
						max = true
					}

				}
				if max {
					rl.PlaySound(audfx[121])
					admsg("artifact > "+levels[levNum].chst[0].itm[itemnum].nm+" > max", rl.Red)
					found := false
					for i := 0; i < len(pl.invn); i++ {
						if pl.invn[i].nm == levels[levNum].chst[0].itm[itemnum].nm {
							pl.invn[i].numof++
							if msgT == 0 {
								admsg("in backpack > store for next run", rl.Magenta)
								msgT = fps
							}
							levels[levNum].chst[0].itm[itemnum].off = true
							levels[levNum].chst[0].itm[itemnum] = xitm{}
							found = true
						}
					}
					if !found {
						if nxInvnNum != blankint {
							pl.invn[nxInvnNum] = levels[levNum].chst[0].itm[itemnum]
							findnxinvnum()
							if msgT == 0 {
								admsg("in backpack > store for next run", rl.Magenta)
								msgT = fps
							}
							levels[levNum].chst[0].itm[itemnum].off = true
							levels[levNum].chst[0].itm[itemnum] = xitm{}
						} else {
							if msgT == 0 {
								admsg("inventory full > drop, stack or use", rl.Red)
								msgT = fps
							}
						}
					}
				} else {
					rl.PlaySound(audfx[74])
					found, numSame := checkArtSameItm(levels[levNum].chst[0].itm[itemnum])
					if found {
						pl.art[numSame].numof++
					} else {
						pl.art = append(pl.art, levels[levNum].chst[0].itm[itemnum])
					}
					admsg("collected artifact "+levels[levNum].chst[0].itm[itemnum].nm, rl.Magenta)
					levels[levNum].chst[0].itm[itemnum].off = true
					levels[levNum].chst[0].itm[itemnum] = xitm{}
				}
			}
		} else {
			foundsame := false
			for i := 0; i < len(pl.quik); i++ {
				if levels[levNum].chst[0].itm[itemnum].nm == pl.quik[i].nm {
					pl.quik[i].numof += levels[levNum].chst[0].itm[itemnum].numof
					foundsame = true
					break
				}
			}
			if !foundsame {
				for i := 0; i < len(pl.invn); i++ {
					if levels[levNum].chst[0].itm[itemnum].nm == pl.invn[i].nm {
						levels[levNum].chst[0].itm[itemnum].off = true
						levels[levNum].chst[0].itm[itemnum] = xitm{}
						pl.invn[i].numof += levels[levNum].chst[0].itm[itemnum].numof
						foundsame = true
						break
					}
				}
			}
			if !foundsame {
				if nxQuikNum != blankint {
					if levels[levNum].chst[0].itm[itemnum].notquick {
						pl.invn[nxInvnNum] = levels[levNum].chst[0].itm[itemnum]
						levels[levNum].chst[0].itm[itemnum].off = true
						levels[levNum].chst[0].itm[itemnum] = xitm{}
						findnxinvnum()
					} else {
						pl.quik[nxQuikNum] = levels[levNum].chst[0].itm[itemnum]
						levels[levNum].chst[0].itm[itemnum].off = true
					}
				} else if nxQuikNum == blankint && nxInvnNum != blankint {
					pl.invn[nxInvnNum] = levels[levNum].chst[chestnum].itm[itemnum]
					findnxinvnum()
				} else if nxQuikNum == blankint && nxInvnNum == blankint {
					if msgT == 0 {
						admsg("inventory full > drop, stack or use", rl.Red)
						msgT = fps
					}
					didnotadd = true
				}
			}
			if !didnotadd {
				admsg("collected "+levels[levNum].chst[chestnum].itm[itemnum].nm, rl.Magenta)
				levels[levNum].chst[0].itm[itemnum].off = true
				levels[levNum].chst[0].itm[itemnum] = xitm{}
				rl.PlaySound(audfx[7])
			}
		}

	}

}
func checkaddscroll(num int) bool { //MARK: CHECK IF INVEN STORE FULL ADD SCROLL

	found2 := false
	foundQuik, _ := checkQuikSameItm(scrollList[num])
	if foundQuik {
		found2 = true
	} else if nxQuikNum != blankint && !foundQuik {
		found2 = true
	} else if nxQuikNum == blankint && nxInvnNum != blankint {
		found2 = true
	} else if nxQuikNum == blankint && nxInvnNum == blankint {
		found, _ := checkInvnSameItm(scrollList[num])
		if found {
			found2 = true
		}
		if !found2 {
			if storeunlocked {
				for i := 0; i < len(storeItm); i++ {
					if storeItm[i].nm == scrollList[num].nm {
						found2 = true
						break
					}
				}
				if !found2 {
					for i := 0; i < len(storeItm); i++ {
						if storeItm[i].nm == "" {
							found2 = true
							break
						}
					}
				}
			}
		}
	}
	return found2
}
func addscroll(num int) bool { //MARK: ADD CRAFTED SCROLL TO INVEN / STORE

	found2 := false
	foundQuik, numSame := checkQuikSameItm(scrollList[num])
	if foundQuik {
		pl.quik[numSame].numof++
		found2 = true
	} else if nxQuikNum != blankint && !foundQuik {
		pl.quik[nxQuikNum] = scrollList[num]
		found2 = true
	} else if nxQuikNum == blankint && nxInvnNum != blankint {
		found, numSame := checkInvnSameItm(scrollList[num])
		if found {
			pl.invn[numSame].numof++
		} else {
			pl.invn[nxInvnNum] = scrollList[num]
			findnxinvnum()
		}
		found2 = true
	} else if nxQuikNum == blankint && nxInvnNum == blankint {
		found, numSame := checkInvnSameItm(scrollList[num])
		if found {
			pl.invn[numSame].numof++
			found2 = true
		}
		if !found2 {
			if storeunlocked {
				for i := 0; i < len(storeItm); i++ {
					if storeItm[i].nm == scrollList[num].nm {
						storeItm[i].numof++
						found2 = true
						break
					}
				}
				if !found2 {
					for i := 0; i < len(storeItm); i++ {
						if storeItm[i].nm == "" {
							storeItm[i] = scrollList[num]
							found2 = true
							break
						}
					}
				}
			}
		}
	}
	return found2
}
func checkaddpotion(num int) bool { //MARK: CHECK STORE INVEN FULL ADD POTION

	found2 := false
	foundQuik, _ := checkQuikSameItm(potionList[num])
	if foundQuik {
		found2 = true
	} else if nxQuikNum != blankint && !foundQuik {
		found2 = true
	} else if nxQuikNum == blankint && nxInvnNum != blankint {
		found2 = true
	} else if nxQuikNum == blankint && nxInvnNum == blankint {
		found, _ := checkInvnSameItm(potionList[num])
		if found {
			found2 = true
		}
		if !found2 {
			if storeunlocked {
				for i := 0; i < len(storeItm); i++ {
					if storeItm[i].nm == potionList[num].nm {
						found2 = true
						break
					}
				}
				if !found2 {
					for i := 0; i < len(storeItm); i++ {
						if storeItm[i].nm == "" {
							found2 = true
							break
						}
					}
				}
			}
		}
	}
	return found2
}
func addpotion(num int) bool { //MARK: ADD CRAFTED POTION TO INVEN / STORE

	found2 := false
	foundQuik, numSame := checkQuikSameItm(potionList[num])
	if foundQuik {
		pl.quik[numSame].numof++
		found2 = true
	} else if nxQuikNum != blankint && !foundQuik {
		pl.quik[nxQuikNum] = potionList[num]
		found2 = true
	} else if nxQuikNum == blankint && nxInvnNum != blankint {
		found, numSame := checkInvnSameItm(potionList[num])
		if found {
			pl.invn[numSame].numof++
		} else {
			pl.invn[nxInvnNum] = potionList[num]
			findnxinvnum()
		}
		found2 = true
	} else if nxQuikNum == blankint && nxInvnNum == blankint {
		found, numSame := checkInvnSameItm(potionList[num])
		if found {
			pl.invn[numSame].numof++
			found2 = true
		}
		if !found2 {
			if storeunlocked {
				for i := 0; i < len(storeItm); i++ {
					if storeItm[i].nm == potionList[num].nm {
						storeItm[i].numof++
						found2 = true
						break
					}
				}
				if !found2 {
					for i := 0; i < len(storeItm); i++ {
						if storeItm[i].nm == "" {
							storeItm[i] = potionList[num]
							found2 = true
							break
						}
					}
				}
			}
		}
	}
	return found2
}
func collectinvn(num int) { //MARK: COLLECT INVENTORY QUICK SLOTS

	if levels[levNum].itm[num].nm == "xp update" {
		rl.PlaySound(audfx[103])
		num4 := RandInt(200, 401)
		pl.xp += num4
		levels[levNum].itm[num] = xitm{}
		levels[levNum].itm[num].off = true
		admsg(fmt.Sprint(num4)+" xp added", rl.Green)
	} else {
		didnotcollect := true
		if levels[levNum].itm[num].notquick || !levels[levNum].itm[num].notquick && nxQuikNum == blankint {
			foundQuik, numSame := checkQuikSameItm(levels[levNum].itm[num])
			if foundQuik {
				pl.quik[numSame].numof++
			} else {
				found, numSame := checkInvnSameItm(levels[levNum].itm[num])
				if found {
					pl.invn[numSame].numof++
				} else {
					if nxInvnNum == blankint {
						if msgT == 0 {
							admsg("inventory full > drop, stack or use", rl.Red)
							msgT = fps
						}
						didnotcollect = false
					} else {
						pl.invn[nxInvnNum] = levels[levNum].itm[num]
						findnxinvnum()
					}
				}
			}
		} else if !levels[levNum].itm[num].notquick && nxQuikNum != blankint {
			foundQuik, numSame := checkQuikSameItm(levels[levNum].itm[num])
			if foundQuik {
				pl.quik[numSame].numof++
			} else {
				pl.quik[nxQuikNum] = levels[levNum].itm[num]
			}
		}

		if didnotcollect {
			txt := "collected " + levels[levNum].itm[num].nm
			if levels[levNum].itm[num].numof > 1 {
				txt = "collected " + fmt.Sprint(levels[levNum].itm[num].numof) + " " + levels[levNum].itm[num].nm
			}
			admsg(txt, rl.Green)
			levels[levNum].itm[num] = xitm{}
			levels[levNum].itm[num].off = true
			pack()
			rl.PlaySound(audfx[1])
		}
	}
}
func collectart(num int) { //MARK: COLLECT ARTIFACT
	if !levels[levNum].itm[num].off {

		if levels[levNum].itm[num].numof > 1 {

			max := false
			num3 := levels[levNum].itm[num].numof

			switch levels[levNum].itm[num].nm {
			//NON BOSS ARTIFACTS MUST ALSO BE ADDED TO COLLECT FROM CHEST

			case "rollo":
				if !rollo {
					rollo = true
					num3--
					max = true
					pl.hpmax += 1
					pl.hp += 1
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "landmine":
				if !landmine {
					landmine = true
					num3--
					max = true
					landmineT = fps * 7
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "batty":
				if !batty {
					batty = true
					num3--
					max = true
					pl.hpmax += 1
					pl.hp += 1
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "zombie head":
				if !zombiehead {
					zombiehead = true
					zombienum = 2
					if pl.hp == pl.hpmax {
						pl.hp--
					}
					pl.hpmax -= 1
					num3--
					max = true
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "pyroball":
				if !pyroball {
					pyroball = true
					num3--
					max = true
					pyroballT = fps * 7
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "space helmet":
				if spacehelmetnum == spacehelmetmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+spacehelmetnum <= spacehelmetmax {
						spacehelmetnum += num3
						for j := 0; j < num3; j++ {
							for i := 0; i < len(itmlist); i++ {
								if !itmlist[i].nocrate {
									if itmlist[i].cost >= 35 {
										itmlist[i].cost -= 25
									}
								}
							}
						}
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}

					} else if num3+spacehelmetnum > spacehelmetmax {
						max = true
						diff := spacehelmetmax - spacehelmetnum
						for j := 0; j < diff; j++ {
							for i := 0; i < len(itmlist); i++ {
								if !itmlist[i].nocrate {
									if itmlist[i].cost >= 35 {
										itmlist[i].cost -= 25
									}
								}
							}
						}
						num3 = (num3 + spacehelmetnum) - spacehelmetmax
						spacehelmetnum = spacehelmetmax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
				if spacehelmetnum < spacehelmetmax {
					spacehelmetnum++
					for i := 0; i < len(itmlist); i++ {
						if !itmlist[i].nocrate {
							if itmlist[i].cost >= 35 {
								itmlist[i].cost -= 25
							}
						}
					}
				} else {
					max = true
				}
			case "spinna":
				if !spinna {
					spinna = true
					num3--
					max = true
					spinnaT = fps * 7
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "mr frisbee's frisbee":
				if !mrfrisbee {
					mrfrisbee = true
					num3--
					max = true
					mrfrisbeeT = fps * 7
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "ice crystal":
				if !icecrystal {
					icecrystal = true
					num3--
					max = true
					icecrystalT = fps * 7
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}

			case "weapon case":
				if weaponcasenum == weaponcasemax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+weaponcasenum <= weaponcasemax {
						for i := 0; i < num3; i++ {
							pl.weaps = append(pl.weaps, xweap{})
							weaponcasenum++
						}
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+weaponcasenum > weaponcasemax {
						max = true
						diff := int(weaponcasemax - weaponcasenum)
						num3 = (num3 + weaponcasenum) - weaponcasemax
						weaponcasenum = weaponcasemax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "umbrella":
				if !umbrella {
					umbrella = true
					num3--
					max = true
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "map chest pin":
				if !chestpin {
					chestpin = true
					num3--
					max = true
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "map exit pin":
				if !mappin {
					mappin = true
					num3--
					max = true
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "gas mask":
				if gasmasknum == gasmaskmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+int(gasmasknum) <= int(gasmaskmax) {
						gasmasknum += int32(num3)
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+int(gasmasknum) > int(gasmaskmax) {
						max = true
						diff := int(gasmaskmax - gasmasknum)
						num3 = (num3 + int(gasmasknum)) - int(gasmaskmax)
						gasmasknum = gasmaskmax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
					if gasmaskT == 0 {
						gasmaskT = fps*8 - (gasmasknum * fps)
					}
				}
			case "noodles":
				if !noodles {
					noodles = true
					num3--
					max = true
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "oven glove":
				if ovenglovenum == ovenglovemax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+ovenglovenum <= ovenglovemax {
						ovenglovenum += num3
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+ovenglovenum > ovenglovemax {
						max = true
						diff := int(ovenglovemax - ovenglovenum)
						num3 = (num3 + ovenglovenum) - ovenglovemax
						ovenglovenum = ovenglovemax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "toaster":
				if !toaster {
					toaster = true
					num3--
					max = true
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "ninja star":
				if ninjanum == ninjamax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+ninjanum <= ninjamax {
						ninjanum += num3
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+ninjanum > ninjamax {
						max = true
						diff := int(ninjamax - ninjanum)
						num3 = (num3 + ninjanum) - ninjamax
						ninjanum = ninjamax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "flamingo":
				if flamingonum == flamingomax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+int(flamingonum) <= int(flamingomax) {
						flamingonum += int32(num3)
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+int(flamingonum) > int(flamingomax) {
						max = true
						diff := int(flamingomax - flamingonum)
						num3 = (num3 + int(flamingonum)) - int(flamingomax)
						flamingonum = flamingomax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
					if flamingoT == 0 {
						flamingoT = (fps + fps/2) / flamingonum
					}
				}
			case "mug of tea":
				if teanum == teamax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+teanum <= teamax {
						teanum += num3
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+teanum > teamax {
						max = true
						diff := int(teamax - teanum)
						num3 = (num3 + teanum) - teamax
						teanum = teamax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "cloak of sparks":
				if !cloak {
					cloak = true
					num3--
					max = true
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "feather":
				if !feather {
					feather = true
					num3--
					max = true
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "mugging":
				if mugnum == mugmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+mugnum <= mugmax {
						mugnum += num3
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+mugnum > mugmax {
						max = true
						diff := int(mugmax - mugnum)
						num3 = (num3 + mugnum) - mugmax
						mugnum = mugmax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "lightbulb":
				if lightbulbnum == lightbulbmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+lightbulbnum <= lightbulbmax {
						lightbulbnum += num3
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+lightbulbnum > lightbulbmax {
						max = true
						diff := int(lightbulbmax - lightbulbnum)
						num3 = (num3 + mugnum) - lightbulbmax
						lightbulbnum = lightbulbmax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "candy cane":
				if candycanenum == candycanemax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+int(candycanenum) <= int(candycanemax) {
						candycanenum += int32(num3)
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+int(candycanenum) > int(candycanemax) {
						max = true
						diff := int(candycanemax - candycanenum)
						num3 = (num3 + int(candycanenum)) - int(candycanemax)
						candycanenum = candycanemax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "pearl":
				if pearlnum == pearlmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+pearlnum <= pearlmax {
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
						pearlnum += num3
						pl.hpmax += num3
						pl.hp += num3
					} else if num3+pearlnum > pearlmax {
						max = true
						diff := pearlmax - pearlnum
						num3 = (num3 + pearlnum) - pearlmax
						pearlnum = pearlmax
						pl.hpmax += diff
						pl.hp += diff
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "magicians hat":
				if magicianshatnum == magicianshatmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+magicianshatnum <= magicianshatmax {
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
						magicianshatnum += num3
						pl.manamax += num3
						pl.mana += num3
					} else if num3+magicianshatnum > magicianshatmax {
						max = true
						diff := magicianshatmax - magicianshatnum
						num3 = (num3 + magicianshatnum) - magicianshatmax
						magicianshatnum = magicianshatmax
						pl.manamax += diff
						pl.mana += diff
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "throwing knife":
				if throwingknifenum == throwingknifemax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+throwingknifenum <= throwingknifemax {
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
						throwingknifenum += num3
					} else if num3+throwingknifenum > throwingknifemax {
						max = true
						diff := throwingknifemax - throwingknifenum
						num3 = (num3 + throwingknifenum) - throwingknifemax
						throwingknifenum = throwingknifemax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "toxic sludge":
				if !toxic {
					toxic = true
					num3--
					max = true
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "mirror":
				if !mirror {
					mirror = true
					num3--
					max = true
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "belt of whipping":
				if beltnum == beltmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+beltnum <= beltmax {
						beltnum += num3
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+beltnum > beltmax {
						max = true
						diff := beltmax - beltnum
						num3 = (num3 + beltnum) - beltmax
						beltnum = beltmax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "amulet of disc":
				if !frisbee {
					frisbee = true
					num3--
					max = true
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "amulet of purple rain":
				if !purplerain {
					purplerain = true
					num3--
					max = true
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "tesla coil":
				if !tesla {
					tesla = true
					num3--
					max = true
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "ring of twin":
				if !twin {
					twin = true
					num3--
					max = true
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "ring of thorns":
				if !thornson {
					thornson = true
					num3--
					max = true
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "ring of vine":
				if !vineRing {
					vineRing = true
					if pl.hp == 1 {
						pl.hp = 2
					}
					num3--
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
					max = true
				} else {
					max = true
				}
			case "toilet paper":
				if toiletpapernum == toiletpapermax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+toiletpapernum <= toiletpapermax {
						toiletpapernum += num3
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+toiletpapernum > toiletpapermax {
						max = true
						diff := toiletpapermax - toiletpapernum
						num3 = (num3 + toiletpapernum) - toiletpapermax
						toiletpapernum = toiletpapermax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "bear trap":
				if beartrapnum == beartrapmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+beartrapnum <= beartrapmax {
						beartrapnum += num3
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+beartrapnum > beartrapmax {
						max = true
						diff := beartrapmax - beartrapnum
						num3 = (num3 + beartrapnum) - beartrapmax
						beartrapnum = beartrapmax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
					beartrapT = (fps * 12) - (int32(beartrapnum*2) * fps)
				}
			case "basketball sneakers":
				if stats.dex == 5 {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+stats.dex <= 5 {
						stats.dex += num3
						stats.dex2 = stats.dex
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+stats.dex > 5 {
						max = true
						diff := 5 - stats.dex
						num3 = (num3 + stats.dex) - 5
						stats.dex = 5
						stats.dex2 = stats.dex
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "dumbbell":
				if stats.str == 5 {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+stats.str <= 5 {
						stats.str += num3
						stats.str2 = stats.str
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+stats.str > 5 {
						max = true
						diff := 5 - stats.str
						num3 = (num3 + stats.str) - 5
						stats.str = 5
						stats.str2 = stats.str
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "dice":
				if stats.luk == 5 {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+stats.luk <= 5 {
						stats.luk += num3
						stats.luk2 = stats.luk
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+stats.luk > 5 {
						max = true
						diff := 5 - stats.luk
						num3 = (num3 + stats.luk) - 5
						stats.luk = 5
						stats.luk2 = stats.luk
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "eyeball":
				if stats.per == 5 {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+stats.per <= 5 {
						stats.per += num3
						stats.per2 = stats.per
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+stats.per > 5 {
						max = true
						diff := 5 - stats.per
						num3 = (num3 + stats.per) - 5
						stats.per = 5
						stats.per2 = stats.per
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "brain":
				if stats.int == 5 {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+stats.int <= 5 {
						stats.int += num3
						stats.int2 = stats.int
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+stats.int > 5 {
						max = true
						diff := 5 - stats.int
						num3 = (num3 + stats.int) - 5
						stats.int = 5
						stats.int2 = stats.int
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "medikit":
				if medikitnum == medikitmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+medikitnum <= medikitmax {
						medikitnum += num3
						beartrapnum += num3
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+medikitnum > medikitmax {
						max = true
						diff := medikitmax - medikitnum
						num3 = (num3 + medikitnum) - medikitmax
						medikitnum = medikitmax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "backpack":
				if len(pl.invn) == invMax {
					max = true
					admsg("inventory max", rl.Red)
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+len(pl.invn) <= invMax {
						for i := 0; i < num3; i++ {
							pl.invn = append(pl.invn, xitm{})
						}
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+len(pl.invn) > invMax {
						max = true
						admsg("inventory max", rl.Red)
						diff := invMax - len(pl.invn)
						for i := 0; i < diff; i++ {
							pl.invn = append(pl.invn, xitm{})
						}
						num3 = (num3 + len(pl.invn)) - invMax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "gas can":
				if gascannum == gascanmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+gascannum <= gascanmax {
						gascannum += num3
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+gascannum > gascanmax {
						max = true
						diff := gascanmax - gascannum
						num3 = (num3 + gascannum) - gascanmax
						gascannum = gascanmax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "bottle of death":
				if deathbottlenum == deathbottlemax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+deathbottlenum <= deathbottlemax {
						deathbottlenum += num3
						gascannum += num3
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+deathbottlenum > deathbottlemax {
						max = true
						diff := deathbottlemax - deathbottlenum
						num3 = (num3 + deathbottlenum) - deathbottlemax
						deathbottlenum = deathbottlemax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "cleaver":
				if cleavernum == cleavermax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+cleavernum <= cleavermax {
						cleavernum += num3
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+cleavernum > cleavermax {
						max = true
						diff := cleavermax - cleavernum
						num3 = (num3 + cleavernum) - cleavermax
						cleavernum = cleavermax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "tenderiser":
				if tenderisernum == tenderisermax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+tenderisernum <= tenderisermax {
						tenderisernum += num3
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+tenderisernum > tenderisermax {
						max = true
						diff := tenderisermax - tenderisernum
						num3 = (num3 + tenderisernum) - tenderisermax
						tenderisernum = tenderisermax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "garlic":
				if garlicnum == garlicmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+garlicnum <= garlicmax {
						garlicnum += num3
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+garlicnum > garlicmax {
						max = true
						diff := garlicmax - garlicnum
						num3 = (num3 + garlicnum) - garlicmax
						garlicnum = garlicmax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "drill":
				if !drillon {
					drillon = true
					num3--
					max = true
					levels[levNum].itm[num].numof = 1
					pl.art = append(pl.art, levels[levNum].itm[num])
				} else {
					max = true
				}
			case "broccoli":
				if broccolinum == broccolimax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+broccolinum <= broccolimax {
						broccolinum += num3
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+broccolinum > broccolimax {
						max = true
						diff := broccolimax - broccolinum
						num3 = (num3 + broccolinum) - broccolimax
						broccolinum = broccolimax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "basketball":
				if basketballnum == basketballmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+basketballnum <= basketballmax {
						basketballnum += num3
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+basketballnum > basketballmax {
						max = true
						diff := basketballmax - basketballnum
						num3 = (num3 + basketballnum) - basketballmax
						basketballnum = basketballmax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "sunglasses":
				if stats.crit == stats.crit2 {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+stats.crit <= stats.crit2 {
						stats.crit += num3
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+stats.crit > stats.crit2 {
						max = true
						diff := stats.crit2 - stats.crit
						num3 = (num3 + stats.crit) - stats.crit2
						stats.crit = stats.crit2
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}
			case "sneakers":
				if sneakersnum == sneakersmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].itm[num].nm)
					if num3+sneakersnum <= sneakersmax {
						sneakersnum += num3
						if pl.spd2 < pl.spdmax {
							pl.spd2 += float32(num3)
							if pl.spd2 > pl.spdmax {
								pl.spd2 = pl.spdmax
							}
							pl.spd = pl.spd2
						}
						if foundArt {
							pl.art[numArtSame].numof += num3
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
						}
					} else if num3+sneakersnum > sneakersmax {
						max = true
						diff := sneakersmax - sneakersnum
						pl.spd2 = pl.spdmax
						pl.spd = pl.spd2
						num3 = (num3 + sneakersnum) - sneakersmax
						sneakersnum = sneakersmax
						if foundArt {
							pl.art[numArtSame].numof += diff
						} else {
							pl.art = append(pl.art, levels[levNum].itm[num])
							pl.art[len(pl.art)-1].numof = diff
						}
					}
				}

			}

			if max {
				rl.PlaySound(audfx[121])
				if msgT == 0 {
					admsg("artifact > "+levels[levNum].itm[num].nm+" > max", rl.Red)
				}
				found := false
				for i := 0; i < len(pl.invn); i++ {
					if pl.invn[i].nm == levels[levNum].itm[num].nm {
						pl.invn[i].numof += num3
						if msgT == 0 {
							admsg("in backpack > store for next run", rl.Magenta)
							msgT = fps
						}
						levels[levNum].itm[num] = xitm{}
						levels[levNum].itm[num].off = true
						found = true
					}
				}
				if !found {
					if nxInvnNum != blankint {
						pl.invn[nxInvnNum] = levels[levNum].itm[num]
						pl.invn[nxInvnNum].numof = num3
						findnxinvnum()
						if msgT == 0 {
							admsg("in backpack > store for next run", rl.Magenta)
							msgT = fps
						}
						levels[levNum].itm[num] = xitm{}
						levels[levNum].itm[num].off = true
					} else {
						if msgT == 0 {
							admsg("inventory full > drop, stack or use", rl.Red)
							msgT = fps
						}
					}
				}
				msgT = fps / 2
			} else {
				rl.PlaySound(audfx[74])
				found, numSame := checkArtSameItm(levels[levNum].itm[num])
				if found {
					pl.art[numSame].numof += num3
				} else {
					levels[levNum].itm[num].numof = num3
					pl.art = append(pl.art, levels[levNum].itm[num])
				}
				admsg("collected artifact "+levels[levNum].itm[num].nm, rl.Magenta)
				levels[levNum].itm[num] = xitm{}
				levels[levNum].itm[num].off = true
			}

		} else {
			max := false
			switch levels[levNum].itm[num].nm {
			//NON BOSS ARTIFACTS MUST ALSO BE ADDED TO COLLECT FROM CHEST

			case "weapon case":
				if weaponcasenum < weaponcasemax {
					pl.weaps = append(pl.weaps, xweap{})
					weaponcasenum++
				} else {
					max = true
				}
			case "umbrella":
				if !umbrella {
					umbrella = true
				} else {
					max = true
				}
			case "map chest pin":
				if !chestpin {
					chestpin = true
				} else {
					max = true
				}
			case "map exit pin":
				if !mappin {
					mappin = true
				} else {
					max = true
				}
			case "gas mask":
				if gasmasknum < gasmaskmax {
					gasmasknum++
					if gasmaskT == 0 {
						gasmaskT = fps*8 - (gasmasknum * fps)
					}
				} else {
					max = true
				}
			case "noodles":
				if !noodles {
					noodles = true
				} else {
					max = true
				}
			case "oven glove":
				if ovenglovenum < ovenglovemax {
					ovenglovenum++
				} else {
					max = true
				}
			case "toaster":
				if !toaster {
					toaster = true
				} else {
					max = true
				}
			case "ninja star":
				if ninjanum < ninjamax {
					ninjanum++
				} else {
					max = true
				}
			case "flamingo":
				if flamingonum < flamingomax {
					flamingonum++
					if flamingoT == 0 {
						flamingoT = (fps + fps/2) / flamingonum
					}
				} else {
					max = true
				}
			case "mug of tea":
				if teanum < teamax {
					teanum++
				} else {
					max = true
				}
			case "cloak of sparks":
				if !cloak {
					cloak = true
				} else {
					max = true
				}
			case "feather":
				if !feather {
					feather = true
				} else {
					max = true
				}
			case "mugging":
				if mugnum < mugmax {
					mugnum++
				} else {
					max = true
				}
			case "lightbulb":
				if lightbulbnum < lightbulbmax {
					lightbulbnum++
				} else {
					max = true
				}
			case "candy cane":
				if candycanenum < candycanemax {
					candycanenum++
				} else {
					max = true
				}
			case "pearl":
				if pearlnum < pearlmax {
					pearlnum++
					pl.hpmax++
					pl.hp++
				} else {
					max = true
				}
			case "magicians hat":
				if magicianshatnum < magicianshatmax {
					magicianshatnum++
					pl.manamax++
					pl.mana++
				} else {
					max = true
				}
			case "throwing knife":
				if throwingknifenum < throwingknifemax {
					throwingknifenum++
				} else {
					max = true
				}
			case "toxic sludge":
				if !toxic {
					toxic = true
				} else {
					max = true
				}
			case "mirror":
				if !mirror {
					mirror = true
				} else {
					max = true
				}
			case "belt of whipping":
				if beltnum < beltmax {
					beltnum++
				} else {
					max = true
				}
			case "amulet of disc":
				if !frisbee {
					frisbee = true
				} else {
					max = true
				}
			case "amulet of purple rain":
				if !purplerain {
					purplerain = true
				} else {
					max = true
				}
			case "tesla coil":
				if !tesla {
					tesla = true
				} else {
					max = true
				}
			case "ring of twin":
				if !twin {
					twin = true
				} else {
					max = true
				}
			case "ring of thorns":
				if !thornson {
					thornson = true
				} else {
					max = true
				}
			case "ring of vine":
				if !vineRing {
					vineRing = true
					if pl.hp == 1 {
						pl.hp = 2
					}
				} else {
					max = true
				}
			case "toilet paper":
				if toiletpapernum < toiletpapermax {
					toiletpapernum++
				} else {
					max = true
				}
			case "bear trap":
				if beartrapnum < beartrapmax {
					beartrapnum++
					beartrapT = (fps * 12) - (int32(beartrapnum*2) * fps)
				} else {
					max = true
				}
			case "basketball sneakers":
				if stats.dex < 5 {
					stats.dex++
					stats.dex2 = stats.dex
				} else {
					max = true
				}
			case "dumbbell":
				if stats.str < 5 {
					stats.str++
					stats.str2 = stats.str
				} else {
					max = true
				}
			case "dice":
				if stats.luk < 5 {
					stats.luk++
					stats.luk2 = stats.luk
				} else {
					max = true
				}
			case "eyeball":
				if stats.per < 5 {
					stats.per++
					stats.per2 = stats.per
				} else {
					max = true
				}
			case "brain":
				if stats.int < 5 {
					stats.int++
					stats.int2 = stats.int
				} else {
					max = true
				}
			case "medikit":
				if medikitnum < medikitmax {
					medikiton = true
					medikitnum++
				} else {
					max = true
				}
			case "backpack":
				if len(pl.invn) < invMax {
					pl.invn = append(pl.invn, xitm{})
				} else {
					max = true
					admsg("inventory max", rl.Red)
				}
			case "gas can":
				if gascannum < gascanmax {
					gascannum++
				} else {
					max = true
				}
			case "bottle of death":
				if deathbottlenum < deathbottlemax {
					deathbottlenum++
				} else {
					max = true
				}
			case "cleaver":
				if cleavernum < cleavermax {
					cleavernum++
				} else {
					max = true
				}
			case "tenderiser":
				if tenderisernum < tenderisermax {
					tenderisernum++
				} else {
					max = true
				}
			case "garlic":
				if garlicnum < garlicmax {
					garlicnum++
				} else {
					max = true
				}
			case "drill":
				if !drillon {
					drillon = true
				} else {
					max = true
				}
			case "broccoli":
				if broccolinum < broccolimax {
					broccolinum++
				} else {
					max = true
				}
			case "basketball":
				if basketballnum < basketballmax {
					basketballnum++
				} else {
					max = true
				}
			case "sunglasses":
				if stats.crit < stats.crit2 {
					stats.crit++
				} else {
					max = true
				}
			case "sneakers":
				if sneakersnum < sneakersmax {
					sneakersnum++
					if pl.spd2 < pl.spdmax {
						pl.spd2++
						pl.spd = pl.spd2
					}
				} else {
					max = true
				}
			}
			if max {
				rl.PlaySound(audfx[121])
				if msgT == 0 {
					admsg("artifact > "+levels[levNum].itm[num].nm+" > max", rl.Red)
				}
				found := false
				for i := 0; i < len(pl.invn); i++ {
					if pl.invn[i].nm == levels[levNum].itm[num].nm {
						pl.invn[i].numof++
						if msgT == 0 {
							admsg("in backpack > store for next run", rl.Magenta)
							msgT = fps
						}
						levels[levNum].itm[num] = xitm{}
						levels[levNum].itm[num].off = true
						found = true
					}
				}
				if !found {
					if nxInvnNum != blankint {
						pl.invn[nxInvnNum] = levels[levNum].itm[num]
						findnxinvnum()
						if msgT == 0 {
							admsg("in backpack > store for next run", rl.Magenta)
							msgT = fps
						}
						levels[levNum].itm[num] = xitm{}
						levels[levNum].itm[num].off = true
					} else {
						if msgT == 0 {
							admsg("inventory full > drop, stack or use", rl.Red)
							msgT = fps
						}
					}
				}
				msgT = fps / 2
			} else {
				rl.PlaySound(audfx[74])
				found, numSame := checkArtSameItm(levels[levNum].itm[num])
				if found {
					pl.art[numSame].numof++
				} else {
					pl.art = append(pl.art, levels[levNum].itm[num])
				}
				admsg("collected artifact "+levels[levNum].itm[num].nm, rl.Magenta)
				levels[levNum].itm[num] = xitm{}
				levels[levNum].itm[num].off = true
			}
		}
	}
}
func dropweap(num, numType int) { //MARK: DROP WEAPON
	checkrec := pl.rec
	checkrec.X -= checkrec.Width
	xorig := checkrec.X
	checkrec.Y -= checkrec.Height
	countbreak := 8
	count := 0

	if numType == 0 {
		for {
			canadd := checkRecChests(checkrec)
			if canadd {
				canadd = checkRecWalls(checkrec)
			}
			if canadd {
				canadd = checkRecSolid(checkrec)
			}
			if canadd {
				canadd = checkItemItem(checkrec)
			}
			if canadd {
				canadd = checkWeapWeap(checkrec)
			}
			countbreak--
			if canadd || countbreak == 0 {
				if canadd {
					cntr := makecnt(checkrec)
					zweap := pl.weaps[num]
					zweap.dropT = fps
					zweap.rec = rl.NewRectangle(cntr.X-zweap.rec.Width/2, cntr.Y-zweap.rec.Height/2, zweap.rec.Width, zweap.rec.Height)
					if zweap.nm == "raspberry" {
						zweap.rec.X -= be
						zweap.rec.Y -= be
						zweap.rec.Width += bq
						zweap.rec.Height += bq
					}
					levels[levNum].weaps = append(levels[levNum].weaps, zweap)
					admsg("dropped "+pl.weaps[num].nm, rl.Blue)
					pl.weaps[num] = xweap{}
					break
				}
				if countbreak == 0 {
					admsg("no space nearby... move please ", rl.Red)
					break
				}
			}
			checkrec.X += checkrec.Width
			count++
			if count == 3 || count == 5 {
				checkrec.X = xorig
				checkrec.Y += checkrec.Height
			}
			if count == 4 {
				checkrec.X += checkrec.Width
			}
		}
	} else {
		for {
			canadd := checkRecChests(checkrec)
			if canadd {
				canadd = checkRecWalls(checkrec)
			}
			if canadd {
				canadd = checkRecSolid(checkrec)
			}
			if canadd {
				canadd = checkItemItem(checkrec)
			}
			if canadd {
				canadd = checkWeapWeap(checkrec)
			}
			countbreak--
			if canadd || countbreak == 0 {
				if canadd {
					cntr := makecnt(checkrec)
					zweap := pl.wp2
					zweap.dropT = fps
					zweap.rec = rl.NewRectangle(cntr.X-zweap.rec.Width/2, cntr.Y-zweap.rec.Height/2, zweap.rec.Width, zweap.rec.Height)
					if zweap.nm == "raspberry" {
						zweap.rec.X -= be
						zweap.rec.Y -= be
						zweap.rec.Width += bq
						zweap.rec.Height += bq
					}
					levels[levNum].weaps = append(levels[levNum].weaps, zweap)
					admsg("dropped "+pl.wp2.nm, rl.Blue)
					pl.wp2 = xweap{}
					break
				}
				if countbreak == 0 {
					admsg("no space nearby... move please ", rl.Red)
					break
				}
			}
			checkrec.X += checkrec.Width
			count++
			if count == 3 || count == 5 {
				checkrec.X = xorig
				checkrec.Y += checkrec.Height
			}
			if count == 4 {
				checkrec.X += checkrec.Width
			}
		}
	}
}
func dropitm(num, inven0quik1 int) { //MARK: DROP ITEM
	checkrec := pl.rec
	checkrec.X -= checkrec.Width
	xorig := checkrec.X
	checkrec.Y -= checkrec.Height
	countbreak := 8
	count := 0
	for {
		canadd := checkRecChests(checkrec)
		if canadd {
			canadd = checkRecWalls(checkrec)
		}
		if canadd {
			canadd = checkRecSolid(checkrec)
		}
		if canadd {
			canadd = checkItemItem(checkrec)
		}
		countbreak--
		if canadd || countbreak == 0 {
			if canadd {
				cntr := makecnt(checkrec)
				zitm := pl.invn[num]
				if inven0quik1 == 1 {
					zitm = pl.quik[num]
				}
				zitm.dropT = fps
				zitm.rec = rl.NewRectangle(cntr.X-zitm.rec.Width/2, cntr.Y-zitm.rec.Height/2, zitm.rec.Width, zitm.rec.Height)
				levels[levNum].itm = append(levels[levNum].itm, zitm)
				if inven0quik1 == 1 {
					admsg("dropped "+pl.quik[num].nm, rl.Blue)
					pl.quik[num] = xitm{}
				} else {
					admsg("dropped "+pl.invn[num].nm, rl.Blue)
					pl.invn[num] = xitm{}
				}
				break
			}
			if countbreak == 0 {
				admsg("no space nearby... move please ", rl.Red)
				break
			}
		}
		checkrec.X += checkrec.Width
		count++
		if count == 3 || count == 5 {
			checkrec.X = xorig
			checkrec.Y += checkrec.Height
		}
		if count == 4 {
			checkrec.X += checkrec.Width
		}
	}
}
func destroycrate(num int) { //MARK: DESTROY CRATE
	//ITEMS
	if levels[levNum].etc[num].img == etc[2] { //OLD CRATE
		if Roll6() > 3 {
			zitm := itmlist[43]
			zitm.rec = rl.NewRectangle(levels[levNum].etc[num].cnt.X-zitm.rec.Width/2, levels[levNum].etc[num].cnt.Y-zitm.rec.Height/2, zitm.rec.Width, zitm.rec.Height)
			levels[levNum].itm = append(levels[levNum].itm, zitm)
		}
		if toiletpapernum > 0 {
			if Roll6() <= toiletpapernum {
				zitm := itmlist[43]
				zitm.rec = rl.NewRectangle(levels[levNum].etc[num].cnt.X-zitm.rec.Width/2, levels[levNum].etc[num].cnt.Y-zitm.rec.Height/2, zitm.rec.Width, zitm.rec.Height)
				levels[levNum].itm = append(levels[levNum].itm, zitm)
			}
		}
	} else if levels[levNum].etc[num].img == etc[4] { //NEW CRATE
		zitm := itmlist[43]
		zitm.rec = rl.NewRectangle(levels[levNum].etc[num].cnt.X-zitm.rec.Width/2, levels[levNum].etc[num].cnt.Y-zitm.rec.Height/2, zitm.rec.Width, zitm.rec.Height)
		levels[levNum].itm = append(levels[levNum].itm, zitm)
		if Roll6() > 3 {
			zitm := itmlist[43]
			zitm.rec = rl.NewRectangle(levels[levNum].etc[num].cnt.X-zitm.rec.Width/2, levels[levNum].etc[num].cnt.Y-zitm.rec.Height/2, zitm.rec.Width, zitm.rec.Height)
			levels[levNum].itm = append(levels[levNum].itm, zitm)
		}
		if toiletpapernum > 0 {
			if Roll6() <= toiletpapernum {
				zitm := itmlist[43]
				zitm.rec = rl.NewRectangle(levels[levNum].etc[num].cnt.X-zitm.rec.Width/2, levels[levNum].etc[num].cnt.Y-zitm.rec.Height/2, zitm.rec.Width, zitm.rec.Height)
				levels[levNum].itm = append(levels[levNum].itm, zitm)
			}
		}
	} else if levels[levNum].etc[num].img == etc[1] { //PINK CRATE
		zitm := crateitm[RandInt(0, len(crateitm))]
		zitm.rec = rl.NewRectangle(levels[levNum].etc[num].cnt.X-zitm.rec.Width/2, levels[levNum].etc[num].cnt.Y-zitm.rec.Height/2, zitm.rec.Width, zitm.rec.Height)
		if zitm.nm == "lead" || zitm.nm == "bronze" || zitm.nm == "silver" || zitm.nm == "gold" || zitm.nm == "platinum" {
			zitm.numof = RandInt(10, 21)
		}
		levels[levNum].itm = append(levels[levNum].itm, zitm)
		//LUK
		if stats.luk > 1 {
			if Roll6() <= stats.luk {
				zitm = xitm{}
				zitm = crateitm[RandInt(0, len(crateitm))]
				zitm.rec = rl.NewRectangle(levels[levNum].etc[num].cnt.X-zitm.rec.Width/2, levels[levNum].etc[num].cnt.Y-zitm.rec.Height/2, zitm.rec.Width, zitm.rec.Height)
				zitm.rec = finddropside(zitm.rec, 1)
				if zitm.rec != blankRec {
					if zitm.nm == "lead" || zitm.nm == "bronze" || zitm.nm == "silver" || zitm.nm == "gold" || zitm.nm == "platinum" {
						zitm.numof = RandInt(10, 21)
					}
					levels[levNum].itm = append(levels[levNum].itm, zitm)
				}
			}
		}

	} else if levels[levNum].etc[num].img == etc[3] { //BLUE CRATE
		zitm := crateitm[RandInt(0, len(crateitm))]
		zitm.rec = rl.NewRectangle(levels[levNum].etc[num].cnt.X-zitm.rec.Width/2, levels[levNum].etc[num].cnt.Y-zitm.rec.Height/2, zitm.rec.Width, zitm.rec.Height)
		if zitm.nm == "lead" || zitm.nm == "bronze" || zitm.nm == "silver" || zitm.nm == "gold" || zitm.nm == "platinum" {
			zitm.numof = RandInt(10, 21)
		}
		levels[levNum].itm = append(levels[levNum].itm, zitm)
		//LUK
		if stats.luk > 1 {
			if Roll6() <= stats.luk {
				zitm = xitm{}
				zitm = crateitm[RandInt(0, len(crateitm))]
				zitm.rec = rl.NewRectangle(levels[levNum].etc[num].cnt.X-zitm.rec.Width/2, levels[levNum].etc[num].cnt.Y-zitm.rec.Height/2, zitm.rec.Width, zitm.rec.Height)
				zitm.rec = finddropside(zitm.rec, 1)
				if zitm.rec != blankRec {
					if zitm.nm == "lead" || zitm.nm == "bronze" || zitm.nm == "silver" || zitm.nm == "gold" || zitm.nm == "platinum" {
						zitm.numof = RandInt(10, 21)
					}
					levels[levNum].itm = append(levels[levNum].itm, zitm)
				}
			}
		}
	}
	//FX
	zfx := xfx{}
	zfx.nm = "desCrate"
	zfx.T = fps / 2
	cntr := levels[levNum].etc[num].cnt
	num2 := RandInt(40, 51)
	for num2 > 0 {
		siz := RandF32(b/8, b/2)
		zrec := xrec{}
		if levels[levNum].etc[num].img == etc[2] || levels[levNum].etc[num].img == etc[4] {
			zrec.col = RandBrown()
		} else if levels[levNum].etc[num].img == etc[1] {
			zrec.col = RandPink()
		} else if levels[levNum].etc[num].img == etc[3] {
			zrec.col = RandCyan()
		}
		zrec.fd = RandF32(0.3, 0.7)
		zrec.rec = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
		zrec.spd = b / 2
		zrec.dirX = RandF32(-zrec.spd, zrec.spd)
		zrec.dirY = RandF32(-zrec.spd, zrec.spd)
		zfx.recs = append(zfx.recs, zrec)
		num2--
	}
	fx = append(fx, zfx)
	rl.PlaySound(audfx[2])

	//FIREWORKS
	if levels[levNum].etc[num].firework {
		rl.PlaySound(audfx[109])
		siz := b / 2
		spd := float32(5)
		zproj := xweap{}
		zproj.nm = "firework"
		zproj.rec2 = anm[201].rec
		zproj.img = etc[210]
		zproj.col = rl.White
		zproj.fd = 1
		zproj.cnt = levels[levNum].etc[num].cnt
		zproj.rec = rl.NewRectangle(zproj.cnt.X-siz/2, zproj.cnt.Y-siz/2, siz, siz)
		zproj.dirX = spd
		zproj.ro = 45
		projPL = append(projPL, zproj)
		zproj.ro = -135
		zproj.dirX = -spd
		projPL = append(projPL, zproj)
		zproj.ro = 135
		zproj.dirX = 0
		zproj.dirY = spd
		projPL = append(projPL, zproj)
		zproj.ro = -45
		zproj.dirY = -spd
		projPL = append(projPL, zproj)
		zproj.ro = 90
		zproj.dirY = 0
		zproj.dirX = 0
		zproj.dirY = spd
		zproj.dirX = spd
		projPL = append(projPL, zproj)
		zproj.ro = 180
		zproj.dirY = spd
		zproj.dirX = -spd
		projPL = append(projPL, zproj)
		zproj.ro = 270
		zproj.dirY = -spd
		zproj.dirX = -spd
		projPL = append(projPL, zproj)
		zproj.ro = 0
		zproj.dirY = -spd
		zproj.dirX = spd
		projPL = append(projPL, zproj)
	}

}
func shcol() rl.Color { //MARK: SHADOW COLOR
	return rl.Fade(rl.Black, 0.7)
}
func admsg(txt string, col rl.Color) { //MARK:ADD MSG
	zmsg := xmsg{}
	zmsg.txt = txt
	zmsg.col = col
	msg = append(msg, zmsg)
}
func Remove(num int) { //MARK:REMOVE FROM SLICE
	switch num {
	case 4: //ENEMIES
		if len(fx) == 0 {
			for i := 0; i < len(levels[levNum].enm); i++ {
				if levels[levNum].enm[i].off {
					levels[levNum].enm = RemoveEnemy(levels[levNum].enm, i)
				}
			}
		}
	case 3: //ITEM
		for i := 0; i < len(levels[levNum].itm); i++ {
			if levels[levNum].itm[i].off {
				levels[levNum].itm = RemoveItem(levels[levNum].itm, i)
			}
		}
	case 2: //ETC TILE
		for i := 0; i < len(levels[levNum].etc); i++ {
			if levels[levNum].etc[i].off {
				levels[levNum].etc = RemoveTile(levels[levNum].etc, i)
			}
		}
	case 1: //FX
		for i := 0; i < len(fx); i++ {
			if fx[i].off {
				fx = RemoveFx(fx, i)
			}
		}
	}
}
func playerDeath() { //MARK:PLAYER DEATH
	if medikiton {
		pl.burnT = 0
		pl.poisonT = 0
		pl.freezeT = 0
		pl.dampT = 0
		medikiton = false
		pl.hp = pl.hpmax
		pl.cnt = cnt
		upplayerrec()
		reviveT = fps / 2
		for i := 0; i < len(pl.art); i++ {
			if pl.art[i].nm == "medikit" {
				pl.art[i].off = true
				break
			}
		}
		admsg("revived by medikit", rl.Green)
	} else if zombienum > 0 {
		pl.burnT = 0
		pl.poisonT = 0
		pl.freezeT = 0
		pl.dampT = 0
		pl.hpmax--
		pl.hp = pl.hpmax
		pl.cnt = cnt
		upplayerrec()
		reviveT = fps / 2
		zombienum--
		if zombienum == 0 {
			for i := 0; i < len(pl.art); i++ {
				if pl.art[i].nm == "zombie head" {
					pl.art[i].off = true
				}
			}
		}
		admsg("revived by zombie head", rl.Green)
	} else {
		rl.PlaySound(audfx[123])
		pl.gameover = true
		gameoverRec = rl.NewRectangle(cnt.X-b2, cnt.Y-b2, b4, b4)
		gameoverfd = 0
		gameoverRo = 0
		gameoverreset = false
		gameover = true

	}
}
func hitPLEnProj(num int) { //MARK:HIT PLAYER ENEMY PROJECTILE SEE ALSO HIT PLAYER BELOW

	if !invincible {

		if vineon {
			if msgT == 0 {
				admsg("vine saves dmg", rl.Green)
				msgT = fps
			}
		} else if turtleT > 0 {
			if msgT == 0 {
				admsg("turtle shell saves dmg", rl.Green)
				msgT = fps
			}
		} else if pl.armorT > 0 {
			if msgT == 0 {
				admsg("armor shield saves dmg", rl.Green)
				msgT = fps
			}
		} else if shrimpnum > 0 {
			if pl.hpT == 0 {
				pl.hpT = fps * 2
				shrimpnum--
				admsg("shrimp shell saves dmg", rl.Green)
			}
		} else {
			if pl.hpT == 0 {
				if pl.hp > 0 {
					pl.hp -= projEn[num].dmg
					//HP LOSS SFX
					if prevplayHP > pl.hp {
						rl.PlaySound(audfx[14])
						prevplayHP = pl.hp
					} else if prevplayHP < pl.hp {
						prevplayHP = pl.hp
					}
					pl.hpT = fps * 2
					admsg("-"+fmt.Sprint(projEn[num].dmg)+" dmg", rl.Red)
					if projEn[num].nm == "icemanProj" && pl.freezeT == 0 && saltT == 0 {
						pl.freezeT = fps * 2
						admsg("frozen", rl.Red)
					} else if saltT > 0 {
						if msgT == 0 {
							admsg("salt saves freeze", rl.Green)
							msgT = fps
						}
					}
					if projEn[num].nm == "yellowdinobull" || projEn[num].nm == "reddevilFlame" {
						if pl.burnT == 0 && pl.dampT == 0 && icelollyT == 0 && pl.resFireT == 0 {
							if ovenglovenum > 0 {
								if Roll6() <= ovenglovenum {
									admsg("oven glove saves burn", rl.Green)
								} else {
									admsg("burning...", rl.Orange)
									pl.burnT += fps * 3
								}
							} else {
								admsg("burning...", rl.Orange)
								pl.burnT += fps * 3
							}
						} else if pl.burnT == 0 && pl.dampT != 0 && icelollyT == 0 && pl.resFireT == 0 {
							admsg("damp saves burn", rl.Green)
						} else if pl.burnT == 0 && pl.dampT == 0 && icelollyT != 0 && pl.resFireT == 0 {
							admsg("ice lolly saves burn", rl.Green)
						} else if pl.burnT == 0 && pl.dampT == 0 && icelollyT == 0 && pl.resFireT != 0 {
							admsg("resist fire saves burn", rl.Green)
						}
					}
					if projEn[num].nm == "dart" {
						pl.poisonT += fps * 3
					}
					//FX
					zfx := xfx{}
					zfx.nm = "plblood"
					zfx.img = splat[RandInt(0, len(splat))]
					zfx.col = RandRed()
					zfx.fade = 0.8
					zfx.rec = pl.rec
					zfx.rec.X -= b
					zfx.rec.Y -= b
					zfx.rec.Width += b2
					zfx.rec.Height += b2
					fx = append(fx, zfx)
				}
				//THORNS
				if thornson {
					thorns()
				}
				//CLOAK
				if cloak && cloakT == 0 {
					cloakT = fps / 2
					siz := b2
					zfx := xfx{}
					zfx.img = anm[96].rec
					zfx.nm = "cloaksparks"
					num := 10
					countbreak := 100
					for num > 0 {
						v2 := pl.cnt
						v2.X += RandF32(-b8, b8)
						v2.Y += RandF32(-b8, b8)
						if checkV2inRooms(v2) {
							num--
							rec := rl.NewRectangle(v2.X-siz/2, v2.Y-siz/2, siz, siz)
							zfx.recs2 = append(zfx.recs2, rec)
							crec := rec
							crec.X += rec.Width / 3
							crec.Y += rec.Height / 3
							crec.Width = rec.Width / 3
							crec.Height = rec.Height / 3
							zfx.crecs = append(zfx.crecs, crec)
						}
						countbreak--
						if countbreak == 0 {
							break
						}
					}
					fx = append(fx, zfx)
				}
			}
		}
		if pl.hp == 1 && vineRing && !pl.art[vineRingArtNum].off {
			admsg("just in the nick of vine", rl.Green)
			pl.burnT = 0
			pl.freezeT = 0
			pl.poisonT = 0
			pl.dampT = 0
			pl.aninum = 0
			pl.art[vineRingArtNum].off = true
			vineon = true
		}
		if pl.hp <= 0 {
			playerDeath()
		}
	}
}
func hitPL(num int) { //MARK:HIT PLAYER SEE ALSO HIT PLAYER ENEMY PROJECTILE ABOVE
	if !invincible {
		if vineon {
			if msgT == 0 {
				admsg("vine saves dmg", rl.Green)
				msgT = fps
			}
		} else if turtleT > 0 {
			if msgT == 0 {
				admsg("turtle shell saves dmg", rl.Green)
				msgT = fps
			}
		} else if pl.armorT > 0 {
			if msgT == 0 {
				admsg("armor shield saves dmg", rl.Green)
				msgT = fps
			}
		} else if shrimpnum > 0 {
			if pl.hpT == 0 {
				pl.hpT = fps * 2
				shrimpnum--
				admsg("shrimp shell saves dmg", rl.Green)
			}
		} else {
			switch num {
			case 2: //-HP NO HP PAUSE BURN DMG
				if pl.hp > 0 && pl.hpT == 0 {
					pl.hpT = fps
					pl.hp--
					admsg("-1 dmg", rl.Red)
					//HP LOSS SFX
					if prevplayHP > pl.hp {
						rl.PlaySound(audfx[14])
						prevplayHP = pl.hp
					} else if prevplayHP < pl.hp {
						prevplayHP = pl.hp
					}
				}
			case 1: //-HP & HP PAUSE
				if pl.hpT == 0 {
					if pl.hp > 0 {
						pl.hp--
						//HP LOSS SFX
						if prevplayHP > pl.hp {
							rl.PlaySound(audfx[14])
							prevplayHP = pl.hp
						} else if prevplayHP < pl.hp {
							prevplayHP = pl.hp
						}
						pl.hpT = fps * 2
						admsg("-1 dmg", rl.Red)
						zfx := xfx{}
						zfx.nm = "plblood"
						zfx.img = splat[RandInt(0, len(splat))]
						zfx.col = RandRed()
						zfx.fade = 0.8
						zfx.rec = pl.rec
						zfx.rec.X -= b
						zfx.rec.Y -= b
						zfx.rec.Width += b2
						zfx.rec.Height += b2
						fx = append(fx, zfx)
					}
				}
			}
			//THORNS
			if thornson {
				thorns()
			}
			//CLOAK
			if cloak && cloakT == 0 {
				cloakT = fps / 2
				siz := b2
				zfx := xfx{}
				zfx.img = anm[96].rec
				zfx.nm = "cloaksparks"
				num := 10
				countbreak := 100
				for num > 0 {
					v2 := pl.cnt
					v2.X += RandF32(-b5, b5)
					v2.Y += RandF32(-b5, b5)
					if checkV2inRooms(v2) {
						num--
						rec := rl.NewRectangle(v2.X-siz/2, v2.Y-siz/2, siz, siz)
						zfx.recs2 = append(zfx.recs2, rec)
						crec := rec
						crec.X += rec.Width / 3
						crec.Y += rec.Height / 3
						crec.Width = rec.Width / 3
						crec.Height = rec.Height / 3
						zfx.crecs = append(zfx.crecs, crec)
					}
					countbreak--
					if countbreak == 0 {
						break
					}
				}
				fx = append(fx, zfx)
			}
		}
		if pl.hp == 1 && vineRing && !pl.art[vineRingArtNum].off {
			admsg("just in the nick of vine", rl.Green)
			pl.burnT = 0
			pl.freezeT = 0
			pl.poisonT = 0
			pl.dampT = 0
			pl.aninum = 0
			pl.art[vineRingArtNum].off = true
			vineon = true
		}
		if pl.hp <= 0 {
			playerDeath()
		}
	}
}
func thorns() { //MARK:THORNS
	siz := b8
	rec := rl.NewRectangle(pl.cnt.X-siz/2, pl.cnt.Y-siz/2, siz, siz)
	for i := 0; i < len(levels[levNum].enm); i++ {
		if rl.CheckCollisionRecs(levels[levNum].enm[i].crec, rec) && levels[levNum].enm[i].hpT == 0 && !levels[levNum].enm[i].nodmg {
			levels[levNum].enm[i].hp--
			if msgT == 0 {
				admsg("ouch... thorns", rl.Red)
				msgT = fps
				zfx := xfx{}
				zfx.nm = "thorns"
				zfx.img = anm[89].rec
				zfx.rec = pl.rec
				zfx.rec.X -= b4
				zfx.rec.Y -= b4
				zfx.rec.Width += b8
				zfx.rec.Height += b8
				fx = append(fx, zfx)
			}
			if levels[levNum].enm[i].hp <= 0 && !levels[levNum].enm[i].off {
				pl.xp += levels[levNum].enm[i].xp
				makeEnDeathFx(i)
				levels[levNum].enm[i].off = true
			} else {
				levels[levNum].enm[i].hpT = fps
				levels[levNum].enm[i].hpY = bq3
				levels[levNum].enm[i].hpY2 = 0
				if bosson {
					levels[levNum].enm[i].hpY = b
					levels[levNum].enm[i].hpY2 = b / 2
				}
			}
		}
	}
}
func shrec(rec rl.Rectangle, amount float32) rl.Rectangle { //MARK:SHADOW REC
	rec.X -= amount
	rec.Y += amount
	return rec
}
func blrec(rec rl.Rectangle, amount float32) rl.Rectangle { //MARK:BLUR REC
	rec.X += RandF32(-amount, amount)
	rec.Y += RandF32(-amount, amount)
	return rec
}
func orgn(rec rl.Rectangle) rl.Vector2 { //MARK:ORIGIN
	return rl.NewVector2(rec.Width/2, rec.Height/2)
}
func drec(rec rl.Rectangle) rl.Rectangle { //MARK:DRAW REC
	rec.X += rec.Width / 2
	rec.Y += rec.Height / 2
	return rec
}

// MARK: UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP
func upprojPL() { //MARK:UP PROJ PLAYER

	clear := false
	for i := 0; i < len(projPL); i++ {
		//ENEMY COLLIS
		for j := 0; j < len(levels[levNum].enm); j++ {
			if !levels[levNum].enm[j].off {
				if rl.CheckCollisionRecs(projPL[i].crec, levels[levNum].enm[j].crec) && levels[levNum].enm[j].hpT == 0 && projPL[i].collisT == 0 {
					projEnmCollis(i, j)
				}
			}
		}
		if !projPL[i].off {
			if projPL[i].collisT > 0 {
				projPL[i].collisT--
			}

			//IMG ANIMS
			if projPL[i].nm == "window cleaner" {
				if frames%4 == 0 {
					projPL[i].img.X += anm[177].W
					if projPL[i].img.X > anm[177].X+anm[177].frames*anm[177].W {
						projPL[i].img.X = anm[177].X
					}
				}
				if projPL[i].rec.Width < b2 {
					projPL[i].rec.X -= 0.5
					projPL[i].rec.Y -= 0.5
					projPL[i].rec.Width += 1
					projPL[i].rec.Height += 1
					projPL[i].cnt = makecnt(projPL[i].rec)
				}
			}
			if projPL[i].nm == "fartfire" {
				if frames%5 == 0 {
					projPL[i].img.X += anm[185].W
					if projPL[i].img.X > anm[185].X+anm[185].frames*anm[185].W {
						projPL[i].img.X = anm[185].X
					}
				}
			}

			//LIGHTER FLAME
			if projPL[i].nm == "lighter" && !rl.CheckCollisionRecs(pl.carec, projPL[i].rec) {
				projPL[i].T--
				if projPL[i].T <= 0 {
					projPL[i].T = fps / 3
					zfx := xfx{}
					zfx.nm = "flamingoflame"
					zfx.fade = 0.8
					zfx.img = anm[98].rec
					zfx.rec = projPL[i].rec
					zfx.rec.X -= b / 4
					zfx.rec.Y -= b / 4
					zfx.rec.Width += b / 2
					zfx.rec.Height += b / 2
					zfx.crec = zfx.rec
					zfx.crec.X += zfx.crec.Width / 8
					zfx.crec.Y += zfx.crec.Height / 8
					zfx.crec.Width -= zfx.crec.Width / 4
					zfx.crec.Height -= zfx.crec.Height / 4
					zfx.T = fps * 3
					zfx.below = true
					fx = append(fx, zfx)
				}
			}
			//MUSTARD INCREASE SIZE
			if projPL[i].nm == "mustard" {
				if projPL[i].rec.Width < b+b/2 {
					projPL[i].rec.X -= 0.5
					projPL[i].rec.Y -= 0.5
					projPL[i].rec.Width += 1
					projPL[i].rec.Height += 1
					projPL[i].cnt = makecnt(projPL[i].rec)
				}
			}
			//PINEAPPLE INCREASE SIZE
			if projPL[i].nm == "pineapple" {
				if projPL[i].rec.Width < b2+b/2 {
					projPL[i].rec.X -= 0.5
					projPL[i].rec.Y -= 0.5
					projPL[i].rec.Width += 1
					projPL[i].rec.Height += 1
					projPL[i].cnt = makecnt(projPL[i].rec)
				}
			}

			switch projPL[i].nm {
			default:
				//MOVE
				canmove := checkRecMoveWalls(projPL[i].crec, projPL[i].dirX, projPL[i].dirY)
				etcNum := 0
				if canmove {
					checkrec := projPL[i].crec
					checkrec.X += projPL[i].dirX
					checkrec.Y += projPL[i].dirY
					canmove, etcNum = checkRecEtcSolid(checkrec)
				} else { //COLLIS WALL CLEAR
					if projPL[i].bounce > 0 {
						projPL[i].bounce--
						projPL[i].dirX = projPL[i].dirX * -1
						projPL[i].dirY = projPL[i].dirY * -1
						if projPL[i].nm == "bunch of carrots" || projPL[i].nm == "drawing pin" || projPL[i].nm == "fork" || projPL[i].nm == "french fries" {
							projPL[i].ro += 180
						}
						if projPL[i].nm == "rubber duck" {

							if projPL[i].dirY > 0 {
								projPL[i].dirY = RandF32(projPL[i].spd/4, projPL[i].spd)
							} else {
								projPL[i].dirY = RandF32(-projPL[i].spd, -projPL[i].spd/4)
							}

							if projPL[i].dirX > 0 {
								projPL[i].dirX = RandF32(projPL[i].spd/4, projPL[i].spd)
							} else {
								projPL[i].dirX = RandF32(-projPL[i].spd, -projPL[i].spd/4)
							}

						}
						if len(projPL) < 50 {
							if projPL[i].nm == "raspberry" {
								zproj := projPL[i]
								zproj.dirX += RandF32(-2, 2)
								zproj.dirY += RandF32(-2, 2)
								projPL = append(projPL, zproj)
							}
						}
						canmove = true
					} else { //WEAPON PROJ END COLLIS ANIM
						switch projPL[i].nm {
						case "raspberry", "chilli", "ladybugproj":
							zfx := xfx{}
							zfx.img = anm[179].rec
							zfx.rec = projPL[i].rec
							if projPL[i].nm == "chilli" {
								zfx.rec.X -= zfx.rec.Width / 4
								zfx.rec.Y -= zfx.rec.Width / 4
								zfx.rec.Width += zfx.rec.Width / 2
								zfx.rec.Height += zfx.rec.Height / 2
							}
							if projPL[i].nm == "raspberry" {
								zfx.rec.X -= zfx.rec.Width
								zfx.rec.Y -= zfx.rec.Width
								zfx.rec.Width += zfx.rec.Width * 2
								zfx.rec.Height += zfx.rec.Height * 2
							}
							zfx.nm = "redWeapEnd"
							fx = append(fx, zfx)
						case "mint ice cream":
							zfx := xfx{}
							zfx.img = anm[179].rec
							zfx.rec = projPL[i].rec
							zfx.nm = "greenWeapEnd"
							fx = append(fx, zfx)
						case "rolling pin", "magnifying glass":
							zfx := xfx{}
							zfx.img = anm[179].rec
							zfx.rec = projPL[i].rec
							zfx.nm = "brownWeapEnd"
							fx = append(fx, zfx)
						case "window cleaner", "fork":
							zfx := xfx{}
							zfx.img = anm[179].rec
							zfx.rec = projPL[i].rec
							zfx.nm = "blueWeapEnd"
							fx = append(fx, zfx)
						case "bunch of carrots", "mustard", "emoji":
							zfx := xfx{}
							zfx.img = anm[179].rec
							zfx.rec = projPL[i].rec
							zfx.nm = "orangeWeapEnd"
							fx = append(fx, zfx)
						case "kitchen knife", "frying pan", "lighter", "hot soup", "drawing pin", "popcornProj", "battyProj":
							zfx := xfx{}
							zfx.img = anm[179].rec
							zfx.rec = projPL[i].rec
							zfx.nm = "greyWeapEnd"
							fx = append(fx, zfx)
						case "pineapple", "rubber duck", "french fries", "guitar", "rolloProj":
							zfx := xfx{}
							zfx.img = anm[179].rec
							zfx.rec = projPL[i].rec
							zfx.nm = "yellowWeapEnd"
							fx = append(fx, zfx)

						}
						projPL[i].off = true
						clear = true
						break
					}
				}
				if canmove { //MOVE PROJ
					projPL[i].rec.X += projPL[i].dirX + delta
					projPL[i].rec.Y += projPL[i].dirY + delta
					projPL[i].crec = projPL[i].rec
					if projPL[i].nm == "fartfire" {
						projPL[i].crec.X += b / 8
						projPL[i].crec.Y += b / 8
						projPL[i].crec.Width -= b / 4
						projPL[i].crec.Height -= b / 4
					}
				} else { //COLLIS ETC
					switch levels[levNum].etc[etcNum].nm {
					case "crate":
						if drillon {
							if projPL[i].firework {
								levels[levNum].etc[etcNum].firework = true
							}
							levels[levNum].etc[etcNum].hp = 0
						} else {
							if levels[levNum].etc[etcNum].hpT == 0 {
								if projPL[i].firework {
									levels[levNum].etc[etcNum].firework = true
								}
								levels[levNum].etc[etcNum].hpT = fps / 10
								levels[levNum].etc[etcNum].hp -= projPL[i].dmg + (stats.str - 1)
							}
						}
					}
					if projPL[i].bounce > 0 {
						projPL[i].bounce--
						projPL[i].dirX = projPL[i].dirX * -1
						projPL[i].dirY = projPL[i].dirY * -1
						canmove = true
					} else {
						projPL[i].off = true
						clear = true
						break
					}
				}
				projPL[i].ro += projPL[i].rospd
			case "rocket":
				checkV2 := projPL[i].cnt
				checkV2.X += projPL[i].dirX
				checkV2.Y += projPL[i].dirY
				canmove := checkV2inRooms(checkV2)
				if canmove {
					projPL[i].rec.X += projPL[i].dirX + delta
					projPL[i].rec.Y += projPL[i].dirY + delta
					projPL[i].rec3.X += projPL[i].dirX + delta
					projPL[i].rec3.Y += projPL[i].dirY + delta
					projPL[i].cnt = makecnt(projPL[i].rec)
				} else {
					rl.PlaySound(audfx[94])
					projPL[i].off = true
					clear = true
					zfx := xfx{}
					zfx.nm = "bombExplode"
					zfx.rec = projPL[i].rec
					zfx.rec.X -= b10
					zfx.rec.Y -= b10
					zfx.rec.Width += b10 * 2
					zfx.rec.Height += b10 * 2
					zfx.img = anm[106].rec
					fx = append(fx, zfx)
				}
			case "chickenProj":
				checkrec := projPL[i].rec
				checkrec.X += projPL[i].dirX
				checkrec.Y += projPL[i].dirY
				canmove := checkRecWalls(checkrec)
				if canmove {
					canmove = checkRecSolid(checkrec)
				}
				if canmove {
					projPL[i].rec = checkrec
				} else {
					projPL[i].dirX = RandF32(-projPL[i].spd, projPL[i].spd)
					projPL[i].dirY = RandF32(-projPL[i].spd, projPL[i].spd)
				}
				projPL[i].moveT--
				if projPL[i].moveT == 0 {
					projPL[i].moveT = fps * 2
					projPL[i].dirX = RandF32(-projPL[i].spd, projPL[i].spd)
					projPL[i].dirY = RandF32(-projPL[i].spd, projPL[i].spd)
					zfx := xfx{}
					zfx.img = etc[130]
					zfx.rec = projPL[i].rec
					zfx.rec.X += b / 4
					zfx.rec.Y += b / 4
					zfx.rec.Width -= b / 2
					zfx.rec.Height -= b / 2
					zfx.below = true
					zfx.nm = "chickenEgg"
					zfx.T = fps * 3
					fx = append(fx, zfx)
				}
				if projPL[i].dirX > 0 {
					projPL[i].direc = true
				} else {
					projPL[i].direc = false
				}
			case "poisongas":
				projPL[i].T--
				if projPL[i].T <= 0 {
					projPL[i].off = true
					clear = true
				}
				checkv2 := projPL[i].cnt
				checkv2.X += projPL[i].dirX
				checkv2.Y += projPL[i].dirY
				if checkV2inRooms(checkv2) {
					projPL[i].cnt = checkv2
					projPL[i].rec = rl.NewRectangle(projPL[i].cnt.X-projPL[i].rec.Width/2, projPL[i].cnt.Y-projPL[i].rec.Height/2, projPL[i].rec.Width, projPL[i].rec.Height)
					projPL[i].crec = projPL[i].rec
					projPL[i].crec.X += projPL[i].crec.Width / 4
					projPL[i].crec.Y += projPL[i].crec.Height / 4
					projPL[i].crec.Width = projPL[i].crec.Width / 2
					projPL[i].crec.Height = projPL[i].crec.Height / 2
				} else {
					projPL[i].dirX = RandF32(-projPL[i].spd, projPL[i].spd)
					projPL[i].dirY = RandF32(-projPL[i].spd, projPL[i].spd)
				}
			case "frogProj":
				//FROG TIMERS
				projPL[i].T--
				if projPL[i].T <= 0 {
					zfx := xfx{}
					zfx.rec = projPL[i].rec
					zfx.img = anm[82].rec
					zfx.nm = "frogexit"
					zfx.T = fps * 10
					fx = append(fx, zfx)
					projPL[i].off = true
					clear = true
				}
				projPL[i].moveT--
				if projPL[i].moveT <= 0 {
					projPL[i].moveT = fps * RandInt32(1, 2)
					if Abs(projPL[i].dirX) > 0 || Abs(projPL[i].dirY) > 0 {
						projPL[i].dirX = 0
						projPL[i].dirY = 0
						projPL[i].img = anm[79].rec
						if projPL[i].lr {
							projPL[i].img = anm[78].rec
						}
					} else if projPL[i].dirX == 0 && projPL[i].dirY == 0 {
						if FlipCoin() {
							projPL[i].dirX = projPL[i].spd
							if FlipCoin() {
								projPL[i].dirX = -projPL[i].spd
							}
						} else {
							projPL[i].dirY = projPL[i].spd
							if FlipCoin() {
								projPL[i].dirY = -projPL[i].spd
							}
						}
						if projPL[i].dirX > 0 {
							projPL[i].lr = false
						} else {
							projPL[i].lr = true
						}
						projPL[i].img = anm[80].rec
						if projPL[i].lr {
							projPL[i].img = anm[81].rec
						}
					}
				}
				//FROG ANIM
				if frames%4 == 0 {
					if Abs(projPL[i].dirX) > 0 || Abs(projPL[i].dirY) > 0 {
						if projPL[i].lr {
							projPL[i].img.X -= anm[81].W
							if projPL[i].img.X < anm[81].X-anm[81].frames*anm[81].W {
								projPL[i].img.X = anm[81].X
							}
						} else {
							projPL[i].img.X += anm[80].W
							if projPL[i].img.X > anm[80].X+anm[80].frames*anm[80].W {
								projPL[i].img.X = anm[80].X
							}
						}
					} else {
						if projPL[i].lr {
							projPL[i].img.X -= anm[79].W
							if projPL[i].img.X < anm[79].X-anm[79].frames*anm[79].W {
								projPL[i].img.X = anm[79].X
							}
						} else {
							projPL[i].img.X += anm[78].W
							if projPL[i].img.X > anm[78].X+anm[78].frames*anm[78].W {
								projPL[i].img.X = anm[78].X
							}
						}
					}
				}
				//FROG MOVEMENT
				canmove := checkRecMoveWalls(projPL[i].crec, projPL[i].dirX, projPL[i].dirY)
				if canmove {
					checkrec := projPL[i].crec
					checkrec.X += projPL[i].dirX
					checkrec.Y += projPL[i].dirY
					canmove, _ = checkRecEtcSolid(checkrec)
				}
				if canmove {
					projPL[i].rec.X += projPL[i].dirX
					projPL[i].rec.Y += projPL[i].dirY
					projPL[i].crec = projPL[i].rec
					projPL[i].crec.X += projPL[i].crec.Width / 4
					projPL[i].crec.X += 2
					projPL[i].crec.Y += projPL[i].crec.Height / 4
					projPL[i].crec.Y += 2
					projPL[i].crec.Width = (projPL[i].crec.Width / 2) - 4
					projPL[i].crec.Height = (projPL[i].crec.Height / 2) - 4
				}
				if !canmove {
					projPL[i].moveT = fps
					projPL[i].dirX = 0
					projPL[i].dirY = 0
					projPL[i].img = anm[79].rec
					if projPL[i].lr {
						projPL[i].img = anm[78].rec
					}
				}
			case "beeProj":
				checkv2 := projPL[i].cnt
				checkv2.X += projPL[i].dirX
				checkv2.Y += projPL[i].dirY
				if checkV2inRooms(checkv2) {
					projPL[i].cnt = checkv2
					projPL[i].rec = rl.NewRectangle(projPL[i].cnt.X-projPL[i].rec.Width/2, projPL[i].cnt.Y-projPL[i].rec.Height/2, projPL[i].rec.Width, projPL[i].rec.Height)
					projPL[i].crec = projPL[i].rec
				} else {
					projPL[i].dirX = RandF32(-projPL[i].spd, projPL[i].spd)
					projPL[i].dirY = RandF32(-projPL[i].spd, projPL[i].spd)
				}
				projPL[i].moveT--
				if projPL[i].moveT == 0 {
					projPL[i].moveT = fps / 2
					projPL[i].dirX = RandF32(-projPL[i].spd, projPL[i].spd)
					projPL[i].dirY = RandF32(-projPL[i].spd, projPL[i].spd)
				}
				if projPL[i].dirX > 0 {
					projPL[i].direc = true
				} else {
					projPL[i].direc = false
				}
			}
		} else {
			clear = true
		}
	}
	if clear {
		for i := 0; i < len(projPL); i++ {
			if projPL[i].off {
				projPL = RemoveWeapon(projPL, i)
			}
		}
	}

	poisongasCount = 0
	for i := 0; i < len(projPL); i++ {
		if projPL[i].nm == "poisongas" {
			poisongasCount++
		}
	}
}
func upprojEn() { //MARK:UP PROJ ENEMY
	clear := false
	for i := 0; i < len(projEn); i++ {
		if !projEn[i].off {
			if !rl.CheckCollisionRecs(projEn[i].rec, inRec) {
				projEn[i].off = true
			}
			//PLAYER COLLIS
			if rl.CheckCollisionRecs(pl.crec, projEn[i].crec) && pl.hpT == 0 && pl.enCollisT == 0 {
				pl.enCollisT = fps
				if stats.dex > 1 {
					if Roll12() <= stats.dex {
						if msgT == 0 {
							admsg("dodged > dexterity", rl.Green)
							msgT = fps
						}
					} else {
						hitPLEnProj(i)
						if projEn[i].nm == "birdProj" {
							zfx := xfx{}
							zfx.img = etc[153]
							zfx.cnt = pl.cnt
							siz := bq3
							zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
							zfx.nm = "birdegg"
							zfx.fade = 1
							zfx.col = rl.White
							zfx.below = true
							fx = append(fx, zfx)
							admsg("easter egg", rl.Yellow)
						}
					}
				} else {
					hitPLEnProj(i)
					if projEn[i].nm == "birdProj" {
						zfx := xfx{}
						zfx.img = etc[153]
						zfx.cnt = pl.cnt
						siz := b4
						zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
						zfx.nm = "birdegg"
						zfx.fade = 1
						zfx.col = rl.White
						zfx.below = true
						fx = append(fx, zfx)
					}
				}
				projEn[i].off = true
			}
		}
		if !projEn[i].off {
			switch projEn[i].nm {
			case "redblobbull", "rolloProj": //INCREASE SIZE
				if projEn[i].rec.Width < b3 {
					projEn[i].rec.Width += 0.2
					projEn[i].rec.X -= 0.1
				}
				if projEn[i].rec.Height < b3 {
					projEn[i].rec.Height += 0.2
					projEn[i].rec.Y -= 0.1
				}
				projEn[i].crec = projEn[i].rec
				if projEn[i].nm == "rolloProj" {
					projEn[i].crec = projEn[i].rec
					projEn[i].crec.X += projEn[i].crec.Width / 8
					projEn[i].crec.Y += projEn[i].crec.Height / 8
					projEn[i].crec.Width -= projEn[i].crec.Width / 4
					projEn[i].crec.Height -= projEn[i].crec.Height / 4
				}
			case "pinkcartbull": //CHANGE DIREC
				projEn[i].dirX, projEn[i].dirY = findSpdXY(projEn[i].cnt, pl.cnt, projEn[i].spd)
			}
			//MOVE
			canmove := checkRecMoveWalls(projEn[i].crec, projEn[i].dirX, projEn[i].dirY)
			etcNum := 0
			if canmove {
				checkrec := projEn[i].crec
				checkrec.X += projEn[i].dirX
				checkrec.Y += projEn[i].dirY
				canmove, etcNum = checkRecEtcSolid(checkrec)
			} else { //COLLIS WALL CLEAR
				if projEn[i].nm == "bonebull" && projEn[i].bounce > 0 {
					projEn[i].dirX = projEn[i].dirX * -1
					projEn[i].dirY = projEn[i].dirY * -1
					projEn[i].bounce--
					canmove = true
				} else if projEn[i].nm == "mushbossProj" && projEn[i].bounce > 0 {
					if projEn[i].dirX > 0 {
						projEn[i].dirX = RandF32(-boss.spd, -boss.spd/4)
					} else {
						projEn[i].dirX = RandF32(boss.spd/4, boss.spd)
					}
					if projEn[i].dirY > 0 {
						projEn[i].dirY = RandF32(-boss.spd, -boss.spd/4)
					} else {
						projEn[i].dirY = RandF32(boss.spd/4, boss.spd)
					}
					projEn[i].bounce--
					canmove = true
				} else if projEn[i].nm == "spinnaProj" && projEn[i].bounce > 0 {
					projEn[i].dirX = projEn[i].dirX * -1
					projEn[i].dirY = projEn[i].dirY * -1
					projEn[i].bounce--
					canmove = true
				} else if projEn[i].nm == "birdProj" && projEn[i].bounce > 0 {
					projEn[i].dirX = projEn[i].dirX * -1
					projEn[i].dirY = projEn[i].dirY * -1
					projEn[i].bounce--
					canmove = true
				} else if projEn[i].nm == "greenpigProj" && projEn[i].bounce > 0 {
					projEn[i].dirX = projEn[i].dirX * -1
					projEn[i].dirY = projEn[i].dirY * -1
					projEn[i].bounce--
					canmove = true
				} else if projEn[i].nm == "mrfrisbeeProj" && projEn[i].bounce > 0 {
					if FlipCoin() {
						projEn[i].dirX *= -1
					}
					if FlipCoin() {
						projEn[i].dirY *= -1
					}
					projEn[i].bounce--
					canmove = true
				} else {
					switch projEn[i].nm {
					case "mushbossProj", "redblobbull", "redantbull", "redspikeproj", "bushProj":
						zfx := xfx{}
						zfx.img = anm[179].rec
						zfx.rec = projEn[i].rec
						zfx.nm = "redWeapEnd"
						fx = append(fx, zfx)
					case "greenpigProj", "greenplantbull", "zomboProj", "spacemanProj":
						zfx := xfx{}
						zfx.img = anm[179].rec
						zfx.rec = projEn[i].rec
						zfx.nm = "greenWeapEnd"
						fx = append(fx, zfx)
					case "rolling pin", "magnifying glass":
						zfx := xfx{}
						zfx.img = anm[179].rec
						zfx.rec = projEn[i].rec
						zfx.nm = "brownWeapEnd"
						fx = append(fx, zfx)
					case "spinnaProj", "bluespikeproj", "icemanProj":
						zfx := xfx{}
						zfx.img = anm[179].rec
						zfx.rec = projEn[i].rec
						zfx.nm = "blueWeapEnd"
						fx = append(fx, zfx)
					case "bonebull", "birdProj", "battyProj":
						zfx := xfx{}
						zfx.img = anm[179].rec
						zfx.rec = projEn[i].rec
						zfx.nm = "greyWeapEnd"
						fx = append(fx, zfx)
					case "mrfrisbeeProj", "rolloProj":
						zfx := xfx{}
						zfx.img = anm[179].rec
						zfx.rec = projEn[i].rec
						zfx.nm = "yellowWeapEnd"
						fx = append(fx, zfx)
					case "pinkcartbull":
						zfx := xfx{}
						zfx.img = anm[179].rec
						zfx.rec = projEn[i].rec
						zfx.nm = "pinkWeapEnd"
						fx = append(fx, zfx)
					case "pigProj":
						zfx := xfx{}
						zfx.img = anm[179].rec
						zfx.rec = projEn[i].rec
						zfx.nm = "orangeWeapEnd"
						fx = append(fx, zfx)

					}

					projEn[i].off = true
					clear = true
					break
				}
			}
			if canmove { //MOVE PROJ
				if !projEn[i].below {
					projEn[i].rec.X += projEn[i].dirX + delta
					projEn[i].rec.Y += projEn[i].dirY + delta
					projEn[i].crec.X += projEn[i].dirX + delta
					projEn[i].crec.Y += projEn[i].dirY + delta
				}
			} else { //COLLIS ETC
				if projEn[i].nm == "bonebull" && projEn[i].bounce > 0 {
					projEn[i].dirX = projEn[i].dirX * -1
					projEn[i].dirY = projEn[i].dirY * -1
					projEn[i].bounce--
					canmove = true
				} else {
					switch levels[levNum].etc[etcNum].nm {
					case "crate":
						if levels[levNum].etc[etcNum].hpT == 0 {
							levels[levNum].etc[etcNum].hpT = fps / 10
							levels[levNum].etc[etcNum].hp--
						}
					}
					projEn[i].off = true
					clear = true
					break
				}
			}
			projEn[i].ro += projEn[i].rospd
		} else {
			clear = true
		}
	}
	if clear {
		for i := 0; i < len(projEn); i++ {
			if projEn[i].off {
				projEn = RemoveWeapon(projEn, i)
			}
		}
	}
}
func upboss() { //MARK:UP BOSS
	if len(levels[levNum].enm) > 0 {
		if levels[levNum].enm[0].hp > 0 {
			upprojEn()
			boss.hp = levels[levNum].enm[0].hp
			boss.hpT = levels[levNum].enm[0].hpT
			switch bossnum {
			case 9: //ROLLO
				if boss.atkT > 0 {
					boss.atkT--
				}
				collided := false
				checkrec := boss.crec
				checkrec.X += boss.dirX
				checkrec.Y += boss.dirY
				if rl.CheckCollisionRecs(pl.crec, checkrec) {
					countbreak := 100
					for {
						if boss.dirX > 0 {
							boss.dirX = RandF32(-boss.spd, -boss.spd/4)
						} else {
							boss.dirX = RandF32(boss.spd/4, boss.spd)
						}
						if boss.dirY > 0 {
							boss.dirY = RandF32(-boss.spd, -boss.spd/4)
						} else {
							boss.dirY = RandF32(boss.spd/4, boss.spd)
						}
						if Abs(boss.dirX) > boss.spd/2 || Abs(boss.dirY) > boss.spd/2 {
							break
						}
						countbreak--
						if countbreak == 0 {
							break
						}
					}
					collided = true
				} else {
					if checkRecWalls(checkrec) {
						boss.rec.X += boss.dirX
						boss.crec.X += boss.dirX
						boss.carec.X += boss.dirX
						boss.rec.Y += boss.dirY
						boss.crec.Y += boss.dirY
						boss.carec.Y += boss.dirY
						boss.cnt = makecnt(boss.rec)
						levels[levNum].enm[0].rec = boss.rec
						levels[levNum].enm[0].crec = boss.crec
						levels[levNum].enm[0].cnt = boss.cnt
					} else {
						collided = true
						countbreak := 100
						for {
							if boss.dirX > 0 {
								boss.dirX = RandF32(-boss.spd, -boss.spd/4)
							} else {
								boss.dirX = RandF32(boss.spd/4, boss.spd)
							}
							if boss.dirY > 0 {
								boss.dirY = RandF32(-boss.spd, -boss.spd/4)
							} else {
								boss.dirY = RandF32(boss.spd/4, boss.spd)
							}
							if Abs(boss.dirX) > boss.spd/2 || Abs(boss.dirY) > boss.spd/2 {
								break
							}
							countbreak--
							if countbreak == 0 {
								break
							}
						}
					}
				}
				if collided && boss.atkT == 0 {
					zproj := xweap{}
					zproj.dmg = 1
					zproj.nm = "rolloProj"
					siz := b
					zproj.spd = 2
					xdiff := AbsDiff(boss.cnt.X, pl.cnt.X)
					ydiff := AbsDiff(boss.cnt.Y, pl.cnt.Y)
					if xdiff > ydiff {
						zproj.dirX = zproj.spd
						zproj.dirY = ydiff / (xdiff / zproj.dirX)
					} else {
						zproj.dirY = zproj.spd
						zproj.dirX = xdiff / (ydiff / zproj.dirY)
					}
					if boss.cnt.X > pl.cnt.X {
						zproj.dirX = -zproj.dirX
					}
					if boss.cnt.Y > pl.cnt.Y {
						zproj.dirY = -zproj.dirY
					}
					cntr2 := makecnt(boss.crec)
					if boss.lr {
						cntr2.X -= b
					} else {
						cntr2.X += b
					}
					zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
					zproj.crec = zproj.rec
					zproj.crec.X += zproj.crec.Width / 8
					zproj.crec.Y += zproj.crec.Height / 8
					zproj.crec.Width -= zproj.crec.Width / 4
					zproj.crec.Height -= zproj.crec.Height / 4
					zproj.img = anm[155].rec
					projEn = append(projEn, zproj)
					boss.atkT = fps / 2
					collided = false
				}
				switch boss.state {
				case 1:
					if frames%3 == 0 {
						if boss.lr {
							boss.img.X -= anm[154].W
							if boss.img.X < anm[154].X-anm[154].frames*anm[154].W {
								boss.img.X = anm[154].X
							}
						} else {
							boss.img.X += anm[153].W
							if boss.img.X > anm[153].X+anm[153].frames*anm[153].W {
								boss.img.X = anm[153].X
							}
						}
					}
				case 0:
					if frames%5 == 0 {
						if boss.lr {
							boss.img.X -= anm[154].W
							if boss.img.X < anm[154].X-anm[154].frames*anm[154].W {
								boss.img.X = anm[154].X
							}
						} else {
							boss.img.X += anm[153].W
							if boss.img.X > anm[153].X+anm[153].frames*anm[153].W {
								boss.img.X = anm[153].X
							}
						}
					}
				}
				if boss.moveChangeT > 0 {
					boss.moveChangeT--
				} else {
					switch boss.state {
					case 0:
						boss.spd = 14
						countbreak := 100
						for {
							boss.dirX = RandF32(-boss.spd, boss.spd)
							boss.dirY = RandF32(-boss.spd, boss.spd)
							if Abs(boss.dirX) > boss.spd/2 || Abs(boss.dirY) > boss.spd/2 {
								break
							}
							countbreak--
							if countbreak == 0 {
								break
							}
						}
						boss.state = 1
						boss.moveChangeT = fps * RandInt32(2, 4)
					case 1:
						boss.spd = 2
						countbreak := 100
						for {
							boss.dirX = RandF32(-boss.spd, boss.spd)
							boss.dirY = RandF32(-boss.spd, boss.spd)
							if Abs(boss.dirX) > boss.spd/2 || Abs(boss.dirY) > boss.spd/2 {
								break
							}
							countbreak--
							if countbreak == 0 {
								break
							}
						}
						boss.state = 0
						boss.moveChangeT = fps * RandInt32(1, 2)
					}
				}
				if pl.cnt.X > boss.cnt.X {
					if boss.lr {
						boss.lr = false
					}
				} else {
					if !boss.lr {
						boss.lr = true
					}
				}
			case 8: //MUSHEE
				if boss.moveChangeT > 0 {
					boss.moveChangeT--
				} else {
					switch boss.state {
					case 2:
						if FlipCoin() {
							boss.state = 0
							boss.img.Y = anm[148].YT
							boss.dirX = RandF32(-boss.spd, boss.spd)
							boss.dirY = RandF32(-boss.spd, boss.spd)
							if boss.lr {
								boss.img.X = anm[149].X
							} else {
								boss.img.X = anm[148].X
							}
						} else {
							boss.state = 1
							boss.img.Y = anm[148].YT
							if boss.lr {
								boss.img.X = anm[149].X
							} else {
								boss.img.X = anm[148].X
							}
						}
					case 1:
						if FlipCoin() {
							boss.state = 0
							boss.img.Y = anm[148].YT
							boss.dirX = RandF32(-boss.spd, boss.spd)
							boss.dirY = RandF32(-boss.spd, boss.spd)
							if boss.lr {
								boss.img.X = anm[149].X
							} else {
								boss.img.X = anm[148].X
							}
						} else {
							boss.state = 2
							boss.img.Y = anm[150].YT
							boss.atkT = fps / 2
							if boss.lr {
								boss.img.X = anm[151].X
							} else {
								boss.img.X = anm[150].X
							}
						}
					case 0:
						if FlipCoin() {
							boss.state = 1
							boss.img.Y = anm[148].YT
							if boss.lr {
								boss.img.X = anm[149].X
							} else {
								boss.img.X = anm[148].X
							}
						} else {
							boss.state = 2
							boss.img.Y = anm[150].YT
							boss.atkT = fps / 2
							if boss.lr {
								boss.img.X = anm[151].X
							} else {
								boss.img.X = anm[150].X
							}
						}
					}
					boss.moveChangeT = RandInt32(2, 3) * fps
				}
				if boss.state != 2 {
					if boss.atkT > 0 {
						boss.atkT--
					} else {
						if Roll6() > 4 {
							zproj := xweap{}
							zproj.dmg = 2
							zproj.below = true
							zproj.nm = "mushLand"
							siz := b / 2
							cntr2 := makecnt(boss.crec)
							zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
							zproj.crec = zproj.rec
							zproj.img = etc[150]
							zproj.cnt = makecnt(zproj.rec)
							projEn = append(projEn, zproj)
						}
						boss.atkT = fps / 2
					}
				}
				switch boss.state {
				case 2: //ATK
					if boss.atkT > 0 {
						boss.atkT--
					} else {
						zproj := xweap{}
						zproj.dmg = 1
						zproj.nm = "mushbossProj"
						siz := b2
						zproj.spd = 2
						zproj.bounce = 3
						xdiff := AbsDiff(boss.cnt.X, pl.cnt.X)
						ydiff := AbsDiff(boss.cnt.Y, pl.cnt.Y)
						if xdiff > ydiff {
							zproj.dirX = zproj.spd
							zproj.dirY = ydiff / (xdiff / zproj.dirX)
						} else {
							zproj.dirY = zproj.spd
							zproj.dirX = xdiff / (ydiff / zproj.dirY)
						}
						if boss.cnt.X > pl.cnt.X {
							zproj.dirX = -zproj.dirX
						}
						if boss.cnt.Y > pl.cnt.Y {
							zproj.dirY = -zproj.dirY
						}
						cntr2 := makecnt(boss.crec)
						if boss.lr {
							cntr2.X -= b
						} else {
							cntr2.X += b
						}
						zproj.ro = AngleBetweenTwoPoints(pl.cnt, boss.cnt) + 180
						zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.crec.X += zproj.crec.Width / 4
						zproj.crec.Y += zproj.crec.Height / 4
						zproj.crec.Width = zproj.crec.Width / 2
						zproj.crec.Height = zproj.crec.Height / 2
						zproj.img = anm[152].rec
						projEn = append(projEn, zproj)
						boss.atkT = fps / 2
					}
					if frames%4 == 0 {
						if boss.lr {
							boss.img.X -= anm[151].W
							if boss.img.X < anm[151].X-anm[151].frames*anm[151].W {
								boss.img.X = anm[151].X
							}
						} else {
							boss.img.X += anm[150].W
							if boss.img.X > anm[150].X+anm[150].frames*anm[150].W {
								boss.img.X = anm[150].X
							}
						}
					}
					if pl.cnt.X > boss.cnt.X {
						if boss.lr {
							boss.lr = false
						}
					} else {
						if !boss.lr {
							boss.lr = true
						}
					}
				case 1: //WALK TO PLAYER
					if frames%4 == 0 {
						if boss.lr {
							boss.img.X -= anm[149].W
							if boss.img.X < anm[149].X-anm[149].frames*anm[149].W {
								boss.img.X = anm[149].X
							}
						} else {
							boss.img.X += anm[148].W
							if boss.img.X > anm[148].X+anm[148].frames*anm[148].W {
								boss.img.X = anm[148].X
							}
						}
					}
					xdiff := AbsDiff(boss.cnt.X, pl.cnt.X)
					ydiff := AbsDiff(boss.cnt.Y, pl.cnt.Y)
					if xdiff > ydiff {
						boss.dirX = boss.spd
						boss.dirY = ydiff / (xdiff / boss.dirX)
					} else {
						boss.dirY = boss.spd
						boss.dirX = xdiff / (ydiff / boss.dirY)
					}
					if boss.cnt.X > pl.cnt.X {
						boss.dirX = -boss.dirX
					}
					if boss.cnt.Y > pl.cnt.Y {
						boss.dirY = -boss.dirY
					}
					checkrec := boss.crec
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(pl.crec, checkrec) {
						boss.dirX = RandF32(-boss.spd, boss.spd)
						boss.dirY = RandF32(-boss.spd, boss.spd)
						boss.moveChangeT = fps
					} else {
						if checkRecWalls(checkrec) {
							boss.rec.X += boss.dirX
							boss.crec.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rec.Y += boss.dirY
							boss.crec.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rec)
							levels[levNum].enm[0].rec = boss.rec
							levels[levNum].enm[0].crec = boss.crec
							levels[levNum].enm[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.spd, boss.spd)
							boss.dirY = RandF32(-boss.spd, boss.spd)
							boss.moveChangeT = fps
						}
					}
					if pl.cnt.X > boss.cnt.X {
						if boss.lr {
							boss.lr = false
						}
					} else {
						if !boss.lr {
							boss.lr = true
						}
					}
				case 0: //WALK RANDOM
					if frames%4 == 0 {
						if boss.lr {
							boss.img.X -= anm[149].W
							if boss.img.X < anm[149].X-anm[149].frames*anm[149].W {
								boss.img.X = anm[149].X
							}
						} else {
							boss.img.X += anm[148].W
							if boss.img.X > anm[148].X+anm[148].frames*anm[148].W {
								boss.img.X = anm[148].X
							}
						}
					}
					checkrec := boss.crec
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(pl.crec, checkrec) {
						boss.dirX = RandF32(-boss.spd, boss.spd)
						boss.dirY = RandF32(-boss.spd, boss.spd)
						boss.moveChangeT += fps
					} else {
						if checkRecWalls(checkrec) {
							boss.rec.X += boss.dirX
							boss.crec.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rec.Y += boss.dirY
							boss.crec.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rec)
							levels[levNum].enm[0].rec = boss.rec
							levels[levNum].enm[0].crec = boss.crec
							levels[levNum].enm[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.spd, boss.spd)
							boss.dirY = RandF32(-boss.spd, boss.spd)
							boss.moveChangeT += fps
						}
					}
					if boss.dirX > 0 {
						boss.lr = false
					} else {
						boss.lr = true
					}
				}
			case 7: // BATTY
				if boss.moveChangeT > 0 {
					boss.moveChangeT--
				} else {
					switch boss.state {
					case 4:
						choose := RandInt(1, 4)
						switch choose {
						case 3:
							boss.img.Y = anm[143].YT
							boss.state = 2
							if boss.lr {
								boss.img.X = anm[144].X
							} else {
								boss.img.X = anm[143].X
							}
						case 2:
							boss.img.Y = anm[145].YT
							boss.state = 0
							if boss.lr {
								boss.img.X = anm[146].X
							} else {
								boss.img.X = anm[145].X
							}
						case 1:
							boss.img.Y = anm[141].YT
							boss.state = 1
							if boss.lr {
								boss.img.X = anm[142].X
							} else {
								boss.img.X = anm[141].X
							}
						}
					case 3:
						boss.img.Y = anm[143].YT
						boss.state = 2
						if boss.lr {
							boss.img.X = anm[144].X
						} else {
							boss.img.X = anm[143].X
						}
					case 2:
						choose := RandInt(1, 4)
						switch choose {
						case 3:
							boss.img.Y = anm[143].YT
							boss.state = 4
							if boss.lr {
								boss.img.X = anm[144].X
							} else {
								boss.img.X = anm[143].X
							}
						case 2:
							boss.img.Y = anm[145].YT
							boss.state = 0
							if boss.lr {
								boss.img.X = anm[146].X
							} else {
								boss.img.X = anm[145].X
							}
						case 1:
							boss.img.Y = anm[141].YT
							boss.state = 1
							if boss.lr {
								boss.img.X = anm[142].X
							} else {
								boss.img.X = anm[141].X
							}
						}
					case 1:
						choose := RandInt(1, 4)
						switch choose {
						case 3:
							boss.img.Y = anm[143].YT
							boss.state = 4
							if boss.lr {
								boss.img.X = anm[144].X
							} else {
								boss.img.X = anm[143].X
							}
						case 2:
							boss.img.Y = anm[145].YT
							boss.state = 0
							if boss.lr {
								boss.img.X = anm[146].X
							} else {
								boss.img.X = anm[145].X
							}
						case 1:
							boss.img.Y = anm[143].YT
							boss.state = 2
							if boss.lr {
								boss.img.X = anm[144].X
							} else {
								boss.img.X = anm[143].X
							}
						}
					case 0:
						choose := RandInt(1, 4)
						switch choose {
						case 3:
							boss.img.Y = anm[143].YT
							boss.state = 4
							if boss.lr {
								boss.img.X = anm[144].X
							} else {
								boss.img.X = anm[143].X
							}
						case 2:
							boss.img.Y = anm[141].YT
							boss.state = 1
							if boss.lr {
								boss.img.X = anm[142].X
							} else {
								boss.img.X = anm[141].X
							}
						case 1:
							boss.img.Y = anm[143].YT
							boss.state = 2
							if boss.lr {
								boss.img.X = anm[144].X
							} else {
								boss.img.X = anm[143].X
							}
						}
					}
					boss.moveChangeT = fps * RandInt32(1, 2)
				}
				switch boss.state {
				case 4:
					if boss.atkT > 0 {
						boss.atkT--
					} else {
						zproj := xweap{}
						zproj.dmg = 2
						zproj.nm = "battyProj"
						siz := b3
						zproj.spd = 3
						cntr2 := makecnt(boss.crec)
						if boss.lr {
							cntr2.X -= b
						} else {
							cntr2.X += b
						}
						zproj.ro = 0
						zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.crec.X += zproj.crec.Width / 4
						zproj.crec.Y += zproj.crec.Height / 4
						zproj.crec.Width = zproj.crec.Width / 2
						zproj.crec.Height = zproj.crec.Height / 2
						zproj.img = anm[147].rec
						zproj.dirY = -zproj.spd
						zproj.ro = -90
						projEn = append(projEn, zproj)
						zproj.ro = 90
						zproj.dirY = zproj.spd
						projEn = append(projEn, zproj)
						zproj.dirY = 0
						zproj.dirX = -zproj.spd
						zproj.ro = 180
						projEn = append(projEn, zproj)
						zproj.dirX = zproj.spd
						zproj.ro = 0
						projEn = append(projEn, zproj)
						boss.atkT = fps - (fps / 3)
					}
					if frames%2 == 0 {
						if boss.lr {
							boss.img.X -= anm[144].W
							if boss.img.X < anm[144].X-anm[144].frames*anm[144].W {
								boss.img.X = anm[144].X
							}
						} else {
							boss.img.X += anm[143].W
							if boss.img.X > anm[143].X+anm[143].frames*anm[143].W {
								boss.img.X = anm[143].X
							}
						}
					}
				case 3:
					checkrec := boss.crec
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(pl.crec, checkrec) {
						boss.dirX = RandF32(-boss.spd, boss.spd)
						boss.dirY = RandF32(-boss.spd, boss.spd)
						boss.img.Y = anm[141].YT
						boss.state = 1
						if boss.lr {
							boss.img.X = anm[142].X
						} else {
							boss.img.X = anm[141].X
						}
						boss.moveChangeT = fps
					} else {
						if checkRecWalls(checkrec) {
							boss.rec.X += boss.dirX
							boss.crec.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rec.Y += boss.dirY
							boss.crec.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rec)
							levels[levNum].enm[0].rec = boss.rec
							levels[levNum].enm[0].crec = boss.crec
							levels[levNum].enm[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.spd, boss.spd)
							boss.dirY = RandF32(-boss.spd, boss.spd)
							boss.img.Y = anm[141].YT
							boss.state = 1
							if boss.lr {
								boss.img.X = anm[142].X
							} else {
								boss.img.X = anm[141].X
							}
							boss.moveChangeT = fps
						}
					}
					if frames%2 == 0 {
						if boss.lr {
							boss.img.X -= anm[142].W
							if boss.img.X < anm[142].X-anm[142].frames*anm[142].W {
								boss.img.X = anm[142].X
							}
						} else {
							boss.img.X += anm[141].W
							if boss.img.X > anm[141].X+anm[141].frames*anm[141].W {
								boss.img.X = anm[141].X
							}
						}
					}
				case 2: //ATK FLY
					if boss.atkT > 0 {
						boss.atkT--
					} else {
						zproj := xweap{}
						zproj.dmg = 2
						zproj.nm = "battyProj"
						siz := b3
						zproj.spd = 3
						xdiff := AbsDiff(boss.cnt.X, pl.cnt.X)
						ydiff := AbsDiff(boss.cnt.Y, pl.cnt.Y)
						if xdiff > ydiff {
							zproj.dirX = zproj.spd
							zproj.dirY = ydiff / (xdiff / zproj.dirX)
						} else {
							zproj.dirY = zproj.spd
							zproj.dirX = xdiff / (ydiff / zproj.dirY)
						}
						if boss.cnt.X > pl.cnt.X {
							zproj.dirX = -zproj.dirX
						}
						if boss.cnt.Y > pl.cnt.Y {
							zproj.dirY = -zproj.dirY
						}
						cntr2 := makecnt(boss.crec)
						if boss.lr {
							cntr2.X -= b
						} else {
							cntr2.X += b
						}
						zproj.ro = AngleBetweenTwoPoints(pl.cnt, boss.cnt) + 180
						zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.crec.X += zproj.crec.Width / 4
						zproj.crec.Y += zproj.crec.Height / 4
						zproj.crec.Width = zproj.crec.Width / 2
						zproj.crec.Height = zproj.crec.Height / 2
						zproj.img = anm[147].rec
						projEn = append(projEn, zproj)
						boss.atkT = fps - (fps / 3)
					}
					xdiff := AbsDiff(boss.cnt.X, pl.cnt.X)
					ydiff := AbsDiff(boss.cnt.Y, pl.cnt.Y)
					if xdiff > ydiff {
						boss.dirX = boss.spd
						boss.dirY = ydiff / (xdiff / boss.dirX)
					} else {
						boss.dirY = boss.spd
						boss.dirX = xdiff / (ydiff / boss.dirY)
					}
					if boss.cnt.X > pl.cnt.X {
						boss.dirX = -boss.dirX
					}
					if boss.cnt.Y > pl.cnt.Y {
						boss.dirY = -boss.dirY
					}
					checkrec := boss.crec
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(pl.crec, checkrec) {
						boss.dirX = RandF32(-boss.spd, boss.spd)
						boss.dirY = RandF32(-boss.spd, boss.spd)
						boss.img.Y = anm[141].YT
						boss.state = 1
						if boss.lr {
							boss.img.X = anm[142].X
						} else {
							boss.img.X = anm[141].X
						}
						boss.moveChangeT = fps
					} else {
						if checkRecWalls(checkrec) {
							boss.rec.X += boss.dirX
							boss.crec.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rec.Y += boss.dirY
							boss.crec.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rec)
							levels[levNum].enm[0].rec = boss.rec
							levels[levNum].enm[0].crec = boss.crec
							levels[levNum].enm[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.spd, boss.spd)
							boss.dirY = RandF32(-boss.spd, boss.spd)
							boss.img.Y = anm[141].YT
							boss.state = 1
							if boss.lr {
								boss.img.X = anm[142].X
							} else {
								boss.img.X = anm[141].X
							}
							boss.moveChangeT = fps
						}
					}
					if frames%2 == 0 {
						if boss.lr {
							boss.img.X -= anm[144].W
							if boss.img.X < anm[144].X-anm[144].frames*anm[144].W {
								boss.img.X = anm[144].X
							}
						} else {
							boss.img.X += anm[143].W
							if boss.img.X > anm[143].X+anm[143].frames*anm[143].W {
								boss.img.X = anm[143].X
							}
						}
					}
				case 1: //FLY
					xdiff := AbsDiff(boss.cnt.X, pl.cnt.X)
					ydiff := AbsDiff(boss.cnt.Y, pl.cnt.Y)
					if xdiff > ydiff {
						boss.dirX = boss.spd
						boss.dirY = ydiff / (xdiff / boss.dirX)
					} else {
						boss.dirY = boss.spd
						boss.dirX = xdiff / (ydiff / boss.dirY)
					}
					if boss.cnt.X > pl.cnt.X {
						boss.dirX = -boss.dirX
					}
					if boss.cnt.Y > pl.cnt.Y {
						boss.dirY = -boss.dirY
					}
					checkrec := boss.crec
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(pl.crec, checkrec) {
						boss.dirX = RandF32(-boss.spd, boss.spd)
						boss.dirY = RandF32(-boss.spd, boss.spd)
						boss.img.Y = anm[141].YT
						boss.state = 3
						if boss.lr {
							boss.img.X = anm[142].X
						} else {
							boss.img.X = anm[141].X
						}
						boss.moveChangeT = fps
					} else {
						if checkRecWalls(checkrec) {
							boss.rec.X += boss.dirX
							boss.crec.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rec.Y += boss.dirY
							boss.crec.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rec)
							levels[levNum].enm[0].rec = boss.rec
							levels[levNum].enm[0].crec = boss.crec
							levels[levNum].enm[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.spd, boss.spd)
							boss.dirY = RandF32(-boss.spd, boss.spd)
							boss.img.Y = anm[141].YT
							boss.state = 3
							if boss.lr {
								boss.img.X = anm[142].X
							} else {
								boss.img.X = anm[141].X
							}
							boss.moveChangeT = fps
						}
					}
					if frames%2 == 0 {
						if boss.lr {
							boss.img.X -= anm[142].W
							if boss.img.X < anm[142].X-anm[142].frames*anm[142].W {
								boss.img.X = anm[142].X
							}
						} else {
							boss.img.X += anm[141].W
							if boss.img.X > anm[141].X+anm[141].frames*anm[141].W {
								boss.img.X = anm[141].X
							}
						}
					}
				case 0: //IDLE
					if frames%2 == 0 {
						if boss.lr {
							boss.img.X -= anm[146].W
							if boss.img.X < anm[146].X-anm[146].frames*anm[146].W {
								boss.img.X = anm[146].X
							}
						} else {
							boss.img.X += anm[145].W
							if boss.img.X > anm[145].X+anm[145].frames*anm[145].W {
								boss.img.X = anm[145].X
							}
						}
					}
				}
				changed := false
				if pl.cnt.X > boss.cnt.X {
					if boss.lr {
						boss.lr = false
						changed = true
					}
				} else {
					if !boss.lr {
						boss.lr = true
						changed = true
					}
				}
				if changed {
					switch boss.state {
					case 2:
						boss.img.Y = anm[143].YT
						if boss.lr {
							boss.img.X = anm[144].X
						} else {
							boss.img.X = anm[143].X
						}
					case 1:
						boss.img.Y = anm[141].YT
						if boss.lr {
							boss.img.X = anm[142].X
						} else {
							boss.img.X = anm[141].X
						}
					case 0:
						boss.img.Y = anm[145].YT
						if boss.lr {
							boss.img.X = anm[146].X
						} else {
							boss.img.X = anm[145].X
						}
					}
				}
			case 6: //ZOMBO
				if boss.atkT2 > 0 {
					boss.atkT2--
				} else {
					zproj := xweap{}
					zproj.nm = "zomboSlime"
					zproj.below = true
					zproj.dmg = 1
					siz := b3
					cntr2 := makecnt(boss.crec)
					zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
					zproj.crec = zproj.rec
					zproj.crec.X += zproj.crec.Width / 8
					zproj.crec.Y += zproj.crec.Width / 8
					zproj.crec.Width -= zproj.crec.Width / 4
					zproj.crec.Height -= zproj.crec.Height / 4
					zproj.img = splat[RandInt(0, len(splat))]
					zproj.fd = 0.7
					projEn = append(projEn, zproj)
					boss.atkT2 = fps
				}
				if boss.atkT > 0 {
					boss.atkT--
				} else {
					zproj := xweap{}
					zproj.dmg = 2
					zproj.nm = "zomboProj"
					siz := b
					zproj.spd = 2
					xdiff := AbsDiff(boss.cnt.X, pl.cnt.X)
					ydiff := AbsDiff(boss.cnt.Y, pl.cnt.Y)
					if xdiff > ydiff {
						zproj.dirX = zproj.spd
						zproj.dirY = ydiff / (xdiff / zproj.dirX)
					} else {
						zproj.dirY = zproj.spd
						zproj.dirX = xdiff / (ydiff / zproj.dirY)
					}
					if boss.cnt.X > pl.cnt.X {
						zproj.dirX = -zproj.dirX
					}
					if boss.cnt.Y > pl.cnt.Y {
						zproj.dirY = -zproj.dirY
					}
					cntr2 := makecnt(boss.crec)
					if boss.lr {
						cntr2.X -= b
					} else {
						cntr2.X += b
					}
					zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
					zproj.crec = zproj.rec
					zproj.crec.X += zproj.crec.Width / 4
					zproj.crec.Y += zproj.crec.Height / 4
					zproj.crec.Width = zproj.crec.Width / 2
					zproj.crec.Height = zproj.crec.Height / 2
					zproj.img = anm[140].rec
					projEn = append(projEn, zproj)
					boss.atkT = fps * 2
				}
				changed := false
				if pl.cnt.X > boss.cnt.X {
					if boss.lr {
						boss.lr = false
						changed = true
					}
				} else {
					if !boss.lr {
						boss.lr = true
						changed = true
					}
				}
				if changed {
					if boss.lr {
						boss.img.X = anm[139].X
					} else {
						boss.img.X = anm[138].X
					}
				}
				if boss.moveChangeT > 0 {
					boss.moveChangeT--
					checkrec := boss.crec
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(pl.crec, checkrec) {
						boss.dirX = RandF32(-boss.spd, boss.spd)
						boss.dirY = RandF32(-boss.spd, boss.spd)
						boss.moveChangeT = fps
					} else {
						if checkRecWalls(checkrec) {
							boss.rec.X += boss.dirX
							boss.crec.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rec.Y += boss.dirY
							boss.crec.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rec)
							levels[levNum].enm[0].rec = boss.rec
							levels[levNum].enm[0].crec = boss.crec
							levels[levNum].enm[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.spd, boss.spd)
							boss.dirY = RandF32(-boss.spd, boss.spd)
							boss.moveChangeT = fps
						}
					}
				} else {
					//MOVE
					xdiff := AbsDiff(boss.cnt.X, pl.cnt.X)
					ydiff := AbsDiff(boss.cnt.Y, pl.cnt.Y)
					if xdiff > ydiff {
						boss.dirX = boss.spd
						boss.dirY = ydiff / (xdiff / boss.dirX)
					} else {
						boss.dirY = boss.spd
						boss.dirX = xdiff / (ydiff / boss.dirY)
					}
					if boss.cnt.X > pl.cnt.X {
						boss.dirX = -boss.dirX
					}
					if boss.cnt.Y > pl.cnt.Y {
						boss.dirY = -boss.dirY
					}
					checkrec := boss.crec
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(pl.crec, checkrec) {
						boss.dirX = RandF32(-boss.spd, boss.spd)
						boss.dirY = RandF32(-boss.spd, boss.spd)
						boss.moveChangeT = fps
					} else {
						if checkRecWalls(checkrec) {
							boss.rec.X += boss.dirX
							boss.crec.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rec.Y += boss.dirY
							boss.crec.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rec)
							levels[levNum].enm[0].rec = boss.rec
							levels[levNum].enm[0].crec = boss.crec
							levels[levNum].enm[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.spd, boss.spd)
							boss.dirY = RandF32(-boss.spd, boss.spd)
							boss.moveChangeT = fps
						}
					}
				}
				if frames%4 == 0 {
					if boss.lr {
						boss.img.X -= anm[139].W
						if boss.img.X < anm[139].X-anm[139].frames*anm[139].W {
							boss.img.X = anm[139].X
						}
					} else {
						boss.img.X += anm[138].W
						if boss.img.X > anm[138].X+anm[138].frames*anm[138].W {
							boss.img.X = anm[138].X
						}
					}
				}
			case 5: // PYRO PIG
				if boss.count == 3 {
					boss.count = 0
					zproj := xweap{}
					zproj.dmg = 2
					zproj.bounce = 1
					zproj.nm = "pigProj"
					siz := b2
					zproj.spd = 4
					cntr2 := makecnt(boss.crec)
					if boss.lr {
						cntr2.X -= b
					} else {
						cntr2.X += b
					}
					zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
					zproj.crec = zproj.rec
					zproj.crec.Y += zproj.crec.Height / 4
					zproj.crec.Height = zproj.crec.Height / 2
					zproj.crec.X += zproj.crec.Width / 4
					zproj.crec.Width = zproj.crec.Width / 2
					zproj.img = anm[135].rec
					zproj.dirY = -zproj.spd
					zproj.ro = 180
					projEn = append(projEn, zproj)
					zproj.ro = 0
					zproj.dirY = zproj.spd
					projEn = append(projEn, zproj)
					zproj.ro = -90
					zproj.dirY = 0
					zproj.dirX = zproj.spd
					projEn = append(projEn, zproj)
					zproj.ro = 90
					zproj.dirX = -zproj.spd
					projEn = append(projEn, zproj)
					zproj.ro = -45
					zproj.dirX = zproj.spd
					zproj.dirY = zproj.spd
					projEn = append(projEn, zproj)
					zproj.ro = -135
					zproj.dirX = zproj.spd
					zproj.dirY = -zproj.spd
					projEn = append(projEn, zproj)
					zproj.ro = 45
					zproj.dirX = -zproj.spd
					zproj.dirY = zproj.spd
					projEn = append(projEn, zproj)
					zproj.ro = 135
					zproj.dirX = -zproj.spd
					zproj.dirY = -zproj.spd
					projEn = append(projEn, zproj)
				}
				if boss.moveChangeT > 0 {
					boss.moveChangeT--
					checkrec := boss.crec
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(pl.crec, checkrec) {
						boss.dirX = RandF32(-boss.spd, boss.spd)
						boss.dirY = RandF32(-boss.spd, boss.spd)
						boss.moveChangeT = fps * 2
						boss.count++
						if pl.burnT == 0 {
							pl.burnT += fps * 3
						}
					} else {
						if checkRecWalls(checkrec) {
							boss.rec.X += boss.dirX
							boss.crec.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rec.Y += boss.dirY
							boss.crec.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rec)
							levels[levNum].enm[0].rec = boss.rec
							levels[levNum].enm[0].crec = boss.crec
							levels[levNum].enm[0].cnt = boss.cnt
						} else {
							boss.count++
							boss.dirX = RandF32(-boss.spd, boss.spd)
							boss.dirY = RandF32(-boss.spd, boss.spd)
							boss.moveChangeT = fps * 2
						}
					}
					if boss.moveChangeT == 0 {
						boss.count++
						boss.atkT = fps * 4
						boss.dirX = RandF32(-boss.spd, boss.spd)
						boss.dirY = RandF32(-boss.spd, boss.spd)
					}
				} else {
					boss.atkT--
					if boss.atkT == 0 {
						boss.moveChangeT = fps * 2
						boss.count++
					}
					//PROJ
					if boss.atkT2 > 0 {
						boss.atkT2--
					} else {
						zproj := xweap{}
						zproj.dmg = 2
						zproj.bounce = 1
						zproj.nm = "pigProj"
						siz := b2
						zproj.spd = 4
						xdiff := AbsDiff(boss.cnt.X, pl.cnt.X)
						ydiff := AbsDiff(boss.cnt.Y, pl.cnt.Y)
						if xdiff > ydiff {
							zproj.dirX = zproj.spd
							zproj.dirY = ydiff / (xdiff / zproj.dirX)
						} else {
							zproj.dirY = zproj.spd
							zproj.dirX = xdiff / (ydiff / zproj.dirY)
						}
						if boss.cnt.X > pl.cnt.X {
							zproj.dirX = -zproj.dirX
						}
						if boss.cnt.Y > pl.cnt.Y {
							zproj.dirY = -zproj.dirY
						}
						cntr2 := makecnt(boss.crec)
						if boss.lr {
							cntr2.X -= b
						} else {
							cntr2.X += b
						}
						zproj.ro = AngleBetweenTwoPoints(pl.cnt, boss.cnt) + 90
						zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.crec.Y += zproj.crec.Height / 4
						zproj.crec.Height = zproj.crec.Height / 2
						zproj.crec.X += zproj.crec.Width / 4
						zproj.crec.Width = zproj.crec.Width / 2
						zproj.img = anm[135].rec
						projEn = append(projEn, zproj)
						boss.atkT2 = fps / 10
					}
					//MOVE
					xdiff := AbsDiff(boss.cnt.X, pl.cnt.X)
					ydiff := AbsDiff(boss.cnt.Y, pl.cnt.Y)
					if xdiff > ydiff {
						boss.dirX = boss.spd
						boss.dirY = ydiff / (xdiff / boss.dirX)
					} else {
						boss.dirY = boss.spd
						boss.dirX = xdiff / (ydiff / boss.dirY)
					}
					if boss.cnt.X > pl.cnt.X {
						boss.dirX = -boss.dirX
					}
					if boss.cnt.Y > pl.cnt.Y {
						boss.dirY = -boss.dirY
					}
					checkrec := boss.crec
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(pl.crec, checkrec) {
						boss.dirX = RandF32(-boss.spd, boss.spd)
						boss.dirY = RandF32(-boss.spd, boss.spd)
						boss.moveChangeT = fps * 2
					} else {
						if checkRecWalls(checkrec) {
							boss.rec.X += boss.dirX
							boss.crec.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rec.Y += boss.dirY
							boss.crec.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rec)
							levels[levNum].enm[0].rec = boss.rec
							levels[levNum].enm[0].crec = boss.crec
							levels[levNum].enm[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.spd, boss.spd)
							boss.dirY = RandF32(-boss.spd, boss.spd)
							boss.moveChangeT = fps * 2
						}
					}
				}
				changed := false
				if pl.cnt.X > boss.cnt.X {
					if boss.lr {
						boss.lr = false
						changed = true
					}
				} else {
					if !boss.lr {
						boss.lr = true
						changed = true
					}
				}
				if changed {
					if boss.lr {
						boss.img.X = anm[134].X
					} else {
						boss.img.X = anm[133].X
					}
				}
				if frames%4 == 0 {
					if boss.lr {
						boss.img.X -= anm[134].W
						if boss.img.X < anm[134].X-anm[134].frames*anm[134].W {
							boss.img.X = anm[134].X
						}
					} else {
						boss.img.X += anm[133].W
						if boss.img.X > anm[133].X+anm[133].frames*anm[133].W {
							boss.img.X = anm[133].X
						}
					}
				}
			case 4: //SPACEMAN
				if boss.state != 2 {
					if boss.moveChangeT > 0 {
						boss.moveChangeT--
					} else {
						if boss.state == 0 {
							boss.state = 1
							if boss.lr {
								boss.img = anm[127].rec
							} else {
								boss.img = anm[126].rec
							}
							boss.moveChangeT = fps * RandInt32(2, 4)
							boss.atkT = fps / 10
						} else if boss.state == 1 {
							boss.state = 0
							boss.moveChangeT = fps * RandInt32(1, 2)
						}
					}
					if pl.cnt.X > boss.cnt.X {
						boss.lr = false
					} else {
						boss.lr = true
					}
				}
				switch boss.state {
				case 2: //HIT
					if frames%4 == 0 {
						if boss.lr {
							boss.img.X -= anm[129].W
							if boss.img.X < anm[129].X-anm[129].frames*anm[129].W {
								boss.state = 0
								boss.moveChangeT = fps * RandInt32(1, 2)
								boss.img.X = anm[125].W
							}
						} else {
							boss.img.X += anm[128].W
							if boss.img.X > anm[128].X+anm[128].frames*anm[128].W {
								boss.state = 0
								boss.moveChangeT = fps * RandInt32(1, 2)
								boss.img.X = anm[124].W
							}
						}
					}
				case 1: //ATK WALK
					xdiff := AbsDiff(boss.cnt.X, pl.cnt.X)
					ydiff := AbsDiff(boss.cnt.Y, pl.cnt.Y)
					if xdiff > ydiff {
						boss.dirX = boss.spd
						boss.dirY = ydiff / (xdiff / boss.dirX)
					} else {
						boss.dirY = boss.spd
						boss.dirX = xdiff / (ydiff / boss.dirY)
					}
					if boss.cnt.X > pl.cnt.X {
						boss.dirX = -boss.dirX
					}
					if boss.cnt.Y > pl.cnt.Y {
						boss.dirY = -boss.dirY
					}
					checkrec := boss.crec
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if boss.atkT > 0 {
						boss.atkT--
					} else {
						zproj := xweap{}
						zproj.dmg = 1
						zproj.bounce = 1
						zproj.nm = "spacemanProj"
						siz := bq3
						zproj.spd = 4
						xdiff := AbsDiff(boss.cnt.X, pl.cnt.X)
						ydiff := AbsDiff(boss.cnt.Y, pl.cnt.Y)
						if xdiff > ydiff {
							zproj.dirX = zproj.spd
							zproj.dirY = ydiff / (xdiff / zproj.dirX)
						} else {
							zproj.dirY = zproj.spd
							zproj.dirX = xdiff / (ydiff / zproj.dirY)
						}
						if boss.cnt.X > pl.cnt.X {
							zproj.dirX = -zproj.dirX
						}
						if boss.cnt.Y > pl.cnt.Y {
							zproj.dirY = -zproj.dirY
						}
						cntr2 := makecnt(boss.crec)
						if boss.lr {
							cntr2.X -= b
						} else {
							cntr2.X += b
						}
						zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.crec.Y += zproj.crec.Height / 4
						zproj.crec.Height -= zproj.crec.Height / 2
						zproj.img = anm[131].rec
						projEn = append(projEn, zproj)
						boss.atkT = fps / 10
					}
					if rl.CheckCollisionRecs(pl.crec, checkrec) {
						boss.moveChangeT = fps * RandInt32(1, 2)
					} else {
						if checkRecWalls(checkrec) {
							boss.rec.X += boss.dirX
							boss.crec.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rec.Y += boss.dirY
							boss.crec.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rec)
							levels[levNum].enm[0].rec = boss.rec
							levels[levNum].enm[0].crec = boss.crec
							levels[levNum].enm[0].cnt = boss.cnt
						} else {
							boss.moveChangeT = fps * RandInt32(1, 2)
						}
					}
					if frames%4 == 0 {
						if boss.lr {
							boss.img.X -= anm[127].W
							if boss.img.X < anm[127].X-anm[127].frames*anm[127].W {
								boss.img.X = anm[127].X
							}
						} else {
							boss.img.X += anm[126].W
							if boss.img.X > anm[126].X+anm[126].frames*anm[126].W {
								boss.img.X = anm[126].X
							}
						}
					}
				case 0: //IDLE
					if frames%5 == 0 {
						if boss.lr {
							boss.img.X -= anm[125].W
							if boss.img.X < anm[125].X-anm[125].frames*anm[125].W {
								boss.img.X = anm[125].X
							}
						} else {
							boss.img.X += anm[124].W
							if boss.img.X > anm[124].X+anm[124].frames*anm[124].W {
								boss.img.X = anm[124].X
							}
						}
					}
				}
			case 3: //SPINNA
				if boss.moveChangeT > 0 {
					boss.moveChangeT--
					if boss.moveChangeT == 1 {
						if boss.state == 0 {
							boss.state = 1
							boss.img.X = anm[120].X
						} else if boss.state == 2 {
							boss.state = 3
							boss.img.X = anm[122].X
						}
					}
				}
				switch boss.state {
				case 3: //SPIN END
					if frames%3 == 0 {
						boss.img.X += anm[122].W
						if boss.img.X > anm[122].X+anm[122].frames*anm[122].W {
							boss.state = 0
							boss.moveChangeT = fps * 2
							boss.atkT = fps / 2
						}
					}
				case 2: //SPIN
					if boss.atkT > 0 {
						boss.atkT--
					} else {
						zproj := xweap{}
						zproj.dmg = 2
						zproj.bounce = 1
						zproj.nm = "spinnaProj"
						siz := b2 + bq
						zproj.spd = 5
						xdiff := AbsDiff(boss.cnt.X, pl.cnt.X)
						ydiff := AbsDiff(boss.cnt.Y, pl.cnt.Y)
						if xdiff > ydiff {
							zproj.dirX = zproj.spd
							zproj.dirY = ydiff / (xdiff / zproj.dirX)
						} else {
							zproj.dirY = zproj.spd
							zproj.dirX = xdiff / (ydiff / zproj.dirY)
						}
						if boss.cnt.X > pl.cnt.X {
							zproj.dirX = -zproj.dirX
						}
						if boss.cnt.Y > pl.cnt.Y {
							zproj.dirY = -zproj.dirY
						}
						zproj.rec = rl.NewRectangle(boss.cnt.X-siz/2, boss.cnt.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.crec.Y += zproj.crec.Height / 4
						zproj.crec.Height -= zproj.crec.Height / 2
						zproj.img = anm[123].rec
						projEn = append(projEn, zproj)
						boss.atkT = fps / 2
					}
					boss.img.X += anm[121].W
					if boss.img.X > anm[121].X+anm[121].frames*anm[121].W {
						boss.img.X = anm[121].X
					}
					checkrec := boss.crec
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(pl.crec, checkrec) {
						boss.dirX = RandF32(-boss.spd/2, boss.spd/2)
						boss.dirY *= -1
					} else {
						if checkRecWalls(checkrec) {
							boss.rec.X += boss.dirX
							boss.crec.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rec.Y += boss.dirY
							boss.crec.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rec)
							levels[levNum].enm[0].rec = boss.rec
							levels[levNum].enm[0].crec = boss.crec
							levels[levNum].enm[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.spd/2, boss.spd/2)
							boss.dirY *= -1
						}
					}
				case 1: //SPIN START
					if frames%3 == 0 {
						boss.img.X += anm[121].W
						if boss.img.X > anm[121].X+anm[121].frames*anm[121].W {
							boss.state = 2
							boss.moveChangeT = fps * 5
							boss.dirY = boss.spd
							if pl.cnt.Y < boss.cnt.Y {
								boss.dirY = -boss.spd
								spdX := RandF32(boss.spd/3, boss.spd)
								if pl.cnt.X < boss.cnt.X {
									spdX *= -1
								}
								boss.dirX = spdX
							}
						}
					}
				case 0: //IDLE
					if frames%5 == 0 {
						if boss.lr {
							boss.img.X -= anm[119].W
							if boss.img.X < anm[119].X-anm[119].frames*anm[119].W {
								boss.img.X = anm[119].X
							}
						} else {
							boss.img.X += anm[118].W
							if boss.img.X > anm[118].X+anm[118].frames*anm[118].W {
								boss.img.X = anm[118].X
							}
						}
					}
				}
				if pl.cnt.X > boss.cnt.X {
					boss.lr = false
				} else {
					boss.lr = true
				}
			case 2: //MR FRISBEE
				if rl.CheckCollisionRecs(pl.crec, boss.carec) && pl.enCollisT == 0 {
					pl.enCollisT = fps / 2
					if pl.hpT == 0 {
						hitPL(1)
					}
					zfx := xfx{}
					zfx.img = anm[117].rec
					zfx.rec = boss.carec
					zfx.nm = "mrfrisbeenear"
					zfx.below = true
					fx = append(fx, zfx)
				}
				if pl.cnt.X > boss.cnt.X {
					boss.dirX = boss.spd
				} else {
					boss.dirX = -boss.spd
				}
				if pl.cnt.Y > boss.cnt.Y {
					boss.dirY = boss.spd / 3
				} else {
					boss.dirY = -boss.spd / 3
				}
				if boss.atkT > 0 {
					boss.img.Y = anm[114].YT
					boss.state = 2
					boss.atkT--
					if boss.atkT2 > 0 {
						boss.atkT2--
						if boss.atkT2 == 0 {
							zproj := xweap{}
							zproj.nm = "mrfrisbeeProj"
							zproj.img = anm[116].rec
							zproj.dmg = 2
							zproj.bounce = 12
							zproj.spd = 8
							siz := b
							zproj.rec = rl.NewRectangle(boss.cnt.X-siz/2, boss.cnt.Y-siz/2, siz, siz)
							zproj.crec = zproj.rec
							zproj.WOrig = zproj.rec.Width
							if pl.cnt.X > boss.cnt.X {
								zproj.dirX = zproj.spd
							} else {
								zproj.dirX = -zproj.spd
							}
							if pl.cnt.Y > boss.cnt.Y {
								zproj.dirY = zproj.spd / 4
							} else {
								zproj.dirY = -zproj.spd / 4
							}
							zproj.fd = 1
							zproj.col = rl.White
							projEn = append(projEn, zproj)
							if Roll6() > 4 {
								zproj.dirY = zproj.spd
								if FlipCoin() {
									if FlipCoin() {
										zproj.dirX = zproj.spd / 4
									} else {
										zproj.dirX -= zproj.spd / 4
									}
								}
								projEn = append(projEn, zproj)
							}
							if Roll6() > 4 {
								zproj.dirY = -zproj.spd
								if FlipCoin() {
									if FlipCoin() {
										zproj.dirX = zproj.spd / 4
									} else {
										zproj.dirX -= zproj.spd / 4
									}
								}
								projEn = append(projEn, zproj)
							}
							boss.atkT2 = fps / RandInt32(2, 3)
						}
					}
					if boss.atkT == 1 {
						if FlipCoin() {
							boss.idlT = fps * RandInt32(1, 3)
						} else {
							boss.walkT = fps * RandInt32(1, 3)
							countbreak := 100
							for {
								boss.dirX = RandF32(-boss.spd, boss.spd)
								if Abs(boss.dirX) > boss.spd/3 {
									break
								}
								countbreak--
								if countbreak == 0 {
									break
								}
							}
							boss.dirY = RandF32(-boss.spd/3, boss.spd/3)
						}
						boss.atkT = 0
					}
				}
				if boss.idlT > 0 {
					boss.img.Y = anm[110].YT
					boss.state = 0
					boss.idlT--
					if boss.idlT == 1 {
						if FlipCoin() {
							boss.atkT = fps * RandInt32(2, 4)
							boss.atkT2 = fps / RandInt32(2, 3)
						} else {
							boss.walkT = fps * RandInt32(1, 3)
							countbreak := 100
							for {
								boss.dirX = RandF32(-boss.spd, boss.spd)
								if Abs(boss.dirX) > boss.spd/3 {
									break
								}
								countbreak--
								if countbreak == 0 {
									break
								}
							}
							boss.dirY = RandF32(-boss.spd/3, boss.spd/3)
						}
						boss.idlT = 0
					}
				}
				if boss.walkT > 0 {
					boss.img.Y = anm[112].YT
					boss.state = 1
					boss.walkT--
					if boss.walkT == 1 {
						if FlipCoin() {
							boss.atkT = fps * RandInt32(2, 4)
							boss.atkT2 = fps / RandInt32(2, 3)
						} else {
							boss.idlT = fps * RandInt32(1, 3)
						}
						boss.walkT = 0
					}
				}
				if boss.dirX > 0 {
					boss.lr = false
				} else {
					boss.lr = true
				}
				switch boss.state {
				case 2: //ATK
					if frames%3 == 0 {
						if boss.lr {
							boss.img.X -= anm[115].W
							if boss.img.X < anm[115].X-anm[115].frames*anm[115].W {
								boss.img.X = anm[115].X
							}
						} else {
							boss.img.X += anm[114].W
							if boss.img.X > anm[114].X+anm[114].frames*anm[114].W {
								boss.img.X = anm[114].X
							}
						}
					}
				case 1: // WALK
					if frames%3 == 0 {
						if boss.lr {
							boss.img.X -= anm[113].W
							if boss.img.X < anm[113].X-anm[113].frames*anm[113].W {
								boss.img.X = anm[113].X
							}
						} else {
							boss.img.X += anm[112].W
							if boss.img.X > anm[112].X+anm[112].frames*anm[112].W {
								boss.img.X = anm[112].X
							}
						}
					}
					checkrec := boss.crec
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(pl.crec, checkrec) {
						boss.idlT = fps
						boss.walkT = 0
					} else {
						if checkRecWalls(checkrec) {
							boss.rec.X += boss.dirX
							boss.crec.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rec.Y += boss.dirY
							boss.crec.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rec)
							levels[levNum].enm[0].rec = boss.rec
							levels[levNum].enm[0].crec = boss.crec
							levels[levNum].enm[0].cnt = boss.cnt
						} else {
							boss.idlT = fps
							boss.walkT = 0
						}
					}
				case 0: //IDLE
					if frames%3 == 0 {
						if boss.lr {
							boss.img.X -= anm[111].W
							if boss.img.X < anm[111].X-anm[111].frames*anm[111].W {
								boss.img.X = anm[111].X
							}
						} else {
							boss.img.X += anm[110].W
							if boss.img.X > anm[110].X+anm[110].frames*anm[110].W {
								boss.img.X = anm[110].X
							}
						}
					}
				}
			case 1: //ICEMAN
				//TIMERS
				if boss.idlT > 0 {
					boss.state = 0
					boss.idlT--
					if boss.idlT == 1 {
						boss.onoff = false
						if FlipCoin() {
							boss.dirX = RandF32(-boss.spd, boss.spd)
							boss.walkT = fps * RandInt32(1, 2)
							boss.ud = FlipCoin()
						} else {
							boss.atkT = fps * 2
						}
						boss.idlT = 0
					}
					if !boss.onoff {
						zfx := xfx{}
						zfx.img = anm[109].rec
						zfx.rec = boss.rec
						zfx.rec.X -= b
						zfx.rec.Y -= b
						zfx.rec.Width += b2
						zfx.rec.Height += b2
						zfx.crec = zfx.rec
						zfx.crec.X += b
						zfx.crec.Y += b
						zfx.crec.Width -= b2
						zfx.crec.Height -= b2
						zfx.nm = "icemanchange"
						fx = append(fx, zfx)
						boss.onoff = true
					}
				}
				if boss.atkT > 0 {
					if boss.atkT2 > 0 {
						boss.atkT2--
					} else {
						siz := b
						zproj := xweap{}
						zproj.rec = rl.NewRectangle(boss.cnt.X-siz/2, boss.cnt.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.crec.X += zproj.rec.Width / 4
						zproj.crec.Width = zproj.crec.Width / 2
						zproj.img = etc[148]
						zproj.dirY = 6
						zproj.dmg = 2
						zproj.cnt = makecnt(zproj.rec)
						zproj.fd = 1
						zproj.col = rl.White
						zproj.nm = "icemanProj"
						projEn = append(projEn, zproj)
						zproj.dirX = zproj.dirY / 4
						zproj.ro = -15
						projEn = append(projEn, zproj)
						zproj.dirX = -zproj.dirY / 4
						zproj.ro = 15
						projEn = append(projEn, zproj)
						zproj.dirX = -zproj.dirY / 2
						zproj.ro = 30
						projEn = append(projEn, zproj)
						zproj.dirX = -zproj.dirY / 1.3
						zproj.ro = 45
						projEn = append(projEn, zproj)
						zproj.dirX = zproj.dirY / 2
						zproj.ro = -30
						projEn = append(projEn, zproj)
						zproj.dirX = zproj.dirY / 1.3
						zproj.ro = -45
						projEn = append(projEn, zproj)
						zproj.dirY = -4
						zproj.dirX = 0
						zproj.ro = -180
						projEn = append(projEn, zproj)
						zproj.dirX = zproj.dirY / 4
						zproj.ro = -195
						projEn = append(projEn, zproj)
						zproj.dirX = -zproj.dirY / 4
						zproj.ro = 195
						projEn = append(projEn, zproj)
						zproj.dirX = -zproj.dirY / 2
						zproj.ro = 210
						projEn = append(projEn, zproj)
						zproj.dirX = -zproj.dirY / 1.3
						zproj.ro = 235
						projEn = append(projEn, zproj)
						zproj.dirX = zproj.dirY / 2
						zproj.ro = -210
						projEn = append(projEn, zproj)
						zproj.dirX = zproj.dirY / 1.3
						zproj.ro = -235
						projEn = append(projEn, zproj)
						zproj.dirX = -4
						zproj.dirY = 0
						zproj.ro = 90
						projEn = append(projEn, zproj)
						zproj.dirY = zproj.dirX / 4
						zproj.ro = 105
						projEn = append(projEn, zproj)
						zproj.dirY = -zproj.dirX / 4
						zproj.ro = 75
						projEn = append(projEn, zproj)
						if Roll12() > 9 {
							zproj.dirY = zproj.dirX / 2
							zproj.ro = 120
							projEn = append(projEn, zproj)
							zproj.dirY = -zproj.dirX / 2
							zproj.ro = 60
							projEn = append(projEn, zproj)
						}
						zproj.dirX = 4
						zproj.dirY = 0
						zproj.ro = -90
						projEn = append(projEn, zproj)
						zproj.dirY = zproj.dirX / 4
						zproj.ro = -75
						projEn = append(projEn, zproj)
						zproj.dirY = -zproj.dirX / 4
						zproj.ro = -105
						projEn = append(projEn, zproj)
						if Roll12() > 9 {
							zproj.dirY = zproj.dirX / 2
							zproj.ro = -60
							projEn = append(projEn, zproj)
							zproj.dirY = -zproj.dirX / 2
							zproj.ro = -120
							projEn = append(projEn, zproj)
						}
						boss.atkT2 = fps / 2
					}
					boss.state = 1
					boss.atkT--
					if boss.atkT == 1 {
						boss.onoff = false
						if FlipCoin() {
							boss.dirX = RandF32(-boss.spd, boss.spd)
							boss.walkT = fps * RandInt32(1, 2)
							boss.ud = FlipCoin()
						} else {
							boss.idlT = fps
						}
						boss.atkT = 0
					}
					if !boss.onoff {
						zfx := xfx{}
						zfx.img = anm[109].rec
						zfx.rec = boss.rec
						zfx.rec.X -= b
						zfx.rec.Y -= b
						zfx.rec.Width += b2
						zfx.rec.Height += b2
						zfx.crec = zfx.rec
						zfx.crec.X += b
						zfx.crec.Y += b
						zfx.crec.Width -= b2
						zfx.crec.Height -= b2
						zfx.nm = "icemanchange"
						fx = append(fx, zfx)
						boss.onoff = true
					}
				}
				if boss.walkT > 0 {
					checkrec := boss.crec
					checkrec.X += boss.dirX
					if boss.ud {
						checkrec.Y += 1
					} else {
						checkrec.Y -= 1
					}
					// ADD BOSS MOVE PLAYER COLLIS
					if rl.CheckCollisionRecs(pl.crec, checkrec) {
						boss.idlT = fps
						boss.walkT = 0
					} else {
						if checkRecWalls(checkrec) {
							boss.rec.X += boss.dirX
							boss.crec.X += boss.dirX
							if boss.ud {
								boss.rec.Y += 0.5
								boss.crec.Y += 0.5
							} else {
								boss.rec.Y -= 0.5
								boss.crec.Y -= 0.5
							}
							boss.cnt = makecnt(boss.rec)
							levels[levNum].enm[0].rec = boss.rec
							levels[levNum].enm[0].crec = boss.crec
							levels[levNum].enm[0].cnt = boss.cnt
						} else {
							boss.idlT = fps
							boss.walkT = 0
						}
					}
					if boss.dirX > 0 {
						boss.lr = true
						boss.state = 2
					} else {
						boss.lr = false
						boss.state = 3
					}
					boss.walkT--
					if boss.walkT == 1 {
						boss.onoff = false
						boss.dirX = 0
						if FlipCoin() {
							boss.atkT = fps * 2
						} else {
							boss.idlT = fps
						}
						boss.walkT = 0
					}
					if !boss.onoff {
						zfx := xfx{}
						zfx.img = anm[109].rec
						zfx.rec = boss.rec
						zfx.rec.X -= b
						zfx.rec.Y -= b
						zfx.crec.X += b
						zfx.crec.Y += b
						zfx.crec.Width -= b2
						zfx.crec.Height -= b2
						zfx.nm = "icemanchange"
						fx = append(fx, zfx)
						boss.onoff = true
					}
				}
				switch boss.state {
				case 3: //WALK L
					if frames%2 == 0 {
						boss.img.X += boss.walkL.W
						if boss.img.X > boss.walkL.X+boss.walkL.frames*boss.walkL.W {
							boss.img.X = boss.walkL.X
						}
					}
				case 2: //WALK R
					if frames%2 == 0 {
						boss.img.X += boss.walkR.W
						if boss.img.X > boss.walkR.X+boss.walkR.frames*boss.walkR.W {
							boss.img.X = boss.walkR.X
						}
					}
				case 1: //ATK
					if frames%2 == 0 {
						boss.img.X += boss.atk.W
						if boss.img.X > boss.atk.X+boss.atk.frames*boss.atk.W {
							boss.img.X = boss.atk.X
						}
					}
				case 0: //IDLE
					if frames%2 == 0 {
						boss.img.X += boss.idlA.W
						if boss.img.X > boss.idlA.X+boss.idlA.frames*boss.idlA.W {
							boss.img.X = boss.idlA.X
						}
					}
				}
			}

		} else {
			if !levels[levNum].enm[0].off {
				switch bossnum {
				case 9: //ROLLO
					siz := b6
					zfx := xfx{}
					zfx.nm = "rollodthfx"
					zfx.img = anm[197].rec
					zfx.cnt = levels[levNum].enm[0].cnt
					zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
					fx = append(fx, zfx)
				case 8: //MUSHEE
					siz := b7
					zfx := xfx{}
					zfx.nm = "musheedthfx"
					zfx.img = anm[196].rec
					zfx.cnt = levels[levNum].enm[0].cnt
					zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
					fx = append(fx, zfx)
				case 7: //BATTY
					siz := b7
					zfx := xfx{}
					zfx.nm = "battydthfx"
					zfx.img = anm[195].rec
					zfx.cnt = levels[levNum].enm[0].cnt
					zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
					fx = append(fx, zfx)
				case 6: //ZOMBO
					siz := b7
					zfx := xfx{}
					zfx.nm = "zombodthfx"
					zfx.img = anm[194].rec
					zfx.cnt = levels[levNum].enm[0].cnt
					zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
					fx = append(fx, zfx)
				case 5: //PYRO PIG
					siz := b9
					zfx := xfx{}
					zfx.nm = "pyrodthfx"
					zfx.img = anm[193].rec
					zfx.cnt = levels[levNum].enm[0].cnt
					zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
					fx = append(fx, zfx)
				case 4: //SPZMAN
					siz := b7
					zfx := xfx{}
					zfx.nm = "spzmandthfx"
					zfx.img = anm[192].rec
					zfx.cnt = levels[levNum].enm[0].cnt
					zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
					fx = append(fx, zfx)
				case 3: //SPINNA
					siz := b7
					zfx := xfx{}
					zfx.nm = "spinnadthfx"
					zfx.img = anm[191].rec
					zfx.cnt = levels[levNum].enm[0].cnt
					zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
					fx = append(fx, zfx)
				case 2: //MR FRISBEE
					siz := b9
					zfx := xfx{}
					zfx.nm = "frisbeedthfx"
					zfx.img = anm[190].rec
					zfx.cnt = levels[levNum].enm[0].cnt
					zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
					fx = append(fx, zfx)
				case 1: //ICEMAN
					siz := b7
					zfx := xfx{}
					zfx.nm = "icedthfx"
					zfx.img = anm[189].rec
					zfx.cnt = levels[levNum].enm[0].cnt
					zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
					fx = append(fx, zfx)

				}
				pl.xp += levels[levNum].enm[0].xp
				pl.hp = pl.hpmax
				pl.mana = pl.manamax

				rl.StopMusicStream(music[currentMusic])
				currentMusic = 3
				switch dispMusic {
				case 0:
					prevMusic = RandInt(4, len(music))
				case 1:
					prevMusic = 4
				case 2:
					prevMusic = 5
				case 3:
					prevMusic = 6
				}
				if !rl.IsSoundPlaying(audfx[122]) {
					rl.PlaySound(audfx[122])
				}
				rl.PlayMusicStream(music[currentMusic])

				//MAKE EXIT
				siz := b
				ztile := xtile{}
				cntr := makecnt(levels[levNum].recs[0])
				ztile.rec = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
				ztile.nm = "stairs"
				ztile.img = etc[147]
				levels[levNum].etc = append(levels[levNum].etc, ztile)

				//MAKE CHEST
				siz = b2
				zchst := xchst{}
				zchst.slots = 5
				for i := 0; i < zchst.slots; i++ {
					zchst.itm = append(zchst.itm, xitm{})
				}
				switch bossnum {
				case 1: //ICEMAN
					zchst.itm[0] = itmlist[122]
				case 2: //MR FRISBEE
					zchst.itm[0] = itmlist[123]
				case 3: //SPINNA
					zchst.itm[0] = itmlist[124]
				case 4: //SPZMAN
					zchst.itm[0] = itmlist[125]
				case 5: //PYRO PIG
					zchst.itm[0] = itmlist[126]
				case 6: //ZOMBO
					zchst.itm[0] = itmlist[127]
				case 7: //BATTY
					zchst.itm[0] = itmlist[128]
				case 8: //MUSHEE
					zchst.itm[0] = itmlist[129]
				case 9: //ROLLO
					zchst.itm[0] = itmlist[130]
				}

				zchst.itm[1] = itmlist[83] //PEARL

				if FlipCoin() { //GOLD
					zchst.itm[2] = itmlist[38]
					zchst.itm[2].numof = 100
				} else { //PLATINUM
					zchst.itm[2] = itmlist[42]
					zchst.itm[2].numof = 100
				}
				if FlipCoin() { //WEAPON CASE
					zchst.itm[3] = itmlist[120]
				} else { //BACKPACK
					zchst.itm[3] = itmlist[31]
				}

				choose2 := RandInt(0, 10)
				switch choose2 {
				case 0:
					zchst.itm[4] = itmlist[82]
				case 1:
					zchst.itm[4] = itmlist[85]
				case 2:
					zchst.itm[4] = itmlist[70]
				case 3:
					zchst.itm[4] = itmlist[72]
				case 4:
					zchst.itm[4] = itmlist[35]
				case 5:
					zchst.itm[4] = itmlist[36]
				case 6:
					zchst.itm[4] = itmlist[69]
				case 7:
					zchst.itm[4] = itmlist[52]
				case 8:
					zchst.itm[4] = itmlist[68]
				case 9:
					zchst.itm[4] = itmlist[67]
				}

				zchst.itm[0].noChestMove = true
				zchst.itm[1].noChestMove = true
				zchst.itm[2].noChestMove = true
				zchst.itm[3].noChestMove = true
				zchst.itm[4].noChestMove = true

				zchst.img = anm[4].rec
				zchst.cnt = cnt
				zchst.cnt.Y += b2
				zchst.rec = rl.NewRectangle(zchst.cnt.X-siz/2, zchst.cnt.Y-siz/2, siz, siz)
				zchst.cnt = makecnt(zchst.rec)
				zchst.crec = zchst.rec
				zchst.crec.X += zchst.crec.Width / 4
				zchst.crec.Y += zchst.crec.Height / 2
				zchst.crec.Y -= 4
				zchst.crec.Width = zchst.crec.Width / 2
				zchst.crec.Height = (zchst.crec.Height / 9) * 4
				levels[levNum].chst = append(levels[levNum].chst, zchst)
				bosskillist = append(bosskillist, bossnum)
				levels[levNum].enm[0].off = true
				Remove(4)
			}

			//UP BOSS KEYS
			if !bossKeyChanged {
				if !bosskey1 {
					bosskey1 = true
					for i := 0; i < len(base.nm); i++ {
						if base.nm[i] == "boss key 1" && !base.unlock[i] {
							base.unlock[i] = true
						}
					}
				} else if !bosskey2 {
					bosskey2 = true
					for i := 0; i < len(base.nm); i++ {
						if base.nm[i] == "boss key 2" && !base.unlock[i] {
							base.unlock[i] = true
						}
					}
				} else if !bosskey3 {
					bosskey3 = true
					for i := 0; i < len(base.nm); i++ {
						if base.nm[i] == "boss key 3" && !base.unlock[i] {
							base.unlock[i] = true
						}
					}

					pause = true
					bosson = false
					endgame = true
				}
				bossKeyChanged = true
			}

		}
	}
}
func upWeapon(num, newlev int) { //MARK:UPGRADE WEAPON

	ore := 0
	switch num {
	case 0:
		pl.wp1.level = newlev
		switch pl.wp1.level {
		case 2:
			pl.wp1.dmg = pl.wp1.origDMG + 1
			weapUpgTXT = "+1 dmg"
		case 3:
			pl.wp1.dmg = pl.wp1.origDMG + 2
			weapUpgTXT = "+2 dmg"
		case 4:
			pl.wp1.dmg = pl.wp1.origDMG + 3
			weapUpgTXT = "+3 dmg"
		case 5:
			pl.wp1.dmg = pl.wp1.origDMG + 3
			pl.wp1.spec1 = RandInt(1, 12)
			switch pl.wp1.spec1 {
			case 1:
				weapUpgTXT = "+3 dmg +chain lightning"
			case 2:
				weapUpgTXT = "+3 dmg +arrow wall"
			case 3:
				weapUpgTXT = "+3 dmg +crate fireworks"
			case 4:
				weapUpgTXT = "+3 dmg +turret drop"
			case 5:
				weapUpgTXT = "+3 dmg +bomb drop"
			case 6:
				weapUpgTXT = "+3 dmg +rocket"
			case 7:
				weapUpgTXT = "+3 dmg +attack speed"
			case 8:
				weapUpgTXT = "+3 dmg +potion drop"
			case 9:
				weapUpgTXT = "+3 dmg +double xp"
			case 10:
				weapUpgTXT = "+3 dmg +ring of fire"
			case 11:
				weapUpgTXT = "+3 dmg +slude geysers"
			}

		case 6:
			pl.wp1.dmg = pl.wp1.origDMG + 3
			if pl.wp1.spec1 == 0 {
				pl.wp1.spec1 = RandInt(1, 12)
			}
			for {
				pl.wp1.spec2 = RandInt(1, 12)
				if pl.wp1.spec2 != pl.wp1.spec1 {
					break
				}
			}
			switch pl.wp1.spec1 {
			case 1:
				weapUpgTXT = "+3 dmg +chain lightning"
			case 2:
				weapUpgTXT = "+3 dmg +arrow wall"
			case 3:
				weapUpgTXT = "+3 dmg +crate fireworks"
			case 4:
				weapUpgTXT = "+3 dmg +turret drop"
			case 5:
				weapUpgTXT = "+3 dmg +bomb drop"
			case 6:
				weapUpgTXT = "+3 dmg +rocket"
			case 7:
				weapUpgTXT = "+3 dmg +attack speed"
			case 8:
				weapUpgTXT = "+3 dmg +potion drop"
			case 9:
				weapUpgTXT = "+3 dmg +double xp"
			case 10:
				weapUpgTXT = "+3 dmg +ring of fire"
			case 11:
				weapUpgTXT = "+3 dmg +slude geysers"
			}
			switch pl.wp1.spec2 {
			case 1:
				weapUpgTXT = weapUpgTXT + " +chain lightning"
			case 2:
				weapUpgTXT = weapUpgTXT + " +arrow wall"
			case 3:
				weapUpgTXT = weapUpgTXT + " +crate fireworks"
			case 4:
				weapUpgTXT = weapUpgTXT + " +turret drop"
			case 5:
				weapUpgTXT = weapUpgTXT + " +bomb drop"
			case 6:
				weapUpgTXT = weapUpgTXT + " +rocket"
			case 7:
				weapUpgTXT = weapUpgTXT + " +attack speed"
			case 8:
				weapUpgTXT = weapUpgTXT + " +potion drop"
			case 9:
				weapUpgTXT = weapUpgTXT + " +double xp"
			case 10:
				weapUpgTXT = weapUpgTXT + " +ring of fire"
			case 11:
				weapUpgTXT = weapUpgTXT + " +slude geysers"
			}
		}
	case 1:
		pl.wp2.level = newlev
		switch pl.wp2.level {
		case 2:
			pl.wp2.dmg = pl.wp2.origDMG + 1
			weapUpgTXT = "+1 dmg"
		case 3:
			pl.wp2.dmg = pl.wp2.origDMG + 2
			weapUpgTXT = "+2 dmg"
		case 4:
			pl.wp2.dmg = pl.wp2.origDMG + 3
			weapUpgTXT = "+3 dmg"
		case 5:
			pl.wp2.dmg = pl.wp2.origDMG + 3
			pl.wp2.spec1 = RandInt(1, 12)
			switch pl.wp2.spec1 {
			case 1:
				weapUpgTXT = "+3 dmg +chain lightning"
			case 2:
				weapUpgTXT = "+3 dmg +arrow wall"
			case 3:
				weapUpgTXT = "+3 dmg +crate fireworks"
			case 4:
				weapUpgTXT = "+3 dmg +turret drop"
			case 5:
				weapUpgTXT = "+3 dmg +bomb drop"
			case 6:
				weapUpgTXT = "+3 dmg +rocket"
			case 7:
				weapUpgTXT = "+3 dmg +attack speed"
			case 8:
				weapUpgTXT = "+3 dmg +potion drop"
			case 9:
				weapUpgTXT = "+3 dmg +double xp"
			case 10:
				weapUpgTXT = "+3 dmg +ring of fire"
			case 11:
				weapUpgTXT = "+3 dmg +slude geysers"
			}
		case 6:
			pl.wp2.dmg = pl.wp2.origDMG + 3
			if pl.wp2.spec1 == 0 {
				pl.wp2.spec1 = RandInt(1, 12)
			}
			for {
				pl.wp2.spec2 = RandInt(1, 12)
				if pl.wp2.spec2 != pl.wp2.spec1 {
					break
				}
			}
			switch pl.wp2.spec1 {
			case 1:
				weapUpgTXT = "+3 dmg +chain lightning"
			case 2:
				weapUpgTXT = "+3 dmg +arrow wall"
			case 3:
				weapUpgTXT = "+3 dmg +crate fireworks"
			case 4:
				weapUpgTXT = "+3 dmg +turret drop"
			case 5:
				weapUpgTXT = "+3 dmg +bomb drop"
			case 6:
				weapUpgTXT = "+3 dmg +rocket"
			case 7:
				weapUpgTXT = "+3 dmg +attack speed"
			case 8:
				weapUpgTXT = "+3 dmg +potion drop"
			case 9:
				weapUpgTXT = "+3 dmg +double xp"
			case 10:
				weapUpgTXT = "+3 dmg +ring of fire"
			case 11:
				weapUpgTXT = "+3 dmg +slude geysers"
			}
			switch pl.wp2.spec2 {
			case 1:
				weapUpgTXT = weapUpgTXT + " +chain lightning"
			case 2:
				weapUpgTXT = weapUpgTXT + " +arrow wall"
			case 3:
				weapUpgTXT = weapUpgTXT + " +crate fireworks"
			case 4:
				weapUpgTXT = weapUpgTXT + " +turret drop"
			case 5:
				weapUpgTXT = weapUpgTXT + " +bomb drop"
			case 6:
				weapUpgTXT = weapUpgTXT + " +rocket"
			case 7:
				weapUpgTXT = weapUpgTXT + " +attack speed"
			case 8:
				weapUpgTXT = weapUpgTXT + " +potion drop"
			case 9:
				weapUpgTXT = weapUpgTXT + " +double xp"
			case 10:
				weapUpgTXT = weapUpgTXT + " +ring of fire"
			case 11:
				weapUpgTXT = weapUpgTXT + " +slude geysers"
			}

		}
	case 2:
		pl.weaps[0].level = newlev
		switch pl.weaps[0].level {
		case 2:
			pl.weaps[0].dmg = pl.weaps[0].origDMG + 1
			weapUpgTXT = "+1 dmg"
		case 3:
			pl.weaps[0].dmg = pl.weaps[0].origDMG + 2
			weapUpgTXT = "+2 dmg"
		case 4:
			pl.weaps[0].dmg = pl.weaps[0].origDMG + 3
			weapUpgTXT = "+3 dmg"
		case 5:
			pl.weaps[0].dmg = pl.weaps[0].origDMG + 3
			pl.weaps[0].spec1 = RandInt(1, 12)

			switch pl.weaps[0].spec1 {
			case 1:
				weapUpgTXT = "+3 dmg +chain lightning"
			case 2:
				weapUpgTXT = "+3 dmg +arrow wall"
			case 3:
				weapUpgTXT = "+3 dmg +crate fireworks"
			case 4:
				weapUpgTXT = "+3 dmg +turret drop"
			case 5:
				weapUpgTXT = "+3 dmg +bomb drop"
			case 6:
				weapUpgTXT = "+3 dmg +rocket"
			case 7:
				weapUpgTXT = "+3 dmg +attack speed"
			case 8:
				weapUpgTXT = "+3 dmg +potion drop"
			case 9:
				weapUpgTXT = "+3 dmg +double xp"
			case 10:
				weapUpgTXT = "+3 dmg +ring of fire"
			case 11:
				weapUpgTXT = "+3 dmg +slude geysers"
			}
		case 6:
			pl.weaps[0].dmg = pl.weaps[0].origDMG + 3
			if pl.weaps[0].spec1 == 0 {
				pl.weaps[0].spec1 = RandInt(1, 12)
			}
			for {
				pl.weaps[0].spec2 = RandInt(1, 12)
				if pl.weaps[0].spec2 != pl.weaps[0].spec1 {
					break
				}
			}

			switch pl.weaps[0].spec1 {
			case 1:
				weapUpgTXT = "+3 dmg +chain lightning"
			case 2:
				weapUpgTXT = "+3 dmg +arrow wall"
			case 3:
				weapUpgTXT = "+3 dmg +crate fireworks"
			case 4:
				weapUpgTXT = "+3 dmg +turret drop"
			case 5:
				weapUpgTXT = "+3 dmg +bomb drop"
			case 6:
				weapUpgTXT = "+3 dmg +rocket"
			case 7:
				weapUpgTXT = "+3 dmg +attack speed"
			case 8:
				weapUpgTXT = "+3 dmg +potion drop"
			case 9:
				weapUpgTXT = "+3 dmg +double xp"
			case 10:
				weapUpgTXT = "+3 dmg +ring of fire"
			case 11:
				weapUpgTXT = "+3 dmg +slude geysers"
			}
			switch pl.weaps[0].spec2 {
			case 1:
				weapUpgTXT = weapUpgTXT + " +chain lightning"
			case 2:
				weapUpgTXT = weapUpgTXT + " +arrow wall"
			case 3:
				weapUpgTXT = weapUpgTXT + " +crate fireworks"
			case 4:
				weapUpgTXT = weapUpgTXT + " +turret drop"
			case 5:
				weapUpgTXT = weapUpgTXT + " +bomb drop"
			case 6:
				weapUpgTXT = weapUpgTXT + " +rocket"
			case 7:
				weapUpgTXT = weapUpgTXT + " +attack speed"
			case 8:
				weapUpgTXT = weapUpgTXT + " +potion drop"
			case 9:
				weapUpgTXT = weapUpgTXT + " +double xp"
			case 10:
				weapUpgTXT = weapUpgTXT + " +ring of fire"
			case 11:
				weapUpgTXT = weapUpgTXT + " +slude geysers"
			}
		}
	case 3:
		pl.weaps[1].level = newlev
		switch pl.weaps[1].level {
		case 2:
			pl.weaps[1].dmg = pl.weaps[1].origDMG + 1
			weapUpgTXT = "+1 dmg"
		case 3:
			pl.weaps[1].dmg = pl.weaps[1].origDMG + 2
			weapUpgTXT = "+2 dmg"
		case 4:
			pl.weaps[1].dmg = pl.weaps[1].origDMG + 3
			weapUpgTXT = "+3 dmg"
		case 5:
			pl.weaps[1].dmg = pl.weaps[1].origDMG + 3
			pl.weaps[1].spec1 = RandInt(1, 12)
			switch pl.weaps[1].spec1 {
			case 1:
				weapUpgTXT = "+3 dmg +chain lightning"
			case 2:
				weapUpgTXT = "+3 dmg +arrow wall"
			case 3:
				weapUpgTXT = "+3 dmg +crate fireworks"
			case 4:
				weapUpgTXT = "+3 dmg +turret drop"
			case 5:
				weapUpgTXT = "+3 dmg +bomb drop"
			case 6:
				weapUpgTXT = "+3 dmg +rocket"
			case 7:
				weapUpgTXT = "+3 dmg +attack speed"
			case 8:
				weapUpgTXT = "+3 dmg +potion drop"
			case 9:
				weapUpgTXT = "+3 dmg +double xp"
			case 10:
				weapUpgTXT = "+3 dmg +ring of fire"
			case 11:
				weapUpgTXT = "+3 dmg +slude geysers"
			}
		case 6:
			pl.weaps[1].dmg = pl.weaps[1].origDMG + 3
			if pl.weaps[1].spec1 == 0 {
				pl.weaps[1].spec1 = RandInt(1, 12)
			}
			for {
				pl.weaps[1].spec2 = RandInt(1, 12)
				if pl.weaps[1].spec2 != pl.weaps[1].spec1 {
					break
				}
			}

			switch pl.weaps[1].spec1 {
			case 1:
				weapUpgTXT = "+3 dmg +chain lightning"
			case 2:
				weapUpgTXT = "+3 dmg +arrow wall"
			case 3:
				weapUpgTXT = "+3 dmg +crate fireworks"
			case 4:
				weapUpgTXT = "+3 dmg +turret drop"
			case 5:
				weapUpgTXT = "+3 dmg +bomb drop"
			case 6:
				weapUpgTXT = "+3 dmg +rocket"
			case 7:
				weapUpgTXT = "+3 dmg +attack speed"
			case 8:
				weapUpgTXT = "+3 dmg +potion drop"
			case 9:
				weapUpgTXT = "+3 dmg +double xp"
			case 10:
				weapUpgTXT = "+3 dmg +ring of fire"
			case 11:
				weapUpgTXT = "+3 dmg +slude geysers"
			}
			switch pl.weaps[1].spec2 {
			case 1:
				weapUpgTXT = weapUpgTXT + " +chain lightning"
			case 2:
				weapUpgTXT = weapUpgTXT + " +arrow wall"
			case 3:
				weapUpgTXT = weapUpgTXT + " +crate fireworks"
			case 4:
				weapUpgTXT = weapUpgTXT + " +turret drop"
			case 5:
				weapUpgTXT = weapUpgTXT + " +bomb drop"
			case 6:
				weapUpgTXT = weapUpgTXT + " +rocket"
			case 7:
				weapUpgTXT = weapUpgTXT + " +attack speed"
			case 8:
				weapUpgTXT = weapUpgTXT + " +potion drop"
			case 9:
				weapUpgTXT = weapUpgTXT + " +double xp"
			case 10:
				weapUpgTXT = weapUpgTXT + " +ring of fire"
			case 11:
				weapUpgTXT = weapUpgTXT + " +slude geysers"
			}
		}
	case 4:
		pl.weaps[2].level = newlev
		switch pl.weaps[2].level {
		case 2:
			pl.weaps[2].dmg = pl.weaps[2].origDMG + 1
			weapUpgTXT = "+1 dmg"
		case 3:
			pl.weaps[2].dmg = pl.weaps[2].origDMG + 2
			weapUpgTXT = "+2 dmg"
		case 4:
			pl.weaps[2].dmg = pl.weaps[2].origDMG + 3
			weapUpgTXT = "+3 dmg"
		case 5:
			pl.weaps[2].dmg = pl.weaps[2].origDMG + 3
			pl.weaps[2].spec1 = RandInt(1, 12)
			switch pl.weaps[2].spec1 {
			case 1:
				weapUpgTXT = "+3 dmg +chain lightning"
			case 2:
				weapUpgTXT = "+3 dmg +arrow wall"
			case 3:
				weapUpgTXT = "+3 dmg +crate fireworks"
			case 4:
				weapUpgTXT = "+3 dmg +turret drop"
			case 5:
				weapUpgTXT = "+3 dmg +bomb drop"
			case 6:
				weapUpgTXT = "+3 dmg +rocket"
			case 7:
				weapUpgTXT = "+3 dmg +attack speed"
			case 8:
				weapUpgTXT = "+3 dmg +potion drop"
			case 9:
				weapUpgTXT = "+3 dmg +double xp"
			case 10:
				weapUpgTXT = "+3 dmg +ring of fire"
			case 11:
				weapUpgTXT = "+3 dmg +slude geysers"
			}
		case 6:
			pl.weaps[2].dmg = pl.weaps[2].origDMG + 3
			if pl.weaps[2].spec1 == 0 {
				pl.weaps[2].spec1 = RandInt(1, 12)
			}
			for {
				pl.weaps[2].spec2 = RandInt(1, 12)
				if pl.weaps[2].spec2 != pl.weaps[2].spec1 {
					break
				}
			}
			switch pl.weaps[2].spec1 {
			case 1:
				weapUpgTXT = "+3 dmg +chain lightning"
			case 2:
				weapUpgTXT = "+3 dmg +arrow wall"
			case 3:
				weapUpgTXT = "+3 dmg +crate fireworks"
			case 4:
				weapUpgTXT = "+3 dmg +turret drop"
			case 5:
				weapUpgTXT = "+3 dmg +bomb drop"
			case 6:
				weapUpgTXT = "+3 dmg +rocket"
			case 7:
				weapUpgTXT = "+3 dmg +attack speed"
			case 8:
				weapUpgTXT = "+3 dmg +potion drop"
			case 9:
				weapUpgTXT = "+3 dmg +double xp"
			case 10:
				weapUpgTXT = "+3 dmg +ring of fire"
			case 11:
				weapUpgTXT = "+3 dmg +slude geysers"
			}
			switch pl.weaps[2].spec2 {
			case 1:
				weapUpgTXT = weapUpgTXT + " +chain lightning"
			case 2:
				weapUpgTXT = weapUpgTXT + " +arrow wall"
			case 3:
				weapUpgTXT = weapUpgTXT + " +crate fireworks"
			case 4:
				weapUpgTXT = weapUpgTXT + " +turret drop"
			case 5:
				weapUpgTXT = weapUpgTXT + " +bomb drop"
			case 6:
				weapUpgTXT = weapUpgTXT + " +rocket"
			case 7:
				weapUpgTXT = weapUpgTXT + " +attack speed"
			case 8:
				weapUpgTXT = weapUpgTXT + " +potion drop"
			case 9:
				weapUpgTXT = weapUpgTXT + " +double xp"
			case 10:
				weapUpgTXT = weapUpgTXT + " +ring of fire"
			case 11:
				weapUpgTXT = weapUpgTXT + " +slude geysers"
			}
		}
	case 5:
		pl.weaps[3].level = newlev
		switch pl.weaps[3].level {
		case 2:
			pl.weaps[3].dmg = pl.weaps[3].origDMG + 1
			weapUpgTXT = "+1 dmg"
		case 3:
			pl.weaps[3].dmg = pl.weaps[3].origDMG + 2
			weapUpgTXT = "+2 dmg"
		case 4:
			pl.weaps[3].dmg = pl.weaps[3].origDMG + 3
			weapUpgTXT = "+3 dmg"
		case 5:
			pl.weaps[3].dmg = pl.weaps[3].origDMG + 3
			pl.weaps[3].spec1 = RandInt(1, 12)
			switch pl.weaps[3].spec1 {
			case 1:
				weapUpgTXT = "+3 dmg +chain lightning"
			case 2:
				weapUpgTXT = "+3 dmg +arrow wall"
			case 3:
				weapUpgTXT = "+3 dmg +crate fireworks"
			case 4:
				weapUpgTXT = "+3 dmg +turret drop"
			case 5:
				weapUpgTXT = "+3 dmg +bomb drop"
			case 6:
				weapUpgTXT = "+3 dmg +rocket"
			case 7:
				weapUpgTXT = "+3 dmg +attack speed"
			case 8:
				weapUpgTXT = "+3 dmg +potion drop"
			case 9:
				weapUpgTXT = "+3 dmg +double xp"
			case 10:
				weapUpgTXT = "+3 dmg +ring of fire"
			case 11:
				weapUpgTXT = "+3 dmg +slude geysers"
			}
		case 6:
			pl.weaps[3].dmg = pl.weaps[3].origDMG + 3
			if pl.weaps[3].spec1 == 0 {
				pl.weaps[3].spec1 = RandInt(1, 12)
			}
			for {
				pl.weaps[3].spec2 = RandInt(1, 12)
				if pl.weaps[3].spec2 != pl.weaps[3].spec1 {
					break
				}
			}
			switch pl.weaps[3].spec1 {
			case 1:
				weapUpgTXT = "+3 dmg +chain lightning"
			case 2:
				weapUpgTXT = "+3 dmg +arrow wall"
			case 3:
				weapUpgTXT = "+3 dmg +crate fireworks"
			case 4:
				weapUpgTXT = "+3 dmg +turret drop"
			case 5:
				weapUpgTXT = "+3 dmg +bomb drop"
			case 6:
				weapUpgTXT = "+3 dmg +rocket"
			case 7:
				weapUpgTXT = "+3 dmg +attack speed"
			case 8:
				weapUpgTXT = "+3 dmg +potion drop"
			case 9:
				weapUpgTXT = "+3 dmg +double xp"
			case 10:
				weapUpgTXT = "+3 dmg +ring of fire"
			case 11:
				weapUpgTXT = "+3 dmg +slude geysers"
			}
			switch pl.weaps[3].spec2 {
			case 1:
				weapUpgTXT = weapUpgTXT + " +chain lightning"
			case 2:
				weapUpgTXT = weapUpgTXT + " +arrow wall"
			case 3:
				weapUpgTXT = weapUpgTXT + " +crate fireworks"
			case 4:
				weapUpgTXT = weapUpgTXT + " +turret drop"
			case 5:
				weapUpgTXT = weapUpgTXT + " +bomb drop"
			case 6:
				weapUpgTXT = weapUpgTXT + " +rocket"
			case 7:
				weapUpgTXT = weapUpgTXT + " +attack speed"
			case 8:
				weapUpgTXT = weapUpgTXT + " +potion drop"
			case 9:
				weapUpgTXT = weapUpgTXT + " +double xp"
			case 10:
				weapUpgTXT = weapUpgTXT + " +ring of fire"
			case 11:
				weapUpgTXT = weapUpgTXT + " +slude geysers"
			}
		}
	}

	switch newlev - 1 {
	case 1:
		ore = 1
	case 2:
		ore = 2
	case 3:
		ore = 3
	case 4:
		ore = 4
	case 5:
		ore = 5
	}

	found := false
	newcost := 0
	switch ore {
	case 5: //PLATINUM
		newcost = platinumcost
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].nm == "platinum" {
				if storeItm[i].numof > newcost {
					storeItm[i].numof -= newcost
					found = true
					break
				} else if storeItm[i].numof == newcost {
					storeItm[i].numof = 0
					storeItm[i].off = true
					storeItm[i] = xitm{}
					found = true
					break
				} else if storeItm[i].numof < newcost {
					newcost -= storeItm[i].numof
					storeItm[i].numof = 0
					storeItm[i].off = true
					storeItm[i] = xitm{}
				}
			}
		}
		if !found {
			for i := 0; i < len(pl.invn); i++ {
				if pl.invn[i].nm == "platinum" {
					if pl.invn[i].numof > newcost {
						pl.invn[i].numof -= newcost
						break
					} else if pl.invn[i].numof == newcost {
						pl.invn[i].numof = 0
						pl.invn[i].off = true
						pl.invn[i] = xitm{}
						break
					} else if pl.invn[i].numof < newcost {
						newcost -= pl.invn[i].numof
						pl.invn[i].numof = 0
						pl.invn[i].off = true
						pl.invn[i] = xitm{}
					}
				}
			}
		}

	case 4: //GOLD
		newcost = goldcost
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].nm == "gold" {
				if storeItm[i].numof > newcost {
					storeItm[i].numof -= newcost
					found = true
				} else if storeItm[i].numof == newcost {
					storeItm[i].numof = 0
					storeItm[i].off = true
					storeItm[i] = xitm{}
					found = true
				} else if storeItm[i].numof < newcost {
					newcost -= storeItm[i].numof
					storeItm[i].numof = 0
					storeItm[i].off = true
					storeItm[i] = xitm{}
				}
			}
		}
		if !found {
			for i := 0; i < len(pl.invn); i++ {
				if pl.invn[i].nm == "gold" {
					if pl.invn[i].numof > newcost {
						pl.invn[i].numof -= newcost
					} else if pl.invn[i].numof == newcost {
						pl.invn[i].numof = 0
						pl.invn[i].off = true
						pl.invn[i] = xitm{}
					} else if pl.invn[i].numof < newcost {
						newcost -= pl.invn[i].numof
						pl.invn[i].numof = 0
						pl.invn[i].off = true
						pl.invn[i] = xitm{}
					}
				}
			}
		}

	case 3: //SILVER

		newcost = silvercost
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].nm == "silver" {
				if storeItm[i].numof > newcost {
					storeItm[i].numof -= newcost
					found = true
				} else if storeItm[i].numof == newcost {
					storeItm[i].numof = 0
					storeItm[i].off = true
					storeItm[i] = xitm{}
					found = true
				} else if storeItm[i].numof < newcost {
					newcost -= storeItm[i].numof
					storeItm[i].numof = 0
					storeItm[i].off = true
					storeItm[i] = xitm{}
				}
			}
		}
		if !found {
			for i := 0; i < len(pl.invn); i++ {
				if pl.invn[i].nm == "silver" {
					if pl.invn[i].numof > newcost {
						pl.invn[i].numof -= newcost
					} else if pl.invn[i].numof == newcost {
						pl.invn[i].numof = 0
						pl.invn[i].off = true
						pl.invn[i] = xitm{}
					} else if pl.invn[i].numof < newcost {
						newcost -= pl.invn[i].numof
						pl.invn[i].numof = 0
						pl.invn[i].off = true
						pl.invn[i] = xitm{}
					}
				}
			}
		}

	case 2: //BRONZE
		newcost = bronzecost
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].nm == "bronze" {
				if storeItm[i].numof > newcost {
					storeItm[i].numof -= newcost
					found = true
				} else if storeItm[i].numof == newcost {
					storeItm[i].numof = 0
					storeItm[i].off = true
					storeItm[i] = xitm{}
					found = true
				} else if storeItm[i].numof < newcost {
					newcost -= storeItm[i].numof
					storeItm[i].numof = 0
					storeItm[i].off = true
					storeItm[i] = xitm{}
				}
			}
		}
		if !found {
			for i := 0; i < len(pl.invn); i++ {
				if pl.invn[i].nm == "bronze" {
					if pl.invn[i].numof > newcost {
						pl.invn[i].numof -= newcost
					} else if pl.invn[i].numof == newcost {
						pl.invn[i].numof = 0
						pl.invn[i].off = true
						pl.invn[i] = xitm{}
					} else if pl.invn[i].numof < newcost {
						newcost -= pl.invn[i].numof
						pl.invn[i].numof = 0
						pl.invn[i].off = true
						pl.invn[i] = xitm{}
					}
				}
			}
		}

	case 1: //LEAD
		newcost = leadcost
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].nm == "lead" {
				if storeItm[i].numof > newcost {
					storeItm[i].numof -= newcost
					found = true
				} else if storeItm[i].numof == newcost {
					storeItm[i].numof = 0
					storeItm[i].off = true
					storeItm[i] = xitm{}
					found = true
				} else if storeItm[i].numof < newcost {
					newcost -= storeItm[i].numof
					storeItm[i].numof = 0
					storeItm[i].off = true
					storeItm[i] = xitm{}
				}
			}
		}
		if !found {
			for i := 0; i < len(pl.invn); i++ {
				if pl.invn[i].nm == "lead" {
					if pl.invn[i].numof > newcost {
						pl.invn[i].numof -= newcost
					} else if pl.invn[i].numof == newcost {
						pl.invn[i].numof = 0
						pl.invn[i].off = true
						pl.invn[i] = xitm{}
					} else if pl.invn[i].numof < newcost {
						newcost -= pl.invn[i].numof
						pl.invn[i].numof = 0
						pl.invn[i].off = true
						pl.invn[i] = xitm{}
					}
				}
			}
		}

	}
	rl.PlaySound(audfx[48])
}
func up() { //MARK:UP

	if musicon {
		rl.UpdateMusicStream(music[currentMusic])
	}

	if !baseon && exiting {
		exiting = false
	}

	if !pause {
		if !pl.gameover {
			upplayer()
		}
		cams()
		if len(fx) > 0 {
			upfxclear()
		}
		if bosson {
			upboss()
		}
		levT++
		if levT%fps == 0 {
			levSecs++
			if levSecs == 60 {
				levMins++
				levSecs = 0
			}
		}
	}
	if batty {
		if !pause || pause && baseon {
			upbatty()
		}
	}
	if rollo {
		if !pause || pause && baseon {
			uprollo()
		}
	}
	if !pl.gameover {
		upquik()
		upinven()
	}
	inp()
	timers()

	if fadeblink {
		if fadeblinkF < 0.7 {
			fadeblinkF += 0.05
		} else {
			fadeblink = false
		}
	} else {
		if fadeblinkF > 0.1 {
			fadeblinkF -= 0.05
		} else {
			fadeblink = true
		}
	}
	if fadeblink2 {
		if fadeblinkF2 < 1 {
			fadeblinkF2 += 0.01
		} else {
			fadeblink2 = false
		}
	} else {
		if fadeblinkF2 > 0.5 {
			fadeblinkF2 -= 0.01
		} else {
			fadeblink2 = true
		}
	}
}
func uprollo() { //MARK:UP ROLLO

	if baseon {
		canmove := false
		v2 := rollocomp.cnt
		v2.X += rollocomp.dirX
		v2.Y += rollocomp.dirY
		if rl.CheckCollisionPointRec(v2, screenBordRec) {
			canmove = true
		}
		for i := 0; i < len(base.crec); i++ {
			if rl.CheckCollisionPointRec(v2, base.crec[i]) {
				canmove = false
			}
		}

		if canmove {
			rollocomp.cnt = v2
			rollocomp.rec = rl.NewRectangle(rollocomp.cnt.X-rollocomp.rec.Width/2, rollocomp.cnt.Y-rollocomp.rec.Height/2, rollocomp.rec.Width, rollocomp.rec.Height)
		} else {
			for {
				if rollocomp.dirX > 0 {
					rollocomp.dirX = RandF32(-rollocomp.spd, -rollocomp.spd/4)
				} else {
					rollocomp.dirX = RandF32(rollocomp.spd/4, rollocomp.spd)
				}
				if rollocomp.dirY > 0 {
					rollocomp.dirY = RandF32(-rollocomp.spd, -rollocomp.spd/4)
				} else {
					rollocomp.dirY = RandF32(rollocomp.spd/4, rollocomp.spd)
				}

				if Abs(rollocomp.dirY) > rollocomp.spd/3 || Abs(rollocomp.dirX) > rollocomp.spd/3 {
					break
				}
			}
		}
		if rollocomp.dirX > 0 {
			rollocomp.lr = false
		} else {
			rollocomp.lr = true
		}
	} else {
		if rollocomp.atkT > 0 {
			rollocomp.atkT--
			if rollocomp.atkT == 1 {
				zproj := xweap{}
				zproj.dmg = 1
				zproj.nm = "rolloProj"
				siz := b
				zproj.spd = 5
				zproj.rec = rl.NewRectangle(rollocomp.cnt.X-siz/2, rollocomp.cnt.Y-siz/2, siz, siz)
				zproj.crec = zproj.rec
				zproj.crec.X += zproj.crec.Width / 8
				zproj.crec.Y += zproj.crec.Height / 8
				zproj.crec.Width -= zproj.crec.Width / 4
				zproj.crec.Height -= zproj.crec.Height / 4
				zproj.img = anm[155].rec
				zproj.dirX = zproj.spd
				zproj.dirY = zproj.spd
				projPL = append(projPL, zproj)
				zproj.dirX = -zproj.spd
				zproj.dirY = zproj.spd
				projPL = append(projPL, zproj)
				zproj.dirX = zproj.spd
				zproj.dirY = -zproj.spd
				projPL = append(projPL, zproj)
				zproj.dirX = -zproj.spd
				zproj.dirY = -zproj.spd
				projPL = append(projPL, zproj)

				rollocomp.atkT = fps * 3
			}
		}

		checkrec := rollocomp.rec
		checkrec.X += rollocomp.dirX
		checkrec.Y += rollocomp.dirY
		canmove := checkRecWalls(checkrec)
		if canmove {
			canmove = checkRecSolid(checkrec)
		}
		if canmove {
			rollocomp.rec = checkrec
			rollocomp.cnt = makecnt(rollocomp.rec)
		} else {
			for {
				if rollocomp.dirX > 0 {
					rollocomp.dirX = RandF32(-rollocomp.spd, -rollocomp.spd/4)
				} else {
					rollocomp.dirX = RandF32(rollocomp.spd/4, rollocomp.spd)
				}
				if rollocomp.dirY > 0 {
					rollocomp.dirY = RandF32(-rollocomp.spd, -rollocomp.spd/4)
				} else {
					rollocomp.dirY = RandF32(rollocomp.spd/4, rollocomp.spd)
				}

				if Abs(rollocomp.dirY) > rollocomp.spd/3 || Abs(rollocomp.dirX) > rollocomp.spd/3 {
					break
				}
			}
		}
		if rollocomp.dirX > 0 {
			rollocomp.lr = false
		} else {
			rollocomp.lr = true
		}

		if frames%30 == 0 {
			if AbsDiff(pl.cnt.X, rollocomp.cnt.X) > b5 {
				if pl.cnt.X > rollocomp.cnt.X {
					rollocomp.dirX = rollocomp.spd
				} else {
					rollocomp.dirX = -rollocomp.spd
				}
			}
			if AbsDiff(pl.cnt.Y, rollocomp.cnt.Y) > b5 {
				if pl.cnt.Y > rollocomp.cnt.Y {
					rollocomp.dirY = rollocomp.spd
				} else {
					rollocomp.dirY = -rollocomp.spd
				}
			}
		}
	}

}
func upbatty() { //MARK:UP BATTY

	if baseon {
		if batcomp.moveChangeT > 0 {
			batcomp.moveChangeT--
		} else {
			batcomp.moveChangeT = fps * RandInt32(1, 4)
			batcomp.dirX = RandF32(-batcomp.spd, batcomp.spd)
			batcomp.dirY = RandF32(-batcomp.spd, batcomp.spd)
		}

		if batcomp.dirX > 0 {
			batcomp.lr = false
		} else {
			batcomp.lr = true
		}

		canmove := false
		v2 := batcomp.cnt
		v2.X += batcomp.dirX
		v2.Y += batcomp.dirY
		if rl.CheckCollisionPointRec(v2, screenBordRec) {
			canmove = true
		}
		if canmove {
			batcomp.cnt.X += batcomp.dirX + delta
			batcomp.cnt.Y += batcomp.dirY + delta
			batcomp.rec = rl.NewRectangle(batcomp.cnt.X-batcomp.rec.Width/2, batcomp.cnt.Y-batcomp.rec.Height/2, batcomp.rec.Width, batcomp.rec.Height)
		} else {
			batcomp.dirX = RandF32(-batcomp.spd, batcomp.spd)
			batcomp.dirY = RandF32(-batcomp.spd, batcomp.spd)
		}

	} else {
		if batcomp.atkT > 0 {
			batcomp.atkT--
			if batcomp.atkT == 1 {

				zproj := xweap{}
				zproj.dmg = 2
				zproj.nm = "battyProj"
				siz := b
				zproj.spd = 3
				cntr2 := makecnt(batcomp.rec)
				zproj.ro = 0
				zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
				zproj.crec = zproj.rec
				zproj.crec.X += zproj.crec.Width / 4
				zproj.crec.Y += zproj.crec.Height / 4
				zproj.crec.Width = zproj.crec.Width / 2
				zproj.crec.Height = zproj.crec.Height / 2
				zproj.img = anm[147].rec
				zproj.dirY = -zproj.spd
				zproj.ro = -90
				projPL = append(projPL, zproj)
				zproj.ro = 90
				zproj.dirY = zproj.spd
				projPL = append(projPL, zproj)
				zproj.dirY = 0
				zproj.dirX = -zproj.spd
				zproj.ro = 180
				projPL = append(projPL, zproj)
				zproj.dirX = zproj.spd
				zproj.ro = 0
				projPL = append(projPL, zproj)

				batcomp.atkT = fps * 7
			}
		}

		if batcomp.moveChangeT > 0 {
			batcomp.moveChangeT--
		} else {
			batcomp.moveChangeT = fps * RandInt32(1, 4)
			batcomp.dirX = RandF32(-batcomp.spd, batcomp.spd)
			batcomp.dirY = RandF32(-batcomp.spd, batcomp.spd)
		}

		if batcomp.dirX > 0 {
			batcomp.lr = false
		} else {
			batcomp.lr = true
		}

		canmove := false
		v2 := batcomp.cnt
		v2.X += batcomp.dirX
		v2.Y += batcomp.dirY
		for i := 0; i < len(levels[levNum].recs); i++ {
			if rl.CheckCollisionPointRec(v2, levels[levNum].recs[i]) {
				canmove = true
			}
		}

		if canmove {
			batcomp.cnt.X += batcomp.dirX + delta
			batcomp.cnt.Y += batcomp.dirY + delta
			batcomp.rec = rl.NewRectangle(batcomp.cnt.X-batcomp.rec.Width/2, batcomp.cnt.Y-batcomp.rec.Height/2, batcomp.rec.Width, batcomp.rec.Height)
		} else {
			batcomp.dirX = RandF32(-batcomp.spd, batcomp.spd)
			batcomp.dirY = RandF32(-batcomp.spd, batcomp.spd)
		}

		if frames%30 == 0 {
			if AbsDiff(pl.cnt.X, batcomp.cnt.X) > b5 {
				if pl.cnt.X > batcomp.cnt.X {
					batcomp.dirX = batcomp.spd
				} else {
					batcomp.dirX = -batcomp.spd
				}
			}
			if AbsDiff(pl.cnt.Y, batcomp.cnt.Y) > b5 {
				if pl.cnt.Y > batcomp.cnt.Y {
					batcomp.dirY = batcomp.spd
				} else {
					batcomp.dirY = -batcomp.spd
				}
			}
		}
	}

}

func upInvenClearArt() { //MARK:UP INVEN CLEAR ARTIFACTS
	for i := 0; i < len(pl.invn); i++ {
		if pl.invn[i].art {
			max := false
			switch pl.invn[i].nm {
			case "umbrella":
				if !umbrella {
					umbrella = true
				} else {
					max = true
				}
			case "map chest pin":
				if !chestpin {
					chestpin = true
				} else {
					max = true
				}
			case "map exit pin":
				if !mappin {
					mappin = true
				} else {
					max = true
				}
			case "gas mask":
				if gasmasknum < gasmaskmax {
					gasmasknum++
					if gasmaskT == 0 {
						gasmaskT = fps*8 - (gasmasknum * fps)
					}
				} else {
					max = true
				}
			case "noodles":
				if !noodles {
					noodles = true
				} else {
					max = true
				}
			case "oven glove":
				if ovenglovenum < ovenglovemax {
					ovenglovenum++
				} else {
					max = true
				}
			case "toaster":
				if !toaster {
					toaster = true
				} else {
					max = true
				}
			case "ninja star":
				if ninjanum < ninjamax {
					ninjanum++
				} else {
					max = true
				}
			case "flamingo":
				if flamingonum < flamingomax {
					flamingonum++
					if flamingoT == 0 {
						flamingoT = (fps + fps/2) / flamingonum
					}
				} else {
					max = true
				}
			case "mug of tea":
				if teanum < teamax {
					teanum++
				} else {
					max = true
				}
			case "cloak of sparks":
				if !cloak {
					cloak = true
				} else {
					max = true
				}
			case "feather":
				if !feather {
					feather = true
				} else {
					max = true
				}
			case "mugging":
				if mugnum < mugmax {
					mugnum++
				} else {
					max = true
				}
			case "lightbulb":
				if lightbulbnum < lightbulbmax {
					lightbulbnum++
				} else {
					max = true
				}
			case "candy cane":
				if candycanenum < candycanemax {
					candycanenum++
				} else {
					max = true
				}
			case "pearl":
				if pearlnum < pearlmax {
					pearlnum++
					pl.hpmax++
					pl.hp++
				} else {
					max = true
				}
			case "magicians hat":
				if magicianshatnum < magicianshatmax {
					magicianshatnum++
					pl.manamax++
					pl.mana++
				} else {
					max = true
				}
			case "throwing knife":
				if throwingknifenum < throwingknifemax {
					throwingknifenum++
				} else {
					max = true
				}
			case "toxic sludge":
				if !toxic {
					toxic = true
				} else {
					max = true
				}
			case "mirror":
				if !mirror {
					mirror = true
				} else {
					max = true
				}
			case "belt of whipping":
				if beltnum < beltmax {
					beltnum++
				} else {
					max = true
				}
			case "amulet of disc":
				if !frisbee {
					frisbee = true
				} else {
					max = true
				}
			case "amulet of purple rain":
				if !purplerain {
					purplerain = true
				} else {
					max = true
				}
			case "tesla coil":
				if !tesla {
					tesla = true
				} else {
					max = true
				}
			case "ring of twin":
				if !twin {
					twin = true
				} else {
					max = true
				}
			case "ring of thorns":
				if !thornson {
					thornson = true
				} else {
					max = true
				}
			case "ring of vine":
				if !vineRing {
					vineRing = true
					if pl.hp == 1 {
						pl.hp = 2
					}
				} else {
					max = true
				}
			case "toilet paper":
				if toiletpapernum < toiletpapermax {
					toiletpapernum++
				} else {
					max = true
				}
			case "bear trap":
				if beartrapnum < beartrapmax {
					beartrapnum++
					beartrapT = (fps * 12) - (int32(beartrapnum*2) * fps)
				} else {
					max = true
				}
			case "basketball sneakers":
				if stats.dex < 5 {
					stats.dex++
					stats.dex2 = stats.dex
				} else {
					max = true
				}
			case "dumbbell":
				if stats.str < 5 {
					stats.str++
					stats.str2 = stats.str
				} else {
					max = true
				}
			case "dice":
				if stats.luk < 5 {
					stats.luk++
					stats.luk2 = stats.luk
				} else {
					max = true
				}
			case "eyeball":
				if stats.per < 5 {
					stats.per++
					stats.per2 = stats.per
				} else {
					max = true
				}
			case "brain":
				if stats.int < 5 {
					stats.int++
					stats.int2 = stats.int
				} else {
					max = true
				}
			case "medikit":
				if medikitnum < medikitmax {
					medikiton = true
				} else {
					max = true
				}
			case "backpack":
				if len(pl.invn) < invMax {
					pl.invn = append(pl.invn, xitm{})
				} else {
					max = true
					admsg("inventory max", rl.Red)
				}
			case "gas can":
				if gascannum < gascanmax {
					gascannum++
				} else {
					max = true
				}
			case "bottle of death":
				if deathbottlenum < deathbottlemax {
					deathbottlenum++
				} else {
					max = true
				}
			case "cleaver":
				if cleavernum < cleavermax {
					cleavernum++
				} else {
					max = true
				}
			case "tenderiser":
				if tenderisernum < tenderisermax {
					tenderisernum++
				} else {
					max = true
				}
			case "garlic":
				if garlicnum < garlicmax {
					garlicnum++
				} else {
					max = true
				}
			case "drill":
				if !drillon {
					drillon = true
				} else {
					max = true
				}
			case "broccoli":
				if broccolinum < broccolimax {
					broccolinum++
				} else {
					max = true
				}
			case "basketball":
				if basketballnum < basketballmax {
					basketballnum++
				} else {
					max = true
				}
			case "sunglasses":
				if stats.crit < stats.crit2 {
					stats.crit++
				} else {
					max = true
				}
			case "sneakers":
				if sneakersnum < sneakersmax {
					sneakersnum++
					if pl.spd2 < pl.spdmax {
						pl.spd2++
						pl.spd = pl.spd2
					}
				} else {
					max = true
				}
			}
			if max {
				rl.PlaySound(audfx[121])
				admsg("artifact > "+pl.invn[i].nm+" > max", rl.Red)
				found := false
				for j := 0; j < len(pl.invn); j++ {
					if pl.invn[i].nm == pl.invn[j].nm && j != i {
						pl.invn[j].numof++
						if msgT == 0 {
							admsg("in backpack > store for next run", rl.Magenta)
							msgT = fps
						}
						pl.invn[i] = xitm{}
						pl.invn[i].off = true
						found = true
					}
				}
				if !found {
					if nxInvnNum != blankint {
						pl.invn[nxInvnNum] = pl.invn[i]
						findnxinvnum()
						if msgT == 0 {
							admsg("in backpack > store for next run", rl.Magenta)
							msgT = fps
						}
						pl.invn[i] = xitm{}
						pl.invn[i].off = true
					} else {
						if msgT == 0 {
							admsg("inventory full > drop, stack or use", rl.Red)
							msgT = fps
						}
					}
				}
			} else {
				found, numSame := checkArtSameItm(pl.invn[i])
				if found {
					pl.art[numSame].numof++
				} else {
					pl.art = append(pl.art, pl.invn[i])
				}
				admsg("collected artifact "+pl.invn[i].nm, rl.Magenta)
				pl.invn[i] = xitm{}
				pl.invn[i].off = true
			}
		}
	}
}
func upunlocks() { //MARK:UP UNLOCKED ITEMS
	crateitm = nil
	unlockNum = 0
	for i := 0; i < len(itmlist); i++ {
		if itmlist[i].unlok && !itmlist[i].nocrate {
			crateitm = append(crateitm, itmlist[i])
			unlockNum++
		}
	}
}

func upfxclear() { //MARK:UP FX CLEAR
	clear := false
	for i := 0; i < len(fx); i++ {
		if fx[i].off {
			clear = true
		} else {
			fx[i].clearT++
		}
		if fx[i].clearT > fps*60 {
			fx[i].off = true
		}
	}
	if clear {
		for i := 0; i < len(fx); i++ {
			if fx[i].off {
				fx = RemoveFx(fx, i)
			}
		}
	}
}
func upenm() { //MARK:UP ENEMIES
	fireson = false
	blackdotCount = 0
	//STUN STARS ANIM
	if frames%4 == 0 {
		anm[107].rec.X += anm[107].W
		if anm[107].rec.X > anm[107].X+anm[107].frames*anm[107].W {
			anm[107].rec.X = anm[107].X
		}
	}
	//BLACK DOT COUNT
	for i := 0; i < len(levels[levNum].enm); i++ {
		if levels[levNum].enm[i].nm == "blackdot" {
			blackdotCount++
		}
	}
	for i := 0; i < len(levels[levNum].enm); i++ {
		if !levels[levNum].enm[i].off {
			//TIMERS

			if levels[levNum].enm[i].hpT > 0 {
				levels[levNum].enm[i].hpT--
			}
			if levels[levNum].enm[i].stunT > 0 {
				levels[levNum].enm[i].stunT--
			}
			if levels[levNum].enm[i].poisonT > 0 {
				levels[levNum].enm[i].poisonT--
				if levels[levNum].enm[i].poisonT == fps {
					levels[levNum].enm[i].hp--
				}
				if levels[levNum].enm[i].poisonT == 0 {
					levels[levNum].enm[i].hp--
				}
				if levels[levNum].enm[i].hp <= 0 && !levels[levNum].enm[i].off {
					pl.xp += levels[levNum].enm[i].xp
					makeEnDeathFx(i)
					levels[levNum].enm[i].off = true
				}
			}
			if levels[levNum].enm[i].bleedT > 0 {
				levels[levNum].enm[i].bleedT--
				if levels[levNum].enm[i].bleedT == fps {
					levels[levNum].enm[i].hp -= levels[levNum].enm[i].bleed
				}
				if levels[levNum].enm[i].bleedT == 0 {
					levels[levNum].enm[i].hp -= levels[levNum].enm[i].bleed
				}
				if levels[levNum].enm[i].hp <= 0 && !levels[levNum].enm[i].off {
					pl.xp += levels[levNum].enm[i].xp
					makeEnDeathFx(i)
					levels[levNum].enm[i].off = true
				}
			}
			if levels[levNum].enm[i].burnT > 0 {
				levels[levNum].enm[i].burnT--
				if levels[levNum].enm[i].burnT == fps {
					levels[levNum].enm[i].hp--
				}
				if levels[levNum].enm[i].burnT == 0 {
					levels[levNum].enm[i].hp--
				}
				if levels[levNum].enm[i].hp <= 0 && !levels[levNum].enm[i].off {
					pl.xp += levels[levNum].enm[i].xp
					makeEnDeathFx(i)
					levels[levNum].enm[i].off = true
				}
			}

			//CLEAR BURNT FIRES
			if levels[levNum].enm[i].nm == "fire" && levels[levNum].enm[i].burnT > 0 {
				levels[levNum].enm[i].burnT = 0
			}
			//OIL TIMER
			if levels[levNum].enm[i].oilT > 0 {
				levels[levNum].enm[i].oilT--
			}
			//FREEZE TIMER
			if levels[levNum].enm[i].freezeT > 0 {
				levels[levNum].enm[i].freezeT--
			}
			//SWITCH FIRES ON
			if !fireson {
				if levels[levNum].enm[i].nm == "fire" {
					fireson = true
				}
			}
			//PLAYER COLLIS
			if pl.hpT == 0 {
				if rl.CheckCollisionRecs(pl.crec, levels[levNum].enm[i].crec) && pl.enCollisT == 0 {
					pl.enCollisT = fps
					switch levels[levNum].enm[i].nm {
					case "fire", "flamehead":
						if pl.resFireT == 0 {
							hitPL(2)
						}
						if pl.burnT == 0 && pl.dampT == 0 && icelollyT == 0 && pl.resFireT == 0 {
							if ovenglovenum > 0 {
								if Roll6() <= ovenglovenum {
									admsg("oven glove saves burn", rl.Green)
								} else {
									admsg("burning...", rl.Orange)
									pl.burnT += fps * 3
								}
							} else {
								admsg("burning...", rl.Orange)
								pl.burnT += fps * 3
							}
						} else if pl.burnT == 0 && pl.dampT != 0 && icelollyT == 0 && pl.resFireT == 0 {
							admsg("damp saves burn", rl.Green)
						} else if pl.burnT == 0 && pl.dampT == 0 && icelollyT != 0 && pl.resFireT == 0 {
							admsg("ice lolly saves burn", rl.Green)
						} else if pl.burnT == 0 && pl.dampT == 0 && icelollyT == 0 && pl.resFireT != 0 {
							admsg("resist fire saves burn", rl.Green)
						}
					default:
						hitPL(1)
					}
				}
			}

			if !bosson && tvT == 0 {
				//ROCK GUY PROJ
				if levels[levNum].enm[i].nm == "bush" && !levels[levNum].enm[i].idl {
					if frames%30 == 0 {
						zproj := xweap{}
						zproj.nm = "bushProj"
						zproj.bounce = 2
						zproj.dmg = 1
						zproj.img = anm[173].rec
						siz := b
						zproj.rec = rl.NewRectangle(levels[levNum].enm[i].cnt.X-siz/2, levels[levNum].enm[i].cnt.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.col = rl.White
						zproj.fd = 1
						zproj.spd = 4
						zproj.rospd = 5
						zproj.dirX, zproj.dirY = findSpdXY(levels[levNum].enm[i].cnt, pl.cnt, zproj.spd)
						projEn = append(projEn, zproj)
					}
				}
				//GREEN PIG PROJ
				if levels[levNum].enm[i].nm == "greenpig" && levels[levNum].enm[i].onoff {
					if frames%30 == 0 {
						zproj := xweap{}
						zproj.nm = "greenpigProj"
						zproj.bounce = 1
						zproj.dmg = 1
						zproj.img = anm[132].rec
						siz := be3
						zproj.rec = rl.NewRectangle(levels[levNum].enm[i].cnt.X-siz/2, levels[levNum].enm[i].cnt.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.col = rl.White
						zproj.fd = 1
						zproj.spd = 4
						if FlipCoin() {
							zproj.dirX = zproj.spd
							projEn = append(projEn, zproj)
							zproj.dirX = -zproj.spd
							projEn = append(projEn, zproj)
							zproj.dirX = 0
							zproj.dirY = zproj.spd
							projEn = append(projEn, zproj)
							zproj.dirY = -zproj.spd
							projEn = append(projEn, zproj)
						} else {
							zproj.dirX = zproj.spd
							zproj.dirY = zproj.spd
							projEn = append(projEn, zproj)
							zproj.dirX = zproj.spd
							zproj.dirY = -zproj.spd
							projEn = append(projEn, zproj)
							zproj.dirX = -zproj.spd
							zproj.dirY = zproj.spd
							projEn = append(projEn, zproj)
							zproj.dirX = -zproj.spd
							zproj.dirY = -zproj.spd
							projEn = append(projEn, zproj)
						}
					}
				}
				//BIRD EGG PROJ
				if levels[levNum].enm[i].nm == "bird" && levels[levNum].enm[i].follow {
					if frames%30 == 0 {
						zproj := xweap{}
						zproj.nm = "birdProj"
						zproj.bounce = 2
						zproj.dmg = 1
						zproj.img = etc[152]
						siz := b / 2
						zproj.rec = rl.NewRectangle(levels[levNum].enm[i].cnt.X-siz/2, levels[levNum].enm[i].cnt.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.col = rl.White
						zproj.fd = 1
						zproj.spd = 4
						zproj.rospd = 5
						zproj.dirX, zproj.dirY = findSpdXY(levels[levNum].enm[i].cnt, pl.cnt, zproj.spd)
						projEn = append(projEn, zproj)
					}
				}
				if levels[levNum].enm[i].atkT > 0 {
					levels[levNum].enm[i].atkT--
					if levels[levNum].enm[i].atkT == 1 && levels[levNum].enm[i].stunT == 0 {
						switch levels[levNum].enm[i].nm {
						case "jersey":
							levels[levNum].enm[i].onoff = !levels[levNum].enm[i].onoff
							levels[levNum].enm[i].atkT = fps * 2
						case "reddevil":
							zproj := xweap{}
							zproj.below = true
							zproj.nm = "reddevilFlame"
							zproj.img = anm[169].rec
							siz := b
							zproj.rec = rl.NewRectangle(levels[levNum].enm[i].cnt.X-siz/2, levels[levNum].enm[i].cnt.Y-siz/2, siz, siz)
							zproj.crec = zproj.rec
							zproj.crec.Y += zproj.rec.Height / 2
							zproj.crec.Height = zproj.crec.Height / 2
							zproj.col = rl.White
							zproj.fd = 1
							projEn = append(projEn, zproj)
							levels[levNum].enm[i].atkT = fps / 2
						case "greenpig":
							levels[levNum].enm[i].onoff = !levels[levNum].enm[i].onoff
							levels[levNum].enm[i].atkT = fps * 2
						case "robot":
							levels[levNum].enm[i].onoff = true
						case "redblob":
							zproj := xweap{}
							zproj.nm = "redblobbull"
							zproj.rospd = 8
							zproj.dmg = 1
							zproj.img = anm[71].rec
							siz := b / 2
							zproj.rec = rl.NewRectangle(levels[levNum].enm[i].cnt.X-siz/2, levels[levNum].enm[i].cnt.Y-siz/2, siz, siz)
							zproj.crec = zproj.rec
							zproj.col = rl.White
							zproj.fd = 1
							zproj.spd = b / 20
							zproj.dirX, zproj.dirY = findSpdXY(levels[levNum].enm[i].cnt, pl.cnt, zproj.spd)
							projEn = append(projEn, zproj)
							levels[levNum].enm[i].atkT = fps * 2
						case "skeleton":
							zproj := xweap{}
							zproj.nm = "bonebull"
							zproj.bounce = 3
							zproj.rospd = 8
							zproj.dmg = 1
							zproj.img = etc[31]
							siz := b / 2
							zproj.rec = rl.NewRectangle(levels[levNum].enm[i].cnt.X-siz/2, levels[levNum].enm[i].cnt.Y-siz/2, siz, siz)
							zproj.crec = zproj.rec
							zproj.col = rl.White
							zproj.fd = 1
							zproj.spd = b / 20
							zproj.dirX, zproj.dirY = findSpdXY(levels[levNum].enm[i].cnt, pl.cnt, zproj.spd)
							projEn = append(projEn, zproj)
							levels[levNum].enm[i].atkT = fps * 2
						case "blackdot":
							if levels[levNum].enm[i].numMax > 0 && blackdotCount < 50 {
								levels[levNum].enm[i].numMax--
								zenm := enmlist[10] //BLACK DOT
								if Roll6() == 6 {
									zenm.numMax = RandInt(2, 5)
									zenm.atkT = fps * 2
								}
								zenm.cnt = levels[levNum].enm[i].cnt
								zenm.rec = rl.NewRectangle(zenm.cnt.X-zenm.rec.Width/2, zenm.cnt.Y-zenm.rec.Height/2, zenm.rec.Width, zenm.rec.Height)
								zenm.crec = zenm.rec
								zenm.dirX = RandF32(-zenm.spd, zenm.spd)
								zenm.dirY = RandF32(-zenm.spd, zenm.spd)
								levels[levNum].enm = append(levels[levNum].enm, zenm)
								levels[levNum].enNum++
								levels[levNum].enm[i].atkT = fps * 2
							}
						case "yellowdino":
							zproj := xweap{}
							zproj.nm = "yellowdinobull"
							zproj.below = true
							zproj.dmg = 1
							zproj.img = anm[62].rec
							siz := b2
							zproj.rec = rl.NewRectangle(levels[levNum].enm[i].cnt.X-siz/2, levels[levNum].enm[i].cnt.Y-siz/2, siz, siz)
							zproj.crec = zproj.rec
							zproj.crec.Y += zproj.rec.Height / 2
							zproj.crec.Height = zproj.crec.Height / 2
							zproj.col = rl.White
							zproj.fd = 1
							projEn = append(projEn, zproj)
							levels[levNum].enm[i].atkT = fps
						case "greenplant":
							zproj := xweap{}
							zproj.nm = "greenplantbull"
							zproj.dmg = 1
							zproj.img = anm[61].rec
							siz := be5
							zproj.rec = rl.NewRectangle(levels[levNum].enm[i].cnt.X-siz/2, levels[levNum].enm[i].cnt.Y-siz/2, siz, siz)
							zproj.crec = zproj.rec
							zproj.col = rl.White
							zproj.fd = 1
							zproj.spd = b / 20
							zproj.dirX, zproj.dirY = findSpdXY(levels[levNum].enm[i].cnt, pl.cnt, zproj.spd)
							projEn = append(projEn, zproj)
							levels[levNum].enm[i].atkT = fps / 4
						case "pinkcart":
							zproj := xweap{}
							zproj.nm = "pinkcartbull"
							zproj.dmg = 1
							zproj.img = anm[60].rec
							siz := b
							zproj.rec = rl.NewRectangle(levels[levNum].enm[i].cnt.X-siz/2, levels[levNum].enm[i].cnt.Y-siz/2, siz, siz)
							zproj.cnt = makecnt(zproj.rec)
							zproj.crec = zproj.rec
							zproj.col = rl.White
							zproj.fd = 0.7
							zproj.spd = b / 12
							zproj.dirX, zproj.dirY = findSpdXY(levels[levNum].enm[i].cnt, pl.cnt, zproj.spd)
							projEn = append(projEn, zproj)
							levels[levNum].enm[i].atkT = fps * RandInt32(1, 3)
						case "redantenna":
							zproj := xweap{}
							zproj.nm = "redantbull"
							zproj.dmg = 1
							zproj.img = anm[56].rec
							siz := be3
							zproj.rec = rl.NewRectangle(levels[levNum].enm[i].cnt.X-siz/2, levels[levNum].enm[i].cnt.Y-siz/2, siz, siz)
							zproj.crec = zproj.rec
							zproj.col = rl.White
							zproj.fd = 1
							zproj.spd = b / 24
							zproj.dirX, zproj.dirY = findSpdXY(levels[levNum].enm[i].cnt, pl.cnt, zproj.spd)
							projEn = append(projEn, zproj)
							levels[levNum].enm[i].atkT = fps
						}
					}
				}
				//MARK: UP ENEMY MOVE CHANGE
				if levels[levNum].enm[i].moveChangeT > 0 {
					levels[levNum].enm[i].moveChangeT--
				} else {
					switch levels[levNum].enm[i].nm {
					case "bird":
						levels[levNum].enm[i].follow = !levels[levNum].enm[i].follow
						levels[levNum].enm[i].moveChangeT = fps * RandInt32(3, 8)
						if !levels[levNum].enm[i].follow {
							levels[levNum].enm[i].dirX = RandF32(-levels[levNum].enm[i].spd, levels[levNum].enm[i].spd)
							levels[levNum].enm[i].dirY = RandF32(-levels[levNum].enm[i].spd, levels[levNum].enm[i].spd)
						}
					case "robot":
						if !levels[levNum].enm[i].follow {
							levels[levNum].enm[i].moveChangeT = fps * RandInt32(1, 2)
							levels[levNum].enm[i].dirX = RandF32(-levels[levNum].enm[i].spd, levels[levNum].enm[i].spd)
							levels[levNum].enm[i].dirY = RandF32(-levels[levNum].enm[i].spd, levels[levNum].enm[i].spd)
						}
					case "redblob":
						levels[levNum].enm[i].moveChangeT = fps * RandInt32(1, 2)
						levels[levNum].enm[i].dirX = RandF32(-levels[levNum].enm[i].spd, levels[levNum].enm[i].spd)
						levels[levNum].enm[i].dirY = RandF32(-levels[levNum].enm[i].spd, levels[levNum].enm[i].spd)
					case "yellowdino", "greenplant", "jersey", "spike":
						levels[levNum].enm[i].moveChangeT = fps * RandInt32(2, 4)
						levels[levNum].enm[i].dirX = RandF32(-levels[levNum].enm[i].spd, levels[levNum].enm[i].spd)
						levels[levNum].enm[i].dirY = RandF32(-levels[levNum].enm[i].spd, levels[levNum].enm[i].spd)
					case "redantenna":
						levels[levNum].enm[i].moveChangeT = fps * RandInt32(1, 4)
						levels[levNum].enm[i].dirX = 0
						levels[levNum].enm[i].dirY = 0
						if FlipCoin() {
							countbreak := 100
							for {
								levels[levNum].enm[i].dirX = RandF32(-levels[levNum].enm[i].spd, levels[levNum].enm[i].spd)
								if Abs(levels[levNum].enm[i].dirX) > 0.4 {
									break
								}
								countbreak--
								if countbreak == 0 {
									break
								}
							}
						} else {
							countbreak := 100
							for {
								levels[levNum].enm[i].dirY = RandF32(-levels[levNum].enm[i].spd, levels[levNum].enm[i].spd)
								if Abs(levels[levNum].enm[i].dirY) > 0.4 {
									break
								}
								countbreak--
								if countbreak == 0 {
									break
								}
							}
						}
					}
				}
				//IDLE
				if levels[levNum].enm[i].idl {
					if levels[levNum].enm[i].idleT > 0 {
						levels[levNum].enm[i].idleT--
					} else {
						levels[levNum].enm[i].idlon = !levels[levNum].enm[i].idlon
						switch levels[levNum].enm[i].nm {
						case "bluespike", "redeye", "redbomb", "pinkcart", "greenplant":
							if levels[levNum].enm[i].idlon {
								levels[levNum].enm[i].idleT = fps * RandInt32(1, 3)
							} else {
								levels[levNum].enm[i].dirX = RandF32(-levels[levNum].enm[i].spd, levels[levNum].enm[i].spd)
								levels[levNum].enm[i].dirY = RandF32(-levels[levNum].enm[i].spd, levels[levNum].enm[i].spd)
								levels[levNum].enm[i].idleT = fps * RandInt32(3, 5)
							}
						}
					}
				}
				//DIREC
				if levels[levNum].enm[i].dirX > 0 {
					levels[levNum].enm[i].lr = false
				} else {
					levels[levNum].enm[i].lr = true
				}
				//MARK: ENEMY MOVEMENT
				if !levels[levNum].enm[i].idlon && !levels[levNum].enm[i].stat {
					if checkMoveEnm(i) {
						if icecreamT == 0 && levels[levNum].enm[i].stunT == 0 && levels[levNum].enm[i].freezeT == 0 {
							if watchT > 0 || levels[levNum].enm[i].oilT > 0 {
								levels[levNum].enm[i].cnt.X += (levels[levNum].enm[i].dirX / 2) + delta
								levels[levNum].enm[i].cnt.Y += (levels[levNum].enm[i].dirY / 2) + delta
							} else { //NORMAL ENEMY MOVEMENT
								levels[levNum].enm[i].cnt.X += levels[levNum].enm[i].dirX + delta
								levels[levNum].enm[i].cnt.Y += levels[levNum].enm[i].dirY + delta
							}
						}
						//UP ENEMY REC
						levels[levNum].enm[i].rec = rl.NewRectangle(levels[levNum].enm[i].cnt.X-levels[levNum].enm[i].rec.Width/2, levels[levNum].enm[i].cnt.Y-levels[levNum].enm[i].rec.Height/2, levels[levNum].enm[i].rec.Width, levels[levNum].enm[i].rec.Height)
						//UP COLLIS RECS
						levels[levNum].enm[i].crec = levels[levNum].enm[i].rec
						switch levels[levNum].enm[i].nm {
						case "bush":
							levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Width / 4
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
							levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 2
							levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 4
							levels[levNum].enm[i].carec = levels[levNum].enm[i].rec
							levels[levNum].enm[i].carec.X -= b4
							levels[levNum].enm[i].carec.Y -= b4
							levels[levNum].enm[i].carec.Width += b8
							levels[levNum].enm[i].carec.Height += b8
							if rl.CheckCollisionRecs(pl.crec, levels[levNum].enm[i].carec) && pl.invisT == 0 {
								levels[levNum].enm[i].idl = false
								if frames%15 == 0 {
									xdiff := AbsDiff(levels[levNum].enm[i].cnt.X, pl.cnt.X)
									ydiff := AbsDiff(levels[levNum].enm[i].cnt.Y, pl.cnt.Y)
									if xdiff > ydiff {
										levels[levNum].enm[i].dirX = levels[levNum].enm[i].spd
										levels[levNum].enm[i].dirY = ydiff / (xdiff / levels[levNum].enm[i].dirX)
									} else {
										levels[levNum].enm[i].dirY = levels[levNum].enm[i].spd
										levels[levNum].enm[i].dirX = xdiff / (ydiff / levels[levNum].enm[i].dirY)
									}
									if levels[levNum].enm[i].cnt.X > pl.cnt.X {
										levels[levNum].enm[i].dirX = -levels[levNum].enm[i].dirX
									}
									if levels[levNum].enm[i].cnt.Y > pl.cnt.Y {
										levels[levNum].enm[i].dirY = -levels[levNum].enm[i].dirY
									}
									levels[levNum].enm[i].dirY *= -1
									levels[levNum].enm[i].dirX *= -1
								}
							} else {
								levels[levNum].enm[i].idl = true
								levels[levNum].enm[i].dirY = 0
								levels[levNum].enm[i].dirX = 0
							}
						case "jersey":
							levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Width / 2
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
							levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 2
							levels[levNum].enm[i].crec.Height = levels[levNum].enm[i].crec.Height / 2
						case "bird":
							levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Width / 8
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 8
							levels[levNum].enm[i].crec.Width -= levels[levNum].enm[i].crec.Width / 4
							levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 4
							if levels[levNum].enm[i].follow {
								if frames%15 == 0 {
									xdiff := AbsDiff(levels[levNum].enm[i].cnt.X, pl.cnt.X)
									ydiff := AbsDiff(levels[levNum].enm[i].cnt.Y, pl.cnt.Y)
									if xdiff > ydiff {
										levels[levNum].enm[i].dirX = levels[levNum].enm[i].spd
										levels[levNum].enm[i].dirY = ydiff / (xdiff / levels[levNum].enm[i].dirX)
									} else {
										levels[levNum].enm[i].dirY = levels[levNum].enm[i].spd
										levels[levNum].enm[i].dirX = xdiff / (ydiff / levels[levNum].enm[i].dirY)
									}
									if levels[levNum].enm[i].cnt.X > pl.cnt.X {
										levels[levNum].enm[i].dirX = -levels[levNum].enm[i].dirX
									}
									if levels[levNum].enm[i].cnt.Y > pl.cnt.Y {
										levels[levNum].enm[i].dirY = -levels[levNum].enm[i].dirY
									}
								}
							}
						case "greenpig":
							levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Width / 3
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 3
							levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 3
							levels[levNum].enm[i].crec.Height = levels[levNum].enm[i].crec.Height / 3
							levels[levNum].enm[i].crec.Y += 4
						case "robot":
							levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 2
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
							levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 2
							levels[levNum].enm[i].crec.Height = levels[levNum].enm[i].crec.Height / 2
							levels[levNum].enm[i].carec = levels[levNum].enm[i].crec
							levels[levNum].enm[i].carec.X -= b5
							levels[levNum].enm[i].carec.Y -= b5
							levels[levNum].enm[i].carec.Width += b10
							levels[levNum].enm[i].carec.Height += b10
							//COLLISION AREA REC
							if rl.CheckCollisionRecs(pl.crec, levels[levNum].enm[i].carec) && pl.invisT == 0 && pl.freezeT == 0 {
								levels[levNum].enm[i].follow = true
								if frames%15 == 0 {
									xdiff := AbsDiff(levels[levNum].enm[i].cnt.X, pl.cnt.X)
									ydiff := AbsDiff(levels[levNum].enm[i].cnt.Y, pl.cnt.Y)
									if xdiff > ydiff {
										levels[levNum].enm[i].dirX = levels[levNum].enm[i].spd
										levels[levNum].enm[i].dirY = ydiff / (xdiff / levels[levNum].enm[i].dirX)
									} else {
										levels[levNum].enm[i].dirY = levels[levNum].enm[i].spd
										levels[levNum].enm[i].dirX = xdiff / (ydiff / levels[levNum].enm[i].dirY)
									}
									if levels[levNum].enm[i].cnt.X > pl.cnt.X {
										levels[levNum].enm[i].dirX = -levels[levNum].enm[i].dirX
									}
									if levels[levNum].enm[i].cnt.Y > pl.cnt.Y {
										levels[levNum].enm[i].dirY = -levels[levNum].enm[i].dirY
									}
								}
							} else {
								levels[levNum].enm[i].follow = false
							}
						case "carrot":
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 8
							levels[levNum].enm[i].crec.Width -= levels[levNum].enm[i].crec.Width / 4
							levels[levNum].enm[i].carec = levels[levNum].enm[i].rec
							levels[levNum].enm[i].carec.X -= b4
							levels[levNum].enm[i].carec.Y -= b4
							levels[levNum].enm[i].carec.Width += b8
							levels[levNum].enm[i].carec.Height += b8
							//COLLISION AREA REC
							if rl.CheckCollisionRecs(pl.crec, levels[levNum].enm[i].carec) && pl.invisT == 0 {
								levels[levNum].enm[i].spd = 4
								if frames%15 == 0 {
									xdiff := AbsDiff(levels[levNum].enm[i].cnt.X, pl.cnt.X)
									ydiff := AbsDiff(levels[levNum].enm[i].cnt.Y, pl.cnt.Y)
									if xdiff > ydiff {
										levels[levNum].enm[i].dirX = levels[levNum].enm[i].spd
										levels[levNum].enm[i].dirY = ydiff / (xdiff / levels[levNum].enm[i].dirX)
									} else {
										levels[levNum].enm[i].dirY = levels[levNum].enm[i].spd
										levels[levNum].enm[i].dirX = xdiff / (ydiff / levels[levNum].enm[i].dirY)
									}
									if levels[levNum].enm[i].cnt.X > pl.cnt.X {
										levels[levNum].enm[i].dirX = -levels[levNum].enm[i].dirX
									}
									if levels[levNum].enm[i].cnt.Y > pl.cnt.Y {
										levels[levNum].enm[i].dirY = -levels[levNum].enm[i].dirY
									}
								}
								if rl.CheckCollisionRecs(pl.crec, levels[levNum].enm[i].crec) {
									zfx := xfx{}
									zfx.img = anm[57].rec
									zfx.cnt = levels[levNum].enm[i].cnt
									siz := b7
									zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
									zfx.crec = zfx.rec
									zfx.crec.X += zfx.crec.Width / 8
									zfx.crec.Y += zfx.crec.Width / 8
									zfx.crec.Height -= zfx.crec.Height / 4
									zfx.crec.Width -= zfx.crec.Width / 4
									zfx.nm = "landmineExplod"
									fx = append(fx, zfx)
									levels[levNum].enm[i].off = true
									if pl.hpT == 0 {
										hitPL(1)
									}
									if pl.burnT == 0 {
										pl.burnT += fps * 3
									}
								}
							} else {
								levels[levNum].enm[i].spd = 2
							}
						case "redblob":
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
							levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 2
							levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 2
							levels[levNum].enm[i].crec.Height = levels[levNum].enm[i].crec.Height / 2
						case "skeleton":
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
							levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 2
							levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 8
						case "orange":
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
							levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 2
							levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 3
							levels[levNum].enm[i].crec.Height = levels[levNum].enm[i].crec.Height / 2
							//AREA REC
							levels[levNum].enm[i].carec = levels[levNum].enm[i].rec
							levels[levNum].enm[i].carec.X -= b3
							levels[levNum].enm[i].carec.Y -= b3
							levels[levNum].enm[i].carec.Width += b6
							levels[levNum].enm[i].carec.Height += b6
							//COLLISION AREA REC
							if rl.CheckCollisionRecs(pl.crec, levels[levNum].enm[i].carec) && pl.invisT == 0 {
								if frames%15 == 0 {
									xdiff := AbsDiff(levels[levNum].enm[i].cnt.X, pl.cnt.X)
									ydiff := AbsDiff(levels[levNum].enm[i].cnt.Y, pl.cnt.Y)
									if xdiff > ydiff {
										levels[levNum].enm[i].dirX = levels[levNum].enm[i].spd
										levels[levNum].enm[i].dirY = ydiff / (xdiff / levels[levNum].enm[i].dirX)
									} else {
										levels[levNum].enm[i].dirY = levels[levNum].enm[i].spd
										levels[levNum].enm[i].dirX = xdiff / (ydiff / levels[levNum].enm[i].dirY)
									}
									if levels[levNum].enm[i].cnt.X > pl.cnt.X {
										levels[levNum].enm[i].dirX = -levels[levNum].enm[i].dirX
									}
									if levels[levNum].enm[i].cnt.Y > pl.cnt.Y {
										levels[levNum].enm[i].dirY = -levels[levNum].enm[i].dirY
									}
								}
							}
						case "flamehead":
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
							levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 2
							//AREA REC
							levels[levNum].enm[i].carec = levels[levNum].enm[i].rec
							levels[levNum].enm[i].carec.X -= b3
							levels[levNum].enm[i].carec.Y -= b3
							levels[levNum].enm[i].carec.Width += b6
							levels[levNum].enm[i].carec.Height += b6
							//COLLISION AREA REC
							if rl.CheckCollisionRecs(pl.crec, levels[levNum].enm[i].carec) && pl.invisT == 0 {
								if frames%15 == 0 {
									xdiff := AbsDiff(levels[levNum].enm[i].cnt.X, pl.cnt.X)
									ydiff := AbsDiff(levels[levNum].enm[i].cnt.Y, pl.cnt.Y)
									if xdiff > ydiff {
										levels[levNum].enm[i].dirX = levels[levNum].enm[i].spd
										levels[levNum].enm[i].dirY = ydiff / (xdiff / levels[levNum].enm[i].dirX)
									} else {
										levels[levNum].enm[i].dirY = levels[levNum].enm[i].spd
										levels[levNum].enm[i].dirX = xdiff / (ydiff / levels[levNum].enm[i].dirY)
									}
									if levels[levNum].enm[i].cnt.X > pl.cnt.X {
										levels[levNum].enm[i].dirX = -levels[levNum].enm[i].dirX
									}
									if levels[levNum].enm[i].cnt.Y > pl.cnt.Y {
										levels[levNum].enm[i].dirY = -levels[levNum].enm[i].dirY
									}
								}
							}
						case "fly":
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
							levels[levNum].enm[i].crec.Width -= levels[levNum].enm[i].crec.Width / 2
							levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 4
							levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 2
							//AREA REC
							levels[levNum].enm[i].carec = levels[levNum].enm[i].rec
							levels[levNum].enm[i].carec.X -= b3
							levels[levNum].enm[i].carec.Y -= b3
							levels[levNum].enm[i].carec.Width += b6
							levels[levNum].enm[i].carec.Height += b6
							//COLLISION AREA REC
							if rl.CheckCollisionRecs(pl.crec, levels[levNum].enm[i].carec) && pl.invisT == 0 {
								if frames%15 == 0 {
									xdiff := AbsDiff(levels[levNum].enm[i].cnt.X, pl.cnt.X)
									ydiff := AbsDiff(levels[levNum].enm[i].cnt.Y, pl.cnt.Y)
									if xdiff > ydiff {
										levels[levNum].enm[i].dirX = levels[levNum].enm[i].spd
										levels[levNum].enm[i].dirY = ydiff / (xdiff / levels[levNum].enm[i].dirX)
									} else {
										levels[levNum].enm[i].dirY = levels[levNum].enm[i].spd
										levels[levNum].enm[i].dirX = xdiff / (ydiff / levels[levNum].enm[i].dirY)
									}
									if levels[levNum].enm[i].cnt.X > pl.cnt.X {
										levels[levNum].enm[i].dirX = -levels[levNum].enm[i].dirX
									}
									if levels[levNum].enm[i].cnt.Y > pl.cnt.Y {
										levels[levNum].enm[i].dirY = -levels[levNum].enm[i].dirY
									}
								}
							}
						case "worm":
							levels[levNum].enm[i].crec.Y += (levels[levNum].enm[i].crec.Height / 4) * 3
							levels[levNum].enm[i].crec.Height = levels[levNum].enm[i].crec.Height / 4
						case "yellowdino":
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 8
							levels[levNum].enm[i].crec.Width -= levels[levNum].enm[i].crec.Width / 4
							levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 3
							levels[levNum].enm[i].crec.Height = (levels[levNum].enm[i].crec.Height / 3) * 2
						case "greenplant":
							levels[levNum].enm[i].crec.Y += (levels[levNum].enm[i].crec.Height / 3) * 2
							levels[levNum].enm[i].crec.Height = levels[levNum].enm[i].crec.Height / 3
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 3
							levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 3
						case "pinkcart":
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
							levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 2
							levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 2
							levels[levNum].enm[i].crec.Height = levels[levNum].enm[i].crec.Height / 2
						case "crocodile":
							levels[levNum].enm[i].crec.Y += (levels[levNum].enm[i].crec.Height / 12) * 7
							levels[levNum].enm[i].crec.Height = (levels[levNum].enm[i].crec.Height / 12) * 5
							//COLLISION AREA REC
							if rl.CheckCollisionRecs(pl.crec, levels[levNum].enm[i].carec) && pl.invisT == 0 {
								if !levels[levNum].enm[i].fast {
									levels[levNum].enm[i].fast = true
									if levels[levNum].enm[i].img.X < anm[58].rec.X {
										levels[levNum].enm[i].img.X = anm[58].rec.X
									}
									if pl.cnt.X < levels[levNum].enm[i].cnt.X {
										levels[levNum].enm[i].lr = true
										levels[levNum].enm[i].dirX = -levels[levNum].enm[i].spd * 2
									} else {
										levels[levNum].enm[i].lr = false
										levels[levNum].enm[i].dirX = levels[levNum].enm[i].spd * 2
									}
								}
							}
							//AREA
							levels[levNum].enm[i].carec = levels[levNum].enm[i].crec
							levels[levNum].enm[i].carec.X -= b4
							levels[levNum].enm[i].carec.Width += b8
						case "balloon":
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
							levels[levNum].enm[i].crec.Width -= levels[levNum].enm[i].crec.Width / 2
							levels[levNum].enm[i].crec.Y += 4
							levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 2
						case "redantenna":
							levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 3
							levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 3
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 6
							levels[levNum].enm[i].crec.Width -= levels[levNum].enm[i].crec.Width / 3
						case "ghost":
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 8
							levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 8
							levels[levNum].enm[i].crec.Width -= levels[levNum].enm[i].crec.Width / 4
							levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 4
							//AREA REC
							levels[levNum].enm[i].carec = levels[levNum].enm[i].rec
							levels[levNum].enm[i].carec.X -= b3
							levels[levNum].enm[i].carec.Y -= b3
							levels[levNum].enm[i].carec.Width += b6
							levels[levNum].enm[i].carec.Height += b6
							//COLLISION AREA REC
							if rl.CheckCollisionRecs(pl.crec, levels[levNum].enm[i].carec) && pl.invisT == 0 {
								if frames%15 == 0 {
									xdiff := AbsDiff(levels[levNum].enm[i].cnt.X, pl.cnt.X)
									ydiff := AbsDiff(levels[levNum].enm[i].cnt.Y, pl.cnt.Y)
									if xdiff > ydiff {
										levels[levNum].enm[i].dirX = levels[levNum].enm[i].spd
										levels[levNum].enm[i].dirY = ydiff / (xdiff / levels[levNum].enm[i].dirX)
									} else {
										levels[levNum].enm[i].dirY = levels[levNum].enm[i].spd
										levels[levNum].enm[i].dirX = xdiff / (ydiff / levels[levNum].enm[i].dirY)
									}
									if levels[levNum].enm[i].cnt.X > pl.cnt.X {
										levels[levNum].enm[i].dirX = -levels[levNum].enm[i].dirX
									}
									if levels[levNum].enm[i].cnt.Y > pl.cnt.Y {
										levels[levNum].enm[i].dirY = -levels[levNum].enm[i].dirY
									}
								}
							}
						case "redeye", "redbomb":
							levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 4
							levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 4
						case "bluespike":
							levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 8
							levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 8
							levels[levNum].enm[i].crec.Width -= levels[levNum].enm[i].crec.Width / 4
							levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 4
						}
						//CHECK ENEMY ETC COLLIS
						if !levels[levNum].enm[i].fly {
							for j := 0; j < len(levels[levNum].etc); j++ {
								if levels[levNum].etc[j].nm == "beartrap" && !levels[levNum].etc[j].onoff {
									if !levels[levNum].enm[i].nodmg {
										if rl.CheckCollisionRecs(levels[levNum].etc[j].crec, levels[levNum].enm[i].crec) {
											levels[levNum].etc[j].onoff = true
											levels[levNum].enm[i].stunT = fps
											levels[levNum].enm[i].stunF = 0.9
											levels[levNum].enm[i].stunY = levels[levNum].enm[i].cnt.Y
											levels[levNum].enm[i].stunSiz = b / 4
											levels[levNum].enm[i].hp -= 1
											if levels[levNum].enm[i].hp <= 0 && !levels[levNum].enm[i].off {
												pl.xp += levels[levNum].enm[i].xp
												makeEnDeathFx(i)
												levels[levNum].enm[i].off = true
											} else {
												levels[levNum].enm[i].hpT = fps
												levels[levNum].enm[i].hpY = bq3
												levels[levNum].enm[i].hpY2 = 0
												if bosson {
													levels[levNum].enm[i].hpY = b
													levels[levNum].enm[i].hpY2 = b / 2
												}
											}
											//FX
											zfx := xfx{}
											zfx.nm = "beartrap"
											zfx.img = anm[87].rec
											siz := b4
											zfx.rec = rl.NewRectangle(levels[levNum].etc[j].cnt.X-siz/2, levels[levNum].etc[j].cnt.Y-siz, siz, siz)
											fx = append(fx, zfx)
										}
									}
								}

								if levels[levNum].etc[j].nm == "landmine" && !levels[levNum].etc[j].onoff {
									if !levels[levNum].enm[i].nodmg {
										if rl.CheckCollisionRecs(levels[levNum].etc[j].crec, levels[levNum].enm[i].crec) {
											levels[levNum].etc[j].off = true
											levels[levNum].enm[i].hp -= 2
											if levels[levNum].enm[i].hp <= 0 && !levels[levNum].enm[i].off {
												pl.xp += levels[levNum].enm[i].xp
												makeEnDeathFx(i)
												levels[levNum].enm[i].off = true
											} else {
												levels[levNum].enm[i].hpT = fps
												levels[levNum].enm[i].hpY = bq3
												levels[levNum].enm[i].hpY2 = 0
												if bosson {
													levels[levNum].enm[i].hpY = b
													levels[levNum].enm[i].hpY2 = b / 2
												}
												if levels[levNum].enm[i].burnT == 0 {
													if levels[levNum].enm[i].nm == "flamehead" || levels[levNum].enm[i].nm == "yellowdino" || levels[levNum].enm[i].nm == "ghost" || levels[levNum].enm[i].nm == "fly" || levels[levNum].enm[i].nm == "reddevil" {
														if msgT == 0 {
															admsg("immune to burn", rl.Yellow)
															msgT = fps
														}
													} else {
														levels[levNum].enm[i].burnT = fps * 3
													}
												}
											}
											zfx := xfx{}
											zfx.img = anm[57].rec
											zfx.cnt = levels[levNum].etc[j].cnt
											siz := b5
											zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
											zfx.crec = zfx.rec
											zfx.crec.X += zfx.crec.Width / 8
											zfx.crec.Y += zfx.crec.Width / 8
											zfx.crec.Height -= zfx.crec.Height / 4
											zfx.crec.Width -= zfx.crec.Width / 4
											zfx.nm = "landmineExplod"
											fx = append(fx, zfx)
										}
									}
								}
							}
						}
					} else { //MARK: ENEMY COLLIS CHANGE DIREC
						if !bosson {
							switch levels[levNum].enm[i].nm {
							case "reddevil":
								if levels[levNum].enm[i].dirX < 0 {
									levels[levNum].enm[i].dirX = -levels[levNum].enm[i].spd
								} else {
									levels[levNum].enm[i].dirX = levels[levNum].enm[i].spd
								}
								levels[levNum].enm[i].dirX *= -1
								if FlipCoin() {
									levels[levNum].enm[i].dirX *= -1
								}
								levels[levNum].enm[i].dirY = levels[levNum].enm[i].spd / RandF32(2, 5)
								if FlipCoin() {
									levels[levNum].enm[i].dirY = -levels[levNum].enm[i].dirY
								}
							case "crocodile", "worm", "redantenna":
								if levels[levNum].enm[i].fast { //SLOW DOWN CROCODILE
									levels[levNum].enm[i].fast = false
								}
								countbreak := 100
								for {
									levels[levNum].enm[i].dirX = RandF32(-levels[levNum].enm[i].spd, levels[levNum].enm[i].spd)
									if Abs(levels[levNum].enm[i].dirX) > 0.4 {
										break
									}
									countbreak--
									if countbreak == 0 {
										break
									}
								}
							case "ghost", "balloon", "blackdot", "fly", "yellowdino", "flamehead", "orange", "skeleton", "redblob", "carrot", "robot", "greenpig", "bush", "bird", "jersey", "spike":
								if levels[levNum].enm[i].dirX > 0 {
									levels[levNum].enm[i].dirX = RandF32(-levels[levNum].enm[i].spd, 0)
								} else {
									levels[levNum].enm[i].dirX = RandF32(0, levels[levNum].enm[i].spd)
								}
								if levels[levNum].enm[i].dirY > 0 {
									levels[levNum].enm[i].dirY = RandF32(-levels[levNum].enm[i].spd, 0)
								} else {
									levels[levNum].enm[i].dirY = RandF32(0, levels[levNum].enm[i].spd)
								}
							case "bluespike", "redeye", "redbomb", "pinkcart", "greenplant":
								levels[levNum].enm[i].idlon = true
								levels[levNum].enm[i].idleT = fps * RandInt32(1, 3)
								if levels[levNum].enm[i].dirX > 0 {
									levels[levNum].enm[i].dirX = RandF32(-levels[levNum].enm[i].spd, 0)
								} else {
									levels[levNum].enm[i].dirX = RandF32(0, levels[levNum].enm[i].spd)
								}
								if levels[levNum].enm[i].dirY > 0 {
									levels[levNum].enm[i].dirY = RandF32(-levels[levNum].enm[i].spd, 0)
								} else {
									levels[levNum].enm[i].dirY = RandF32(0, levels[levNum].enm[i].spd)
								}
								countbreak := 100
								for {
									levels[levNum].enm[i].dirX = RandF32(-levels[levNum].enm[i].spd, levels[levNum].enm[i].spd)
									levels[levNum].enm[i].dirY = RandF32(-levels[levNum].enm[i].spd, levels[levNum].enm[i].spd)
									if Abs(levels[levNum].enm[i].dirX) > 0.4 && Abs(levels[levNum].enm[i].dirY) > 0.4 {
										break
									}
									countbreak--
									if countbreak == 0 {
										break
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
func upquik() { //MARK:UP QUICK SLOTS
	nxQuikNum = blankint
	for i := 0; i < len(pl.quik); i++ {
		//TIMERS
		if !pause {
			if pl.quik[i].coolT > 0 {
				pl.quik[i].coolT--
			}
		}
		//FIND NEXT EMPTY SLOT
		if pl.quik[i].nm == "" {
			nxQuikNum = i
			break
		}
		switch pl.quik[i].nm {
		//ANIM
		case "armor potion full":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[20].W
				if pl.quik[i].img.X > anm[20].X+anm[20].frames*anm[20].W {
					pl.quik[i].img.X = anm[20].X
				}
			}
		case "armor potion half":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[18].W
				if pl.quik[i].img.X > anm[18].X+anm[18].frames*anm[18].W {
					pl.quik[i].img.X = anm[18].X
				}
			}
		case "armor potion quarter":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[19].W
				if pl.quik[i].img.X > anm[19].X+anm[19].frames*anm[19].W {
					pl.quik[i].img.X = anm[19].X
				}
			}
		case "invisibility full":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[17].W
				if pl.quik[i].img.X > anm[17].X+anm[17].frames*anm[17].W {
					pl.quik[i].img.X = anm[17].X
				}
			}
		case "invisibility half":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[18].W
				if pl.quik[i].img.X > anm[18].X+anm[18].frames*anm[18].W {
					pl.quik[i].img.X = anm[18].X
				}
			}
		case "invisibility quarter":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[19].W
				if pl.quik[i].img.X > anm[19].X+anm[19].frames*anm[19].W {
					pl.quik[i].img.X = anm[19].X
				}
			}
		case "resist poison full":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[14].W
				if pl.quik[i].img.X > anm[14].X+anm[14].frames*anm[14].W {
					pl.quik[i].img.X = anm[14].X
				}
			}
		case "resist poison half":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[15].W
				if pl.quik[i].img.X > anm[15].X+anm[15].frames*anm[15].W {
					pl.quik[i].img.X = anm[15].X
				}
			}
		case "resist poison quarter":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[16].W
				if pl.quik[i].img.X > anm[16].X+anm[16].frames*anm[16].W {
					pl.quik[i].img.X = anm[16].X
				}
			}
		case "resist fire full":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[11].W
				if pl.quik[i].img.X > anm[11].X+anm[11].frames*anm[11].W {
					pl.quik[i].img.X = anm[11].X
				}
			}
		case "resist fire half":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[12].W
				if pl.quik[i].img.X > anm[12].X+anm[12].frames*anm[12].W {
					pl.quik[i].img.X = anm[12].X
				}
			}
		case "resist fire quarter":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[13].W
				if pl.quik[i].img.X > anm[13].X+anm[13].frames*anm[13].W {
					pl.quik[i].img.X = anm[13].X
				}
			}
		case "mana potion full":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[8].W
				if pl.quik[i].img.X > anm[8].X+anm[8].frames*anm[8].W {
					pl.quik[i].img.X = anm[8].X
				}
			}
		case "mana potion half":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[9].W
				if pl.quik[i].img.X > anm[9].X+anm[9].frames*anm[9].W {
					pl.quik[i].img.X = anm[9].X
				}
			}
		case "mana potion quarter":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[10].W
				if pl.quik[i].img.X > anm[10].X+anm[10].frames*anm[10].W {
					pl.quik[i].img.X = anm[10].X
				}
			}
		case "hp potion full":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[5].W
				if pl.quik[i].img.X > anm[5].X+anm[5].frames*anm[5].W {
					pl.quik[i].img.X = anm[5].X
				}
			}
		case "hp potion half":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[6].W
				if pl.quik[i].img.X > anm[6].X+anm[6].frames*anm[6].W {
					pl.quik[i].img.X = anm[6].X
				}
			}
		case "hp potion quarter":
			if frames%6 == 0 {
				pl.quik[i].img.X += anm[7].W
				if pl.quik[i].img.X > anm[7].X+anm[7].frames*anm[7].W {
					pl.quik[i].img.X = anm[7].X
				}
			}
		}
	}
}
func upinven() { //MARK:UP INVENTORY
	nxInvnNum = blankint
	scrapNum = 0
	for i := 0; i < len(pl.invn); i++ {
		//TIMERS
		if !pause {
			if pl.invn[i].coolT > 0 {
				pl.invn[i].coolT--
			}
		}
		//FIND NEXT EMPTY SLOT
		if pl.invn[i].nm == "" {
			nxInvnNum = i
			break
		}
		switch pl.invn[i].nm {
		//POTION ANIM
		case "armor potion full":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[20].W
				if pl.invn[i].img.X > anm[20].X+anm[20].frames*anm[20].W {
					pl.invn[i].img.X = anm[20].X
				}
			}
		case "armor potion half":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[18].W
				if pl.invn[i].img.X > anm[18].X+anm[18].frames*anm[18].W {
					pl.invn[i].img.X = anm[18].X
				}
			}
		case "armor potion quarter":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[19].W
				if pl.invn[i].img.X > anm[19].X+anm[19].frames*anm[19].W {
					pl.invn[i].img.X = anm[19].X
				}
			}
		case "invisibility full":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[17].W
				if pl.invn[i].img.X > anm[17].X+anm[17].frames*anm[17].W {
					pl.invn[i].img.X = anm[17].X
				}
			}
		case "invisibility half":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[18].W
				if pl.invn[i].img.X > anm[18].X+anm[18].frames*anm[18].W {
					pl.invn[i].img.X = anm[18].X
				}
			}
		case "invisibility quarter":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[19].W
				if pl.invn[i].img.X > anm[19].X+anm[19].frames*anm[19].W {
					pl.invn[i].img.X = anm[19].X
				}
			}
		case "resist poison full":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[14].W
				if pl.invn[i].img.X > anm[14].X+anm[14].frames*anm[14].W {
					pl.invn[i].img.X = anm[14].X
				}
			}
		case "resist poison half":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[15].W
				if pl.invn[i].img.X > anm[15].X+anm[15].frames*anm[15].W {
					pl.invn[i].img.X = anm[15].X
				}
			}
		case "resist poison quarter":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[16].W
				if pl.invn[i].img.X > anm[16].X+anm[16].frames*anm[16].W {
					pl.invn[i].img.X = anm[16].X
				}
			}
		case "resist fire full":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[11].W
				if pl.invn[i].img.X > anm[11].X+anm[11].frames*anm[11].W {
					pl.invn[i].img.X = anm[11].X
				}
			}
		case "resist fire half":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[12].W
				if pl.invn[i].img.X > anm[12].X+anm[12].frames*anm[12].W {
					pl.invn[i].img.X = anm[12].X
				}
			}
		case "resist fire quarter":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[13].W
				if pl.invn[i].img.X > anm[13].X+anm[13].frames*anm[13].W {
					pl.invn[i].img.X = anm[13].X
				}
			}
		case "mana potion full":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[8].W
				if pl.invn[i].img.X > anm[8].X+anm[8].frames*anm[8].W {
					pl.invn[i].img.X = anm[8].X
				}
			}
		case "mana potion half":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[9].W
				if pl.invn[i].img.X > anm[9].X+anm[9].frames*anm[9].W {
					pl.invn[i].img.X = anm[9].X
				}
			}
		case "mana potion quarter":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[10].W
				if pl.invn[i].img.X > anm[10].X+anm[10].frames*anm[10].W {
					pl.invn[i].img.X = anm[10].X
				}
			}
		case "hp potion full":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[5].W
				if pl.invn[i].img.X > anm[5].X+anm[5].frames*anm[5].W {
					pl.invn[i].img.X = anm[5].X
				}
			}
		case "hp potion half":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[6].W
				if pl.invn[i].img.X > anm[6].X+anm[6].frames*anm[6].W {
					pl.invn[i].img.X = anm[6].X
				}
			}
		case "hp potion quarter":
			if frames%6 == 0 {
				pl.invn[i].img.X += anm[7].W
				if pl.invn[i].img.X > anm[7].X+anm[7].frames*anm[7].W {
					pl.invn[i].img.X = anm[7].X
				}
			}
		}
	}

	maxWeapDmg = 0
	if pl.wp1.nm != "" {
		maxWeapDmg = pl.wp1.dmg
	}
	if pl.wp2.nm != "" {
		if maxWeapDmg < pl.wp2.dmg {
			maxWeapDmg = pl.wp2.dmg
		}
	}
	if len(pl.weaps) > 0 {
		for i := 0; i < len(pl.weaps); i++ {
			if maxWeapDmg < pl.weaps[i].dmg {
				maxWeapDmg = pl.weaps[i].dmg
			}
		}
	}

}

func upplayer() { //MARK:UP PLAYER
	if !baseon {

		//TIMERS
		if pl.collectT > 0 {
			pl.collectT--
		}
		if pl.freezeT > 0 {
			pl.freezeT--
		}
		if pl.poisonT > 0 {
			pl.poisonT--
		}
		if pl.enCollisT > 0 {
			pl.enCollisT--
		}
		if pl.armorT > 0 {
			pl.armorT--
		}
		if pl.invisT > 0 {
			pl.invisT--
		}
		if pl.resPoisT > 0 {
			pl.resPoisT--
		}
		if pl.resFireT > 0 {
			pl.resFireT--
		}
		if pl.atkT > 0 {
			pl.atkT--
		}
		if pl.hpT > 0 {
			pl.hpT--
		}
		if pl.burnT > 0 {
			pl.burnT--
			if pl.dampT > 0 {
				pl.burnT = 0
			} else {
				if pl.burnT%fps == 0 {
					admsg("burning...", rl.Orange)
					hitPL(2)
				}
				if pl.burnT <= 1 {
					admsg("flames extinguished", rl.Green)
				}
			}
		}
		if pl.poisonT > 0 {
			if pl.resPoisT > 0 {
				pl.poisonT = 0
				admsg("resist poison saves poisoning", rl.Green)
			} else {
				if pl.poisonT%fps == 0 {
					admsg("poisoned...", rl.Red)
					hitPL(2)
				}
			}
		}
		if pl.dampT > 0 && slugT == 0 && sodaT == 0 {
			if pl.dampT%fps == 0 {
				admsg("-2 speed", rl.Red)
			}
			pl.dampT--
			pl.spd = pl.spd2 - 2
			if pl.dampT == 1 {
				admsg("dry again", rl.Green)
			}
		} else if slugT > 0 && pl.dampT == 0 && sodaT == 0 {
			pl.spd = pl.spd2 + 2
		} else if slugT > 0 && pl.dampT == 0 && sodaT > 0 {
			pl.spd = pl.spd2 + 3
			if pl.spd > pl.spdmax {
				pl.spd = pl.spdmax
			}
		} else if slugT > 0 && pl.dampT > 0 && sodaT == 0 {
			pl.spd = pl.spd2
		} else if slugT > 0 && pl.dampT > 0 && sodaT > 0 {
			pl.spd = pl.spd2
		} else if slugT == 0 && pl.dampT > 0 && sodaT > 0 {
			pl.spd = pl.spd2
		} else if slugT == 0 && pl.dampT == 0 && sodaT > 0 {
			pl.spd = pl.spd2 + 1
		} else {
			pl.spd = pl.spd2
		}
		//INP
		if vineon {
			if vineon2 {
				if pl.cnt.Y < cnt.Y {
					pl.cnt.Y += pl.spd
				} else {
					pl.hp += 2
					pl.hpT = fps * 2
					vineon = false
					vineon2 = false
				}
			} else {
				pl.cnt.Y -= pl.spd
				if pl.cnt.Y <= inRec.Y {
					pl.cnt.X = cnt.X
					vineon2 = true
				}
			}
		} else {
			if pl.freezeT == 0 {
				movedown := false
				if pl.atkT == 0 && !inquick && !inchestslot {
					atkNum := 0
					if rl.IsMouseButtonDown(rl.MouseButtonLeft) || rl.IsGamepadButtonDown(0, 12) {
						atkNum = 1
					}
					if rl.IsMouseButtonDown(rl.MouseButtonRight) || rl.IsGamepadButtonDown(0, 10) {
						atkNum = 2
					}

					if atkNum != 0 {
						if pistolT > 0 {
							pl.atkT = fps / 10
						} else {
							if candycanenum > 4 {
								if atkNum == 1 && pl.wp1.spec1 == 7 || atkNum == 1 && pl.wp1.spec2 == 7 {
									pl.atkT = fps / 8
								} else if atkNum == 2 && pl.wp2.spec1 == 7 || atkNum == 2 && pl.wp2.spec2 == 7 {
									pl.atkT = fps / 8
								} else {
									pl.atkT = fps / candycanenum
								}
							} else {
								if atkNum == 1 && pl.wp1.spec1 == 7 || atkNum == 1 && pl.wp1.spec2 == 7 {
									pl.atkT = fps / 8
								} else if atkNum == 2 && pl.wp2.spec1 == 7 || atkNum == 2 && pl.wp2.spec2 == 7 {
									pl.atkT = fps / 8
								} else {
									pl.atkT = fps / 3
								}
							}
						}
						atkV2 = cursorV2cam
						atkCNT = pl.cnt
						makeplproj(atkNum)
						//BELT
						if beltnum > 0 {
							beltAtk++
							if beltAtk == 11-beltnum {
								beltAtk = 0
								zfx := xfx{}
								zfx.nm = "belt"
								zfx.img = anm[94].rec
								zfx.rec = pl.rec
								zfx.rec.X -= b3
								zfx.rec.Y -= b3
								zfx.rec.Width += b6
								zfx.rec.Height += b6
								fx = append(fx, zfx)
							}
						}

					}
				}
				plWorldScreenV2 := rl.GetWorldToScreen2D(pl.cnt, cam2)
				if cursorV2.X < plWorldScreenV2.X && pl.pushT == 0 {
					pl.direc = true
				} else if cursorV2.X > plWorldScreenV2.X && pl.pushT == 0 {
					pl.direc = false
				}
				pl.aninum = 0
				if pl.direc {
					pl.aninum = 1
				}

				if rl.IsKeyDown(rl.KeyW) || rl.IsKeyDown(rl.KeyUp) || rl.GetGamepadAxisMovement(0, 1) < 0 { //UP
					if checkplayermove(1) {
						pl.cnt.Y -= pl.spd + delta
					}
					pl.aninum = 4
				}
				if rl.IsKeyDown(rl.KeyS) || rl.IsKeyDown(rl.KeyDown) || rl.GetGamepadAxisMovement(0, 1) > 0 { //DOWN
					if checkplayermove(3) {
						pl.cnt.Y += pl.spd + delta
					}
					pl.aninum = 2
					if pl.direc {
						pl.aninum = 3
					}
					movedown = true
				}
				if rl.IsKeyDown(rl.KeyA) || rl.IsKeyDown(rl.KeyLeft) || rl.GetGamepadAxisMovement(0, 0) < 0 { //LEFT
					if checkplayermove(4) {
						pl.cnt.X -= pl.spd + delta
					}
					pl.aninum = 3
					pl.direc = true
				}
				if rl.IsKeyDown(rl.KeyD) || rl.IsKeyDown(rl.KeyRight) || rl.GetGamepadAxisMovement(0, 0) > 0 { //RIGHT
					if checkplayermove(2) {
						pl.cnt.X += pl.spd + delta
					}
					pl.aninum = 2
					pl.direc = false
				}

				if pl.pushT > 0 {
					if pl.aninum != 4 {
						if !movedown {
							pl.aninum = 7
							if pl.direc {
								pl.aninum = 8
							}
						}
					}
					pl.pushT--
					if !rl.IsSoundPlaying(audfx[15]) {
						rl.PlaySound(audfx[15])
					}
				} else {
					if rl.IsSoundPlaying(audfx[15]) {
						rl.StopSound(audfx[15])
					}
				}
				if pl.atkT > 0 {
					pl.aninum = 5
					if pl.direc {
						pl.aninum = 6
					}
				}
			}
		}
		//UP PLAYER REC
		upplayerrec()
		//UP ROOM VISITED
		if !bosson && !treasureroom {
			for i := 0; i < len(levels[levNum].recs); i++ {
				if rl.CheckCollisionRecs(pl.rec, levels[levNum].recs[i]) {
					if !levels[levNum].inf[i].vis {
						levels[levNum].inf[i].vis = true
					}
					plroom = i
				}
			}
		}
	}
}
func upplayerrec() { //MARK:UP PLAYER REC
	if baseon {
		pl2.rec = rl.NewRectangle(pl2.cnt.X-pl2.rec.Width/2, pl2.cnt.Y-pl2.rec.Height/2, pl2.rec.Width, pl2.rec.Height)
		pl2.crec = pl2.rec
		pl2.crec.X += 4
		pl2.crec.Width -= 8
		pl2.carec = rl.NewRectangle(pl2.cnt.X-pl2.carec.Width/2, pl2.cnt.Y-pl2.carec.Height/2, pl2.carec.Width, pl2.carec.Height)
		pl.perrec = pl.carec
		pl.perrec.X -= b / 2
		pl.perrec.Y -= b / 2
		pl.perrec.Width += b
		pl.perrec.Height += b
		if stats.per > 1 {
			diff := stats.per - 1
			for diff > 0 {
				pl.perrec.X -= b / 2
				pl.perrec.Y -= b / 2
				pl.perrec.Width += b
				pl.perrec.Height += b
				diff--
			}
		}
	} else {
		pl.rec = rl.NewRectangle(pl.cnt.X-pl.rec.Width/2, pl.cnt.Y-pl.rec.Height/2, pl.rec.Width, pl.rec.Height)
		pl.crec = pl.rec
		pl.crec.X += 4
		pl.crec.Width -= 8
		pl.carec = rl.NewRectangle(pl.cnt.X-pl.carec.Width/2, pl.cnt.Y-pl.carec.Height/2, pl.carec.Width, pl.carec.Height)
		pl.perrec = pl.carec
		pl.perrec.X -= b / 2
		pl.perrec.Y -= b / 2
		pl.perrec.Width += b
		pl.perrec.Height += b
		if stats.per > 1 {
			diff := stats.per - 1
			for diff > 0 {
				pl.perrec.X -= b / 2
				pl.perrec.Y -= b / 2
				pl.perrec.Width += b
				pl.perrec.Height += b
				diff--
			}
		}
	}
}

// MARK:MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE
func makesound() { //MARK:MAKE SOUND

	music = append(music, rl.LoadMusicStream("music/title.ogg"))
	music = append(music, rl.LoadMusicStream("music/boss.ogg"))
	music = append(music, rl.LoadMusicStream("music/camp.ogg"))
	music = append(music, rl.LoadMusicStream("music/treasure.ogg"))
	music = append(music, rl.LoadMusicStream("music/01.ogg"))
	music = append(music, rl.LoadMusicStream("music/02.ogg"))
	music = append(music, rl.LoadMusicStream("music/03.ogg"))

	for i := 0; i < len(music); i++ {
		music[i].Looping = true
	}

	audfx = append(audfx, rl.LoadSound("fx/00.ogg"))  // 0 KNIFE PROJ
	audfx = append(audfx, rl.LoadSound("fx/01.ogg"))  // 1 COLLECT ITEM
	audfx = append(audfx, rl.LoadSound("fx/02.ogg"))  // 2 DESTROY CRATE
	audfx = append(audfx, rl.LoadSound("fx/03.ogg"))  // 3 OPEN CHEST
	audfx = append(audfx, rl.LoadSound("fx/04.ogg"))  // 4 BUTTON
	audfx = append(audfx, rl.LoadSound("fx/05.ogg"))  // 5 CLOSE CHEST
	audfx = append(audfx, rl.LoadSound("fx/06.ogg"))  // 6 WATER SPLASH
	audfx = append(audfx, rl.LoadSound("fx/07.ogg"))  // 7 MOVE CHEST ITEM
	audfx = append(audfx, rl.LoadSound("fx/08.ogg"))  // 8 ENEMY HIT
	audfx = append(audfx, rl.LoadSound("fx/09.ogg"))  // 9 ENEMY DEATH 1
	audfx = append(audfx, rl.LoadSound("fx/10.ogg"))  // 10 ENEMY DEATH 2
	audfx = append(audfx, rl.LoadSound("fx/11.ogg"))  // 11 ENEMY DEATH 3
	audfx = append(audfx, rl.LoadSound("fx/12.ogg"))  // 12 SPIKE TRAP
	audfx = append(audfx, rl.LoadSound("fx/13.ogg"))  // 13 FLAME TRAP
	audfx = append(audfx, rl.LoadSound("fx/14.ogg"))  // 14 PLAYER HIT
	audfx = append(audfx, rl.LoadSound("fx/15.ogg"))  // 15 PUSH CRATE
	audfx = append(audfx, rl.LoadSound("fx/16.ogg"))  // 16 DRINK POTION
	audfx = append(audfx, rl.LoadSound("fx/17.ogg"))  // 17 OPEN INVENTORY
	audfx = append(audfx, rl.LoadSound("fx/18.ogg"))  // 18 MOVE INVENTORY ITEM
	audfx = append(audfx, rl.LoadSound("fx/19.ogg"))  // 19 OPEN OPTIONS
	audfx = append(audfx, rl.LoadSound("fx/20.ogg"))  // 20 CARROTS PROJ
	audfx = append(audfx, rl.LoadSound("fx/21.ogg"))  // 21 WINDOW CLEANER PROJ
	audfx = append(audfx, rl.LoadSound("fx/22.ogg"))  // 22 RUBBER DUCK PROJ
	audfx = append(audfx, rl.LoadSound("fx/23.ogg"))  // 23 FRYING PAN PROJ
	audfx = append(audfx, rl.LoadSound("fx/24.ogg"))  // 24 ROLLING PIN PROJ
	audfx = append(audfx, rl.LoadSound("fx/25.ogg"))  // 25 MUSTARD PROJ
	audfx = append(audfx, rl.LoadSound("fx/26.ogg"))  // 26 ICE CREAM PROJ
	audfx = append(audfx, rl.LoadSound("fx/27.ogg"))  // 27 ZIPPO PROJ
	audfx = append(audfx, rl.LoadSound("fx/28.ogg"))  // 28 MAGNIFYING GLASS PROJ
	audfx = append(audfx, rl.LoadSound("fx/29.ogg"))  // 29 RASPBERRY PROJ
	audfx = append(audfx, rl.LoadSound("fx/30.ogg"))  // 30 ORBITAL LOLLY PROJ
	audfx = append(audfx, rl.LoadSound("fx/31.ogg"))  // 31 PINEAPPLE PROJ
	audfx = append(audfx, rl.LoadSound("fx/32.ogg"))  // 32 FORK PROJ
	audfx = append(audfx, rl.LoadSound("fx/33.ogg"))  // 33 CHILLI PROJ
	audfx = append(audfx, rl.LoadSound("fx/34.ogg"))  // 34 EMOJI PROJ
	audfx = append(audfx, rl.LoadSound("fx/35.ogg"))  // 35 FRENCH FRIES PROJ
	audfx = append(audfx, rl.LoadSound("fx/36.ogg"))  // 36 SOUP PROJ
	audfx = append(audfx, rl.LoadSound("fx/37.ogg"))  // 37 GUITAR PROJ
	audfx = append(audfx, rl.LoadSound("fx/38.ogg"))  // 38 DRAWING PIN PROJ
	audfx = append(audfx, rl.LoadSound("fx/39.ogg"))  // 39 SCROLL OF DETECTION
	audfx = append(audfx, rl.LoadSound("fx/40.ogg"))  // 40 SAVE SLOT INVEN MENU CLICK
	audfx = append(audfx, rl.LoadSound("fx/41.ogg"))  // 41 LOAD SAVE
	audfx = append(audfx, rl.LoadSound("fx/42.ogg"))  // 42 DELETE SAVE
	audfx = append(audfx, rl.LoadSound("fx/43.ogg"))  // 43 CONFIRM DELETE SAVE DROP ITEM GENERAL ERROR
	audfx = append(audfx, rl.LoadSound("fx/44.ogg"))  // 44 PRESS START INVEN MENU
	audfx = append(audfx, rl.LoadSound("fx/45.ogg"))  // 45 TELEPORTER
	audfx = append(audfx, rl.LoadSound("fx/46.ogg"))  // 46 BASE UNLOCK
	audfx = append(audfx, rl.LoadSound("fx/47.ogg"))  // 47 BASE UPGRADE
	audfx = append(audfx, rl.LoadSound("fx/48.ogg"))  // 48 WEAPON UPGRADE
	audfx = append(audfx, rl.LoadSound("fx/49.ogg"))  // 49 ENTER STRUCTURE
	audfx = append(audfx, rl.LoadSound("fx/50.ogg"))  // 50 ENTER DUNGEON LAUGH
	audfx = append(audfx, rl.LoadSound("fx/51.ogg"))  // 51 ENTER DUNGEON LAUGH
	audfx = append(audfx, rl.LoadSound("fx/52.ogg"))  // 52 ENTER DUNGEON LAUGH
	audfx = append(audfx, rl.LoadSound("fx/53.ogg"))  // 53 ENTER DUNGEON LAUGH
	audfx = append(audfx, rl.LoadSound("fx/54.ogg"))  // 54 ENTER DUNGEON LAUGH
	audfx = append(audfx, rl.LoadSound("fx/55.ogg"))  // 55 ENTER DUNGEON LAUGH
	audfx = append(audfx, rl.LoadSound("fx/56.ogg"))  // 56 ENTER DUNGEON LAUGH
	audfx = append(audfx, rl.LoadSound("fx/57.ogg"))  // 57 ENTER DUNGEON LAUGH
	audfx = append(audfx, rl.LoadSound("fx/58.ogg"))  // 58 OPEN BOOK
	audfx = append(audfx, rl.LoadSound("fx/59.ogg"))  // 59 OPEN BOOK
	audfx = append(audfx, rl.LoadSound("fx/60.ogg"))  // 60 OPEN BOOK
	audfx = append(audfx, rl.LoadSound("fx/61.ogg"))  // 61 OPEN BOOK
	audfx = append(audfx, rl.LoadSound("fx/62.ogg"))  // 62 OPEN BOOK
	audfx = append(audfx, rl.LoadSound("fx/63.ogg"))  // 63 OPEN BOOK
	audfx = append(audfx, rl.LoadSound("fx/64.ogg"))  // 64 OPEN BOOK
	audfx = append(audfx, rl.LoadSound("fx/65.ogg"))  // 65 COLLECT MUSHROOM STRUCTURE
	audfx = append(audfx, rl.LoadSound("fx/66.ogg"))  // 66 SCROLL POISON GAS
	audfx = append(audfx, rl.LoadSound("fx/67.ogg"))  // 67 SCROLL FROGS
	audfx = append(audfx, rl.LoadSound("fx/68.ogg"))  // 68 SCROLL INTANGIBILITY
	audfx = append(audfx, rl.LoadSound("fx/69.ogg"))  // 69 SCROLL HOME
	audfx = append(audfx, rl.LoadSound("fx/70.ogg"))  // 70 SCROLL BEGINNING
	audfx = append(audfx, rl.LoadSound("fx/71.ogg"))  // 71 SCROLL INFLICT
	audfx = append(audfx, rl.LoadSound("fx/72.ogg"))  // 72 SCROLL POWER
	audfx = append(audfx, rl.LoadSound("fx/73.ogg"))  // 73 LONG RANGE SCOPE
	audfx = append(audfx, rl.LoadSound("fx/74.ogg"))  // 74 COLLECT ARTIFACT
	audfx = append(audfx, rl.LoadSound("fx/75.ogg"))  // 75 STEROIDS
	audfx = append(audfx, rl.LoadSound("fx/76.ogg"))  // 76 WATCH
	audfx = append(audfx, rl.LoadSound("fx/77.ogg"))  // 77 SHRIMP
	audfx = append(audfx, rl.LoadSound("fx/78.ogg"))  // 78 PISTOL
	audfx = append(audfx, rl.LoadSound("fx/79.ogg"))  // 79 TURTLE
	audfx = append(audfx, rl.LoadSound("fx/80.ogg"))  // 80 ICE CREAM
	audfx = append(audfx, rl.LoadSound("fx/81.ogg"))  // 81 ICE LOLLY
	audfx = append(audfx, rl.LoadSound("fx/82.ogg"))  // 82 QUAIL EGG
	audfx = append(audfx, rl.LoadSound("fx/83.ogg"))  // 83 BEETROOT
	audfx = append(audfx, rl.LoadSound("fx/84.ogg"))  // 84 LADYBUG
	audfx = append(audfx, rl.LoadSound("fx/85.ogg"))  // 85 LADYBUG PROJ
	audfx = append(audfx, rl.LoadSound("fx/86.ogg"))  // 86 POPCORN PROJ
	audfx = append(audfx, rl.LoadSound("fx/87.ogg"))  // 87 POPCORN
	audfx = append(audfx, rl.LoadSound("fx/88.ogg"))  // 88 ORANGE SLICE
	audfx = append(audfx, rl.LoadSound("fx/89.ogg"))  // 89 TV
	audfx = append(audfx, rl.LoadSound("fx/90.ogg"))  // 90 LOLLIPOP
	audfx = append(audfx, rl.LoadSound("fx/91.ogg"))  // 91 BEES
	audfx = append(audfx, rl.LoadSound("fx/92.ogg"))  // 92 EGGS
	audfx = append(audfx, rl.LoadSound("fx/93.ogg"))  // 93 BOMB
	audfx = append(audfx, rl.LoadSound("fx/94.ogg"))  // 94 BOMB EXPLODE
	audfx = append(audfx, rl.LoadSound("fx/95.ogg"))  // 95 PSYCHEDELIC
	audfx = append(audfx, rl.LoadSound("fx/96.ogg"))  // 96 BOOTS
	audfx = append(audfx, rl.LoadSound("fx/97.ogg"))  // 97 FART GAS
	audfx = append(audfx, rl.LoadSound("fx/98.ogg"))  // 98 FART
	audfx = append(audfx, rl.LoadSound("fx/99.ogg"))  // 99 FART
	audfx = append(audfx, rl.LoadSound("fx/100.ogg")) // 100 FART
	audfx = append(audfx, rl.LoadSound("fx/101.ogg")) // 101 FART
	audfx = append(audfx, rl.LoadSound("fx/102.ogg")) // 102 SALT
	audfx = append(audfx, rl.LoadSound("fx/103.ogg")) // 103 XP BONUS
	audfx = append(audfx, rl.LoadSound("fx/104.ogg")) // 104 RED BOMB EXPLODE
	audfx = append(audfx, rl.LoadSound("fx/105.ogg")) // 105 FRYING PAN COLLIS
	audfx = append(audfx, rl.LoadSound("fx/106.ogg")) // 106 VINE
	audfx = append(audfx, rl.LoadSound("fx/107.ogg")) // 107 LIGHTNING
	audfx = append(audfx, rl.LoadSound("fx/108.ogg")) // 108 ARROWS
	audfx = append(audfx, rl.LoadSound("fx/109.ogg")) // 109 CRATE FIREWORKS
	audfx = append(audfx, rl.LoadSound("fx/110.ogg")) // 110 PROJ TURRET DROP
	audfx = append(audfx, rl.LoadSound("fx/111.ogg")) // 111 ROCKET
	audfx = append(audfx, rl.LoadSound("fx/112.ogg")) // 112 ROCKET
	audfx = append(audfx, rl.LoadSound("fx/113.ogg")) // 113 SLUDGE GEYSER
	audfx = append(audfx, rl.LoadSound("fx/114.ogg")) // 114 SWITCH ORE
	audfx = append(audfx, rl.LoadSound("fx/115.ogg")) // 115 SWITCH DARTS
	audfx = append(audfx, rl.LoadSound("fx/116.ogg")) // 116 SWITCH ENEMY
	audfx = append(audfx, rl.LoadSound("fx/117.ogg")) // 117 WEAPON CRATE
	audfx = append(audfx, rl.LoadSound("fx/118.ogg")) // 118 DESTROY WEAPON CRATE
	audfx = append(audfx, rl.LoadSound("fx/119.ogg")) // 119 COLLECT WEAPON
	audfx = append(audfx, rl.LoadSound("fx/120.ogg")) // 120 CHILLI BURN
	audfx = append(audfx, rl.LoadSound("fx/121.ogg")) // 121 IN BACKPACK
	audfx = append(audfx, rl.LoadSound("fx/122.ogg")) // 122 BOSS CHEER
	audfx = append(audfx, rl.LoadSound("fx/123.ogg")) // 123 PLAYER DEATH
	audfx = append(audfx, rl.LoadSound("fx/124.ogg")) // 124 NEXT LEVEL
	audfx = append(audfx, rl.LoadSound("fx/125.ogg")) // 125 NEXT LEVEL
	audfx = append(audfx, rl.LoadSound("fx/126.ogg")) // 126 NEXT LEVEL
	audfx = append(audfx, rl.LoadSound("fx/127.ogg")) // 127 NEXT LEVEL
	audfx = append(audfx, rl.LoadSound("fx/128.ogg")) // 128 NEXT LEVEL

}
func makeitems(lev x1scr) x1scr { //MARK:MAKE ITEMS

	/*
		zitm := itmlist[122]
		zitm.cnt = pl.cnt
		zitm.cnt.X -= b2
		zitm.cnt.Y -= b
		zitm.rec = rl.NewRectangle(zitm.cnt.X-zitm.rec.Width/2, zitm.cnt.Y-zitm.rec.Height/2, zitm.rec.Width, zitm.rec.Height)
		lev.itm = append(lev.itm, zitm)
	*/

	//INVIS
	num := RandInt(1, 4)
	for num > 0 {
		zitm := xitm{}
		zitm = invisItm[RandInt(0, len(invisItm))]
		zitm.invis = true
		countbreak := 100
		for {
			zitm.cnt = findRanCntLev(lev)
			zitm.rec = rl.NewRectangle(zitm.cnt.X-zitm.rec.Width/2, zitm.cnt.Y-zitm.rec.Height/2, zitm.rec.Width, zitm.rec.Height)
			canadd := checkaddtilerecInner(zitm.rec, lev)
			if canadd {
				canadd = checkaddetc(zitm.rec, lev)
				lev.itm = append(lev.itm, zitm)
				num--
			}
			if canadd || countbreak == 0 {
				break
			}
			countbreak--
		}
	}
	return lev
}

func makeweaponsINTIIAL() { //MARK:MAKE WEAPONS INITIAL
	siz := b / 2
	zweap := xweap{}
	zweap.col = rl.White
	zweap.fd = 1
	zweap.num = 1
	//0 KITCHEN KNIFE
	zweap.nm = "kitchen knife"
	zweap.level = 1
	zweap.weapListNum = 0
	zweap.img = etc[8]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 1
	zweap.origDMG = zweap.dmg
	zweap.spd = 4
	zweap.rospd = 8
	zweap.des = "ye olde trusty knife"
	zweap.des2 = "what better way to start any adventure than"
	zweap.des3 = "a trusty old kitchen knife? perhaps not the"
	zweap.des4 = "most formidable of choices though serves"
	zweap.des5 = "the purpose of hacking all the dungeon baddies"
	zweap.des6 = "into little pieces, like chopping onions"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//1 CARROTS
	zweap.nm = "bunch of carrots"
	zweap.weapListNum = 1
	zweap.img = etc[154]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 1
	zweap.origDMG = zweap.dmg
	zweap.spd = 5
	zweap.rospd = 0
	zweap.des = "3x projectiles"
	zweap.des2 = "vitamins are your friends unless, of course,"
	zweap.des3 = "you happen to be a dungeon baddie and mr"
	zweap.des4 = "snuggles is wielding a bunch of carrots."
	zweap.des5 = "all the minions in the dungeon cringe at the"
	zweap.des6 = "sight though at least it's not brussels sprouts"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//2 WINDOW CLEANER
	zweap.nm = "window cleaner"
	zweap.weapListNum = 2
	zweap.img = etc[156]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 1
	zweap.origDMG = zweap.dmg
	zweap.spd = 6
	zweap.rospd = 0
	zweap.des = "projectiles increase in size"
	zweap.des2 = "what could be better than lovely shiny, clean"
	zweap.des3 = "windows? well, a shiny, clean dungeon would"
	zweap.des4 = "be one thing, a few less baddies to terrorise"
	zweap.des5 = "poor mr snuggles is always a good thing. don't"
	zweap.des6 = "ponder the logistics of deadly window cleaner"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//3 RUBBER DUCK
	zweap.nm = "rubber duck"
	zweap.weapListNum = 3
	zweap.img = etc[157]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 1
	zweap.origDMG = zweap.dmg
	zweap.spd = 4
	zweap.rospd = 5
	zweap.des = "bounce & squeak"
	zweap.des2 = "remember when you were younger and bathing"
	zweap.des3 = "was a favourite past time? well, that has"
	zweap.des4 = "absolutely nothing to do with this game."
	zweap.des5 = "anyway, apart from the sometimes annoying"
	zweap.des6 = "squeak the rubber duck is a great weapon"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//4 FRYING PAN
	zweap.nm = "frying pan"
	zweap.weapListNum = 4
	zweap.img = etc[158]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 2
	zweap.origDMG = zweap.dmg
	zweap.spd = 4
	zweap.rospd = 5
	zweap.des = "collision shock wave"
	zweap.des2 = "there are a lot of kitchen implements in"
	zweap.des3 = "this game and the frying pan is perhaps"
	zweap.des4 = "one of the more useful ones. whilst a"
	zweap.des5 = "slightly slower pojectile, on enemy kill"
	zweap.des6 = "it releases a shockwave that stuns"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//5 ROLLING PIN
	zweap.nm = "rolling pin"
	zweap.weapListNum = 5
	zweap.img = etc[159]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 1
	zweap.origDMG = zweap.dmg
	zweap.spd = 5
	zweap.rospd = 7
	zweap.des = "collision > splinter projectiles"
	zweap.des2 = "making cookies, rolling pizzas, the"
	zweap.des3 = "trusty rolling pin has many uses and"
	zweap.des4 = "so why not use it to slay baddies in"
	zweap.des5 = "the dungeon? even better, as it is"
	zweap.des6 = "wood, it splinters on enemy kill"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//6 MUSTARD
	zweap.nm = "mustard"
	zweap.weapListNum = 6
	zweap.img = etc[160]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 1
	zweap.origDMG = zweap.dmg
	zweap.spd = 5
	zweap.rospd = 7
	zweap.des = "projectiles increase in size"
	zweap.des2 = "more kitchen mayhem in this rpg"
	zweap.des3 = "roguelike dungeon crawler. mustard"
	zweap.des4 = "is an erratic weapon, shooting 3"
	zweap.des5 = "projectiles, generally in slightly"
	zweap.des6 = "random directions with spread"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//7 MINT ICE CREAM
	zweap.nm = "mint ice cream"
	zweap.weapListNum = 7
	zweap.img = etc[163]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 1
	zweap.origDMG = zweap.dmg
	zweap.spd = 5
	zweap.rospd = 4
	zweap.des = "puddle of freeze"
	zweap.des2 = "what could be better than a mint"
	zweap.des3 = "ice cream cone on a hot summer's"
	zweap.des4 = "day or even on a gloomy, dingy"
	zweap.des5 = "and dank day in the dungeon?"
	zweap.des6 = "freezing sludge on enemy kill"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//8 LIGHTER
	zweap.nm = "lighter"
	zweap.weapListNum = 8
	zweap.img = etc[164]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 1
	zweap.origDMG = zweap.dmg
	zweap.spd = 5
	zweap.rospd = 4
	zweap.des = "burning trail"
	zweap.des2 = "not to be tried at home, the metal"
	zweap.des3 = "lighter is a bit of a double-edged"
	zweap.des4 = "sword, not only  inflicting damage"
	zweap.des5 = "on impact but also leaving a trail"
	zweap.des6 = "of fire in its path"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//9 MAGNIFYING GLASS
	zweap.nm = "magnifying glass"
	zweap.weapListNum = 9
	zweap.img = etc[165]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 2
	zweap.origDMG = zweap.dmg
	zweap.spd = 4
	zweap.rospd = 4
	zweap.des = "enemies increase in size"
	zweap.des2 = "officially the stupidest weapon"
	zweap.des3 = "in mr snuggles dungeon adventure"
	zweap.des4 = "the magnifying glass has a higher"
	zweap.des5 = "damage and also increases enemy size"
	zweap.des6 = "on hit, making aiming easier"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//10 RASPBERRY
	zweap.nm = "raspberry"
	zweap.weapListNum = 10
	zweap.img = etc[166]
	zweap.rec = rl.NewRectangle(0, 0, siz/3, siz/3)
	zweap.dmg = 1
	zweap.origDMG = zweap.dmg
	zweap.spd = 5
	zweap.rospd = 10
	zweap.des = "bounce & split"
	zweap.des2 = "sometimes smaller can be better and"
	zweap.des3 = "the raspberry is an excellent example"
	zweap.des4 = "of this. on bounce, the projectile"
	zweap.des5 = "duplicates and pretty soon the room"
	zweap.des6 = "is filled with deadly berries"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//11 PINEAPPLE
	zweap.nm = "pineapple"
	zweap.weapListNum = 11
	zweap.img = etc[168]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 2
	zweap.origDMG = zweap.dmg
	zweap.spd = 3
	zweap.rospd = 3
	zweap.des = "increases in size"
	zweap.des2 = "should people be allowed to use"
	zweap.des3 = "pineapple on pizza? well, if it"
	zweap.des4 = "was illegal it would be pretty"
	zweap.des5 = "difficult to police so if you want"
	zweap.des6 = "to then just go ahead and do it"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//12 FORK
	zweap.nm = "fork"
	zweap.weapListNum = 12
	zweap.img = etc[170]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 1
	zweap.origDMG = zweap.dmg
	zweap.spd = 7
	zweap.rospd = 0
	zweap.des = "multiple fast projectiles"
	zweap.des2 = "much like the prongs of a fork"
	zweap.des3 = "this projectile offers a 3 pronged"
	zweap.des4 = "accurate attack meaning that if one"
	zweap.des5 = "projectile strikes the remaining"
	zweap.des6 = "two carry on going"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//13 CHILLI
	zweap.nm = "chilli"
	zweap.weapListNum = 13
	zweap.img = etc[171]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 1
	zweap.origDMG = zweap.dmg
	zweap.spd = 5
	zweap.rospd = 7
	zweap.des = "burn on hit"
	zweap.des2 = "a chilli is a strange thing, on"
	zweap.des3 = "occasion, when cooking, you can add"
	zweap.des4 = "10 to a dish and still find it fairly"
	zweap.des5 = "mild. then, another day, you add just"
	zweap.des6 = "1 and it burns like fire"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//14 EMOJI
	zweap.nm = "emoji"
	zweap.weapListNum = 14
	zweap.img = etc[172]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 1
	zweap.origDMG = zweap.dmg
	zweap.spd = 10
	zweap.rospd = 5
	zweap.des = "fast bounce"
	zweap.des2 = "happiness is something that is often"
	zweap.des3 = "expressed using emojis when chatting"
	zweap.des4 = "and has become almost a part of our"
	zweap.des5 = "digital language. in this game they"
	zweap.des6 = "are, however, used to kill baddies"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//15 FRIES
	zweap.nm = "french fries"
	zweap.weapListNum = 15
	zweap.img = etc[173]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 1
	zweap.origDMG = zweap.dmg
	zweap.spd = 8
	zweap.rospd = 0
	zweap.des = "oil slick"
	zweap.des2 = "ever been attacked in the dark of the"
	zweap.des3 = "night by someone wielding a box of"
	zweap.des4 = "french fries? probably not, though if"
	zweap.des5 = "you are then maybe just laugh as it is"
	zweap.des6 = "very silly and the person will go away"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//16 HOT SOUP
	zweap.nm = "hot soup"
	zweap.weapListNum = 16
	zweap.img = etc[174]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 1
	zweap.origDMG = zweap.dmg
	zweap.spd = 5
	zweap.rospd = 4
	zweap.des = "puddle of hot soup burns"
	zweap.des2 = "the logistics of mr snuggles running"
	zweap.des3 = "around the dungeon carrying a ladle"
	zweap.des4 = "of hot soup is something that you"
	zweap.des5 = "may ponder on long, boring nights"
	zweap.des6 = "and if you work it out, good for you"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//17 GUITAR
	zweap.nm = "guitar"
	zweap.weapListNum = 17
	zweap.img = etc[176]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 1
	zweap.origDMG = zweap.dmg
	zweap.spd = 5
	zweap.rospd = 0
	zweap.des = "multiple fast projectiles"
	zweap.des2 = "a musical interlude is a great way to"
	zweap.des3 = "break the mundanity of playing endlessly"
	zweap.des4 = "and what better way to liven things up"
	zweap.des5 = "then by playing a bit of guitar and also"
	zweap.des6 = "killing dungoeon nasties"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
	//18 DRAWING PIN
	zweap.nm = "drawing pin"
	zweap.weapListNum = 18
	zweap.img = etc[177]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.dmg = 1
	zweap.origDMG = zweap.dmg
	zweap.spd = 7
	zweap.rospd = 0
	zweap.des = "enemies freeze in place"
	zweap.des2 = "great if you are wanting to stop enemies"
	zweap.des3 = "in their tracks, this weapon will freeze"
	zweap.des4 = "enemies in place on hit. so, if you have"
	zweap.des5 = "a wave of dungeon nasties on the way then"
	zweap.des6 = "nail them to floor with drawing pins"
	zweap.des7 = "dmg > " + fmt.Sprint(zweap.dmg)
	weap = append(weap, zweap)
}

func makeitemsINITAL() { //MARK:MAKE ITEMS INITIAL
	siz := be5
	//POTIONS
	zitm := xitm{}
	zitm.numof = 1
	zitm.rec = rl.NewRectangle(0, 0, siz, siz)
	zitm.img = anm[5].rec
	zitm.listNum = 0
	zitm.cost = 100
	zitm.nm = "hp potion full"
	zitm.des = "restores full hp"
	zitm.des2 = "while you are sleeping, every night mr snuggles gets up,"
	zitm.des3 = "leaves his tent & searches high & low for ingredients to"
	zitm.des4 = "make his potions. He doesn't just use mushrooms, often he"
	zitm.des5 = "might require berries, herbs, squirrel sweat, bark, bat"
	zitm.des6 = "testicles, lizzard toenails & other essentials to complete"
	zitm.des7 = "his secret brew. good luck mr snuggles!"
	itmlist = append(itmlist, zitm) //0
	zitm.img = anm[6].rec
	zitm.listNum = 1
	zitm.cost = 75
	zitm.costPotion = nil
	zitm.nm = "hp potion half"
	zitm.des = "restores half hp"
	zitm.des2 = "while you are sleeping, every night mr snuggles gets up,"
	zitm.des3 = "leaves his tent & searches high & low for ingredients to"
	zitm.des4 = "make his potions. He doesn't just use mushrooms, often he"
	zitm.des5 = "might require berries, herbs, squirrel sweat, bark, bat"
	zitm.des6 = "testicles, lizzard toenails & other essentials to complete"
	zitm.des7 = "his secret brew. good luck mr snuggles!"
	itmlist = append(itmlist, zitm) //1
	zitm.img = anm[7].rec
	zitm.listNum = 2
	zitm.unlok = true
	zitm.costPotion = nil
	zitm.nm = "hp potion quarter"
	zitm.des = "restores quarter hp"
	zitm.des2 = "while you are sleeping, every night mr snuggles gets up,"
	zitm.des3 = "leaves his tent & searches high & low for ingredients to"
	zitm.des4 = "make his potions. He doesn't just use mushrooms, often he"
	zitm.des5 = "might require berries, herbs, squirrel sweat, bark, bat"
	zitm.des6 = "testicles, lizzard toenails & other essentials to complete"
	zitm.des7 = "his secret brew. good luck mr snuggles!"
	itmlist = append(itmlist, zitm) //2
	zitm.img = anm[8].rec
	zitm.listNum = 3
	zitm.cost = 100
	zitm.unlok = false
	zitm.costPotion = nil
	zitm.nm = "mana potion full"
	zitm.des = "restores full mana"
	zitm.des2 = "while you are sleeping, every night mr snuggles gets up,"
	zitm.des3 = "leaves his tent & searches high & low for ingredients to"
	zitm.des4 = "make his potions. He doesn't just use mushrooms, often he"
	zitm.des5 = "might require berries, herbs, squirrel sweat, bark, bat"
	zitm.des6 = "testicles, lizzard toenails & other essentials to complete"
	zitm.des7 = "his secret brew. good luck mr snuggles!"
	itmlist = append(itmlist, zitm) //3
	zitm.img = anm[9].rec
	zitm.listNum = 4
	zitm.cost = 75
	zitm.costPotion = nil
	zitm.nm = "mana potion half"
	zitm.des = "restores half mana"
	zitm.des2 = "while you are sleeping, every night mr snuggles gets up,"
	zitm.des3 = "leaves his tent & searches high & low for ingredients to"
	zitm.des4 = "make his potions. He doesn't just use mushrooms, often he"
	zitm.des5 = "might require berries, herbs, squirrel sweat, bark, bat"
	zitm.des6 = "testicles, lizzard toenails & other essentials to complete"
	zitm.des7 = "his secret brew. good luck mr snuggles!"
	itmlist = append(itmlist, zitm) //4
	zitm.img = anm[10].rec
	zitm.listNum = 5
	zitm.unlok = true
	zitm.costPotion = nil
	zitm.nm = "mana potion quarter"
	zitm.des = "restores quarter mana"
	zitm.des2 = "while you are sleeping, every night mr snuggles gets up,"
	zitm.des3 = "leaves his tent & searches high & low for ingredients to"
	zitm.des4 = "make his potions. He doesn't just use mushrooms, often he"
	zitm.des5 = "might require berries, herbs, squirrel sweat, bark, bat"
	zitm.des6 = "testicles, lizzard toenails & other essentials to complete"
	zitm.des7 = "his secret brew. good luck mr snuggles!"
	itmlist = append(itmlist, zitm) //5
	zitm.img = anm[11].rec
	zitm.listNum = 6
	zitm.cost = 100
	zitm.unlok = false
	zitm.costPotion = nil
	zitm.nm = "resist fire full"
	zitm.des = "extinguish & immune fire > 120s"
	zitm.des2 = "burn baby burn"
	zitm.des3 = "disco inferno"
	zitm.des4 = "can be resisted for"
	zitm.des5 = "120 seconds (2 minutes)"
	zitm.des6 = "by using this potion"
	zitm.des7 = ""
	itmlist = append(itmlist, zitm) //6
	zitm.img = anm[12].rec
	zitm.listNum = 7
	zitm.cost = 75
	zitm.costPotion = nil
	zitm.nm = "resist fire half"
	zitm.des = "extinguish & immune fire > 60s"
	zitm.des2 = "burn baby burn"
	zitm.des3 = "disco inferno"
	zitm.des4 = "can be resisted for"
	zitm.des5 = "60 seconds (1 minute)"
	zitm.des6 = "by using this potion"
	zitm.des7 = ""
	itmlist = append(itmlist, zitm) //7
	zitm.img = anm[13].rec
	zitm.listNum = 8
	zitm.unlok = true
	zitm.costPotion = nil
	zitm.nm = "resist fire quarter"
	zitm.des = "extinguish & immune fire > 30s"
	zitm.des2 = "burn baby burn"
	zitm.des3 = "disco inferno"
	zitm.des4 = "can be resisted for"
	zitm.des5 = "30 seconds by"
	zitm.des6 = "using this potion"
	zitm.des7 = ""
	itmlist = append(itmlist, zitm) //8
	zitm.img = anm[14].rec
	zitm.listNum = 9
	zitm.cost = 100
	zitm.unlok = false
	zitm.costPotion = nil
	zitm.nm = "resist poison full"
	zitm.des = "cures & resist poison > 120s"
	zitm.des2 = "if you grew up a very long time ago"
	zitm.des3 = "then you may remember a famous song"
	zitm.des4 = "by alice cooper all about poison that"
	zitm.des5 = "was (and still is to some people)"
	zitm.des6 = "very popular. mr snuggles loves the"
	zitm.des7 = "song as well, so it must be good"
	itmlist = append(itmlist, zitm) //9
	zitm.img = anm[15].rec
	zitm.listNum = 10
	zitm.cost = 75
	zitm.costPotion = nil
	zitm.nm = "resist poison half"
	zitm.des = "cures & resist poison > 60s"
	zitm.des2 = "if you grew up a very long time ago"
	zitm.des3 = "then you may remember a famous song"
	zitm.des4 = "by alice cooper all about poison that"
	zitm.des5 = "was (and still is to some people)"
	zitm.des6 = "very popular. mr snuggles loves the"
	zitm.des7 = "song as well, so it must be good"
	itmlist = append(itmlist, zitm) //10
	zitm.img = anm[16].rec
	zitm.listNum = 11
	zitm.unlok = true
	zitm.costPotion = nil
	zitm.nm = "resist poison quarter"
	zitm.des = "cures & resist poison > 30s"
	zitm.des2 = "if you grew up a very long time ago"
	zitm.des3 = "then you may remember a famous song"
	zitm.des4 = "by alice cooper all about poison that"
	zitm.des5 = "was (and still is to some people)"
	zitm.des6 = "very popular. mr snuggles loves the"
	zitm.des7 = "song as well, so it must be good"
	itmlist = append(itmlist, zitm) //11
	zitm.img = anm[17].rec
	zitm.listNum = 12
	zitm.cost = 100
	zitm.unlok = false
	zitm.costPotion = nil
	zitm.nm = "invisibility full"
	zitm.des = "enemies don't follow > 90s"
	zitm.des2 = "as you already know smells are invisible"
	zitm.des3 = "though if the enemies in the dungeon"
	zitm.des4 = "tracked by smell then mr snuggles would"
	zitm.des5 = "never get any peace as he happens"
	zitm.des6 = "to be quite a smelly farter"
	zitm.des7 = ""
	itmlist = append(itmlist, zitm) //12
	zitm.img = anm[18].rec
	zitm.listNum = 13
	zitm.cost = 75
	zitm.costPotion = nil
	zitm.nm = "invisibility half"
	zitm.des = "enemies don't follow > 60s"
	zitm.des2 = "as you already know smells are invisible"
	zitm.des3 = "though if the enemies in the dungeon"
	zitm.des4 = "tracked by smell then mr snuggles would"
	zitm.des5 = "never get any peace as he happens"
	zitm.des6 = "to be quite a smelly farter"
	zitm.des7 = ""
	itmlist = append(itmlist, zitm) //13
	zitm.img = anm[19].rec
	zitm.listNum = 14
	zitm.cost = 50
	zitm.costPotion = nil
	zitm.nm = "invisibility quarter"
	zitm.des = "enemies don't follow > 30s"
	zitm.des2 = "as you already know smells are invisible"
	zitm.des3 = "though if the enemies in the dungeon"
	zitm.des4 = "tracked by smell then mr snuggles would"
	zitm.des5 = "never get any peace as he happens"
	zitm.des6 = "to be quite a smelly farter"
	zitm.des7 = ""
	itmlist = append(itmlist, zitm) //14
	zitm.img = anm[20].rec
	zitm.listNum = 15
	zitm.cost = 200
	zitm.costPotion = nil
	zitm.nm = "armor potion full"
	zitm.des = "no damage > 60s"
	zitm.des2 = "mr snuggles is quite proud of his"
	zitm.des3 = "armor potion formula and it has, on"
	zitm.des4 = "numerous occasions, saved him from"
	zitm.des5 = "certain death. unfortunately, once it"
	zitm.des6 = "wears off, he then often dies shortly"
	zitm.des7 = "afterwards, though a valiant effort"
	itmlist = append(itmlist, zitm) //15
	zitm.img = anm[21].rec
	zitm.listNum = 16
	zitm.cost = 150
	zitm.costPotion = nil
	zitm.nm = "armor potion half"
	zitm.des = "no damage > 30s"
	zitm.des2 = "mr snuggles is quite proud of his"
	zitm.des3 = "armor potion formula and it has, on"
	zitm.des4 = "numerous occasions, saved him from"
	zitm.des5 = "certain death. unfortunately, once it"
	zitm.des6 = "wears off, he then often dies shortly"
	zitm.des7 = "afterwards, though a valiant effort"
	itmlist = append(itmlist, zitm) //16
	zitm.img = anm[22].rec
	zitm.listNum = 17
	zitm.cost = 100
	zitm.costPotion = nil
	zitm.nm = "armor potion quarter"
	zitm.des = "no damage > 15s"
	zitm.des2 = "mr snuggles is quite proud of his"
	zitm.des3 = "armor potion formula and it has, on"
	zitm.des4 = "numerous occasions, saved him from"
	zitm.des5 = "certain death. unfortunately, once it"
	zitm.des6 = "wears off, he then often dies shortly"
	zitm.des7 = "afterwards, though a valiant effort"
	itmlist = append(itmlist, zitm) //17
	//SCROLLS
	zitm.img = etc[9]
	zitm.listNum = 18
	zitm.cost = 100
	zitm.mana = 1
	zitm.nm = "scroll of poison gas"
	zitm.des = "creates poison gas > +int"
	zitm.des2 = "one day mr snuggles farted on a"
	zitm.des3 = "piece of paper and, in the process,"
	zitm.des4 = "accidentally created a poison gas"
	zitm.des5 = "scroll. he still credits himself as"
	zitm.des6 = "the inventor though this is disputed"
	zitm.des7 = "max int 5 = 5 gas clouds > mana cost > 1"
	itmlist = append(itmlist, zitm) //18
	zitm.img = etc[10]
	zitm.listNum = 19
	zitm.cost = 150
	zitm.mana = 2
	zitm.nm = "scroll of frogs"
	zitm.des = "spawns frogs > +int"
	zitm.des2 = "mr snuggles has never liked frogs and"
	zitm.des3 = "hence he does not like using this scroll"
	zitm.des4 = "however his enemies all cower in fear when"
	zitm.des5 = "the dreaded scroll of frogs is used"
	zitm.des6 = "mana cost > 2"
	zitm.des7 = "max int 5 = 20 (5x4) frogs"
	itmlist = append(itmlist, zitm) //19
	zitm.img = etc[11]
	zitm.listNum = 20
	zitm.cost = 50
	zitm.mana = 2
	zitm.nm = "scroll of intangibility"
	zitm.des = "walk through some walls > 30s"
	zitm.des2 = "whether or not we live in a tangible world"
	zitm.des3 = "is a debatable point until you bump your head"
	zitm.des4 = "on something pointy. following this you realise"
	zitm.des5 = "that these types of discussions are generally"
	zitm.des6 = "rubbish and lacking any substance."
	zitm.des7 = "mana cost > 2 > return to dungeon center at end"
	itmlist = append(itmlist, zitm) //20
	zitm.img = etc[12]
	zitm.listNum = 21
	zitm.cost = 75
	zitm.mana = 1
	zitm.nm = "scroll of detection"
	zitm.des = "reveals invisible items/rooms"
	zitm.des2 = "the world around us may hide many things that"
	zitm.des3 = "we cannot see, unless of course you happen to"
	zitm.des4 = "have a handy scroll of detection lying around"
	zitm.des5 = "which makes all those invisible items visible"
	zitm.des6 = "again to be plundered for loot"
	zitm.des7 = "mana cost > 1"
	itmlist = append(itmlist, zitm) //21
	zitm.img = etc[13]
	zitm.listNum = 22
	zitm.cost = 125
	zitm.mana = 3
	zitm.nm = "scroll of home"
	zitm.des = "teleport back to camp"
	zitm.des2 = "everyone gets that feeling sometimes, when you"
	zitm.des3 = "just want to go home. not to worry, the handy"
	zitm.des4 = "scroll of home will sort that all out in a jiffy."
	zitm.des5 = "have a quick read of the scroll, snap your fingers"
	zitm.des6 = "(or teddy paws) and you are back at camp"
	zitm.des7 = "mana cost > 3"
	itmlist = append(itmlist, zitm) //22
	zitm.img = etc[14]
	zitm.listNum = 23
	zitm.cost = 100
	zitm.mana = 2
	zitm.nm = "scroll of beginning"
	zitm.des = "teleport to dungeon center"
	zitm.des2 = "being attacked by a swarm of devious"
	zitm.des3 = "dungeon critters? never fear, the scroll"
	zitm.des4 = "of beginning is here. take a quick trip"
	zitm.des5 = "back to the dungeon center and save"
	zitm.des6 = "mr snuggles from certain death"
	zitm.des7 = "mana cost > 2"
	itmlist = append(itmlist, zitm) //23
	zitm.img = etc[15]
	zitm.listNum = 24
	zitm.cost = 200
	zitm.mana = 4
	zitm.nm = "scroll of inflict"
	zitm.des = "damage all enemies > +int"
	zitm.des2 = "though not someone that generally enjoys"
	zitm.des3 = "the idea of inflicting pain onto others"
	zitm.des4 = "this is an unfortunate part of mr snuggles'"
	zitm.des5 = "job and the scroll of inflict is just the thing"
	zitm.des6 = "mana cost > 4"
	zitm.des7 = "damage = intelligence"
	itmlist = append(itmlist, zitm) //24
	zitm.img = etc[16]
	zitm.listNum = 25
	zitm.cost = 250
	zitm.mana = 5
	zitm.nm = "scroll of power"
	zitm.des = "max all stats for 30s"
	zitm.des2 = "ever wanted to be superman with super"
	zitm.des3 = "powers? the scroll of power does a"
	zitm.des4 = "pretty good job and maxes all your"
	zitm.des5 = "stats to allow you to feel like a super"
	zitm.des6 = "hero without the kryptonite worries"
	zitm.des7 = "mana cost > 5"
	itmlist = append(itmlist, zitm) //25
	//ETC
	zitm.img = etc[17]
	zitm.listNum = 26
	zitm.cost = 50
	zitm.mana = 0
	zitm.nm = "long range scope"
	zitm.des = "bird's eye view"
	zitm.des2 = "flying above the world like an eagle"
	zitm.des3 = "is not something you will ever experience"
	zitm.des4 = "however the long range scope gives you"
	zitm.des5 = "a pretty good idea of what the dungeon looks"
	zitm.des6 = "like from above, despite not being a bird"
	zitm.des7 = "cooldown > 10s"
	itmlist = append(itmlist, zitm) //26
	zitm.img = etc[18]
	zitm.nocrate = true
	zitm.listNum = 27
	zitm.cost = 50
	zitm.notquick = true
	zitm.nm = "tools"
	zitm.des = ""
	zitm.des2 = ""
	zitm.des3 = ""
	zitm.des4 = ""
	zitm.des5 = ""
	zitm.des6 = ""
	zitm.des7 = ""
	itmlist = append(itmlist, zitm) //27
	zitm.img = etc[19]
	zitm.nocrate = false
	zitm.listNum = 28
	zitm.cost = 75
	zitm.notquick = false
	zitm.art = true
	zitm.nm = "gas can"
	zitm.des = "explosion chance > stacks"
	zitm.des2 = "whilst not a violent person, under the"
	zitm.des3 = "circumstances mr snuggles has had to"
	zitm.des4 = "adapt and hence learned to fashion"
	zitm.des5 = "explosive gas bombs that inflict damage on"
	zitm.des6 = "adjacent enemies. possibly not as creative"
	zitm.des7 = "as knitting, though it passes the time"
	itmlist = append(itmlist, zitm) //28
	zitm.img = etc[20]
	zitm.nocrate = true
	zitm.listNum = 29
	zitm.cost = 50
	zitm.art = false
	zitm.notquick = true
	zitm.nm = "battery"
	zitm.des = ""
	zitm.des2 = ""
	zitm.des3 = ""
	zitm.des4 = ""
	zitm.des5 = ""
	zitm.des6 = ""
	zitm.des7 = ""
	itmlist = append(itmlist, zitm) //29
	zitm.img = etc[21]
	zitm.nocrate = false
	zitm.listNum = 30
	zitm.cost = 100
	zitm.nm = "map"
	zitm.des = "reveals location of interest"
	zitm.des2 = "be warned, the promise of treasure"
	zitm.des3 = "has lured many dungeon adventurers"
	zitm.des4 = "to untimely deaths. chasing after"
	zitm.des5 = "loot without preparing first can be"
	zitm.des6 = "a very unwise decision."
	zitm.des7 = "can only be used at camp"
	itmlist = append(itmlist, zitm) //30
	zitm.img = etc[22]
	zitm.listNum = 31
	zitm.cost = 75
	zitm.art = true
	zitm.nm = "backpack"
	zitm.des = "adds one inventory slot"
	zitm.des2 = "how any video game character is ever"
	zitm.des3 = "expected to carry as much as they do is"
	zitm.des4 = "something that has always puzzled mr"
	zitm.des5 = "snuggles. that was until he discovered"
	zitm.des6 = "the magical backpack, like carrying narnia"
	zitm.des7 = "around in a handy, portable accessory."
	itmlist = append(itmlist, zitm) //31
	zitm.img = etc[23]
	zitm.nocrate = true
	zitm.listNum = 32
	zitm.cost = 75
	zitm.art = false
	zitm.nm = "ammo box"
	zitm.des = ""
	zitm.des2 = ""
	zitm.des3 = ""
	zitm.des4 = ""
	zitm.des5 = ""
	zitm.des6 = ""
	zitm.des7 = ""
	itmlist = append(itmlist, zitm) //32
	zitm.img = etc[24]
	zitm.nocrate = false
	zitm.listNum = 33
	zitm.cost = 75
	zitm.notquick = false
	zitm.nm = "steroids"
	zitm.des = "strength = 5 max > 30s"
	zitm.des2 = "not normally one to toy with such serious"
	zitm.des3 = "things, under dire circumstances mr snuggles"
	zitm.des4 = "has had to forgo his virtuous nature as a"
	zitm.des5 = "means to survive the treacherous dungeon."
	zitm.des6 = "it is also a lot of fun to be very strong as"
	zitm.des7 = "enemies die a lot faster"
	itmlist = append(itmlist, zitm) //33
	zitm.img = etc[25]
	zitm.listNum = 34
	zitm.cost = 200
	zitm.art = true
	zitm.nm = "medikit"
	zitm.des = "revives mr snuggles on death"
	zitm.des2 = "how does it work you may ask, the answer"
	zitm.des3 = "is no one knows. a magical device that,"
	zitm.des4 = "just in the nick of time, manages to revive"
	zitm.des5 = "poor mr snuggles and return him to full health"
	zitm.des6 = "until the next time it happens"
	zitm.des7 = "full hp > return to dungeon center"
	itmlist = append(itmlist, zitm) //34
	zitm.img = etc[26]
	zitm.listNum = 35
	zitm.cost = 150
	zitm.nm = "brain"
	zitm.des = "+1 intelligence"
	zitm.des2 = "not to be confused with zombie brains"
	zitm.des3 = "mr snuggles uses only the finest rat"
	zitm.des4 = "brains that he can find in the dank,"
	zitm.des5 = "dingy dungeon to bolster his intellect"
	zitm.des6 = "and help him to cast better spells"
	zitm.des7 = "+1 int > max = 5"
	zitm.art = true
	itmlist = append(itmlist, zitm) //35
	zitm.img = etc[27]
	zitm.listNum = 36
	zitm.cost = 150
	zitm.nm = "eyeball"
	zitm.des = "+1 perception"
	zitm.des2 = "as you can imagine, dungeons often have an"
	zitm.des3 = "abundance of items you generally won't find"
	zitm.des4 = "anywhere else and bat eyeballs is one of the"
	zitm.des5 = "more useful bits and bobs that mr snuggles uses"
	zitm.des6 = "to help him seek out invisible loot"
	zitm.des7 = "+1 per > max = 5"
	itmlist = append(itmlist, zitm) //36
	zitm.img = etc[28]
	zitm.listNum = 37
	zitm.cost = 150
	zitm.nm = "bear trap"
	zitm.des = "leave traps behind > stacks"
	zitm.des2 = "stuck in a tight situation? then a bear"
	zitm.des3 = "trap might be the culprit so check that"
	zitm.des4 = "you are not standing in one, though it"
	zitm.des5 = "would probably be apparent from the"
	zitm.des6 = "significant pain being experienced"
	zitm.des7 = "more traps = more drops > max 5"
	itmlist = append(itmlist, zitm) //37
	zitm.img = etc[50]
	zitm.listNum = 38
	zitm.cost = 100
	zitm.nm = "gold"
	zitm.des = "used for upgrades"
	zitm.art = false
	zitm.notquick = true
	zitm.des2 = "all that glitters is not gold, except gold which is."
	zitm.des3 = "mr snuggles uses the gold that he finds in the dungeon"
	zitm.des4 = "to upgrade his equipment so he can repeat the cycle"
	zitm.des5 = "of bashing crates, finding more precious items that he"
	zitm.des6 = "can upgrade to repeat the cycle of bashing more crates"
	zitm.des7 = "and so on, until you get bored of this game"
	itmlist = append(itmlist, zitm) //38
	zitm.img = etc[51]
	zitm.listNum = 39
	zitm.cost = 75
	zitm.nm = "silver"
	zitm.des = "used for upgrades"
	zitm.des2 = "silver is not the stuff used for tin foil hats that"
	zitm.des3 = "protect you from the television's brainwashing waves."
	zitm.des4 = "whilst this may be misinformation, if you ever feel you"
	zitm.des5 = "may be at risk of brainswashing from your tv then google"
	zitm.des6 = "tin foil hat tv brainwashing and the wikipedia entry has"
	zitm.des7 = "some interesting facts you may want to read"
	itmlist = append(itmlist, zitm) //39
	zitm.img = etc[52]
	zitm.listNum = 40
	zitm.cost = 50
	zitm.nm = "bronze"
	zitm.des = "used for upgrades"
	zitm.des2 = "bronzer is something any 80's child may remember from"
	zitm.des3 = "popular television shows where men with too much facial"
	zitm.des4 = "hair drove around in fancy cars wearing hawaiian shirts."
	zitm.des5 = "these men were generally 'bronzed' which was acheived by"
	zitm.des6 = "the application of a 'bronzer' or, as you may know it,"
	zitm.des7 = "fake tanning lotion"
	itmlist = append(itmlist, zitm) //40
	zitm.img = etc[53]
	zitm.listNum = 41
	zitm.cost = 25
	zitm.nm = "lead"
	zitm.des = "used for upgrades"
	zitm.des2 = "lead is something that has always intrigued the narrator"
	zitm.des3 = "so heavy and solid, yet when you take a swiss army knife"
	zitm.des4 = "to it, it can be easily marked, quite a remarkable metal."
	zitm.des5 = "the most common place you will have seen lead would be"
	zitm.des6 = "used as fishing weights or 'sinkers'"
	zitm.des7 = ""
	itmlist = append(itmlist, zitm) //41
	zitm.img = etc[54]
	zitm.listNum = 42
	zitm.nm = "platinum"
	zitm.cost = 150
	zitm.des = "used for upgrades"
	zitm.des2 = "this stuff is expensive so use it sparingly please"
	zitm.des3 = "the ultimate in upgrade material, platinum will"
	zitm.des4 = "help mr snuggles to reach his goal of conquering"
	zitm.des5 = "the nasties in the dungeon and reaching the end"
	zitm.des6 = "of this incredibly silly game about a teddy bear"
	zitm.des7 = "in a dungeon"
	itmlist = append(itmlist, zitm) //42
	zitm.img = etc[55]
	zitm.listNum = 43
	zitm.unlok = true
	zitm.nm = "scrap"
	zitm.des = "used for unlocks"
	zitm.des2 = "scrap is found throughout the dungeon and is"
	zitm.des3 = "obtained by destroying crates, a tedious chore"
	zitm.des4 = "you may sometimes think, however, how else will"
	zitm.des5 = "you ever finish the game? so keep bashing"
	zitm.des6 = "crates and onto glory mr snuggles!"
	zitm.des7 = ""
	itmlist = append(itmlist, zitm) //43
	zitm.img = etc[56]
	zitm.uniq = true
	zitm.listNum = 44
	zitm.cost = 50
	zitm.unlok = false
	zitm.nm = "watch"
	zitm.des = "slower enemies > 30s"
	zitm.notquick = false
	zitm.des2 = "if i could turn back time was a song that"
	zitm.des3 = "was popular and is somewhat related to"
	zitm.des4 = "the power of the watch. though mr snuggles"
	zitm.des5 = "cannot turn back time he is able to slow it"
	zitm.des6 = "down a bit and dungeon nasties move slower"
	zitm.des7 = "cooldown 30s"
	itmlist = append(itmlist, zitm) //44
	zitm.img = etc[57]
	zitm.uniq = false
	zitm.listNum = 45
	zitm.cost = 50
	zitm.nm = "shrimp"
	zitm.des = "+3 shrimp shell armor"
	zitm.des2 = "ever had a shrimp with a super tough shell"
	zitm.des3 = "and thought maybe i could use this as armor"
	zitm.des4 = "if i was a teddy bear trapped in a dungeon?"
	zitm.des5 = "probably not, though the next time you eat"
	zitm.des6 = "a tough shrimp then remember these words and"
	zitm.des7 = "try and fashion yourself some shrimp scale mail"
	itmlist = append(itmlist, zitm) //45
	zitm.img = etc[58]
	zitm.listNum = 46
	zitm.cost = 75
	zitm.nm = "flask of slug pee"
	zitm.des = "move faster > 30s"
	zitm.des2 = "whilst the slug is a slow moving creature,"
	zitm.des3 = "you would be surprised to know that a"
	zitm.des4 = "little known extract from slug pee can"
	zitm.des5 = "have the most amazing effect on a teddy bear's"
	zitm.des6 = "walking speed. just a little sip and mr"
	zitm.des7 = "snuggles moves around at double pace"
	itmlist = append(itmlist, zitm) //46
	zitm.img = etc[59]
	zitm.listNum = 47
	zitm.cost = 75
	zitm.nm = "pistol"
	zitm.des = "faster attack > 30s"
	zitm.des2 = "mr snuggles the game as an entity and the"
	zitm.des3 = "character himself do not condone violence in"
	zitm.des4 = "video games, hence this game is very cutesy"
	zitm.des5 = "wutsey. however sometimes it is necessary to add"
	zitm.des6 = "guns to spice things up a bit though this"
	zitm.des7 = "remains a surrealist recreational experience"
	itmlist = append(itmlist, zitm) //47
	zitm.img = etc[60]
	zitm.listNum = 48
	zitm.cost = 100
	zitm.nm = "turtle"
	zitm.des = "take no damage > 15s"
	zitm.des2 = "turtles have thick shells and act as armor"
	zitm.des3 = "for their soft insides and, for this reason,"
	zitm.des4 = "they make an excellent choice for any dungeon"
	zitm.des5 = "adventurer seeking to protect himself from"
	zitm.des6 = "harm from the various dreadful creatures"
	zitm.des7 = "lurking the dungeon depths"
	itmlist = append(itmlist, zitm) //48
	zitm.img = etc[61]
	zitm.listNum = 49
	zitm.cost = 125
	zitm.art = true
	zitm.nm = "sneakers"
	zitm.des = "+1 move speed > stacks"
	zitm.des2 = "there is nothing like a brisk stroll"
	zitm.des3 = "to clear one's mind and sneakers help"
	zitm.des4 = "mr snuggles move just a little faster."
	zitm.des5 = "collect more and he moves even quicker"
	zitm.des6 = "making it easier to escape the range of"
	zitm.des7 = "horrible nasty dungeon creatures"
	itmlist = append(itmlist, zitm) //49
	zitm.img = etc[62]
	zitm.listNum = 50
	zitm.cost = 50
	zitm.art = false
	zitm.nm = "soda"
	zitm.des = "+1 hp & faster movement > 30s"
	zitm.des2 = "nothing like a refreshing soda to"
	zitm.des3 = "liven oneself up and mr snuggles"
	zitm.des4 = "really enjoys a refreshing drink"
	zitm.des5 = "whilst completing the arduous task"
	zitm.des6 = "of clearing the dungeon of nasty"
	zitm.des7 = "creatures and baddies"
	itmlist = append(itmlist, zitm) //50
	zitm.img = etc[63]
	zitm.listNum = 51
	zitm.nocrate = true
	zitm.notquick = true
	zitm.nm = "key"
	zitm.des = "store room key > unlock"
	zitm.des2 = ""
	zitm.des3 = ""
	zitm.des4 = ""
	zitm.des5 = ""
	zitm.des6 = ""
	zitm.des7 = ""
	itmlist = append(itmlist, zitm) //51
	zitm.img = etc[64]
	zitm.listNum = 52
	zitm.cost = 75
	zitm.nocrate = false
	zitm.art = true
	zitm.notquick = false
	zitm.nm = "sunglasses"
	zitm.des = "+1 critical hit chance > stacks"
	zitm.des2 = "whilst sunglasses probably do not"
	zitm.des3 = "improve one's visual acuity in a"
	zitm.des4 = "dingy dungeon as, one would assume,"
	zitm.des5 = "everything would get darker please"
	zitm.des6 = "try and not take things so seriously"
	zitm.des7 = "this is a video game, not real life"
	itmlist = append(itmlist, zitm) //52
	zitm.img = etc[65]
	zitm.listNum = 53
	zitm.cost = 50
	zitm.art = false
	zitm.nm = "ice cream"
	zitm.des = "freeze enemies > 10s"
	zitm.des2 = "the horrible sludge of melted ice"
	zitm.des3 = "cream is an excellent way of"
	zitm.des4 = "slowing down any potential enemies"
	zitm.des5 = "heading in mr snuggles direction"
	zitm.des6 = "freezing them in place giving him"
	zitm.des7 = "ample opportunity to attack"
	itmlist = append(itmlist, zitm) //53
	zitm.img = etc[66]
	zitm.listNum = 54
	zitm.cost = 100
	zitm.art = true
	zitm.nm = "basketball"
	zitm.des = "projectiles bounce > stacks"
	zitm.des2 = "what could be better than recycling"
	zitm.des3 = "a weapon projectile via a bounce? well"
	zitm.des4 = "possibly recycling a projectile more"
	zitm.des5 = "than once if you collect more than one"
	zitm.des6 = "basketball. mr snuggles weapons will now"
	zitm.des7 = "bounce against the walls"
	itmlist = append(itmlist, zitm) //54
	zitm.img = etc[67]
	zitm.listNum = 55
	zitm.cost = 50
	zitm.art = false
	zitm.nm = "jar of gas"
	zitm.des = "chance to inflict burn > 30s"
	zitm.des2 = "mr snuggles uses the jar of gas to"
	zitm.des3 = "douse his weapons meaning that when"
	zitm.des4 = "they impact with nasties and baddies"
	zitm.des5 = "that there is a chance that they will"
	zitm.des6 = "inflict burn which means that over a"
	zitm.des7 = "few seconds more damage is done"
	itmlist = append(itmlist, zitm) //55
	zitm.img = etc[68]
	zitm.listNum = 56
	zitm.cost = 50
	zitm.nm = "jar of blood"
	zitm.des = "chance to inflict bleed > 30s"
	zitm.des2 = "the jar of blood is used to further"
	zitm.des3 = "enhance mr snuggles weapons meaning"
	zitm.des4 = "that they inflict further bleed damage"
	zitm.des5 = "over time. the nice thing, if that is the"
	zitm.des6 = "correct word, is that bleed damage stacks"
	zitm.des7 = "with more hits on the same enemy"
	itmlist = append(itmlist, zitm) //56
	zitm.img = etc[69]
	zitm.nocrate = true
	zitm.listNum = 57
	zitm.cost = 25
	zitm.nm = "record"
	zitm.des = "unlocks new music"
	zitm.des2 = ""
	zitm.des3 = ""
	zitm.des4 = ""
	zitm.des5 = ""
	zitm.des6 = ""
	zitm.des7 = ""
	itmlist = append(itmlist, zitm) //57
	zitm.img = etc[70]
	zitm.nocrate = false
	zitm.listNum = 58
	zitm.cost = 75
	zitm.art = true
	zitm.nm = "broccoli"
	zitm.des = "poison gas on hit > stacks"
	zitm.des2 = "smelly, smelly brocolli may be good for you"
	zitm.des3 = "though when used to make a poison gas can be"
	zitm.des4 = "quite harmful to all the dreadful foes in the"
	zitm.des5 = "dungeon, so baddies beware."
	zitm.des6 = "increased stack > increased chance of gas"
	zitm.des7 = "max 6 > rolls 1 dice > 6 = 100% chance"
	itmlist = append(itmlist, zitm) //58
	zitm.img = etc[71]
	zitm.listNum = 59
	zitm.cost = 10
	zitm.nm = "drill"
	zitm.des = "single hit destroys crates"
	zitm.des2 = "at the start of every new run mr snuggles"
	zitm.des3 = "will be bashing crates repeatedly as a"
	zitm.des4 = "means of annoyance. the drill makes it much"
	zitm.des5 = "easier for him to break open crates and saves"
	zitm.des6 = "you the exertion of having to press mouse"
	zitm.des7 = "or controller buttons extra times"
	itmlist = append(itmlist, zitm) //59
	zitm.img = etc[72]
	zitm.listNum = 60
	zitm.cost = 150
	zitm.art = false
	zitm.notquick = true
	zitm.nm = "cook book"
	zitm.des = "1 free unlock < 100xp "
	zitm.des2 = "the dungeon is filled with weird &"
	zitm.des3 = "wonderful things so what better place"
	zitm.des4 = "to write a cook book using all the odd"
	zitm.des5 = "things that mr snuggles finds whilst"
	zitm.des6 = "wandering the dingy corridors of these"
	zitm.des7 = "gloomy depths"
	itmlist = append(itmlist, zitm) //60
	zitm.img = etc[73]
	zitm.listNum = 61
	zitm.cost = 50
	zitm.notquick = false
	zitm.nm = "ice lolly"
	zitm.des = "extinguish & immune fire > 15s"
	zitm.des2 = "nothing like a cool ice lolly on a hot"
	zitm.des3 = "summer's day or if mr snuggles is, or"
	zitm.des4 = "going to be, on fire. the coolness of"
	zitm.des5 = "the lolly really helps when the flames"
	zitm.des6 = "are quickly melting his cheap polyester "
	zitm.des7 = "fluff on their way to his stuffing"
	itmlist = append(itmlist, zitm) //61
	zitm.img = etc[74]
	zitm.listNum = 62
	zitm.cost = 50
	zitm.art = true
	zitm.nm = "toilet paper"
	zitm.des = "more (s)crap drop > stacks"
	zitm.des2 = "whether this is an anagram, a pun, or"
	zitm.des3 = "merely a clever play on words is anyone's"
	zitm.des4 = "guess however the author/developer of this"
	zitm.des5 = "game thought that he was quite clever to"
	zitm.des6 = "have accidentally thought of it"
	zitm.des7 = "max 6 > rolls 1 dice > 6 = 100% chance"
	itmlist = append(itmlist, zitm) //62
	zitm.img = etc[75]
	zitm.listNum = 63
	zitm.cost = 100
	zitm.nm = "garlic"
	zitm.des = "chance to heal on kill > stacks"
	zitm.des2 = "vampires are known to not like garlic"
	zitm.des3 = "very much though mr snuggles loves it."
	zitm.des4 = "when not toiling away in the dungeon he"
	zitm.des5 = "loves to make pasta sauces & garlic"
	zitm.des6 = "makes them even more delicious."
	zitm.des7 = "max 12 > rolls 2 dice > 12 = 100% chance"
	itmlist = append(itmlist, zitm) //63
	zitm.img = etc[76]
	zitm.listNum = 64
	zitm.cost = 75
	zitm.nm = "tenderiser"
	zitm.des = "stun on hit > stacks"
	zitm.des2 = "one would not think that tenderisers and"
	zitm.des3 = "any other kitchen equipment would be"
	zitm.des4 = "quite so prevalent in a dungeon as they"
	zitm.des5 = "are in this video game. this leaves the"
	zitm.des6 = "player something to ponder for the evening"
	zitm.des7 = "max 6 > rolls 1 dice > 6 = 100% chance"
	itmlist = append(itmlist, zitm) //64
	zitm.img = etc[77]
	zitm.listNum = 65
	zitm.cost = 75
	zitm.nm = "cleaver"
	zitm.des = "split projectile on hit > stacks"
	zitm.des2 = "one would probably, or possibly, have seen"
	zitm.des3 = "coconuts being halved using a large knife or"
	zitm.des4 = "machete. the cleaver works very much on the"
	zitm.des5 = "same prinicple, splitting the weapon into two"
	zitm.des6 = "and sending the duplicate in a new direction"
	zitm.des7 = "max 6 > rolls 1 dice > 6 = 100% chance"
	itmlist = append(itmlist, zitm) //65
	zitm.img = etc[78]
	zitm.listNum = 66
	zitm.cost = 100
	zitm.nm = "bottle of death"
	zitm.des = "extra xp per kill > stacks"
	zitm.des2 = "xp is how mr snuggles unlocks the various"
	zitm.des3 = "items that he finds in the crates and then"
	zitm.des4 = "uses to help reach the end of the dungeon."
	zitm.des5 = "so he won't be complaining when he acquires"
	zitm.des6 = "this artifact increasing xp per kill"
	zitm.des7 = "max 5"
	itmlist = append(itmlist, zitm) //66
	zitm.img = etc[92]
	zitm.listNum = 67
	zitm.cost = 150
	zitm.nm = "basketball sneakers"
	zitm.des = "+1 dexterity > stacks"
	zitm.des2 = "dexterity is something you may not think"
	zitm.des3 = "you need or actually see happening in the"
	zitm.des4 = "game however when you have 1 hp left and"
	zitm.des5 = "accidently stand on a spike trap that kills"
	zitm.des6 = "you then remember dexterity & dodge chance"
	zitm.des7 = "+1 dex > max = 5"
	itmlist = append(itmlist, zitm) //67
	zitm.img = etc[91]
	zitm.listNum = 68
	zitm.nm = "dumbbell"
	zitm.cost = 200
	zitm.des = "+1 strength > stacks"
	zitm.des2 = "funnily enough this makes mr snuggles"
	zitm.des3 = "stronger and therefore increases attack"
	zitm.des4 = "damage meaning that nasties will require"
	zitm.des5 = "less hits to die. this will make the game"
	zitm.des6 = "easier & might be something to unlock first"
	zitm.des7 = "+1 str > max = 5"
	itmlist = append(itmlist, zitm) //68
	zitm.img = etc[90]
	zitm.listNum = 69
	zitm.cost = 150
	zitm.nm = "dice"
	zitm.des = "+1 luck > stacks"
	zitm.des2 = "when christmas arrives and you only have"
	zitm.des3 = "one present under the tree and you think"
	zitm.des4 = "i really hope this magically transforms"
	zitm.des5 = "into two is exactly how luck works, extra"
	zitm.des6 = "loots drops with higher luck"
	zitm.des7 = "+1 luk > max = 5"
	itmlist = append(itmlist, zitm) //69
	zitm.img = etc[93]
	zitm.listNum = 70
	zitm.cost = 150
	zitm.nm = "ring of vine"
	zitm.rec = rl.NewRectangle(0, 0, be3, be3)
	zitm.des = "escapes on 1 hp > +2 hp"
	zitm.des2 = "the developer cannot remember where he"
	zitm.des3 = "got this idea from though it is copied"
	zitm.des4 = "from another video game he played a long"
	zitm.des5 = "time ago and remains a good idea, when hp"
	zitm.des6 = "is low mr snuggles is rescued by a vine"
	zitm.des7 = "1 use per run"
	itmlist = append(itmlist, zitm) //70
	zitm.img = etc[94]
	zitm.listNum = 71
	zitm.cost = 125
	zitm.nm = "ring of thorns"
	zitm.des = "damages enemies on player hit"
	zitm.des2 = "no one likes getting hit and neither does"
	zitm.des3 = "mr snuggles. the ring of thorns offers a"
	zitm.des4 = "form of retribution when mr snuggles loses"
	zitm.des5 = "hp damaging nearby enemies and thereby"
	zitm.des6 = "helping them to empathise"
	zitm.des7 = "any player dmg > dmg nearby enemies"
	itmlist = append(itmlist, zitm) //71
	zitm.img = etc[95]
	zitm.listNum = 72
	zitm.cost = 125
	zitm.nm = "ring of twin"
	zitm.des = "fire backwards"
	zitm.des2 = "why settle for weapon projectiles in"
	zitm.des3 = "one direction when you could have two"
	zitm.des4 = "sets of projectiles being fired at the"
	zitm.des5 = "same time? the ring of twin does just"
	zitm.des6 = "that and helps to ensure that any nasty"
	zitm.des7 = "in the opposing direction also gets hit"
	itmlist = append(itmlist, zitm) //72
	zitm.img = etc[96]
	zitm.listNum = 73
	zitm.cost = 75
	zitm.art = false
	zitm.nm = "quail egg"
	zitm.des = "creates tornado stuns > 30s"
	zitm.des2 = "how does a quail egg summon a"
	zitm.des3 = "tornado? mr snuggles has pondered"
	zitm.des4 = "this question many an evening in"
	zitm.des5 = "front of the camp fire and it"
	zitm.des6 = "remains one of the many unsolved"
	zitm.des7 = "mysteries of the dungeon"
	itmlist = append(itmlist, zitm) //73
	zitm.img = etc[97]
	zitm.listNum = 74
	zitm.cost = 125
	zitm.art = true
	zitm.rec = rl.NewRectangle(0, 0, siz, siz)
	zitm.nm = "tesla coil"
	zitm.des = "electric field every 5 kills"
	zitm.des2 = "one of the more 'shocking' items"
	zitm.des3 = "found in the dungeon, excuse the pun."
	zitm.des4 = "after making a certain number of kills"
	zitm.des5 = "a field of electricity will stun and"
	zitm.des6 = "damage nearby baddies and nasties and"
	zitm.des7 = "is an excellent addition to any run"
	itmlist = append(itmlist, zitm) //74
	zitm.img = etc[98]
	zitm.listNum = 75
	zitm.cost = 100
	zitm.nm = "amulet of purple rain"
	zitm.des = "damaging rain every 4 kills"
	zitm.des2 = "there used to be a musician by the"
	zitm.des3 = "name of prince after which one of"
	zitm.des4 = "his songs this item is named. his"
	zitm.des5 = "own particular name became"
	zitm.des6 = "increasingly difficult to"
	zitm.des7 = "determine & remains unclear"
	itmlist = append(itmlist, zitm) //75
	zitm.img = etc[99]
	zitm.listNum = 76
	zitm.cost = 100
	zitm.nm = "amulet of disc"
	zitm.des = "damaging disc every 7 kills"
	zitm.des2 = "if you are reading this and are maybe"
	zitm.des3 = "wondering what is a disc or disk then"
	zitm.des4 = "you started playing video games a long"
	zitm.des5 = "time after i did so please don't ask"
	zitm.des6 = "silly questions & rather play the game"
	zitm.des7 = "10s duration"
	itmlist = append(itmlist, zitm) //76
	zitm.img = etc[100]
	zitm.listNum = 77
	zitm.cost = 100
	zitm.nm = "belt of whipping"
	zitm.des = "inflicts bleed > stacks"
	zitm.des2 = "a rather cruel though effective use for a"
	zitm.des3 = "belt, every certain number of attacks"
	zitm.des4 = "nearby enemies will be whipped by mr"
	zitm.des5 = "snuggles belt though it remains a"
	zitm.des6 = "dastardly form of punishment"
	zitm.des7 = "more belts = more whips"
	itmlist = append(itmlist, zitm) //77
	zitm.img = etc[101]
	zitm.listNum = 78
	zitm.cost = 150
	zitm.nm = "mirror"
	zitm.des = "does what it says on the box"
	zitm.des2 = "what could be better than mr snuggles?"
	zitm.des3 = "well, two mr snuggles maybe & the mirror"
	zitm.des4 = "does exactly that, making a mirror copy"
	zitm.des5 = "of mr snuggles who attacks in the opposite"
	zitm.des6 = "direction & theoretically should assist"
	zitm.des7 = "though aiming can be tricky"
	itmlist = append(itmlist, zitm) //78
	zitm.img = etc[102]
	zitm.listNum = 79
	zitm.cost = 100
	zitm.nm = "toxic sludge"
	zitm.des = "trail of poison sludge "
	zitm.des2 = "a classic video game & comic book idea,"
	zitm.des3 = "the ubiquitous 'toxic sludge' did of"
	zitm.des4 = "course make an appearance in mr snuggles"
	zitm.des5 = "dungeon adventure and is likely to appear"
	zitm.des6 = "in many future video games all around the"
	zitm.des7 = "world so watch this space"
	itmlist = append(itmlist, zitm) //79
	zitm.img = etc[103]
	zitm.listNum = 80
	zitm.cost = 75
	zitm.nm = "throwing knife"
	zitm.des = "auto knives > stacks"
	zitm.des2 = "classic rpg fare, what dungeon adventure"
	zitm.des3 = "is complete without throwing knives. the"
	zitm.des4 = "knives will automatically fire at interval"
	zitm.des5 = "damaging any nasties in their path, the"
	zitm.des6 = "more you collect the more knives are thrown"
	zitm.des7 = "max 8 > 8 directions"
	itmlist = append(itmlist, zitm) //80
	zitm.img = etc[104]
	zitm.listNum = 81
	zitm.cost = 50
	zitm.art = false
	zitm.nm = "beetroot"
	zitm.des = "inflicts 'rain of beetroot'"
	zitm.des2 = "the lost 11th plague of the bible that"
	zitm.des3 = "no one talks about - 'rain of beetroot'."
	zitm.des4 = "the scourge of all dungeon critters this"
	zitm.des5 = "attack causes a high damage rain of"
	zitm.des6 = "taproots, the stuff of nightmares, note"
	zitm.des7 = "not to be used in soup preparation."
	itmlist = append(itmlist, zitm) //81
	zitm.img = etc[105]
	zitm.listNum = 82
	zitm.cost = 125
	zitm.art = true
	zitm.nm = "magicians hat"
	zitm.des = "+1 mana > stacks"
	zitm.des2 = "using scrolls uses mana and, just like"
	zitm.des3 = "hp this is in short supply and will"
	zitm.des4 = "need to be refilled. the more mana you"
	zitm.des5 = "have the more powerful scrolls can be used"
	zitm.des6 = "hence the magicians hat is a must have item"
	zitm.des7 = "max 5 = +5 mana"
	itmlist = append(itmlist, zitm) //82
	zitm.img = etc[106]
	zitm.listNum = 83
	zitm.cost = 200
	zitm.rec = rl.NewRectangle(0, 0, be3, be3)
	zitm.nm = "pearl"
	zitm.des = "+1 hp > stacks"
	zitm.des2 = "as in most video games, hp is a crucial"
	zitm.des3 = "element of your success or failure in"
	zitm.des4 = "mr snuggles dungeon adventure and having"
	zitm.des5 = "a higher hp max will increase your chances"
	zitm.des6 = "of success, so collect pearls"
	zitm.des7 = "max 5 = +5 hp"
	itmlist = append(itmlist, zitm) //83
	zitm.img = etc[107]
	zitm.listNum = 84
	zitm.cost = 100
	zitm.rec = rl.NewRectangle(0, 0, siz, siz)
	zitm.nm = "candy cane"
	zitm.des = "faster attack > stacks"
	zitm.des2 = "the faster mr snuggles throws projectiles"
	zitm.des3 = "the faster that enemies die, in theory, as"
	zitm.des4 = "this is based on many factors including wind"
	zitm.des5 = "speed, trajectory, skill of game player &"
	zitm.des6 = "hit pause, however shooting faster is also cool"
	zitm.des7 = "max 8"
	itmlist = append(itmlist, zitm) //84
	zitm.img = etc[108]
	zitm.listNum = 85
	zitm.cost = 200
	zitm.nm = "lightbulb"
	zitm.des = "circle of light > stacks"
	zitm.des2 = "possibly one of the more useful items in the"
	zitm.des3 = "game, the lightbulb creates a circle of light"
	zitm.des4 = "around mr snuggles and will stun any baddie or"
	zitm.des5 = "nasty that enters it, preventing mr snuggles"
	zitm.des6 = "from colliding & losing hp"
	zitm.des7 = "stuns > max 5 = larger circle"
	itmlist = append(itmlist, zitm) //85
	zitm.img = etc[109]
	zitm.listNum = 86
	zitm.cost = 75
	zitm.nm = "mugging"
	zitm.des = "enemies drop scrap > stacks"
	zitm.des2 = "scrap is an essential part of the game as there is"
	zitm.des3 = "annoyingly no real save feature apart from the"
	zitm.des4 = "store room. this means that you need to keep"
	zitm.des5 = "collecting scrap, and this item helps to ensure"
	zitm.des6 = "that you get maximum scrap from kills"
	zitm.des7 = "max 6 > rolls 1 dice > 6 = 100% chance"
	itmlist = append(itmlist, zitm) //86
	zitm.img = etc[110]
	zitm.listNum = 87
	zitm.cost = 75
	zitm.nm = "feather"
	zitm.des = "cushions > no spike damage"
	zitm.des2 = "personally mr snuggles is not a big fan of"
	zitm.des3 = "feathers as they remiind him of pillow"
	zitm.des4 = "stuffing which is a little too close to"
	zitm.des5 = "home with him being a teddy  bear, similar"
	zitm.des6 = "to someone handing you an intestine"
	zitm.des7 = "zero damage > spike traps & blocks"
	itmlist = append(itmlist, zitm) //87
	zitm.img = etc[111]
	zitm.listNum = 88
	zitm.cost = 100
	zitm.nm = "cloak of sparks"
	zitm.des = "player hit > damaging sparks"
	zitm.des2 = "very similar to thorns, this cloak will"
	zitm.des3 = "create an aura of nearby sparks when mr"
	zitm.des4 = "snuggles takes damage. this help his"
	zitm.des5 = "attackers to empathise better with his"
	zitm.des6 = "situation which is not a bad thing"
	zitm.des7 = "10 sparks > 1 damage each"
	itmlist = append(itmlist, zitm) //88
	zitm.img = etc[112]
	zitm.listNum = 89
	zitm.cost = 100
	zitm.art = false
	zitm.nm = "ladybug"
	zitm.des = "creates a ladybug turret"
	zitm.des2 = "is this is a game about fairies? no, it"
	zitm.des3 = "is not you would say, then you would ask"
	zitm.des4 = "why does it have ladybug turrets and not"
	zitm.des5 = "nuclear rocket turrets? the game developer"
	zitm.des6 = "does not condone violence so live with it"
	zitm.des7 = "single use > no timer expiration"
	itmlist = append(itmlist, zitm) //89
	zitm.img = etc[113]
	zitm.listNum = 90
	zitm.cost = 75
	zitm.art = true
	zitm.nm = "mug of tea"
	zitm.des = "orbital croissants > stacks"
	zitm.des2 = "do you know what the percentage chance is"
	zitm.des3 = "being stunned by an orbiting croissant?"
	zitm.des4 = "neither do i, and i am not sure that there"
	zitm.des5 = "is a mathematical calculation that exists"
	zitm.des6 = "that would determine the probability"
	zitm.des7 = "max 2"
	itmlist = append(itmlist, zitm) //90
	zitm.img = etc[114]
	zitm.listNum = 91
	zitm.cost = 75
	zitm.nm = "flamingo"
	zitm.des = "leave a flaming trail > stacks"
	zitm.des2 = "flaming-o, yet another clever play on"
	zitm.des3 = "words that leaves the gamer giggling or"
	zitm.des4 = "perhaps querying the sanity of the game"
	zitm.des5 = "developer. neither of these could be"
	zitm.des6 = "deemed as an inappropriate response"
	zitm.des7 = "+flamingos > +flames > max 5"
	itmlist = append(itmlist, zitm) //91
	zitm.img = etc[115]
	zitm.listNum = 92
	zitm.cost = 75
	zitm.nm = "ninja star"
	zitm.des = "orbital shurikens > stacks"
	zitm.des2 = "there is no better accompaniment to any"
	zitm.des3 = "dungeon adventure than orbiting ninja"
	zitm.des4 = "stars, or shurikens for purists. why"
	zitm.des5 = "bother attacking when the orbiting"
	zitm.des6 = "metal discs take care of everything"
	zitm.des7 = "max 2"
	itmlist = append(itmlist, zitm) //92
	zitm.img = etc[116]
	zitm.listNum = 93
	zitm.cost = 100
	zitm.art = false
	zitm.nm = "orange slice"
	zitm.des = "regenerate health > 30s"
	zitm.des2 = "refreshing & nutritious the orange"
	zitm.des3 = "slice will mean that mr snuggles hp"
	zitm.des4 = "will regenerate over time until it"
	zitm.des5 = "reaches maximum again and is a"
	zitm.des6 = "really, really, really"
	zitm.des7 = "useful item to have"
	itmlist = append(itmlist, zitm) //93
	zitm.img = etc[117]
	zitm.listNum = 94
	zitm.cost = 150
	zitm.nm = "television"
	zitm.des = "pause everything > 10s"
	zitm.des2 = "in the good old days pausing TV was not"
	zitm.des3 = "really a thing, unless it was recorded on"
	zitm.des4 = "a tape. what is a tape some of the younger"
	zitm.des5 = "audience may be asking? you might be able"
	zitm.des6 = "to find it in the encyclopedia in the library"
	zitm.des7 = "if you know what either of those is"
	itmlist = append(itmlist, zitm) //94
	zitm.img = etc[118]
	zitm.listNum = 95
	zitm.cost = 125
	zitm.art = true
	zitm.nm = "toaster"
	zitm.des = "shockwave in puddles"
	zitm.des2 = "not to be attempted at home - acquiring"
	zitm.des3 = "a toaster means that when mr snuggles"
	zitm.des4 = "wallks through a puddle of water an"
	zitm.des5 = "electric shockwave emanates causing"
	zitm.des6 = "stun & damage to nearby enemies"
	zitm.des7 = "damage + stun"
	itmlist = append(itmlist, zitm) //95
	zitm.img = etc[119]
	zitm.listNum = 96
	zitm.cost = 75
	zitm.art = false
	zitm.nm = "lollipop"
	zitm.des = "regenerate mana > 30s"
	zitm.des2 = "run out of mana? well a lollipop is"
	zitm.des3 = "an item you are gonna wanna find asap"
	zitm.des4 = "using it will mean mana regeneration"
	zitm.des5 = "over time until mana reaches maximum"
	zitm.des6 = "which will alllow you to use more scrolls"
	zitm.des7 = "and then need more mana and so on"
	itmlist = append(itmlist, zitm) //96
	zitm.img = etc[120]
	zitm.listNum = 97
	zitm.cost = 150
	zitm.nm = "honeycomb"
	zitm.des = "swarm of deadly bees > 60s"
	zitm.des2 = "bees are not generally deadly however"
	zitm.des3 = "this is a video game and these are"
	zitm.des4 = "particularly deadly bees meaning that"
	zitm.des5 = "when released any baddies that encounter"
	zitm.des6 = "them are likely to die a quick & nasty"
	zitm.des7 = "death, serves them right"
	itmlist = append(itmlist, zitm) //97
	zitm.img = etc[121]
	zitm.listNum = 98
	zitm.cost = 125
	zitm.nm = "fried eggs"
	zitm.des = "chicken of fiery eggs > 60s"
	zitm.des2 = "the chicken that lays exploding eggs"
	zitm.des3 = "is not a typical addition to an rpg"
	zitm.des4 = "game however now that one has been"
	zitm.des5 = "added surely the next game you play"
	zitm.des6 = "you will ask yourself, why don't they"
	zitm.des7 = "have a chicken that lays exploding eggs"
	itmlist = append(itmlist, zitm) //98
	zitm.img = etc[122]
	zitm.listNum = 99
	zitm.cost = 75
	zitm.nm = "popcorn"
	zitm.des = "creates a popcorn turret"
	zitm.des2 = "being a generally non-violent, comic,"
	zitm.des3 = "cutesy game means that compromises in"
	zitm.des4 = "terms of items have had to be made. so,"
	zitm.des5 = "instead of a deadly missile turret we"
	zitm.des6 = "have a deadly bucket of popcorn which"
	zitm.des7 = "is much more wholesome & family friendly"
	itmlist = append(itmlist, zitm) //99
	zitm.img = etc[123]
	zitm.listNum = 100
	zitm.cost = 100
	zitm.nm = "bomb"
	zitm.des = "drops a bomb > 3s timer"
	zitm.des2 = "in the old days, before the internet"
	zitm.des3 = "there used to be something called a"
	zitm.des4 = "magazine and in mad magazines there"
	zitm.des5 = "was spy vs spy and these guys made"
	zitm.des6 = "use of a lot of bombs, therefore the"
	zitm.des7 = "classic bomb made an appearance"
	itmlist = append(itmlist, zitm) //100
	zitm.img = etc[124]
	zitm.listNum = 101
	zitm.cost = 75
	zitm.art = true
	zitm.nm = "oven glove"
	zitm.des = "reduces risk of burn > stacks"
	zitm.des2 = "quite a simple and effective item that"
	zitm.des3 = "reduces the chance that mr snuggles will"
	zitm.des4 = "start burning when he stands on flame traps"
	zitm.des5 = "or bumps into floating flames in the dungeon"
	zitm.des6 = "so get yours today"
	zitm.des7 = "max 5 > rolls 1 dice = 83% chance of save"
	itmlist = append(itmlist, zitm) //101
	zitm.img = etc[125]
	zitm.listNum = 102
	zitm.cost = 75
	zitm.nm = "noodles"
	zitm.des = "pulls in items"
	zitm.des2 = "stringy, bouncy noodles pull back into shape"
	zitm.des3 = "hence this item pulls items on the dungeon floor"
	zitm.des4 = "toward mr snuggles meaning that he doesn't"
	zitm.des5 = "have to walk as far as without them. this is"
	zitm.des6 = "particularly useful in flaming areas meaning"
	zitm.des7 = "he often doesn't need to walk through fire"
	itmlist = append(itmlist, zitm) //102
	zitm.img = etc[126]
	zitm.listNum = 103
	zitm.cost = 200
	zitm.nm = "gas mask"
	zitm.des = "releases poison gas"
	zitm.des2 = "poison gas damages baddies over time, meaning"
	zitm.des3 = "that they may die without mr snuggles even"
	zitm.des4 = "being in the same room, which is not a bad"
	zitm.des5 = "thing as mr snuggles has seen too much death"
	zitm.des6 = "in his life, being such a great dungeoneer"
	zitm.des7 = "more gas masks = faster release"
	itmlist = append(itmlist, zitm) //103
	zitm.img = etc[127]
	zitm.listNum = 104
	zitm.cost = 25
	zitm.art = false
	zitm.notquick = true
	zitm.nm = "teleporter crystal"
	zitm.des = "activates teleporter"
	zitm.des2 = "teleporting back & forth in the dungeon"
	zitm.des3 = "is an essential activity if you want to"
	zitm.des4 = "complete the game and without a teleporter"
	zitm.des5 = "crystal you can't so be sure to find them"
	zitm.des6 = "using switches or in crates if unlocked"
	zitm.des7 = "1 crystal = 1 teleport"
	itmlist = append(itmlist, zitm) //104
	zitm.img = etc[139]
	zitm.listNum = 105
	zitm.nocrate = true
	zitm.nm = "amethyst mushroom"
	zitm.des = "potion ingredient"
	zitm.des2 = "mr snuggles quite enjoys brewing potions"
	zitm.des3 = "in his spare time and they help him make"
	zitm.des4 = "his way through the dungeon much more"
	zitm.des5 = "easily than if he didn't. so, if you want"
	zitm.des6 = "mr snuggles to survive then collect mushrooms"
	zitm.des7 = "and they are also useful to scrap"
	itmlist = append(itmlist, zitm) //105
	zitm.img = etc[140]
	zitm.listNum = 106
	zitm.nocrate = true
	zitm.nm = "zircon mushroom"
	zitm.des = "potion ingredient"
	zitm.des2 = "mr snuggles quite enjoys brewing potions"
	zitm.des3 = "in his spare time and they help him make"
	zitm.des4 = "his way through the dungeon much more"
	zitm.des5 = "easily than if he didn't. so, if you want"
	zitm.des6 = "mr snuggles to survive then collect mushrooms"
	zitm.des7 = "and they are also useful to scrap"
	itmlist = append(itmlist, zitm) //106
	zitm.img = etc[141]
	zitm.listNum = 107
	zitm.nocrate = true
	zitm.nm = "topaz mushroom"
	zitm.des = "potion ingredient"
	zitm.des2 = "mr snuggles quite enjoys brewing potions"
	zitm.des3 = "in his spare time and they help him make"
	zitm.des4 = "his way through the dungeon much more"
	zitm.des5 = "easily than if he didn't. so, if you want"
	zitm.des6 = "mr snuggles to survive then collect mushrooms"
	zitm.des7 = "and they are also useful to scrap"
	itmlist = append(itmlist, zitm) //107
	zitm.img = etc[142]
	zitm.listNum = 108
	zitm.nocrate = true
	zitm.nm = "rubelite mushroom"
	zitm.des = "potion ingredient"
	zitm.des2 = "mr snuggles quite enjoys brewing potions"
	zitm.des3 = "in his spare time and they help him make"
	zitm.des4 = "his way through the dungeon much more"
	zitm.des5 = "easily than if he didn't. so, if you want"
	zitm.des6 = "mr snuggles to survive then collect mushrooms"
	zitm.des7 = "and they are also useful to scrap"
	itmlist = append(itmlist, zitm) //108
	zitm.img = etc[143]
	zitm.listNum = 109
	zitm.nocrate = true
	zitm.nm = "jade mushroom"
	zitm.des = "potion ingredient"
	zitm.des2 = "mr snuggles quite enjoys brewing potions"
	zitm.des3 = "in his spare time and they help him make"
	zitm.des4 = "his way through the dungeon much more"
	zitm.des5 = "easily than if he didn't. so, if you want"
	zitm.des6 = "mr snuggles to survive then collect mushrooms"
	zitm.des7 = "and they are also useful to scrap"
	itmlist = append(itmlist, zitm) //109
	zitm.img = etc[144]
	zitm.listNum = 110
	zitm.nocrate = true
	zitm.nm = "larimar mushroom"
	zitm.des = "potion ingredient"
	zitm.des2 = "mr snuggles quite enjoys brewing potions"
	zitm.des3 = "in his spare time and they help him make"
	zitm.des4 = "his way through the dungeon much more"
	zitm.des5 = "easily than if he didn't. so, if you want"
	zitm.des6 = "mr snuggles to survive then collect mushrooms"
	zitm.des7 = "and they are also useful to scrap"
	itmlist = append(itmlist, zitm) //110
	zitm.img = etc[145]
	zitm.listNum = 111
	zitm.nocrate = true
	zitm.nm = "scroll paper"
	zitm.des = "scroll component"
	zitm.des2 = "not to be confused with toilet paper, this"
	zitm.des3 = "items allows mr snuggles to craft scrolls"
	zitm.des4 = "once he has unlocked the appropriate"
	zitm.des5 = "structure at camp. scrolls have a variety"
	zitm.des6 = "of different uses & can be the difference"
	zitm.des7 = "between mr snuggles surviving or not"
	itmlist = append(itmlist, zitm) //111
	zitm.img = etc[146]
	zitm.listNum = 112
	zitm.nocrate = true
	zitm.nm = "scroll ink"
	zitm.des = "scroll component"
	zitm.des2 = "not to be confused with snot, scroll ink"
	zitm.des3 = "allows mr snuggles to craft scrolls"
	zitm.des4 = "once he has unlocked the appropriate"
	zitm.des5 = "structure at camp. scrolls have a variety"
	zitm.des6 = "of different uses & can be the difference"
	zitm.des7 = "between mr snuggles surviving or not"
	itmlist = append(itmlist, zitm) //112
	zitm.img = anm[175].rec
	zitm.listNum = 113
	zitm.cost = 100
	zitm.nocrate = false
	zitm.art = true
	zitm.nm = "map exit pin"
	zitm.des = "marks exits room in minimap"
	zitm.des2 = "tired of wandering back & forth looking"
	zitm.des3 = "for the exit stairs? the handy map exit"
	zitm.des4 = "pin is here to help and will mark the"
	zitm.des5 = "appropriate room on the minimap that"
	zitm.des6 = "has the exit. this saves you time & allows"
	zitm.des7 = "you to 'speed run' more easily"
	itmlist = append(itmlist, zitm) //113
	zitm.img = anm[176].rec
	zitm.listNum = 114
	zitm.cost = 100
	zitm.nm = "map chest pin"
	zitm.des = "marks chest room in minimap"
	zitm.des2 = "chests hold items & any items placed in"
	zitm.des3 = "chests will be placed in the store room"
	zitm.des4 = "if it is unlocked at the end of the level."
	zitm.des5 = "collecting items for future runs is an"
	zitm.des6 = "essential tactic to complete the game"
	zitm.des7 = "as it is pretty darn difficult"
	itmlist = append(itmlist, zitm) //114
	zitm.img = etc[182]
	zitm.uniq = true
	zitm.listNum = 115
	zitm.cost = 75
	zitm.art = false
	zitm.notquick = false
	zitm.mana = 0
	zitm.nm = "psychedelics"
	zitm.des = "colorize the world > 60s"
	zitm.des2 = "why is everything black, white & grey"
	zitm.des3 = "you may ask yourself when looking at"
	zitm.des4 = "the background scenery in the dungeon."
	zitm.des5 = "well, no need to worry any longer as"
	zitm.des6 = "this item helps you see rainbows"
	zitm.des7 = "cooldown > 60s"
	itmlist = append(itmlist, zitm) //115
	zitm.img = etc[183]
	zitm.listNum = 116
	zitm.cost = 150
	zitm.mana = 0
	zitm.nm = "boots"
	zitm.des = "no floor trap damage > 30s"
	zitm.des2 = "how many times has mr snuggles died"
	zitm.des3 = "by standing on a floor trap that you"
	zitm.des4 = "didn't see as you were rushing through"
	zitm.des5 = "the dungeon? probably a lot more than you"
	zitm.des6 = "realise & boots really help a lot"
	zitm.des7 = "cooldown > 60s"
	itmlist = append(itmlist, zitm) //116
	zitm.img = etc[184]
	zitm.listNum = 117
	zitm.cost = 125
	zitm.mana = 0
	zitm.nm = "fart gas"
	zitm.des = "flaming fart > 30s"
	zitm.des2 = "is this too crude? the short answer is"
	zitm.des3 = "yes it is, however what better way to"
	zitm.des4 = "generate cheap laughs than the inclusion"
	zitm.des5 = "of an auto fart gas fireball cannon? i"
	zitm.des6 = "don't think there is a better way"
	zitm.des7 = "cooldown > 90s"
	itmlist = append(itmlist, zitm) //117
	zitm.img = etc[186]
	zitm.listNum = 118
	zitm.cost = 50
	zitm.mana = 0
	zitm.nm = "salt"
	zitm.des = "prevents freeze > 30s"
	zitm.des2 = "did you know that salt helps to prevent"
	zitm.des3 = "freezing? well, if you didn't then now"
	zitm.des4 = "you do and this item will be particularly"
	zitm.des5 = "useful in the later stages of the game as"
	zitm.des6 = "there are some horrible ice robots"
	zitm.des7 = "cooldown > 90s"
	itmlist = append(itmlist, zitm) //118
	zitm.img = etc[187]
	zitm.uniq = false
	zitm.art = true
	zitm.listNum = 119
	zitm.cost = 75
	zitm.mana = 0
	zitm.nm = "umbrella"
	zitm.des = "no puddle slow down & no damp"
	zitm.des2 = "very much a yin & yang item, if you are"
	zitm.des3 = "on fire and step in a puddle then the"
	zitm.des4 = "flame is extinguished unless of course"
	zitm.des5 = "you have an umbrella. so, whilst, there"
	zitm.des6 = "is no slowdown in puddles anymore there"
	zitm.des7 = "is also a higher burn risk"
	itmlist = append(itmlist, zitm) //119
	zitm.img = etc[188]
	zitm.listNum = 120
	zitm.cost = 125
	zitm.mana = 0
	zitm.nm = "weapon case"
	zitm.des = "unlocks backpack weapon slot"
	zitm.des2 = "carrying more weapons allows"
	zitm.des3 = "mr snuggles to better mix and"
	zitm.des4 = "match his attacks based on the"
	zitm.des5 = "situation and a weapon case"
	zitm.des6 = "unlocks a slot to store a weapon"
	zitm.des7 = "in the backpack"
	itmlist = append(itmlist, zitm) //120
	zitm.img = etc[197]
	zitm.art = false
	zitm.listNum = 121
	zitm.cost = 1000
	zitm.mana = 0
	zitm.nm = "xp update"
	zitm.des = "large quantity of xp added"
	zitm.des2 = "the xp update is a great item"
	zitm.des3 = "to have when you want to unlock"
	zitm.des4 = "a lot of things all at once to"
	zitm.des5 = "make things a little easier &"
	zitm.des6 = "gives mr snuggles a big chunk of"
	zitm.des7 = "xp to use in the book"
	itmlist = append(itmlist, zitm) //121
	zitm.img = etc[200]
	zitm.nocrate = true
	zitm.art = true
	zitm.listNum = 122
	zitm.cost = 0
	zitm.mana = 0
	zitm.nm = "ice crystal"
	zitm.des = "freezing ring every 5s"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "boss item > not found in crates"
	itmlist = append(itmlist, zitm) //122
	zitm.img = etc[202]
	zitm.listNum = 123
	zitm.cost = 0
	zitm.mana = 0
	zitm.nm = "mr frisbee's frisbee"
	zitm.des = "fires frisbees every 7s"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "boss item > not found in crates"
	itmlist = append(itmlist, zitm) //123
	zitm.img = etc[203]
	zitm.listNum = 124
	zitm.cost = 0
	zitm.mana = 0
	zitm.nm = "spinna"
	zitm.des = "damaging spin every 7s"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "boss item > not found in crates"
	itmlist = append(itmlist, zitm) //124
	zitm.img = etc[204]
	zitm.listNum = 125
	zitm.cost = 0
	zitm.mana = 0
	zitm.nm = "space helmet"
	zitm.des = "book items 25xp less > stacks"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "max 4 = 100xp less cost > min 10xp"
	itmlist = append(itmlist, zitm) //125
	zitm.img = etc[205]
	zitm.listNum = 126
	zitm.cost = 0
	zitm.mana = 0
	zitm.nm = "pyroball"
	zitm.des = "fireballs every 7s"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "boss item > not found in crates"
	itmlist = append(itmlist, zitm) //126
	zitm.img = etc[206]
	zitm.listNum = 127
	zitm.cost = 0
	zitm.mana = 0
	zitm.nm = "zombie head"
	zitm.des = "revive from death twice > -1 hp max"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "boss item > not found in crates"
	itmlist = append(itmlist, zitm) //127
	zitm.img = etc[207]
	zitm.listNum = 128
	zitm.cost = 0
	zitm.mana = 0
	zitm.nm = "batty"
	zitm.des = "a bat companion > +1 hp"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "boss item > not found in crates"
	itmlist = append(itmlist, zitm) //128
	zitm.img = etc[150]
	zitm.listNum = 129
	zitm.cost = 0
	zitm.mana = 0
	zitm.nm = "landmine"
	zitm.des = "drops a landmine every 7s"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "boss item > not found in crates"
	itmlist = append(itmlist, zitm) //129
	zitm.img = etc[208]
	zitm.listNum = 130
	zitm.cost = 0
	zitm.mana = 0
	zitm.nm = "rollo"
	zitm.des = "rolling companion > +1 hp"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "boss item > not found in crates"
	itmlist = append(itmlist, zitm) //130

	//INVIS ITEMS LIST
	invisItm = append(invisItm, itmlist[30])
	invisItm = append(invisItm, itmlist[115])
	invisItm = append(invisItm, itmlist[60])
	invisItm = append(invisItm, itmlist[67])
	invisItm = append(invisItm, itmlist[68])
	invisItm = append(invisItm, itmlist[69])
	invisItm = append(invisItm, itmlist[15])
	invisItm = append(invisItm, itmlist[12])
	invisItm = append(invisItm, itmlist[9])
	invisItm = append(invisItm, itmlist[6])
	invisItm = append(invisItm, itmlist[3])
	invisItm = append(invisItm, itmlist[0])
	invisItm = append(invisItm, itmlist[19])
	invisItm = append(invisItm, itmlist[20])
	invisItm = append(invisItm, itmlist[22])
	invisItm = append(invisItm, itmlist[35])
	invisItm = append(invisItm, itmlist[36])
	invisItm = append(invisItm, itmlist[121])
	invisItm = append(invisItm, itmlist[63])
	invisItm = append(invisItm, itmlist[84])
	invisItm = append(invisItm, itmlist[85])
	invisItm = append(invisItm, itmlist[74])
	invisItm = append(invisItm, itmlist[75])
	invisItm = append(invisItm, itmlist[76])
	invisItm = append(invisItm, itmlist[78])
	invisItm = append(invisItm, itmlist[83])
	invisItm = append(invisItm, itmlist[90])
	invisItm = append(invisItm, itmlist[116])
	invisItm = append(invisItm, itmlist[117])
	invisItm = append(invisItm, itmlist[118])
	invisItm = append(invisItm, itmlist[119])
	invisItm = append(invisItm, itmlist[120])

	for i := 0; i < len(itmlist); i++ {
		if !itmlist[i].nocrate {
			crateItmLen++
		}
	}

	upunlocks()

}

func makeplayer() { //MARK:MAKE PLAYER

	siz := b - (b / 4)
	pl.weapmax = 4
	pl.cnt = cnt
	pl.rec = rl.NewRectangle(pl.cnt.X-siz/2, pl.cnt.Y-siz/2, siz, siz)
	pl.crec = pl.rec
	pl.crec.X += 4
	pl.crec.Width -= 8
	pl.carec = pl.rec
	pl.carec.X -= b / 2
	pl.carec.Y -= b / 2
	pl.carec.Width += b
	pl.carec.Height += b
	pl.perrec = pl.carec
	pl.perrec.X -= b / 2
	pl.perrec.Y -= b / 2
	pl.perrec.Width += b
	pl.perrec.Height += b
	pl.spd = 8
	pl.spd2 = pl.spd
	pl.spdmax = 12
	pl.hpmax = 7
	pl.hp = pl.hpmax
	prevplayHP = pl.hp
	pl.manamax = 3
	pl.mana = pl.manamax
	zanim := xanim{}
	zanim.W = 32
	zanim.X = zanim.rec.X
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(0, 118, 32, 32)
	pl.anim = append(pl.anim, zanim) //0 IDLE R
	zanim.rec = rl.NewRectangle(224, 118, 32, 32)
	zanim.X = zanim.rec.X
	pl.anim = append(pl.anim, zanim) //1 IDLE L
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(256, 118, 32, 32)
	zanim.X = zanim.rec.X
	pl.anim = append(pl.anim, zanim) //2 RUN R
	zanim.rec = rl.NewRectangle(608, 118, 32, 32)
	zanim.X = zanim.rec.X
	pl.anim = append(pl.anim, zanim) //3 RUN L
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(640, 118, 32, 32)
	zanim.X = zanim.rec.X
	pl.anim = append(pl.anim, zanim) //4 RUN U
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(768, 118, 32, 32)
	zanim.X = zanim.rec.X
	pl.anim = append(pl.anim, zanim) //5 ATK R
	zanim.rec = rl.NewRectangle(1120, 118, 32, 32)
	zanim.X = zanim.rec.X
	pl.anim = append(pl.anim, zanim) //6 ATK L
	zanim.rec = rl.NewRectangle(1152, 118, 32, 32)
	zanim.X = zanim.rec.X
	pl.anim = append(pl.anim, zanim) //7 PUSH R
	zanim.rec = rl.NewRectangle(1504, 118, 32, 32)
	zanim.X = zanim.rec.X
	pl.anim = append(pl.anim, zanim) //8 PUSH L
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(0, 85, 32, 32)
	zanim.X = zanim.rec.X
	pl.anim = append(pl.anim, zanim) //9 JUMP R
	zanim.rec = rl.NewRectangle(480, 85, 32, 32)
	zanim.X = zanim.rec.X
	pl.anim = append(pl.anim, zanim) //9 JUMP L
	for i := 0; i < 4; i++ {
		pl.quik = append(pl.quik, xitm{})
	}
	sizInvn := 18
	for i := 0; i < sizInvn; i++ {
		pl.invn = append(pl.invn, xitm{})
	}

	stats.dex = 1
	stats.int = 1
	stats.luk = 1
	stats.per = 1
	stats.str = 1
	stats.dex2 = stats.dex
	stats.int2 = stats.int
	stats.luk2 = stats.luk
	stats.per2 = stats.per
	stats.str2 = stats.str
	stats.crit2 = 6

	//BASE PLAYER
	pl2 = pl
	pl2.rec.X -= b / 4
	pl2.rec.Y -= b / 4
	pl2.rec.Width += b / 2
	pl2.rec.Height += b / 2
	pl2.crec = pl2.rec
	pl2.crec.X += 4
	pl2.crec.Width -= 8
	pl2.carec = pl2.rec
	pl2.carec.X -= b / 2
	pl2.carec.Y -= b / 2

	//BOSS PLAYER
	pl3 = pl
	pl3.rec.X -= b / 4
	pl3.rec.Y -= b / 4
	pl3.rec.Width += b / 2
	pl3.rec.Height += b / 2
	pl3.crec = pl3.rec
	pl3.crec.X += 4
	pl3.crec.Width -= 8
	pl3.carec = pl3.rec
	pl3.carec.X -= b / 2
	pl3.carec.Y -= b / 2

	pl.wp1 = weap[0]

}
func makeplProjSpecial(weapNum, spec1or2 int) { //MARK:MAKE PLAYER PROJ SPECIAL
	/*
		1 LIGHTNING
		2 ARROWS
		3 FIREWORKS
		4 TURRET
		5 BOMB
		6 ROCKET
		7 ATTACK SPEED
		8 POTION
		9 DOUBLE XP
		10 RING OF FIRE
		11 SLUDGE GEYSER
	*/

	num := 0
	if weapNum == 1 {
		if spec1or2 == 1 {
			num = pl.wp1.spec1
		} else if spec1or2 == 2 {
			num = pl.wp1.spec2
		}
	} else if weapNum == 2 {
		if spec1or2 == 1 {
			num = pl.wp2.spec1
		} else if spec1or2 == 2 {
			num = pl.wp2.spec2
		}
	}

	switch num {
	case 6: //ROCKET
		if len(levels[levNum].enm) > 1 {
			rl.PlaySound(audfx[111])
			siz := b
			spd := float32(7)
			zproj := xweap{}
			zproj.nm = "rocket"
			zproj.cnt = pl.cnt
			zproj.rec = rl.NewRectangle(zproj.cnt.X-siz/2, zproj.cnt.Y-siz/2, siz, siz)
			zproj.crec = zproj.rec
			zproj.spd = spd
			zproj.img = etc[211]
			zproj.col = rl.White
			zproj.fd = 1
			choose := RandInt(0, len(levels[levNum].enm))
			zproj.ro = AngleBetweenTwoPoints(pl.cnt, levels[levNum].enm[choose].cnt) + 90
			xdiff := AbsDiff(pl.cnt.X, levels[levNum].enm[choose].cnt.X)
			ydiff := AbsDiff(pl.cnt.Y, levels[levNum].enm[choose].cnt.Y)
			if xdiff > ydiff {
				zproj.dirX = zproj.spd
				zproj.dirY = ydiff / (xdiff / zproj.dirX)
			} else {
				zproj.dirY = zproj.spd
				zproj.dirX = xdiff / (ydiff / zproj.dirY)
			}
			if pl.cnt.X > levels[levNum].enm[choose].cnt.X {
				zproj.dirX = -zproj.dirX
			}
			if pl.cnt.Y > levels[levNum].enm[choose].cnt.Y {
				zproj.dirY = -zproj.dirY
			}
			zproj.rec2 = anm[201].rec
			zproj.rec3 = zproj.rec
			zproj.rec3.X -= zproj.rec3.Width / 4
			zproj.rec3.Y -= zproj.rec3.Width / 4
			zproj.rec3.Width += zproj.rec3.Width / 2
			zproj.rec3.Height += zproj.rec3.Height / 2
			zproj.rec3.X -= 4 * zproj.dirX
			zproj.rec3.Y -= 4 * zproj.dirY
			projPL = append(projPL, zproj)
		}
	case 2: //ARROWS
		rl.PlaySound(audfx[108])
		siz := b / 2
		spd := float32(10)
		zproj := xweap{}
		zproj.cnt = pl.cnt
		zproj.rec = rl.NewRectangle(zproj.cnt.X-siz/2, zproj.cnt.Y-siz/2, siz, siz)
		zproj.spd = spd
		zproj.img = etc[209]
		zproj.col = rl.White
		zproj.fd = 1
		zproj.dmg = 1
		origRec := zproj.rec
		side := RandInt(1, 5)
		switch side {
		case 1: //UP
			zproj.dirY = -zproj.spd
			zproj.ro = -45
			projPL = append(projPL, zproj)
			zproj.rec.X += siz
			cntr := makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.X += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.X += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.X += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec = origRec
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
		case 2: //RIGHT
			zproj.dirX = zproj.spd
			zproj.ro = 45
			projPL = append(projPL, zproj)
			zproj.rec.Y += siz
			cntr := makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.Y += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.Y += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.Y += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec = origRec
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
		case 3: //DOWN
			zproj.dirY = +zproj.spd
			zproj.ro = 135
			projPL = append(projPL, zproj)
			zproj.rec.X += siz
			cntr := makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.X += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.X += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.X += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec = origRec
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
		case 4: //LEFT
			zproj.dirX = -zproj.spd
			zproj.ro = 225
			projPL = append(projPL, zproj)
			zproj.rec.Y += siz
			cntr := makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.Y += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.Y += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.Y += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec = origRec
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				projPL = append(projPL, zproj)
			}
		}
	}
}
func makeplproj(num int) { //MARK:MAKE PLAYER PROJ

	weapName := ""
	if num == 1 {
		weapName = pl.wp1.nm
	} else {
		weapName = pl.wp2.nm
	}

	zproj := pl.wp1
	if num == 2 {
		zproj = pl.wp2
	}
	if num == 1 {
		if pl.wp1.spec1 == 1 || pl.wp1.spec2 == 1 {
			if Roll6() > 4 {
				zproj.lightning = true
			}
		}
		if pl.wp1.spec1 == 3 || pl.wp1.spec2 == 3 {
			zproj.firework = true
		}
		if pl.wp1.spec1 == 4 || pl.wp1.spec2 == 4 {
			zproj.turret = true
		}
		if pl.wp1.spec1 == 5 || pl.wp1.spec2 == 5 {
			zproj.bomb = true
		}
		if pl.wp1.spec1 == 8 || pl.wp1.spec2 == 8 {
			zproj.potion = true
		}
		if pl.wp1.spec1 == 9 || pl.wp1.spec2 == 9 {
			zproj.xp = true
		}
		if pl.wp1.spec1 == 10 || pl.wp1.spec2 == 10 {
			zproj.ringoffire = true
		}
		if pl.wp1.spec1 == 11 || pl.wp1.spec2 == 11 {
			zproj.sludgegeyser = true
		}
	} else if num == 2 {
		if pl.wp2.spec1 == 1 || pl.wp2.spec2 == 1 {
			if Roll6() > 4 {
				zproj.lightning = true
			}
		}
		if pl.wp2.spec1 == 3 || pl.wp2.spec2 == 3 {
			zproj.firework = true
		}
		if pl.wp2.spec1 == 4 || pl.wp2.spec2 == 4 {
			zproj.turret = true
		}
		if pl.wp2.spec1 == 5 || pl.wp2.spec2 == 5 {
			zproj.bomb = true
		}
		if pl.wp2.spec1 == 8 || pl.wp2.spec2 == 8 {
			zproj.potion = true
		}
		if pl.wp2.spec1 == 9 || pl.wp2.spec2 == 9 {
			zproj.xp = true
		}
		if pl.wp2.spec1 == 10 || pl.wp2.spec2 == 10 {
			zproj.ringoffire = true
		}
		if pl.wp2.spec1 == 11 || pl.wp2.spec2 == 11 {
			zproj.sludgegeyser = true
		}
	}
	xdiff := AbsDiff(atkCNT.X, atkV2.X)
	ydiff := AbsDiff(atkCNT.Y, atkV2.Y)
	if xdiff > ydiff {
		zproj.dirX = zproj.spd
		zproj.dirY = ydiff / (xdiff / zproj.dirX)
	} else {
		zproj.dirY = zproj.spd
		zproj.dirX = xdiff / (ydiff / zproj.dirY)
	}
	if atkCNT.X > atkV2.X {
		zproj.dirX = -zproj.dirX
	}
	if atkCNT.Y > atkV2.Y {
		zproj.dirY = -zproj.dirY
	}
	zproj.rec = rl.NewRectangle(atkCNT.X-zproj.rec.Width/2, atkCNT.Y-zproj.rec.Height/2, zproj.rec.Width, zproj.rec.Height)
	zproj.crec = zproj.rec
	zproj.bounce += basketballnum

	//MAKE PROJ ORIG
	switch weapName {
	case "guitar":
		zproj.img = etc[175]
		zproj.ro = AngleBetweenTwoPoints(atkCNT, atkV2)
		if pl.direc {
			zproj.ro += 180
		}
		zproj.rec.X -= 2
		zproj.rec.Y -= 2
		zproj.rec.Width += 4
		zproj.rec.Height += 4
		projPL = append(projPL, zproj)

		zproj2 := zproj
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			projPL = append(projPL, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			projPL = append(projPL, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			projPL = append(projPL, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			projPL = append(projPL, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			projPL = append(projPL, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			projPL = append(projPL, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			projPL = append(projPL, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			projPL = append(projPL, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			proj2 := zproj
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			projPL = append(projPL, zproj)
			proj3 := zproj
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			projPL = append(projPL, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			projPL = append(projPL, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			projPL = append(projPL, zproj)
			zproj = proj3
			zproj.dirX *= -1
			zproj.dirY *= -1
			projPL = append(projPL, zproj)
			proj3 = zproj
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			projPL = append(projPL, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			projPL = append(projPL, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			projPL = append(projPL, zproj)
			zproj = proj2
			zproj.dirX *= -1
			zproj.dirY *= -1
			projPL = append(projPL, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			projPL = append(projPL, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			projPL = append(projPL, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			projPL = append(projPL, zproj)
		}

		zproj = zproj2
		zproj.rec.X += zproj.dirX * 4
		zproj.rec.Y += zproj.dirY * 4
		projPL = append(projPL, zproj)
		zproj.rec.X += zproj.dirX * 4
		zproj.rec.Y += zproj.dirY * 4
		projPL = append(projPL, zproj)
		zproj.rec.X += zproj.dirX * 4
		zproj.rec.Y += zproj.dirY * 4
		projPL = append(projPL, zproj)
	case "fork":
		zproj.rec.X -= 4
		zproj.rec.Y -= 4
		zproj.rec.Width += 8
		zproj.rec.Height += 8
		zproj.ro = AngleBetweenTwoPoints(atkCNT, atkV2) + 45
		projPL = append(projPL, zproj)
		zprojORIG := zproj
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			zproj.ro = MirrorAngle(zproj.ro) + 90
			projPL = append(projPL, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X -= zproj.rec.Width / 2
			} else {
				zproj.rec.Y -= zproj.rec.Width / 2
			}
			projPL = append(projPL, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X += zproj.rec.Width
			} else {
				zproj.rec.Y += zproj.rec.Width
			}
			projPL = append(projPL, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X -= zproj.rec.Width / 2
			} else {
				zproj.rec.Y -= zproj.rec.Width / 2
			}
			projPL = append(projPL, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X += zproj.rec.Width
			} else {
				zproj.rec.Y += zproj.rec.Width
			}
			projPL = append(projPL, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			zproj.ro = MirrorAngle(zproj.ro) + 90
			projPL = append(projPL, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X -= zproj.rec.Width / 2
			} else {
				zproj.rec.Y -= zproj.rec.Width / 2
			}
			projPL = append(projPL, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X += zproj.rec.Width
			} else {
				zproj.rec.Y += zproj.rec.Width
			}
			projPL = append(projPL, zproj)

			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X -= zproj.rec.Width / 2
			} else {
				zproj.rec.Y -= zproj.rec.Width / 2
			}
			projPL = append(projPL, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X += zproj.rec.Width
			} else {
				zproj.rec.Y += zproj.rec.Width
			}
			projPL = append(projPL, zproj)

			zproj = zprojORIG
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X -= zproj.rec.Width / 2
			} else {
				zproj.rec.Y -= zproj.rec.Width / 2
			}
			projPL = append(projPL, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X += zproj.rec.Width
			} else {
				zproj.rec.Y += zproj.rec.Width
			}
			projPL = append(projPL, zproj)
		}
		zproj = zprojORIG
		if Abs(zproj.dirY) > Abs(zproj.dirX) {
			zproj.rec.X -= zproj.rec.Width / 2
		} else {
			zproj.rec.Y -= zproj.rec.Width / 2
		}
		projPL = append(projPL, zproj)
		if Abs(zproj.dirY) > Abs(zproj.dirX) {
			zproj.rec.X += zproj.rec.Width
		} else {
			zproj.rec.Y += zproj.rec.Width
		}
		projPL = append(projPL, zproj)
	case "pineapple":
		zproj.bounce += 3
		zproj.rec.X -= 4
		zproj.rec.Y -= 4
		zproj.rec.Width += 8
		zproj.rec.Height += 8
		zproj.img = etc[169]
		projPL = append(projPL, zproj)
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			projPL = append(projPL, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			projPL = append(projPL, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			proj2 := zproj
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			projPL = append(projPL, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			projPL = append(projPL, zproj)
			zproj = proj2
			zproj.dirX *= -1
			zproj.dirY *= -1
			projPL = append(projPL, zproj)
		}
	case "mustard":
		zproj.rec.X -= 4
		zproj.rec.Y -= 4
		zproj.rec.Width += 8
		zproj.rec.Height += 8
		zproj.img = splat[RandInt(0, len(splat))]
		projPL = append(projPL, zproj)
		zprojORIG := zproj
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			zproj.ro = -zproj.ro
			projPL = append(projPL, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			zproj.ro = -zproj.ro
			projPL = append(projPL, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
			zproj = zprojORIG
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
		}
		zproj = zprojORIG
		diff := RandF32(-4, 4)
		zproj.rec.X -= diff
		zproj.rec.Y -= diff
		zproj.rec.Width += diff * 2
		zproj.rec.Height += diff * 2
		zproj.dirX += RandF32(-2, 2)
		zproj.dirY += RandF32(-2, 2)
		zproj.img = splat[RandInt(0, len(splat))]
		projPL = append(projPL, zproj)
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			zproj.ro = -zproj.ro
			projPL = append(projPL, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			zproj.ro = -zproj.ro
			projPL = append(projPL, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
			zproj = zprojORIG
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
		}
		zproj = zprojORIG
		diff = RandF32(-4, 4)
		zproj.rec.X -= diff
		zproj.rec.Y -= diff
		zproj.rec.Width += diff * 2
		zproj.rec.Height += diff * 2
		zproj.dirX += RandF32(-2, 2)
		zproj.dirY += RandF32(-2, 2)
		zproj.img = splat[RandInt(0, len(splat))]
		projPL = append(projPL, zproj)
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			zproj.ro = -zproj.ro
			projPL = append(projPL, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			zproj.ro = -zproj.ro
			projPL = append(projPL, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
			zproj = zprojORIG
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
		}
	case "rubber duck":
		zproj.rec.X -= 4
		zproj.rec.Y -= 4
		zproj.rec.Width += 8
		zproj.rec.Height += 8
		zproj.bounce += 3
		projPL = append(projPL, zproj)
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			projPL = append(projPL, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			projPL = append(projPL, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj2 := zproj
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			projPL = append(projPL, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			projPL = append(projPL, zproj)
			zproj = zproj2
			zproj.dirX *= -1
			zproj.dirY *= -1
			projPL = append(projPL, zproj)
		}
	case "window cleaner":
		zproj.img = anm[177].rec
		projPL = append(projPL, zproj)

		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			projPL = append(projPL, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			projPL = append(projPL, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj2 := zproj
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			projPL = append(projPL, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			projPL = append(projPL, zproj)
			zproj = zproj2
			zproj.dirX *= -1
			zproj.dirY *= -1
			projPL = append(projPL, zproj)
		}
	case "bunch of carrots":
		zproj.img = etc[155]
		zproj.rec.X -= 2
		zproj.rec.Y -= 2
		zproj.rec.Width += 4
		zproj.rec.Height += 4
		zproj.ro = AngleBetweenTwoPoints(atkCNT, atkV2) - 90
		projPL = append(projPL, zproj)
		zprojORIG := zproj
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			zproj.ro = -zproj.ro
			projPL = append(projPL, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			zproj.ro = -zproj.ro
			projPL = append(projPL, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
			zproj = zprojORIG
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
		}
		zproj = zprojORIG
		atkV3 := atkV2
		atkV3.X += RandF32(20, 41)
		atkV3.Y += RandF32(20, 41)
		xdiff = AbsDiff(atkCNT.X, atkV3.X)
		ydiff = AbsDiff(atkCNT.Y, atkV3.Y)
		if xdiff > ydiff {
			zproj.dirX = zproj.spd
			zproj.dirY = ydiff / (xdiff / zproj.dirX)
		} else {
			zproj.dirY = zproj.spd
			zproj.dirX = xdiff / (ydiff / zproj.dirY)
		}
		if atkCNT.X > atkV3.X {
			zproj.dirX = -zproj.dirX
		}
		if atkCNT.Y > atkV3.Y {
			zproj.dirY = -zproj.dirY
		}
		zproj.ro = AngleBetweenTwoPoints(atkCNT, atkV3) - 90
		zproj.rec = rl.NewRectangle(atkCNT.X-zproj.rec.Width/2, atkCNT.Y-zproj.rec.Height/2, zproj.rec.Width, zproj.rec.Height)
		projPL = append(projPL, zproj)
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			zproj.ro = -zproj.ro
			projPL = append(projPL, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			zproj.ro = -zproj.ro
			projPL = append(projPL, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
			zproj = zprojORIG
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
		}
		atkV3 = atkV2
		atkV3.X -= RandF32(20, 41)
		atkV3.Y -= RandF32(20, 41)
		xdiff = AbsDiff(atkCNT.X, atkV3.X)
		ydiff = AbsDiff(atkCNT.Y, atkV3.Y)
		if xdiff > ydiff {
			zproj.dirX = zproj.spd
			zproj.dirY = ydiff / (xdiff / zproj.dirX)
		} else {
			zproj.dirY = zproj.spd
			zproj.dirX = xdiff / (ydiff / zproj.dirY)
		}
		if atkCNT.X > atkV3.X {
			zproj.dirX = -zproj.dirX
		}
		if atkCNT.Y > atkV3.Y {
			zproj.dirY = -zproj.dirY
		}
		zproj.ro = AngleBetweenTwoPoints(atkCNT, atkV3) - 90
		zproj.rec = rl.NewRectangle(atkCNT.X-zproj.rec.Width/2, atkCNT.Y-zproj.rec.Height/2, zproj.rec.Width, zproj.rec.Height)
		projPL = append(projPL, zproj)
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			zproj.ro = -zproj.ro
			projPL = append(projPL, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			zproj.ro = -zproj.ro
			projPL = append(projPL, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
			zproj = zprojORIG
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.ro += 180
			projPL = append(projPL, zproj)
		}
	case "kitchen knife", "frying pan", "rolling pin", "mint ice cream", "lighter", "magnifying glass", "raspberry", "chilli", "emoji", "french fries", "hot soup", "drawing pin":
		if zproj.nm == "drawing pin" {
			zproj.ro = AngleBetweenTwoPoints(atkCNT, atkV2) + 45
		}
		if zproj.nm == "french fries" {
			zproj.img = etc[178]
			zproj.ro = AngleBetweenTwoPoints(atkCNT, atkV2) - 90
		}
		if zproj.nm == "raspberry" {
			zproj.bounce += 4
		}
		if zproj.nm == "emoji" {
			zproj.bounce += 3
		}
		if zproj.nm == "frying pan" {
			zproj.rec.X -= 10
			zproj.rec.Y -= 10
			zproj.rec.Width += 20
			zproj.rec.Height += 20
		} else if zproj.nm == "rolling pin" || zproj.nm == "mint ice cream" || zproj.nm == "lighter" || zproj.nm == "chilli" || zproj.nm == "hot soup" {
			zproj.rec.X -= 4
			zproj.rec.Y -= 4
			zproj.rec.Width += 8
			zproj.rec.Height += 8
		} else if zproj.nm == "lighter" {
			zproj.T = fps / 3
			zproj.rec.X -= 2
			zproj.rec.Y -= 2
			zproj.rec.Width += 4
			zproj.rec.Height += 4
		}
		projPL = append(projPL, zproj)

		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			if zproj.nm == "french fries" || zproj.nm == "drawing pin" {
				zproj.ro = MirrorAngle(zproj.ro) + 90
			}
			projPL = append(projPL, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			if zproj.nm == "french fries" || zproj.nm == "drawing pin" {
				zproj.ro += 180
			}
			projPL = append(projPL, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			proj2 := zproj
			zproj.dirX *= -1
			if pl.direc {
				zproj.rec.X += pl.rec.Width
			} else {
				zproj.rec.X -= pl.rec.Width
			}
			if zproj.nm == "french fries" || zproj.nm == "drawing pin" {
				zproj.ro = MirrorAngle(zproj.ro) + 90
			}
			projPL = append(projPL, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			if zproj.nm == "french fries" || zproj.nm == "drawing pin" {
				zproj.ro += 180
			}
			projPL = append(projPL, zproj)
			zproj = proj2
			zproj.dirX *= -1
			zproj.dirY *= -1
			if zproj.nm == "french fries" || zproj.nm == "drawing pin" {
				zproj.ro += 180
			}
			projPL = append(projPL, zproj)
		}

	}

	//SPECIAL RANDOM BONUS
	if num == 1 {
		if pl.wp1.spec1 == 2 {
			if Roll12() > 9 {
				makeplProjSpecial(1, 1)
			}
		} else if pl.wp1.spec1 == 6 {
			if Roll12() > 10 {
				makeplProjSpecial(1, 1)
			}
		}
		if pl.wp1.spec2 == 2 {
			if Roll12() > 9 {
				makeplProjSpecial(1, 2)
			}
		} else if pl.wp1.spec2 == 6 {
			if Roll12() > 10 {
				makeplProjSpecial(1, 2)
			}
		}
	} else {
		if pl.wp2.spec1 == 2 {
			if Roll12() > 9 {
				makeplProjSpecial(2, 1)
			}
		} else if pl.wp2.spec1 == 6 {
			if Roll12() > 10 {
				makeplProjSpecial(2, 1)
			}
		}
		if pl.wp2.spec2 == 2 {
			if Roll12() > 9 {
				makeplProjSpecial(2, 2)
			}
		} else if pl.wp2.spec2 == 6 {
			if Roll12() > 10 {
				makeplProjSpecial(2, 2)
			}
		}
	}

	//SOUND FX
	switch weapName {
	case "drawing pin":
		rl.PlaySound(audfx[38])
	case "guitar":
		rl.PlaySound(audfx[37])
	case "hot soup":
		rl.PlaySound(audfx[36])
	case "french fries":
		rl.PlaySound(audfx[35])
	case "emoji":
		rl.PlaySound(audfx[34])
	case "chilli":
		rl.PlaySound(audfx[33])
	case "fork":
		rl.PlaySound(audfx[32])
	case "pineapple":
		rl.PlaySound(audfx[31])
	case "raspberry":
		rl.PlaySound(audfx[29])
	case "magnifying glass":
		rl.PlaySound(audfx[28])
	case "lighter":
		rl.PlaySound(audfx[27])
	case "mint ice cream":
		rl.PlaySound(audfx[26])
	case "mustard":
		rl.PlaySound(audfx[25])
	case "rolling pin":
		rl.PlaySound(audfx[24])
	case "frying pan":
		rl.PlaySound(audfx[23])
	case "rubber duck":
		rl.PlaySound(audfx[22])
	case "window cleaner":
		rl.PlaySound(audfx[21])
	case "bunch of carrots":
		rl.PlaySound(audfx[20])
	case "kitchen knife":
		rl.PlaySound(audfx[0])
	}
}

func makebase() { //MARK:MAKE BASE

	mushroomTimerMax = 12
	mushroomTimer = 0

	base.mouse.img = anm[182].rec
	if FlipCoin() {
		base.mouse.img = anm[183].rec
		base.mouse.onoff = true
	}
	siz2 := be5
	base.mouse.rec = rl.NewRectangle(cnt.X-siz2/2, cnt.Y-siz2/2, siz2, siz2)
	base.mouse.spd = 2
	base.mouse.dirX = -RandF32(-base.mouse.spd, base.mouse.spd)
	base.mouse.dirY = -RandF32(-base.mouse.spd, base.mouse.spd)
	base.mouse.crec = base.mouse.rec

	W := float32(1280)
	H := float32(720)
	baseBordRec = rl.NewRectangle(cnt.X-W/2, cnt.Y-H/2, W, H)

	bs1 := W / 16 //BASE UNIT = 1280/16 =80

	//TENT
	base.lev = append(base.lev, 0)
	siz := bs1 * 2
	rec := rl.NewRectangle(cnt.X-siz/2, baseBordRec.Y, siz, siz)
	crec := rec
	crec.X += crec.Width / 4
	crec.Width = crec.Width / 2
	crec.Y += crec.Height / 4
	crec.Height = crec.Height / 2
	base.nm = append(base.nm, "tent")
	base.img = append(base.img, etc[33])
	base.rec = append(base.rec, rec)
	base.crec = append(base.crec, crec)
	base.carec = append(base.carec, crec)
	base.unlock = append(base.unlock, true)
	base.desc = append(base.desc, "")
	base.cost = append(base.cost, 0)
	base.fd = append(base.fd, 1)
	//BOOK
	base.lev = append(base.lev, 0)
	siz = bs1
	rec = rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/16)*9, baseBordRec.Y+baseBordRec.Height/4, siz, siz)
	crec = rec
	base.nm = append(base.nm, "book of unlock things")
	base.img = append(base.img, etc[180])
	base.rec = append(base.rec, rec)
	base.crec = append(base.crec, crec)
	crec.X -= b / 4
	crec.Y -= b / 4
	crec.Width += b / 2
	crec.Height += b / 2
	base.carec = append(base.carec, crec)
	base.unlock = append(base.unlock, true)
	base.desc = append(base.desc, "")
	base.cost = append(base.cost, 0)
	base.fd = append(base.fd, 1)
	//WEAPON STAND
	base.lev = append(base.lev, 0)
	siz = bs1 + bs1/3
	rec = rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/16)*6, baseBordRec.Y+baseBordRec.Height/4, siz, siz)
	crec = rec
	crec.X += b / 4
	crec.Width -= b / 2
	base.nm = append(base.nm, "weapon stand")
	base.img = append(base.img, etc[213])
	base.rec = append(base.rec, rec)
	base.crec = append(base.crec, crec)
	crec.X -= b / 4
	crec.Y -= b / 4
	crec.Width += b / 2
	crec.Height += b / 2
	base.carec = append(base.carec, crec)
	base.unlock = append(base.unlock, false)
	base.desc = append(base.desc, "")
	base.cost = append(base.cost, 10)
	base.fd = append(base.fd, 1)
	//ROCK
	base.lev = append(base.lev, 0)
	siz = bs1
	rec = rl.NewRectangle(baseBordRec.X+siz/5, baseBordRec.Y+baseBordRec.Height-(siz+siz/5), siz, siz)
	if asp1610 {
		rec.X += siz
	}
	crec = rec
	base.nm = append(base.nm, "an attractive rocky outcrop")
	base.img = append(base.img, etc[39])
	base.rec = append(base.rec, rec)
	base.crec = append(base.crec, crec)
	base.carec = append(base.carec, crec)
	base.unlock = append(base.unlock, true)
	base.desc = append(base.desc, "")
	base.cost = append(base.cost, 0)
	base.fd = append(base.fd, 1)
	//STORE ROOM
	base.lev = append(base.lev, 0)
	siz = bs1 * 3
	rec = rl.NewRectangle(baseBordRec.X+b3, baseBordRec.Y+b/4, siz, siz)
	if asp1610 {
		rec.Y += siz / 8
	}
	crec = rec
	crec.Y += crec.Height / 4
	crec.Height = (crec.Height / 3) * 2
	base.nm = append(base.nm, "store room")
	base.img = append(base.img, etc[40])
	base.rec = append(base.rec, rec)
	base.crec = append(base.crec, crec)
	crec.X -= b / 2
	crec.Y -= b / 2
	crec.Width += b
	crec.Height += b
	base.carec = append(base.carec, crec)
	base.unlock = append(base.unlock, false)
	base.desc = append(base.desc, "")
	base.cost = append(base.cost, 10)
	base.fd = append(base.fd, 0)
	//EXIT
	base.lev = append(base.lev, 0)
	siz = bs1 * 3
	rec = rl.NewRectangle(baseBordRec.X+baseBordRec.Width-(siz+siz/7), baseBordRec.Y+baseBordRec.Height-(siz+siz/3), siz, siz)
	if asp1610 {
		rec.X -= siz / 6
	}
	crec = rec
	crec.X += crec.Width / 4
	crec.Width = crec.Width - crec.Width/2
	crec.Y += crec.Height / 4
	crec.Height = crec.Height - crec.Height/4
	carec := crec
	carec.X -= carec.Width / 8
	carec.Width += carec.Width / 4
	base.nm = append(base.nm, "to the dungeon")
	base.img = append(base.img, etc[41])
	base.rec = append(base.rec, rec)
	base.crec = append(base.crec, crec)
	base.carec = append(base.carec, carec)
	base.unlock = append(base.unlock, true)
	base.desc = append(base.desc, "")
	base.cost = append(base.cost, 0)
	base.fd = append(base.fd, 1)
	//WEAPON SHED
	base.lev = append(base.lev, 1)
	siz = bs1 * 3
	rec = rl.NewRectangle(baseBordRec.X+baseBordRec.Width/12, baseBordRec.Y+baseBordRec.Height/2-b2, siz, siz)
	if asp1610 {
		rec.Y += siz / 12
	}
	crec = rec
	crec.X += crec.Width / 4
	crec.Width = crec.Width - crec.Width/2
	crec.Y += b / 2
	crec.Height = crec.Height - crec.Height/3
	base.nm = append(base.nm, "weapon shed")
	base.img = append(base.img, etc[44])
	base.rec = append(base.rec, rec)
	base.crec = append(base.crec, crec)
	crec.X -= b / 2
	crec.Y -= b / 2
	crec.Width += b
	crec.Height += b
	base.carec = append(base.carec, crec)
	base.unlock = append(base.unlock, false)
	base.desc = append(base.desc, "")
	base.cost = append(base.cost, 10)
	base.fd = append(base.fd, 0)
	//APOTHECARY
	base.lev = append(base.lev, 1)
	siz = bs1 * 3
	rec = rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/20)*15, baseBordRec.Y+baseBordRec.Height/9, siz, siz)
	crec = rec
	crec.X += crec.Width / 4
	crec.Width = crec.Width - crec.Width/2
	crec.Y += b / 2
	crec.Height = crec.Height - crec.Height/8
	base.nm = append(base.nm, "apothecary")
	base.img = append(base.img, etc[45])
	base.rec = append(base.rec, rec)
	base.crec = append(base.crec, crec)
	crec.X -= b / 4
	crec.Y -= b / 4
	crec.Width += b / 2
	crec.Height += b / 2
	base.carec = append(base.carec, crec)
	base.unlock = append(base.unlock, false)
	base.desc = append(base.desc, "")
	base.cost = append(base.cost, 10)
	base.fd = append(base.fd, 0)
	//CAMPFIRE STONE
	base.lev = append(base.lev, 0)
	rec = rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/3)+b/4, baseBordRec.Y+b3-b/8, b+b/2, b+b/2)
	crec = rec
	base.nm = append(base.nm, "campfire stone")
	base.img = append(base.img, etc[47])
	base.rec = append(base.rec, rec)
	base.crec = append(base.crec, crec)
	base.carec = append(base.carec, crec)
	base.unlock = append(base.unlock, true)
	base.desc = append(base.desc, "")
	base.cost = append(base.cost, 0)
	//CAMPFIRE
	base.lev = append(base.lev, 0)
	rec = rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/3)+2, baseBordRec.Y+b, b2, b2)
	crec = rec
	base.nm = append(base.nm, "campfire")
	base.img = append(base.img, anm[72].rec)
	base.rec = append(base.rec, rec)
	base.crec = append(base.crec, crec)
	base.carec = append(base.carec, crec)
	base.unlock = append(base.unlock, true)
	base.desc = append(base.desc, "")
	base.cost = append(base.cost, 0)
	//TREE
	base.lev = append(base.lev, 0)
	siz = bs1 * 2
	rec = rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/12)*7, baseBordRec.Y+b/8, b5, b5)
	crec = rec
	crec.X += crec.Width / 8
	crec.Width = crec.Width - crec.Width/4
	crec.Y += crec.Height / 8
	crec.Height = crec.Height - crec.Height/4
	base.nm = append(base.nm, "a tree")
	base.img = append(base.img, etc[48])
	base.rec = append(base.rec, rec)
	base.crec = append(base.crec, crec)
	base.carec = append(base.carec, crec)
	base.unlock = append(base.unlock, true)
	base.desc = append(base.desc, "")
	base.cost = append(base.cost, 0)
	//MUSHROOM PATCH
	base.lev = append(base.lev, 1)
	rec = rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/3), baseBordRec.Y+baseBordRec.Height/2+b4, b6, b6)
	crec = rec
	base.nm = append(base.nm, "mushroom patch")
	base.img = append(base.img, etc[49])
	base.rec = append(base.rec, rec)
	base.crec = append(base.crec, crec)
	crec.X -= b / 4
	crec.Y -= b / 4
	crec.Width += b / 2
	crec.Height += b / 2
	base.carec = append(base.carec, crec)
	base.unlock = append(base.unlock, false)
	base.desc = append(base.desc, "")
	base.cost = append(base.cost, 10)
	base.fd = append(base.fd, 0)
	//BOSS KEYS
	siz = (bs1 / 8) * 5
	base.lev = append(base.lev, 0)
	rec = rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/2)+b3, baseBordRec.Y+baseBordRec.Height-(siz+siz/3), siz, siz)
	crec = rec
	base.nm = append(base.nm, "boss key 1")
	base.img = append(base.img, etc[189])
	base.rec = append(base.rec, rec)
	base.crec = append(base.crec, crec)
	base.carec = append(base.carec, crec)
	base.unlock = append(base.unlock, false)
	base.desc = append(base.desc, "kill boss > unlocks ")
	base.cost = append(base.cost, 0)
	base.fd = append(base.fd, 1)
	rec.X += siz + siz/5
	crec = rec
	base.lev = append(base.lev, 0)
	base.nm = append(base.nm, "boss key 2")
	base.img = append(base.img, etc[189])
	base.rec = append(base.rec, rec)
	base.crec = append(base.crec, crec)
	base.carec = append(base.carec, crec)
	base.unlock = append(base.unlock, false)
	base.desc = append(base.desc, "kill boss > unlocks ")
	base.cost = append(base.cost, 0)
	base.fd = append(base.fd, 1)
	rec.X += siz + siz/5
	crec = rec
	base.lev = append(base.lev, 0)
	base.nm = append(base.nm, "boss key 3")
	base.img = append(base.img, etc[189])
	base.rec = append(base.rec, rec)
	base.crec = append(base.crec, crec)
	base.carec = append(base.carec, crec)
	base.unlock = append(base.unlock, false)
	base.desc = append(base.desc, "kill boss > unlocks ")
	base.cost = append(base.cost, 0)
	base.fd = append(base.fd, 1)

	//rec3 := rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/3),baseBordRec.Y+baseBordRec.Height/2+b4,b6,b6)
	//rl.DrawTexturePro(imgs,etc[49],rec3,rl.Vector2Zero(),0,rl.White)
	base.pigeon.img = anm[73].rec
	base.pigeon.dirX = 4
	base.pigeon.rec = rl.NewRectangle(baseBordRec.X+4, baseBordRec.Y+4, b, b)
	x := baseBordRec.X
	y := baseBordRec.Y
	siz = b2
	for {
		zbgi := xbgi{}
		zbgi.rec = rl.NewRectangle(x, y, siz, siz)
		zbgi.img = etc[34]
		if Roll6() == 6 {
			choose := RandInt(1, 5)
			switch choose {
			case 1:
				zbgi.img = etc[35]
			case 2:
				zbgi.img = etc[36]
			case 3:
				zbgi.img = etc[37]
			case 4:
				zbgi.img = etc[38]
			}
		}
		baseBG = append(baseBG, zbgi)
		x += siz
		if x >= baseBordRec.X+baseBordRec.Width {
			x = baseBordRec.X
			y += siz
		}
		if y >= baseBordRec.Y+baseBordRec.Height {
			break
		}
	}
}
func makechest(lev x1scr) x1scr { //MARK:MAKE CHEST
	siz := b2
	zchst := xchst{}
	zchst.slots = RandInt(2, 5)
	for i := 0; i < zchst.slots; i++ {
		zchst.itm = append(zchst.itm, xitm{})
	}
	zchst.img = anm[4].rec
	zchst.cnt = cnt
	countbreak := 100
	found := false
	for {
		choose2 := RandInt(0, len(lev.recs))
		choose := lev.recs[choose2]
		x := choose.X + b
		y := choose.Y + b
		x += RandF32(0, choose.Width-b2-siz)
		y += RandF32(0, choose.Height-b2-siz)
		zchst.rec = rl.NewRectangle(x, y, siz, siz)
		canadd := checkaddtilerecInner(zchst.rec, lev)
		if canadd {
			canadd = checkaddetc(zchst.rec, lev)
		}
		if canadd {
			found = true
			chestRoomNum = choose2
			break
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	if found {
		zchst.cnt = makecnt(zchst.rec)
		zchst.crec = zchst.rec
		zchst.crec.X += zchst.crec.Width / 4
		zchst.crec.Y += zchst.crec.Height / 2
		zchst.crec.Y -= 4
		zchst.crec.Width = zchst.crec.Width / 2
		zchst.crec.Height = (zchst.crec.Height / 9) * 4
		choose := RandInt(0, 30)
		switch choose {
		case 0:
			zchst.itm[0] = itmlist[48]
			zchst.itm[0].noChestMove = true
		case 1:
			zchst.itm[0] = itmlist[19]
			zchst.itm[0].noChestMove = true
		case 2:
			zchst.itm[0] = itmlist[21]
			zchst.itm[0].noChestMove = true
		case 3:
			zchst.itm[0] = itmlist[80]
			zchst.itm[0].noChestMove = true
		case 4:
			zchst.itm[0] = itmlist[97]
			zchst.itm[0].noChestMove = true
		case 5:
			zchst.itm[0] = itmlist[102]
			zchst.itm[0].noChestMove = true
		case 6:
			zchst.itm[0] = itmlist[0]
			zchst.itm[0].noChestMove = true
		case 7:
			zchst.itm[0] = itmlist[3]
			zchst.itm[0].noChestMove = true
		case 8:
			zchst.itm[0] = itmlist[17]
			zchst.itm[0].noChestMove = true
		case 9:
			zchst.itm[0] = itmlist[14]
			zchst.itm[0].noChestMove = true
		case 10:
			zchst.itm[0] = itmlist[73]
			zchst.itm[0].noChestMove = true
		case 11:
			zchst.itm[0] = itmlist[64]
			zchst.itm[0].noChestMove = true
		case 12:
			zchst.itm[0] = itmlist[70]
			zchst.itm[0].noChestMove = true
		case 13:
			zchst.itm[0] = itmlist[86]
			zchst.itm[0].noChestMove = true
		case 14:
			zchst.itm[0] = itmlist[95]
			zchst.itm[0].noChestMove = true
		case 15:
			zchst.itm[0] = itmlist[99]
			zchst.itm[0].noChestMove = true
		case 16:
			zchst.itm[0] = itmlist[113]
			zchst.itm[0].noChestMove = true
		case 17:
			zchst.itm[0] = itmlist[114]
			zchst.itm[0].noChestMove = true
		case 18:
			zchst.itm[0] = itmlist[101]
			zchst.itm[0].noChestMove = true
		case 19:
			zchst.itm[0] = itmlist[100]
			zchst.itm[0].noChestMove = true
		case 20:
			zchst.itm[0] = itmlist[52]
			zchst.itm[0].noChestMove = true
		case 21:
			zchst.itm[0] = itmlist[79]
			zchst.itm[0].noChestMove = true
		case 22:
			zchst.itm[0] = itmlist[94]
			zchst.itm[0].noChestMove = true
		case 23:
			zchst.itm[0] = itmlist[91]
			zchst.itm[0].noChestMove = true
		case 24:
			zchst.itm[0] = itmlist[37]
			zchst.itm[0].noChestMove = true
		case 25:
			zchst.itm[0] = itmlist[46]
			zchst.itm[0].noChestMove = true
		case 26:
			zchst.itm[0] = itmlist[115]
			zchst.itm[0].noChestMove = true
		case 27:
			zchst.itm[0] = itmlist[118]
			zchst.itm[0].noChestMove = true
		case 28:
			zchst.itm[0] = itmlist[58]
			zchst.itm[0].noChestMove = true
		case 29:
			zchst.itm[0] = itmlist[33]
			zchst.itm[0].noChestMove = true
		}

		if Roll6() == 6 {
			zchst.itm[1] = itmlist[104]
			zchst.itm[1].noChestMove = true
		}

		lev.chst = append(lev.chst, zchst)
	}

	return lev
}

func makeboss() { //MARK:MAKE BOSS
	zboss := xenm{}
	if len(bosskillist) > 0 {
		for {
			canadd := true
			bossnum = RandInt(1, 10)
			for i := 0; i < len(bosskillist); i++ {
				if bosskillist[i] == bossnum {
					canadd = false
				}
			}
			if canadd {
				break
			}
		}
	} else {
		bossnum = RandInt(1, 10)
	}
	zboss.xp = 500
	//bossnum = 9
	switch bossnum {
	case 9: //ROLLO
		siz := b2
		zboss.moveChangeT = fps * 2
		zboss.hpmax = 20
		zboss.hp = zboss.hpmax
		x := levels[levNum].recs[0].X + b/2
		y := levels[levNum].recs[0].Y + b/2
		zboss.rec = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rec)
		zboss.crec = zboss.rec
		zboss.img = anm[153].rec
		zboss.nm = "rollo"
		zboss.spd = 3
		countbreak := 100
		for {
			zboss.dirX = RandF32(-zboss.spd, zboss.spd)
			zboss.dirY = RandF32(-zboss.spd, zboss.spd)
			if Abs(zboss.dirX) > zboss.spd/2 || Abs(zboss.dirY) > zboss.spd/2 {
				break
			}
			countbreak--
			if countbreak == 0 {
				break
			}
		}
	case 8: //MUSHROOM
		siz := b5
		zboss.state = 1
		zboss.moveChangeT = fps * 2
		zboss.hpmax = 50
		zboss.hp = zboss.hpmax
		x := levels[levNum].recs[0].X + b/2
		y := levels[levNum].recs[0].Y + b/2
		zboss.rec = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rec)
		zboss.crec = zboss.rec
		zboss.crec.X += zboss.crec.Width / 3
		zboss.crec.Y += zboss.crec.Width / 3
		zboss.crec.Width = zboss.crec.Width / 3
		zboss.crec.Height = zboss.crec.Height / 3
		zboss.img = anm[148].rec
		zboss.nm = "mushee"
		zboss.spd = 2
		zboss.dirX = RandF32(-zboss.spd, zboss.spd)
		zboss.dirY = RandF32(-zboss.spd, zboss.spd)
	case 7: //RED BAT
		siz := b6
		zboss.moveChangeT = fps
		zboss.hpmax = 60
		zboss.hp = zboss.hpmax
		x := levels[levNum].recs[0].X + b/2
		y := levels[levNum].recs[0].Y + b/2
		zboss.rec = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rec)
		zboss.crec = zboss.rec
		zboss.crec.X += zboss.crec.Width / 3
		zboss.crec.Y += zboss.crec.Width / 3
		zboss.crec.Width = zboss.crec.Width / 3
		zboss.crec.Height = zboss.crec.Height / 3
		zboss.img = anm[145].rec
		zboss.nm = "batty"
		zboss.spd = 2
		zboss.dirX = RandF32(-zboss.spd, zboss.spd)
		zboss.dirY = RandF32(-zboss.spd, zboss.spd)
	case 6: //ZOMBO
		siz := b5
		zboss.atkT2 = fps
		zboss.atkT = fps * 2
		zboss.hpmax = 40
		zboss.hp = zboss.hpmax
		x := levels[levNum].recs[0].X + b/2
		y := levels[levNum].recs[0].Y + b/2
		zboss.rec = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rec)
		zboss.crec = zboss.rec
		zboss.crec.X += zboss.crec.Width / 3
		zboss.crec.Width = zboss.crec.Width / 3
		zboss.crec.Y += zboss.crec.Height / 3
		zboss.crec.Height = zboss.crec.Height / 3
		zboss.crec.Y += 8
		zboss.img = anm[138].rec
		zboss.nm = "zombo"
		zboss.spd = 1
		zboss.dirX = RandF32(-zboss.spd, zboss.spd)
		zboss.dirY = RandF32(-zboss.spd, zboss.spd)
	case 5: //PYRO PIG
		siz := b7
		zboss.atkT = fps * 4
		zboss.moveChangeT = fps
		zboss.hpmax = 35
		zboss.hp = zboss.hpmax
		x := levels[levNum].recs[0].X + b/2
		y := levels[levNum].recs[0].Y + b/2
		zboss.rec = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rec)
		zboss.crec = zboss.rec
		zboss.crec.X += zboss.crec.Width / 3
		zboss.crec.Width = zboss.crec.Width / 3
		zboss.crec.Y += zboss.crec.Height / 3
		zboss.crec.Height = zboss.crec.Height / 3
		zboss.crec.Y += 8
		zboss.img = anm[133].rec
		zboss.nm = "pyro pig"
		zboss.spd = 4
		zboss.dirX = RandF32(-zboss.spd, zboss.spd)
		zboss.dirY = RandF32(-zboss.spd, zboss.spd)
	case 4: //SPACEMAN
		siz := b5
		zboss.moveChangeT = fps
		zboss.hpmax = 55
		zboss.hp = zboss.hpmax
		x := levels[levNum].recs[0].X + b/2
		y := levels[levNum].recs[0].Y + b/2
		zboss.rec = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rec)
		zboss.crec = zboss.rec
		zboss.crec.X += zboss.crec.Width / 3
		zboss.crec.Width = zboss.crec.Width / 3
		zboss.crec.Y += zboss.crec.Height / 2
		zboss.crec.Y -= 12
		zboss.crec.Height = zboss.crec.Height / 2
		zboss.img = anm[124].rec
		zboss.nm = "spzman"
		zboss.spd = 2
	case 3: //SPINNA
		siz := b3 + b/2
		zboss.moveChangeT = fps
		zboss.hpmax = 30
		zboss.hp = zboss.hpmax
		x := levels[levNum].recs[0].X + b/2
		y := levels[levNum].recs[0].Y + b/2
		zboss.rec = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rec)
		zboss.crec = zboss.rec
		zboss.crec.X += zboss.crec.Width / 4
		zboss.crec.Width = zboss.crec.Width / 2
		zboss.img = anm[118].rec
		zboss.nm = "spinna"
		zboss.spd = 7
		zboss.dirY = zboss.spd
		if FlipCoin() {
			zboss.dirY -= zboss.spd
		}
	case 2: //MR FRISBEE
		siz := b8
		zboss.idlT = fps
		zboss.hpmax = 50
		zboss.hp = zboss.hpmax
		x := levels[levNum].recs[0].X + b/2
		y := levels[levNum].recs[0].Y + b/2
		zboss.rec = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rec)
		zboss.crec = zboss.rec
		zboss.crec.X += zboss.crec.Width / 3
		zboss.crec.Y += zboss.crec.Height / 3
		zboss.crec.Width = zboss.crec.Width / 3
		zboss.crec.Height = zboss.crec.Height / 3
		zboss.carec = zboss.crec
		zboss.carec.X -= b
		zboss.carec.Y -= b
		zboss.carec.Width += b2
		zboss.carec.Height += b2
		zboss.nm = "mr frisbee"
		zboss.spd = 3
		countbreak := 100
		for {
			zboss.dirX = RandF32(-zboss.spd, zboss.spd)
			if Abs(zboss.dirX) > zboss.spd/3 {
				break
			}
			countbreak--
			if countbreak == 0 {
				break
			}
		}
		zboss.dirY = RandF32(-zboss.spd/3, zboss.spd/3)
		zboss.img = anm[110].rec
	case 1: //ICEMAN
		zboss.atkT2 = fps / 2
		zboss.hpmax = 50
		zboss.hp = zboss.hpmax
		bossWALKL = rl.LoadTexture("img/boss/wl1.png")
		zanim := xanim{}
		zanim.frames = 19
		zanim.rec = rl.NewRectangle(0, 0, 256, 256)
		zanim.W = 256
		zanim.X = zanim.rec.X
		zboss.walkL = zanim
		bossWALKR = rl.LoadTexture("img/boss/wr1.png")
		zanim = xanim{}
		zanim.frames = 19
		zanim.rec = rl.NewRectangle(0, 0, 256, 256)
		zanim.W = 256
		zanim.X = zanim.rec.X
		zboss.walkR = zanim
		bossATK = rl.LoadTexture("img/boss/a1.png")
		zanim = xanim{}
		zanim.frames = 23
		zanim.rec = rl.NewRectangle(0, 0, 256, 256)
		zanim.W = 256
		zanim.X = zanim.rec.X
		zboss.atk = zanim
		bossIDL = rl.LoadTexture("img/boss/i1.png")
		zanim = xanim{}
		zanim.frames = 19
		zanim.rec = rl.NewRectangle(0, 0, 256, 256)
		zanim.W = 256
		zanim.X = zanim.rec.X
		zboss.idlA = zanim
		siz := b7
		x := levels[levNum].recs[0].X + b/2
		y := levels[levNum].recs[0].Y + b/2
		zboss.rec = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rec)
		zboss.crec = zboss.rec
		zboss.crec.X += zboss.rec.Width / 3
		zboss.crec.Y += zboss.rec.Height / 3
		zboss.crec.Height = zboss.rec.Height / 3
		zboss.crec.Height += b / 2
		zboss.crec.X -= bq
		zboss.crec.Width = zboss.rec.Width / 3
		zboss.crec.Width += b / 2
		zboss.img = zboss.idlA.rec
		zboss.nm = "iceman"
		zboss.idlT = fps * 2
		zboss.spd = 2
	}

	//zboss.hp = 1

	boss = zboss
	levels[levNum].enm = append(levels[levNum].enm, zboss)
}

func makebosslev() { //MARK:MAKE BOSS LEVEL
	//WALLS FLOOR
	floortile = floortiles[RandInt(0, len(floortiles))]
	walltile = walltiles[RandInt(0, len(walltiles))]
	W3 := float32(3840)
	H3 := float32(2160)
	bossBordRec = rl.NewRectangle(cnt.X-W3/2, cnt.Y-H3/2, W3, H3)
	bossBordRec.X -= b3
	bossBordRec.Y -= b3
	bossBordRec.Width += b6
	bossBordRec.Height += b6
	zboss := x1scr{}
	//CENTER REC
	min, max := 17, 25
	numW := RandInt(min, max)
	min, max = 12, 19
	numH := RandInt(min, max)
	W, H := float32(numW)*b, float32(numH)*b
	rec := rl.NewRectangle(cnt.X-W/2, cnt.Y-H/2, W, H)
	zboss.recs = append(zboss.recs, rec)
	numWo := numW
	numHo := numH
	//OTHER RECS
	countbreak := 100
	num := RandInt(5, 11)
	for num > 0 {
		side := RandInt(1, 5)
		switch side {
		case 1:
			min, max := 5, 9
			numW = RandInt(min, max)
			min, max = 3, 8
			numH = RandInt(min, max)
			W, H = float32(numW)*b, float32(numH)*b
			diff := numWo - numW
			change := float32(RandInt(0, diff))
			x := zboss.recs[0].X + (change * b)
			y := zboss.recs[0].Y - H
			rec = rl.NewRectangle(x, y, W, H)
		case 2:
			min, max := 3, 8
			numW = RandInt(min, max)
			min, max = 5, 9
			numH = RandInt(min, max)
			W, H = float32(numW)*b, float32(numH)*b
			diff := numHo - numH
			change := float32(RandInt(0, diff))
			x := zboss.recs[0].X + zboss.recs[0].Width
			y := zboss.recs[0].Y + (change * b)
			rec = rl.NewRectangle(x, y, W, H)
		case 3:
			min, max := 5, 9
			numW = RandInt(min, max)
			min, max = 3, 8
			numH = RandInt(min, max)
			W, H = float32(numW)*b, float32(numH)*b
			diff := numWo - numW
			change := float32(RandInt(0, diff))
			x := zboss.recs[0].X + (change * b)
			y := zboss.recs[0].Y + zboss.recs[0].Height
			rec = rl.NewRectangle(x, y, W, H)
		case 4:
			min, max := 3, 8
			numW = RandInt(min, max)
			min, max = 5, 9
			numH = RandInt(min, max)
			W, H = float32(numW)*b, float32(numH)*b
			diff := numHo - numH
			change := float32(RandInt(0, diff))
			x := zboss.recs[0].X - W
			y := zboss.recs[0].Y + (change * b)
			rec = rl.NewRectangle(x, y, W, H)
		}
		if len(zboss.recs) > 1 {
			canadd := true
			for i := 1; i < len(zboss.recs); i++ {
				if rl.CheckCollisionRecs(rec, zboss.recs[i]) {
					canadd = false
				}
			}
			if canadd {
				v1 := rl.NewVector2(rec.X, rec.Y)
				v2 := v1
				v2.X += rec.Width
				v3 := v2
				v3.Y += rec.Height
				v4 := v3
				v4.X -= rec.Width
				if !rl.CheckCollisionPointRec(v1, bossBordRec) || !rl.CheckCollisionPointRec(v2, bossBordRec) || !rl.CheckCollisionPointRec(v3, bossBordRec) || !rl.CheckCollisionPointRec(v4, bossBordRec) {
					canadd = false
				}
			}
			if canadd {
				zboss.recs = append(zboss.recs, rec)
				num--
			}
		} else {
			canadd := true
			if canadd {
				v1 := rl.NewVector2(rec.X, rec.Y)
				v2 := v1
				v2.X += rec.Width
				v3 := v2
				v3.Y += rec.Height
				v4 := v3
				v4.X -= rec.Width
				if !rl.CheckCollisionPointRec(v1, bossBordRec) || !rl.CheckCollisionPointRec(v2, bossBordRec) || !rl.CheckCollisionPointRec(v3, bossBordRec) || !rl.CheckCollisionPointRec(v4, bossBordRec) {
					canadd = false
				}
			}
			if canadd {
				zboss.recs = append(zboss.recs, rec)
				num--
			}
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	//WALLS
	for i := 0; i < len(zboss.recs); i++ {
		siz := b
		x := zboss.recs[i].X
		y := zboss.recs[i].Y
		x -= siz
		y -= siz
		//TOP BOTTOM
		for x <= zboss.recs[i].X+zboss.recs[i].Width {
			rec := rl.NewRectangle(x, y, siz, siz)
			canadd := true
			for i := 0; i < len(zboss.recs); i++ {
				if rl.CheckCollisionRecs(rec, zboss.recs[i]) {
					canadd = false
				}
			}
			if canadd && len(zboss.walls) > 1 {
				for i := 0; i < len(zboss.walls); i++ {
					if rl.CheckCollisionRecs(rec, zboss.walls[i].rec) {
						canadd = false
					}
				}
			}
			if canadd {
				ztile := xtile{}
				ztile.rec = rec
				ztile.img = wallBoss
				ztile.fade = RandF32(0.4, 0.7)
				ztile.color = rl.White
				ztile.col2 = RandColor()
				ztile.solid = true
				zboss.walls = append(zboss.walls, ztile)
			}
			rec.Y += zboss.recs[i].Height + siz
			canadd = true
			for i := 0; i < len(zboss.recs); i++ {
				if rl.CheckCollisionRecs(rec, zboss.recs[i]) {
					canadd = false
				}
			}
			if canadd && len(zboss.walls) > 1 {
				for i := 0; i < len(zboss.walls); i++ {
					if rl.CheckCollisionRecs(rec, zboss.walls[i].rec) {
						canadd = false
					}
				}
			}
			if canadd {
				ztile := xtile{}
				ztile.rec = rec
				ztile.img = wallBoss
				ztile.fade = RandF32(0.3, 0.9)
				ztile.color = rl.White
				ztile.col2 = RandColor()
				ztile.solid = true
				zboss.walls = append(zboss.walls, ztile)
			}
			x += siz
		}
		//RIGHT LEFT
		x = zboss.recs[i].X
		y = zboss.recs[i].Y
		x -= siz
		for y < zboss.recs[i].Y+zboss.recs[i].Height {
			rec := rl.NewRectangle(x, y, siz, siz)
			canadd := true
			for i := 0; i < len(zboss.recs); i++ {
				if rl.CheckCollisionRecs(rec, zboss.recs[i]) {
					canadd = false
				}
			}
			if canadd && len(zboss.walls) > 1 {
				for i := 0; i < len(zboss.walls); i++ {
					if rl.CheckCollisionRecs(rec, zboss.walls[i].rec) {
						canadd = false
					}
				}
			}
			if canadd {
				ztile := xtile{}
				ztile.rec = rec
				ztile.img = wallBoss
				ztile.fade = RandF32(0.4, 0.7)
				ztile.color = rl.White
				ztile.col2 = RandColor()
				ztile.solid = true
				zboss.walls = append(zboss.walls, ztile)
			}
			rec.X += zboss.recs[i].Width + siz
			canadd = true
			for i := 0; i < len(zboss.recs); i++ {
				if rl.CheckCollisionRecs(rec, zboss.recs[i]) {
					canadd = false
				}
			}
			if canadd && len(zboss.walls) > 1 {
				for i := 0; i < len(zboss.walls); i++ {
					if rl.CheckCollisionRecs(rec, zboss.walls[i].rec) {
						canadd = false
					}
				}
			}
			if canadd {
				ztile := xtile{}
				ztile.rec = rec
				ztile.img = wallBoss
				ztile.fade = RandF32(0.4, 0.7)
				ztile.color = rl.White
				ztile.col2 = RandColor()
				ztile.solid = true
				zboss.walls = append(zboss.walls, ztile)
			}
			y += siz
		}
	}
	//FLOORS
	for i := 0; i < len(zboss.recs); i++ {
		siz := b
		x := zboss.recs[i].X
		y := zboss.recs[i].Y
		for y < zboss.recs[i].Y+zboss.recs[i].Height {
			rec := rl.NewRectangle(x, y, siz, siz)
			ztile := xtile{}
			ztile.rec = rec
			ztile.img = floorBoss
			ztile.color = rl.White
			ztile.col2 = RandColor()
			ztile.fade = RandF32(0.04, 0.08)
			zboss.floors = append(zboss.floors, ztile)
			x += siz
			if x >= zboss.recs[i].X+zboss.recs[i].Width {
				x = zboss.recs[i].X
				y += siz
			}
		}
	}
	size := b
	for i := 0; i < len(zboss.recs); i++ {
		//WATER
		if Roll12() > 10 {
			x := zboss.recs[i].X + size
			y := zboss.recs[i].Y + size
			x2 := x + zboss.recs[i].Width - size*3
			y2 := y + zboss.recs[i].Height - size*3
			ztile := xtile{}
			ztile.nm = "water"
			ztile.img = anm[0].rec
			ztile.color = rl.DarkBlue
			ztile.fade = RandF32(0.2, 0.5)
			ztile.rec = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
			ztile.img2 = splat[RandInt(0, len(splat))]
			ztile.rec2 = ztile.rec
			ztile.rec2.X -= b / 2
			ztile.rec2.Y -= b / 2
			ztile.rec2.Width += b
			ztile.rec2.Height += b
			if checkaddtilerecInner(ztile.rec, zboss) && checkaddetc(ztile.rec, zboss) {
				ztile.cnt = makecnt(ztile.rec)
				zboss.etc = append(zboss.etc, ztile)
			}
		}
		//SPIKE TRAPS
		if Roll12() > 10 {
			x := zboss.recs[i].X
			y := zboss.recs[i].Y
			x2 := x + zboss.recs[i].Width - size
			y2 := y + zboss.recs[i].Height - size
			ztile := xtile{}
			ztile.nm = "spiketrap"
			ztile.img = anm[1].rec
			ztile.color = rl.White
			ztile.col2 = RandColor()
			ztile.fade = 1
			ztile.rec = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
			if checkaddtilerecInner(ztile.rec, zboss) && checkaddetc(ztile.rec, zboss) {
				ztile.cnt = makecnt(ztile.rec)
				zboss.etc = append(zboss.etc, ztile)
			}
		}
		//FLAME TRAPS
		if Roll12() > 10 {
			x := zboss.recs[i].X
			y := zboss.recs[i].Y
			x2 := x + zboss.recs[i].Width - size
			y2 := y + zboss.recs[i].Height - size
			ztile := xtile{}
			ztile.nm = "flametrap"
			ztile.img = anm[2].rec
			ztile.color = rl.White
			ztile.fade = 1
			ztile.rec = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
			if checkaddtilerecInner(ztile.rec, zboss) && checkaddetc(ztile.rec, zboss) {
				ztile.rec2 = ztile.rec
				ztile.rec2.Height = 32
				ztile.rec2.Y += 4.5
				ztile.cnt = makecnt(ztile.rec)
				zboss.etc = append(zboss.etc, ztile)
			}
		}
	}
	levels = append(levels, zboss)
	//BGI
	siz := RandF32(b2, b4)
	x := levels[levNum].recs[0].X + b/2
	x += RandF32(0, levels[levNum].recs[0].Width-(siz+b))
	y := levels[levNum].recs[0].Y + b/2
	y += RandF32(0, levels[levNum].recs[0].Height-(siz+b))
	rec = rl.NewRectangle(x, y, siz, siz)
	zbgi := bgilist[RandInt(0, len(bgilist))]
	zbgi.rec = rec
	zbgi.fd = 1
	levels[levNum].bgi = append(levels[levNum].bgi, zbgi)
	//FLOWERS
	num = RandInt(2, 9)
	for num > 0 {
		cntr := findRanCnt()
		siz := RandF32(be3, b/2)
		zbgi := xbgi{}
		zbgi.rec = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
		zbgi.img = flowers[RandInt(0, len(flowers))]
		levels[levNum].flowers = append(levels[levNum].flowers, zbgi)
		num--
	}
	pl.cnt = rl.NewVector2(levels[levNum].recs[0].X+levels[levNum].recs[0].Width-b2, levels[levNum].recs[0].Y+levels[levNum].recs[0].Height-b2)
	upplayerrec()
}
func makeScroll(num int) string { //MARK:MAKE SCROLL
	txt := ""
	if checkaddscroll(num) {
		for i := 0; i < len(scrollList[num].costScroll); i++ {
			switch i {
			case 1:
				found := false
				newcost := scrollList[num].costScroll[i]
				for j := 0; j < len(storeItm); j++ {
					if storeItm[j].nm == "scroll ink" {
						if storeItm[j].numof > newcost {
							storeItm[j].numof -= newcost
							found = true
							break
						} else if storeItm[j].numof == newcost {
							storeItm[j].numof = 0
							storeItm[j].off = true
							storeItm[j] = xitm{}
							found = true
							break
						} else if storeItm[j].numof < newcost {
							newcost -= storeItm[j].numof
							storeItm[j].numof = 0
							storeItm[j].off = true
							storeItm[j] = xitm{}
						}
					}
				}
				if !found {
					for j := 0; j < len(pl.invn); j++ {
						if pl.invn[j].nm == "scroll ink" {
							if pl.invn[j].numof > newcost {
								pl.invn[j].numof -= newcost
								break
							} else if pl.invn[j].numof == newcost {
								pl.invn[j].numof = 0
								pl.invn[j].off = true
								pl.invn[j] = xitm{}
								break
							} else if pl.invn[j].numof < newcost {
								newcost -= pl.invn[j].numof
								pl.invn[j].numof = 0
								pl.invn[j].off = true
								pl.invn[j] = xitm{}
							}
						}
					}
				}
			case 0:
				found := false
				newcost := scrollList[num].costScroll[i]
				for j := 0; j < len(storeItm); j++ {
					if storeItm[j].nm == "scroll paper" {
						if storeItm[j].numof > newcost {
							storeItm[j].numof -= newcost
							found = true
							break
						} else if storeItm[j].numof == newcost {
							storeItm[j].numof = 0
							storeItm[j].off = true
							storeItm[j] = xitm{}
							found = true
							break
						} else if storeItm[j].numof < newcost {
							newcost -= storeItm[j].numof
							storeItm[j].numof = 0
							storeItm[j].off = true
							storeItm[j] = xitm{}
						}
					}
				}
				if !found {
					for j := 0; j < len(pl.invn); j++ {
						if pl.invn[j].nm == "scroll paper" {
							if pl.invn[j].numof > newcost {
								pl.invn[j].numof -= newcost
								break
							} else if pl.invn[j].numof == newcost {
								pl.invn[j].numof = 0
								pl.invn[j].off = true
								pl.invn[j] = xitm{}
								break
							} else if pl.invn[j].numof < newcost {
								newcost -= pl.invn[j].numof
								pl.invn[j].numof = 0
								pl.invn[j].off = true
								pl.invn[j] = xitm{}
							}
						}
					}
				}

			}

		}

		added := addscroll(num)
		if added {
			rl.PlaySound(audfx[48])
			txt = "created " + scrollList[num].nm
		}

	} else {
		rl.PlaySound(audfx[43])
		txt = "no more space in inventory or store room"
	}
	return txt
}
func makePotion(num int) string { //MARK:MAKE POTION

	txt := ""

	if checkaddpotion(num) {
		for i := 0; i < len(potionList[num].costPotion); i++ {
			if potionList[num].costPotion[i] != 0 {
				switch i {
				case 5:
					found := false
					newcost := potionList[num].costPotion[i]
					for j := 0; j < len(storeItm); j++ {
						if storeItm[j].nm == "larimar mushroom" {
							if storeItm[j].numof > newcost {
								storeItm[j].numof -= newcost
								found = true
								break
							} else if storeItm[j].numof == newcost {
								storeItm[j].numof = 0
								storeItm[j].off = true
								storeItm[j] = xitm{}
								found = true
								break
							} else if storeItm[j].numof < newcost {
								newcost -= storeItm[j].numof
								storeItm[j].numof = 0
								storeItm[j].off = true
								storeItm[j] = xitm{}
							}
						}
					}
					if !found {
						for j := 0; j < len(pl.invn); j++ {
							if pl.invn[j].nm == "larimar mushroom" {
								if pl.invn[j].numof > newcost {
									pl.invn[j].numof -= newcost
									break
								} else if pl.invn[j].numof == newcost {
									pl.invn[j].numof = 0
									pl.invn[j].off = true
									pl.invn[j] = xitm{}
									break
								} else if pl.invn[j].numof < newcost {
									newcost -= pl.invn[j].numof
									pl.invn[j].numof = 0
									pl.invn[j].off = true
									pl.invn[j] = xitm{}
								}
							}
						}
					}
				case 4:
					found := false
					newcost := potionList[num].costPotion[i]
					for j := 0; j < len(storeItm); j++ {
						if storeItm[j].nm == "jade mushroom" {
							if storeItm[j].numof > newcost {
								storeItm[j].numof -= newcost
								found = true
								break
							} else if storeItm[j].numof == newcost {
								storeItm[j].numof = 0
								storeItm[j].off = true
								storeItm[j] = xitm{}
								found = true
								break
							} else if storeItm[j].numof < newcost {
								newcost -= storeItm[j].numof
								storeItm[j].numof = 0
								storeItm[j].off = true
								storeItm[j] = xitm{}
							}
						}
					}
					if !found {
						for j := 0; j < len(pl.invn); j++ {
							if pl.invn[j].nm == "jade mushroom" {
								if pl.invn[j].numof > newcost {
									pl.invn[j].numof -= newcost
									break
								} else if pl.invn[j].numof == newcost {
									pl.invn[j].numof = 0
									pl.invn[j].off = true
									pl.invn[j] = xitm{}
									break
								} else if pl.invn[j].numof < newcost {
									newcost -= pl.invn[j].numof
									pl.invn[j].numof = 0
									pl.invn[j].off = true
									pl.invn[j] = xitm{}
								}
							}
						}
					}
				case 3:
					found := false
					newcost := potionList[num].costPotion[i]
					for j := 0; j < len(storeItm); j++ {
						if storeItm[j].nm == "rubelite mushroom" {
							if storeItm[j].numof > newcost {
								storeItm[j].numof -= newcost
								found = true
								break
							} else if storeItm[j].numof == newcost {
								storeItm[j].numof = 0
								storeItm[j].off = true
								storeItm[j] = xitm{}
								found = true
								break
							} else if storeItm[j].numof < newcost {
								newcost -= storeItm[j].numof
								storeItm[j].numof = 0
								storeItm[j].off = true
								storeItm[j] = xitm{}
							}
						}
					}
					if !found {
						for j := 0; j < len(pl.invn); j++ {
							if pl.invn[j].nm == "rubelite mushroom" {
								if pl.invn[j].numof > newcost {
									pl.invn[j].numof -= newcost
									break
								} else if pl.invn[j].numof == newcost {
									pl.invn[j].numof = 0
									pl.invn[j].off = true
									pl.invn[j] = xitm{}
									break
								} else if pl.invn[j].numof < newcost {
									newcost -= pl.invn[j].numof
									pl.invn[j].numof = 0
									pl.invn[j].off = true
									pl.invn[j] = xitm{}
								}
							}
						}
					}
				case 2:
					found := false
					newcost := potionList[num].costPotion[i]
					for j := 0; j < len(storeItm); j++ {
						if storeItm[j].nm == "topaz mushroom" {
							if storeItm[j].numof > newcost {
								storeItm[j].numof -= newcost
								found = true
								break
							} else if storeItm[j].numof == newcost {
								storeItm[j].numof = 0
								storeItm[j].off = true
								storeItm[j] = xitm{}
								found = true
								break
							} else if storeItm[j].numof < newcost {
								newcost -= storeItm[j].numof
								storeItm[j].numof = 0
								storeItm[j].off = true
								storeItm[j] = xitm{}
							}
						}
					}
					if !found {
						for j := 0; j < len(pl.invn); j++ {
							if pl.invn[j].nm == "topaz mushroom" {
								if pl.invn[j].numof > newcost {
									pl.invn[j].numof -= newcost
									break
								} else if pl.invn[j].numof == newcost {
									pl.invn[j].numof = 0
									pl.invn[j].off = true
									pl.invn[j] = xitm{}
									break
								} else if pl.invn[j].numof < newcost {
									newcost -= pl.invn[j].numof
									pl.invn[j].numof = 0
									pl.invn[j].off = true
									pl.invn[j] = xitm{}
								}
							}
						}
					}
				case 1:
					found := false
					newcost := potionList[num].costPotion[i]
					for j := 0; j < len(storeItm); j++ {
						if storeItm[j].nm == "zircon mushroom" {
							if storeItm[j].numof > newcost {
								storeItm[j].numof -= newcost
								found = true
								break
							} else if storeItm[j].numof == newcost {
								storeItm[j].numof = 0
								storeItm[j].off = true
								storeItm[j] = xitm{}
								found = true
								break
							} else if storeItm[j].numof < newcost {
								newcost -= storeItm[j].numof
								storeItm[j].numof = 0
								storeItm[j].off = true
								storeItm[j] = xitm{}
							}
						}
					}
					if !found {
						for j := 0; j < len(pl.invn); j++ {
							if pl.invn[j].nm == "zircon mushroom" {
								if pl.invn[j].numof > newcost {
									pl.invn[j].numof -= newcost
									break
								} else if pl.invn[j].numof == newcost {
									pl.invn[j].numof = 0
									pl.invn[j].off = true
									pl.invn[j] = xitm{}
									break
								} else if pl.invn[j].numof < newcost {
									newcost -= pl.invn[j].numof
									pl.invn[j].numof = 0
									pl.invn[j].off = true
									pl.invn[j] = xitm{}
								}
							}
						}
					}
				case 0:
					found := false
					newcost := potionList[num].costPotion[i]
					for j := 0; j < len(storeItm); j++ {
						if storeItm[j].nm == "amethyst mushroom" {
							if storeItm[j].numof > newcost {
								storeItm[j].numof -= newcost
								found = true
								break
							} else if storeItm[j].numof == newcost {
								storeItm[j].numof = 0
								storeItm[j].off = true
								storeItm[j] = xitm{}
								found = true
								break
							} else if storeItm[j].numof < newcost {
								newcost -= storeItm[j].numof
								storeItm[j].numof = 0
								storeItm[j].off = true
								storeItm[j] = xitm{}
							}
						}
					}
					if !found {
						for j := 0; j < len(pl.invn); j++ {
							if pl.invn[j].nm == "amethyst mushroom" {
								if pl.invn[j].numof > newcost {
									pl.invn[j].numof -= newcost
									break
								} else if pl.invn[j].numof == newcost {
									pl.invn[j].numof = 0
									pl.invn[j].off = true
									pl.invn[j] = xitm{}
									break
								} else if pl.invn[j].numof < newcost {
									newcost -= pl.invn[j].numof
									pl.invn[j].numof = 0
									pl.invn[j].off = true
									pl.invn[j] = xitm{}
								}
							}
						}
					}

				}
			}
		}

		added := addpotion(num)
		if added {
			rl.PlaySound(audfx[48])
			txt = "created " + potionList[num].nm
		}
	} else {
		rl.PlaySound(audfx[43])
		txt = "no more space in inventory or store room"
	}
	return txt
}
func maketreasureroom() { //MARK:MAKE TREASURE ROOM
	//WALLS FLOOR
	floortile = floortiles[RandInt(0, len(floortiles))]
	walltile = walltiles[RandInt(0, len(walltiles))]
	W3 := float32(3840)
	H3 := float32(2160)
	bossBordRec = rl.NewRectangle(cnt.X-W3/2, cnt.Y-H3/2, W3, H3)
	bossBordRec.X -= b3
	bossBordRec.Y -= b3
	bossBordRec.Width += b6
	bossBordRec.Height += b6
	zboss := x1scr{}
	//CENTER REC
	min, max := 20, 29
	numW := RandInt(min, max)
	min, max = 15, 23
	numH := RandInt(min, max)
	W, H := float32(numW)*b, float32(numH)*b
	rec := rl.NewRectangle(cnt.X-W/2, cnt.Y-H/2, W, H)
	zboss.recs = append(zboss.recs, rec)
	numWo := numW
	numHo := numH
	//OTHER RECS
	countbreak := 100
	num := RandInt(5, 11)
	for num > 0 {
		side := RandInt(1, 5)
		switch side {
		case 1:
			min, max := 3, 6
			numW = RandInt(min, max)
			min, max = 2, 5
			numH = RandInt(min, max)
			W, H = float32(numW)*b, float32(numH)*b
			diff := numWo - numW
			change := float32(RandInt(0, diff))
			x := zboss.recs[0].X + (change * b)
			y := zboss.recs[0].Y - H
			rec = rl.NewRectangle(x, y, W, H)
		case 2:
			min, max := 2, 5
			numW = RandInt(min, max)
			min, max = 3, 6
			numH = RandInt(min, max)
			W, H = float32(numW)*b, float32(numH)*b
			diff := numHo - numH
			change := float32(RandInt(0, diff))
			x := zboss.recs[0].X + zboss.recs[0].Width
			y := zboss.recs[0].Y + (change * b)
			rec = rl.NewRectangle(x, y, W, H)
		case 3:
			min, max := 3, 6
			numW = RandInt(min, max)
			min, max = 2, 5
			numH = RandInt(min, max)
			W, H = float32(numW)*b, float32(numH)*b
			diff := numWo - numW
			change := float32(RandInt(0, diff))
			x := zboss.recs[0].X + (change * b)
			y := zboss.recs[0].Y + zboss.recs[0].Height
			rec = rl.NewRectangle(x, y, W, H)
		case 4:
			min, max := 2, 5
			numW = RandInt(min, max)
			min, max = 3, 6
			numH = RandInt(min, max)
			W, H = float32(numW)*b, float32(numH)*b
			diff := numHo - numH
			change := float32(RandInt(0, diff))
			x := zboss.recs[0].X - W
			y := zboss.recs[0].Y + (change * b)
			rec = rl.NewRectangle(x, y, W, H)
		}
		if len(zboss.recs) > 1 {
			canadd := true
			for i := 1; i < len(zboss.recs); i++ {
				if rl.CheckCollisionRecs(rec, zboss.recs[i]) {
					canadd = false
				}
			}
			if canadd {
				v1 := rl.NewVector2(rec.X, rec.Y)
				v2 := v1
				v2.X += rec.Width
				v3 := v2
				v3.Y += rec.Height
				v4 := v3
				v4.X -= rec.Width
				if !rl.CheckCollisionPointRec(v1, bossBordRec) || !rl.CheckCollisionPointRec(v2, bossBordRec) || !rl.CheckCollisionPointRec(v3, bossBordRec) || !rl.CheckCollisionPointRec(v4, bossBordRec) {
					canadd = false
				}
			}
			if canadd {
				zboss.recs = append(zboss.recs, rec)
				num--
			}
		} else {
			canadd := true
			if canadd {
				v1 := rl.NewVector2(rec.X, rec.Y)
				v2 := v1
				v2.X += rec.Width
				v3 := v2
				v3.Y += rec.Height
				v4 := v3
				v4.X -= rec.Width
				if !rl.CheckCollisionPointRec(v1, bossBordRec) || !rl.CheckCollisionPointRec(v2, bossBordRec) || !rl.CheckCollisionPointRec(v3, bossBordRec) || !rl.CheckCollisionPointRec(v4, bossBordRec) {
					canadd = false
				}
			}
			if canadd {
				zboss.recs = append(zboss.recs, rec)
				num--
			}
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	//WALLS
	for i := 0; i < len(zboss.recs); i++ {
		siz := b
		x := zboss.recs[i].X
		y := zboss.recs[i].Y
		x -= siz
		y -= siz
		//TOP BOTTOM
		for x <= zboss.recs[i].X+zboss.recs[i].Width {
			rec := rl.NewRectangle(x, y, siz, siz)
			canadd := true
			for i := 0; i < len(zboss.recs); i++ {
				if rl.CheckCollisionRecs(rec, zboss.recs[i]) {
					canadd = false
				}
			}
			if canadd && len(zboss.walls) > 1 {
				for i := 0; i < len(zboss.walls); i++ {
					if rl.CheckCollisionRecs(rec, zboss.walls[i].rec) {
						canadd = false
					}
				}
			}
			if canadd {
				ztile := xtile{}
				ztile.rec = rec
				ztile.img = wallBoss
				ztile.fade = RandF32(0.4, 0.7)
				ztile.color = rl.White
				ztile.col2 = RandColor()
				ztile.solid = true
				zboss.walls = append(zboss.walls, ztile)
			}
			rec.Y += zboss.recs[i].Height + siz
			canadd = true
			for i := 0; i < len(zboss.recs); i++ {
				if rl.CheckCollisionRecs(rec, zboss.recs[i]) {
					canadd = false
				}
			}
			if canadd && len(zboss.walls) > 1 {
				for i := 0; i < len(zboss.walls); i++ {
					if rl.CheckCollisionRecs(rec, zboss.walls[i].rec) {
						canadd = false
					}
				}
			}
			if canadd {
				ztile := xtile{}
				ztile.rec = rec
				ztile.img = wallBoss
				ztile.fade = RandF32(0.3, 0.9)
				ztile.color = rl.White
				ztile.col2 = RandColor()
				ztile.solid = true
				zboss.walls = append(zboss.walls, ztile)
			}
			x += siz
		}
		//RIGHT LEFT
		x = zboss.recs[i].X
		y = zboss.recs[i].Y
		x -= siz
		for y < zboss.recs[i].Y+zboss.recs[i].Height {
			rec := rl.NewRectangle(x, y, siz, siz)
			canadd := true
			for i := 0; i < len(zboss.recs); i++ {
				if rl.CheckCollisionRecs(rec, zboss.recs[i]) {
					canadd = false
				}
			}
			if canadd && len(zboss.walls) > 1 {
				for i := 0; i < len(zboss.walls); i++ {
					if rl.CheckCollisionRecs(rec, zboss.walls[i].rec) {
						canadd = false
					}
				}
			}
			if canadd {
				ztile := xtile{}
				ztile.rec = rec
				ztile.img = wallBoss
				ztile.fade = RandF32(0.4, 0.7)
				ztile.color = rl.White
				ztile.col2 = RandColor()
				ztile.solid = true
				zboss.walls = append(zboss.walls, ztile)
			}
			rec.X += zboss.recs[i].Width + siz
			canadd = true
			for i := 0; i < len(zboss.recs); i++ {
				if rl.CheckCollisionRecs(rec, zboss.recs[i]) {
					canadd = false
				}
			}
			if canadd && len(zboss.walls) > 1 {
				for i := 0; i < len(zboss.walls); i++ {
					if rl.CheckCollisionRecs(rec, zboss.walls[i].rec) {
						canadd = false
					}
				}
			}
			if canadd {
				ztile := xtile{}
				ztile.rec = rec
				ztile.img = wallBoss
				ztile.fade = RandF32(0.4, 0.7)
				ztile.color = rl.White
				ztile.col2 = RandColor()
				ztile.solid = true
				zboss.walls = append(zboss.walls, ztile)
			}
			y += siz
		}
	}
	//FLOORS
	for i := 0; i < len(zboss.recs); i++ {
		siz := b
		x := zboss.recs[i].X
		y := zboss.recs[i].Y
		for y < zboss.recs[i].Y+zboss.recs[i].Height {
			rec := rl.NewRectangle(x, y, siz, siz)
			ztile := xtile{}
			ztile.rec = rec
			ztile.img = floorBoss
			ztile.color = rl.White
			ztile.col2 = RandColor()
			ztile.fade = RandF32(0.04, 0.08)
			zboss.floors = append(zboss.floors, ztile)
			x += siz
			if x >= zboss.recs[i].X+zboss.recs[i].Width {
				x = zboss.recs[i].X
				y += siz
			}
		}
	}

	//PLAYER CENTER
	pl.cnt = rl.NewVector2(zboss.recs[0].X+zboss.recs[0].Width-b2, zboss.recs[0].Y+zboss.recs[0].Height-b2)
	upplayerrec()

	//ROOM TYPE
	choose := RandInt(1, 9)
	switch choose {
	case 8:

		countbreak := 100
		num := RandInt(10, 21)

		size := b
		for num > 0 {
			i := RandInt(0, len(zboss.recs))
			if Roll6() > 2 {
				i = 0
			}
			//SPIKE TRAPS
			if FlipCoin() {
				x := zboss.recs[i].X
				y := zboss.recs[i].Y
				x2 := x + zboss.recs[i].Width - size
				y2 := y + zboss.recs[i].Height - size
				ztile := xtile{}
				ztile.nm = "spiketrap"
				ztile.img = anm[1].rec
				ztile.color = rl.White
				ztile.col2 = RandColor()
				ztile.fade = 1
				ztile.rec = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
				if checkaddtilerecInner(ztile.rec, zboss) && checkaddetc(ztile.rec, zboss) {
					ztile.cnt = makecnt(ztile.rec)
					zboss.etc = append(zboss.etc, ztile)
					num--
				}
			}
			//FLAME TRAPS
			if FlipCoin() {
				x := zboss.recs[i].X
				y := zboss.recs[i].Y
				x2 := x + zboss.recs[i].Width - size
				y2 := y + zboss.recs[i].Height - size
				ztile := xtile{}
				ztile.nm = "flametrap"
				ztile.img = anm[2].rec
				ztile.color = rl.White
				ztile.fade = 1
				ztile.rec = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
				if checkaddtilerecInner(ztile.rec, zboss) && checkaddetc(ztile.rec, zboss) {
					ztile.rec2 = ztile.rec
					ztile.rec2.Height = 32
					ztile.rec2.Y += 4.5
					ztile.cnt = makecnt(ztile.rec)
					zboss.etc = append(zboss.etc, ztile)
					num--
				}
			}
			countbreak--
			if countbreak == 0 {
				break
			}
		}

		countbreak = 100
		num = RandInt(3, 8)
		for num > 0 {
			size := RandF32(b, b3)
			x := zboss.recs[0].X + size
			y := zboss.recs[0].Y + size
			x2 := x + zboss.recs[0].Width - size*3
			y2 := y + zboss.recs[0].Height - size*3
			ztile := xtile{}
			ztile.img = walltile
			ztile.col2 = RandColor()
			ztile.color = rl.White
			ztile.fade = RandF32(0.3, 0.9)
			ztile.rec = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
			ztile.spikes = true
			if ztile.spikes {
				for j := 0; j < 4; j++ {
					ztile.col2 = RandColor()
					rec2 := ztile.rec
					rec2.X += ztile.rec.Width / 4
					rec2.Y += ztile.rec.Height / 4
					rec2.Width -= ztile.rec.Width / 2
					rec2.Height -= ztile.rec.Height / 2
					ztile.spikerecs = append(ztile.spikerecs, rec2)
				}
			}
			if checkaddtilerecInner(ztile.rec, zboss) && checkRecPlayer(ztile.rec) {
				ztile.spd = RandF32(b/12, b/7)
				if FlipCoin() {
					ztile.dirX = ztile.spd
					if FlipCoin() {
						ztile.dirX = -ztile.dirX
					}
				} else {
					ztile.dirY = ztile.spd
					if FlipCoin() {
						ztile.dirY = -ztile.dirY
					}
				}
				zboss.walls = append(zboss.walls, ztile)
				num--
			}
			countbreak--
			if countbreak == 0 {
				break
			}

		}

		num = RandInt(10, 16) //FLAME HEAD
		for num > 0 {
			zenm := xenm{}
			zenm = enmlist[13]
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rec = rl.NewRectangle(zenm.cnt.X-zenm.rec.Width/2, zenm.cnt.Y-zenm.rec.Height/2, zenm.rec.Width, zenm.rec.Height)
			zboss.enm = append(zboss.enm, zenm)
			zboss.enNum++
			num--
		}

	case 7:
		zboss = makeswitchesTreasureRoom(zboss, 0)
		num := RandInt(5, 9) //ROTATING SPIKES
		for num > 0 {
			zenm := xenm{}
			zenm = enmlist[24]
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rec = rl.NewRectangle(zenm.cnt.X-zenm.rec.Width/2, zenm.cnt.Y-zenm.rec.Height/2, zenm.rec.Width, zenm.rec.Height)
			zboss.enm = append(zboss.enm, zenm)
			zboss.enNum++
			num--
		}
		num = RandInt(5, 9) //ROBOT
		for num > 0 {
			zenm := xenm{}
			zenm = enmlist[18]
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rec = rl.NewRectangle(zenm.cnt.X-zenm.rec.Width/2, zenm.cnt.Y-zenm.rec.Height/2, zenm.rec.Width, zenm.rec.Height)
			zboss.enm = append(zboss.enm, zenm)
			zboss.enNum++
			num--
		}
		num = RandInt(5, 9) //ROCK
		for num > 0 {
			zenm := xenm{}
			zenm = enmlist[21]
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rec = rl.NewRectangle(zenm.cnt.X-zenm.rec.Width/2, zenm.cnt.Y-zenm.rec.Height/2, zenm.rec.Width, zenm.rec.Height)
			zboss.enm = append(zboss.enm, zenm)
			zboss.enNum++
			num--
		}
	case 6:
		zboss = makeswitchesTreasureRoom(zboss, 0)
		num := RandInt(5, 9) //RED ANTENNA
		for num > 0 {
			zenm := xenm{}
			zenm = enmlist[4]
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rec = rl.NewRectangle(zenm.cnt.X-zenm.rec.Width/2, zenm.cnt.Y-zenm.rec.Height/2, zenm.rec.Width, zenm.rec.Height)
			zenm.atkT = RandInt32(1, 5) * fps
			zboss.enm = append(zboss.enm, zenm)
			zboss.enNum++
			num--
		}
	case 5:
		zboss = makeswitchesTreasureRoom(zboss, 0)
		num := RandInt(20, 31) //FLY
		for num > 0 {
			zenm := xenm{}
			zenm = enmlist[12]
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rec = rl.NewRectangle(zenm.cnt.X-zenm.rec.Width/2, zenm.cnt.Y-zenm.rec.Height/2, zenm.rec.Width, zenm.rec.Height)
			zboss.enm = append(zboss.enm, zenm)
			zboss.enNum++
			num--
		}
	case 4:
		num := RandInt(40, 61) //RED BOMB
		for num > 0 {
			zenm := xenm{}
			zenm = enmlist[2]
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rec = rl.NewRectangle(zenm.cnt.X-zenm.rec.Width/2, zenm.cnt.Y-zenm.rec.Height/2, zenm.rec.Width, zenm.rec.Height)
			zboss.enm = append(zboss.enm, zenm)
			zboss.enNum++
			num--
		}
	case 3:
		zboss = makeswitchesTreasureRoom(zboss, 1)
		num := RandInt(25, 36) //CARROT
		for num > 0 {
			zenm := xenm{}
			zenm = enmlist[17]
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rec = rl.NewRectangle(zenm.cnt.X-zenm.rec.Width/2, zenm.cnt.Y-zenm.rec.Height/2, zenm.rec.Width, zenm.rec.Height)
			zboss.enm = append(zboss.enm, zenm)
			zboss.enNum++
			num--
		}
	case 2:
		num := RandInt(70, 91) //BALLOON
		for num > 0 {
			zenm := xenm{}
			zenm = enmlist[5]
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rec = rl.NewRectangle(zenm.cnt.X-zenm.rec.Width/2, zenm.cnt.Y-zenm.rec.Height/2, zenm.rec.Width, zenm.rec.Height)
			zboss.enm = append(zboss.enm, zenm)
			zboss.enNum++
			num--
		}
	case 1:
		num := RandInt(25, 36) //FLAME HEAD
		for num > 0 {
			zenm := xenm{}
			zenm = enmlist[13]
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rec = rl.NewRectangle(zenm.cnt.X-zenm.rec.Width/2, zenm.cnt.Y-zenm.rec.Height/2, zenm.rec.Width, zenm.rec.Height)
			zboss.enm = append(zboss.enm, zenm)
			zboss.enNum++
			num--
		}
	}

	//CHEST
	siz := b2
	zchst := xchst{}
	zchst.slots = 4
	for i := 0; i < zchst.slots; i++ {
		zchst.itm = append(zchst.itm, xitm{})
	}
	countbreak = 100
	var unloknums []int
	for i := 27; i < len(itmlist); i++ {
		if !itmlist[i].unlok && !itmlist[i].nocrate {
			unloknums = append(unloknums, i)
		}
	}
	count := 0
	for zchst.itm[3].nm == "" {
		zchst.itm[count] = itmlist[unloknums[RandInt(0, len(unloknums))]]

		if zchst.itm[count].nm == "gold" || zchst.itm[count].nm == "silver" || zchst.itm[count].nm == "platinum" || zchst.itm[count].nm == "bronze" || zchst.itm[count].nm == "lead" {
			zchst.itm[count].numof = RandInt(40, 71)
		} else if zchst.itm[count].nm == "hp potion full" || zchst.itm[count].nm == "mana potion full" || zchst.itm[count].nm == "beetroot" || zchst.itm[count].nm == "honeycomb" || zchst.itm[count].nm == "bomb" || zchst.itm[count].nm == "soda" || zchst.itm[count].nm == "jar of gas" || zchst.itm[count].nm == "jar of blood" || zchst.itm[count].nm == "pistol" || zchst.itm[count].nm == "popcorn" || zchst.itm[count].nm == "ladybug" {
			zchst.itm[count].numof = RandInt(1, 11)
		}

		count++
		countbreak--
		if countbreak == 0 {
			break
		}
	}

	zchst.img = anm[4].rec
	zchst.cnt = makecnt(zboss.recs[len(zboss.recs)-1])
	zchst.rec = rl.NewRectangle(zchst.cnt.X-siz/2, zchst.cnt.Y-siz/2, siz, siz)
	zchst.crec = zchst.rec
	zchst.crec.X += zchst.crec.Width / 4
	zchst.crec.Y += zchst.crec.Height / 2
	zchst.crec.Y -= 4
	zchst.crec.Width = zchst.crec.Width / 2
	zchst.crec.Height = (zchst.crec.Height / 9) * 4
	zboss.chst = append(zboss.chst, zchst)

	levels = append(levels, zboss)
	//BGI
	siz = RandF32(b2, b4)
	x := levels[levNum].recs[0].X + b/2
	x += RandF32(0, levels[levNum].recs[0].Width-(siz+b))
	y := levels[levNum].recs[0].Y + b/2
	y += RandF32(0, levels[levNum].recs[0].Height-(siz+b))
	rec = rl.NewRectangle(x, y, siz, siz)
	zbgi := bgilist[RandInt(0, len(bgilist))]
	zbgi.rec = rec
	zbgi.fd = 1
	levels[levNum].bgi = append(levels[levNum].bgi, zbgi)
	//FLOWERS
	num = RandInt(2, 9)
	for num > 0 {
		cntr := findRanCnt()
		siz := RandF32(be3, b/2)
		zbgi := xbgi{}
		zbgi.rec = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
		zbgi.img = flowers[RandInt(0, len(flowers))]
		levels[levNum].flowers = append(levels[levNum].flowers, zbgi)
		num--
	}

	pl.cnt = rl.NewVector2(levels[levNum].recs[0].X+levels[levNum].recs[0].Width-b2, levels[levNum].recs[0].Y+levels[levNum].recs[0].Height-b2)
	upplayerrec()

	completed := makeexit()
	if !completed {
		makelevel()
	}

}
func makeenemies() { //MARK:MAKE ENEMIES

	num := 0

	switch levNumDis {
	case 1:
		num = RandInt(10, 16)
	case 2:
		num = RandInt(10, 16)
	case 3:
		num = RandInt(10, 16)
	case 4:
		num = RandInt(15, 21)
	case 5:
		num = RandInt(15, 21)
	case 6:
		num = RandInt(15, 21)
	case 7:
		num = RandInt(20, 26)
	case 8:
		num = RandInt(20, 26)
	case 9:
		num = RandInt(20, 26)
	case 10:
		num = RandInt(30, 36)
	default:
		num = RandInt(10, 16)
	}

	if bosskey2 {
		num += RandInt(1, 4)
	}
	if bosskey3 {
		num += RandInt(1, 4)
	}

	countbreak := 500
	for {
		zenm := xenm{}
		choose := 0

		switch levNumDis {
		case 1:
			choose = RandInt(0, 3)
			if bosskey1 || bosskey2 {
				choose = RandInt(0, 4)
			}
		case 2:
			choose = RandInt(0, 5)
			if bosskey1 || bosskey2 {
				choose = RandInt(0, 6)
			}
		case 3:
			choose = RandInt(0, 6)
			if bosskey1 || bosskey2 {
				choose = RandInt(0, 7)
			}
		case 4:
			choose = RandInt(0, 9)
			if bosskey1 || bosskey2 {
				choose = RandInt(0, 11)
			}
		case 5:
			choose = RandInt(0, 12)
			if bosskey1 || bosskey2 {
				choose = RandInt(0, 13)
			}
		case 6:
			choose = RandInt(0, 13)
			if bosskey1 || bosskey2 {
				choose = RandInt(0, 15)
			}
		case 7:
			choose = RandInt(0, 15)
			if bosskey1 || bosskey2 {
				choose = RandInt(0, 17)
			}
		case 8:
			choose = RandInt(0, 17)
			if bosskey1 || bosskey2 {
				choose = RandInt(0, 19)
			}
		case 9:
			choose = RandInt(0, 20)
			if bosskey2 {
				choose = RandInt(0, 25)
			} else if bosskey1 {
				choose = RandInt(0, 23)
			}

		case 10:
			choose = RandInt(0, 21)
			if bosskey2 {
				choose = RandInt(0, 25)
			} else if bosskey1 {
				choose = RandInt(0, 24)
			}
		}

		switch choose {
		case 0:
			zenm = enmlist[0] //BLUE SPIKE
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
		case 1:
			zenm = enmlist[1] //RED EYE
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
		case 2:
			zenm = enmlist[11] //WORM
			countbreak := 100
			for {
				zenm.dirX = RandF32(-zenm.spd, zenm.spd)
				countbreak--
				if countbreak == 0 || Abs(zenm.dirX) > zenm.spd/2 {
					break
				}
			}
		case 3:
			zenm = enmlist[13] //FLAME HEAD
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
		case 4:
			zenm = enmlist[2] //RED BOMB
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
		case 5:
			zenm = enmlist[4] //RED ANTENNA
			countbreak := 100
			for {
				zenm.dirX = RandF32(-zenm.spd, zenm.spd)
				if Abs(zenm.dirX) > 0.4 {
					break
				}
				countbreak--
				if countbreak == 0 {
					break
				}
			}
			zenm.atkT = RandInt32(1, 5) * fps
		case 6:
			zenm = enmlist[5] //BALLOON
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
		case 7:
			zenm = enmlist[12] //FLY
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
		case 8:
			zenm = enmlist[14] //ORANGE
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
		case 9:
			zenm = enmlist[9] //YELLOW DINO
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
		case 10:
			zenm = enmlist[3] //GHOST
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
		case 11:
			zenm = enmlist[6] //CROCODILE
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
		case 12:
			zenm = enmlist[7] //PINK CART WHEEL
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
			zenm.atkT = fps * RandInt32(1, 3)
		case 13:
			zenm = enmlist[8] //GREEN PLANT
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
			zenm.moveChangeT = fps * RandInt32(2, 5)
			zenm.atkT = fps / 4
		case 14:
			zenm = enmlist[10] //BLACK DOT
			zenm.numMax = RandInt(4, 11)
			zenm.atkT = fps
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
		case 15:
			zenm = enmlist[15] //SKELETON
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
		case 16:
			zenm = enmlist[16] //RED BLOB
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
		case 17:
			zenm = enmlist[17] //CARROT
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
		case 18:
			zenm = enmlist[20] //RED DEVIL
		case 19:
			zenm = enmlist[21] //ROCK GUY
			zenm.idl = true
			zenm.moveChangeT = fps * 2
		case 20:
			zenm = enmlist[22] //BIRD
		case 21:
			zenm = enmlist[24] //ROTATING SPIKES
		case 22:
			zenm = enmlist[19] //GREEN PIG
			zenm.dirX = RandF32(-zenm.spd, zenm.spd)
			zenm.dirY = RandF32(-zenm.spd, zenm.spd)
		case 23:
			zenm = enmlist[23] //JERSEY
		case 24:
			zenm = enmlist[18] //ROBOT
		}

		//INCREASE HP WEAP DMG STR
		switch maxWeapDmg {
		case 3:
			zenm.hpmax++
			zenm.hp = zenm.hpmax
		case 4, 5:
			zenm.hpmax += 2
			zenm.hp = zenm.hpmax
		case 6, 7:
			zenm.hpmax += 4
			zenm.hp = zenm.hpmax
		case 8, 9, 10, 11, 12:
			zenm.hpmax += 7
			zenm.hp = zenm.hpmax
		}
		switch stats.str {
		case 2:
			zenm.hpmax++
			zenm.hp = zenm.hpmax
		case 3:
			zenm.hpmax += 2
			zenm.hp = zenm.hpmax
		case 4:
			zenm.hpmax += 4
			zenm.hp = zenm.hpmax
		case 5:
			zenm.hpmax += 5
			zenm.hp = zenm.hpmax
		}

		canadd := false
		zenm.rec, canadd = findranrecpos(zenm.rec)

		if canadd {
			zenm.cnt = makecnt(zenm.rec)
			switch zenm.nm {
			case "bush":
				zenm.crec.Y += zenm.crec.Width / 4
				zenm.crec.X += zenm.crec.Width / 4
				zenm.crec.Width = zenm.crec.Width / 2
				zenm.crec.Height -= zenm.crec.Height / 4
				zenm.carec = zenm.rec
				zenm.carec.X -= b4
				zenm.carec.Y -= b4
				zenm.carec.Width += b8
				zenm.carec.Height += b8
			case "jersey":
				zenm.crec.Y += zenm.crec.Width / 2
				zenm.crec.X += zenm.crec.Width / 4
				zenm.crec.Width = zenm.crec.Width / 2
				zenm.crec.Height = zenm.crec.Height / 2
			case "bird":
				zenm.crec.Y += zenm.crec.Width / 8
				zenm.crec.X += zenm.crec.Width / 8
				zenm.crec.Width -= zenm.crec.Width / 4
				zenm.crec.Height -= zenm.crec.Height / 4
			case "greenpig":
				zenm.crec.Y += zenm.crec.Width / 3
				zenm.crec.X += zenm.crec.Width / 3
				zenm.crec.Width = zenm.crec.Width / 3
				zenm.crec.Height = zenm.crec.Height / 3
				zenm.crec.Y += 4
			case "robot":
				zenm.crec.Y += zenm.crec.Height / 2
				zenm.crec.X += zenm.crec.Width / 4
				zenm.crec.Width = zenm.crec.Width / 2
				zenm.crec.Height = zenm.crec.Height / 2
				zenm.carec = zenm.crec
				zenm.carec.X -= b5
				zenm.carec.Y -= b5
				zenm.carec.Width += b10
				zenm.carec.Height += b10
			case "carrot":
				zenm.crec.X += zenm.crec.Width / 8
				zenm.crec.Width -= zenm.crec.Width / 4
				zenm.carec = zenm.rec
				zenm.carec.X -= b4
				zenm.carec.Y -= b4
				zenm.carec.Width += b8
				zenm.carec.Height += b8
			case "redblob":
				zenm.crec.X += zenm.crec.Width / 4
				zenm.crec.Width = zenm.crec.Width / 2
				zenm.crec.Y += zenm.crec.Height / 2
				zenm.crec.Height = zenm.crec.Height / 2
			case "skeleton":
				zenm.crec.X += zenm.crec.Width / 4
				zenm.crec.Width = zenm.crec.Width / 2
				zenm.crec.Height -= zenm.crec.Height / 8
			case "orange":
				zenm.crec.X += zenm.crec.Width / 4
				zenm.crec.Width = zenm.crec.Width / 2
				zenm.crec.Y += zenm.crec.Height / 3
				zenm.crec.Height = zenm.crec.Height / 2
				zenm.carec = zenm.rec
				zenm.carec.X -= b3
				zenm.carec.Y -= b3
				zenm.carec.Width += b6
				zenm.carec.Height += b6
			case "flamehead":
				zenm.crec.X += zenm.crec.Width / 4
				zenm.crec.Width = zenm.crec.Width / 2
				zenm.carec = zenm.rec
				zenm.carec.X -= b3
				zenm.carec.Y -= b3
				zenm.carec.Width += b6
				zenm.carec.Height += b6
			case "fly":
				zenm.crec.X += zenm.crec.Width / 4
				zenm.crec.Width -= zenm.crec.Width / 2
				zenm.crec.Y += zenm.crec.Height / 4
				zenm.crec.Height -= zenm.crec.Height / 2
				zenm.carec = zenm.rec
				zenm.carec.X -= b3
				zenm.carec.Y -= b3
				zenm.carec.Width += b6
				zenm.carec.Height += b6
			case "worm":
				zenm.crec.Y += (zenm.crec.Height / 4) * 3
				zenm.crec.Height = zenm.crec.Height / 4
			case "yellowdino":
				zenm.crec.X += zenm.crec.Width / 8
				zenm.crec.Width -= zenm.crec.Width / 4
				zenm.crec.Y += zenm.crec.Height / 3
				zenm.crec.Height = (zenm.crec.Height / 3) * 2
			case "greenplant":
				zenm.crec.Y += (zenm.crec.Height / 3) * 2
				zenm.crec.Height = zenm.crec.Height / 3
				zenm.crec.X += zenm.crec.Width / 3
				zenm.crec.Width = zenm.crec.Width / 3
			case "pinkcart":
				zenm.crec.X += zenm.crec.Width / 4
				zenm.crec.Width = zenm.crec.Width / 2
				zenm.crec.Y += zenm.crec.Height / 2
				zenm.crec.Height = zenm.crec.Height / 2
			case "crocodile":
				zenm.crec.Y += (zenm.crec.Height / 12) * 7
				zenm.crec.Height = (zenm.crec.Height / 12) * 5
				zenm.carec = zenm.crec
				zenm.carec.X -= b4
				zenm.carec.Width += b8
			case "balloon":
				zenm.crec.X += zenm.crec.Width / 4
				zenm.crec.Width -= zenm.crec.Width / 2
				zenm.crec.Y += 4
				zenm.crec.Height -= zenm.crec.Height / 2
			case "redantenna":
				zenm.crec.Y += zenm.crec.Height / 3
				zenm.crec.Height -= zenm.crec.Height / 3
				zenm.crec.X += zenm.crec.Width / 6
				zenm.crec.Width -= zenm.crec.Width / 3
			case "ghost":
				zenm.crec.X += zenm.crec.Width / 8
				zenm.crec.Y += zenm.crec.Height / 8
				zenm.crec.Width -= zenm.crec.Width / 4
				zenm.crec.Height -= zenm.crec.Height / 4
				//AREA REC
				zenm.carec = zenm.rec
				zenm.carec.X -= b3
				zenm.carec.Y -= b3
				zenm.carec.Width += b6
				zenm.carec.Height += b6
			case "redeye", "redbomb":
				zenm.crec.Y += zenm.crec.Height / 4
				zenm.crec.Height -= zenm.crec.Height / 4
			case "bluespike":
				zenm.crec.Y += zenm.crec.Height / 8
				zenm.crec.X += zenm.crec.Width / 8
				zenm.crec.Width -= zenm.crec.Width / 4
				zenm.crec.Height -= zenm.crec.Height / 4
			}

			levels[levNum].enm = append(levels[levNum].enm, zenm)
			levels[levNum].enNum++
			num--
		}

		countbreak--
		if num == 0 || countbreak == 0 {
			break
		}
	}

}
func makenemcollisrecs() {

	for i := 0; i < len(levels[levNum].enm); i++ {
		levels[levNum].enm[i].crec = levels[levNum].enm[i].rec
		switch levels[levNum].enm[i].nm {
		case "bush":
			levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Width / 4
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
			levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 2
			levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 4
			levels[levNum].enm[i].carec = levels[levNum].enm[i].rec
			levels[levNum].enm[i].carec.X -= b4
			levels[levNum].enm[i].carec.Y -= b4
			levels[levNum].enm[i].carec.Width += b8
			levels[levNum].enm[i].carec.Height += b8
		case "jersey":
			levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Width / 2
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
			levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 2
			levels[levNum].enm[i].crec.Height = levels[levNum].enm[i].crec.Height / 2
		case "bird":
			levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Width / 8
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 8
			levels[levNum].enm[i].crec.Width -= levels[levNum].enm[i].crec.Width / 4
			levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 4
		case "greenpig":
			levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Width / 3
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 3
			levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 3
			levels[levNum].enm[i].crec.Height = levels[levNum].enm[i].crec.Height / 3
			levels[levNum].enm[i].crec.Y += 4
		case "robot":
			levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 2
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
			levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 2
			levels[levNum].enm[i].crec.Height = levels[levNum].enm[i].crec.Height / 2
			levels[levNum].enm[i].carec = levels[levNum].enm[i].crec
			levels[levNum].enm[i].carec.X -= b5
			levels[levNum].enm[i].carec.Y -= b5
			levels[levNum].enm[i].carec.Width += b10
			levels[levNum].enm[i].carec.Height += b10
		case "carrot":
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 8
			levels[levNum].enm[i].crec.Width -= levels[levNum].enm[i].crec.Width / 4
			levels[levNum].enm[i].carec = levels[levNum].enm[i].rec
			levels[levNum].enm[i].carec.X -= b4
			levels[levNum].enm[i].carec.Y -= b4
			levels[levNum].enm[i].carec.Width += b8
			levels[levNum].enm[i].carec.Height += b8
		case "redblob":
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
			levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 2
			levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 2
			levels[levNum].enm[i].crec.Height = levels[levNum].enm[i].crec.Height / 2
		case "skeleton":
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
			levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 2
			levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 8
		case "orange":
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
			levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 2
			levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 3
			levels[levNum].enm[i].crec.Height = levels[levNum].enm[i].crec.Height / 2
			//AREA REC
			levels[levNum].enm[i].carec = levels[levNum].enm[i].rec
			levels[levNum].enm[i].carec.X -= b3
			levels[levNum].enm[i].carec.Y -= b3
			levels[levNum].enm[i].carec.Width += b6
			levels[levNum].enm[i].carec.Height += b6
		case "flamehead":
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
			levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 2
			//AREA REC
			levels[levNum].enm[i].carec = levels[levNum].enm[i].rec
			levels[levNum].enm[i].carec.X -= b3
			levels[levNum].enm[i].carec.Y -= b3
			levels[levNum].enm[i].carec.Width += b6
			levels[levNum].enm[i].carec.Height += b6
		case "fly":
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
			levels[levNum].enm[i].crec.Width -= levels[levNum].enm[i].crec.Width / 2
			levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 4
			levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 2
			//AREA REC
			levels[levNum].enm[i].carec = levels[levNum].enm[i].rec
			levels[levNum].enm[i].carec.X -= b3
			levels[levNum].enm[i].carec.Y -= b3
			levels[levNum].enm[i].carec.Width += b6
			levels[levNum].enm[i].carec.Height += b6
		case "worm":
			levels[levNum].enm[i].crec.Y += (levels[levNum].enm[i].crec.Height / 4) * 3
			levels[levNum].enm[i].crec.Height = levels[levNum].enm[i].crec.Height / 4
		case "yellowdino":
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 8
			levels[levNum].enm[i].crec.Width -= levels[levNum].enm[i].crec.Width / 4
			levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 3
			levels[levNum].enm[i].crec.Height = (levels[levNum].enm[i].crec.Height / 3) * 2
		case "greenplant":
			levels[levNum].enm[i].crec.Y += (levels[levNum].enm[i].crec.Height / 3) * 2
			levels[levNum].enm[i].crec.Height = levels[levNum].enm[i].crec.Height / 3
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 3
			levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 3
		case "pinkcart":
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
			levels[levNum].enm[i].crec.Width = levels[levNum].enm[i].crec.Width / 2
			levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 2
			levels[levNum].enm[i].crec.Height = levels[levNum].enm[i].crec.Height / 2
		case "crocodile":
			levels[levNum].enm[i].crec.Y += (levels[levNum].enm[i].crec.Height / 12) * 7
			levels[levNum].enm[i].crec.Height = (levels[levNum].enm[i].crec.Height / 12) * 5
			//AREA
			levels[levNum].enm[i].carec = levels[levNum].enm[i].crec
			levels[levNum].enm[i].carec.X -= b4
			levels[levNum].enm[i].carec.Width += b8
		case "balloon":
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 4
			levels[levNum].enm[i].crec.Width -= levels[levNum].enm[i].crec.Width / 2
			levels[levNum].enm[i].crec.Y += 4
			levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 2
		case "redantenna":
			levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 3
			levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 3
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 6
			levels[levNum].enm[i].crec.Width -= levels[levNum].enm[i].crec.Width / 3
		case "ghost":
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 8
			levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 8
			levels[levNum].enm[i].crec.Width -= levels[levNum].enm[i].crec.Width / 4
			levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 4
			//AREA REC
			levels[levNum].enm[i].carec = levels[levNum].enm[i].rec
			levels[levNum].enm[i].carec.X -= b3
			levels[levNum].enm[i].carec.Y -= b3
			levels[levNum].enm[i].carec.Width += b6
			levels[levNum].enm[i].carec.Height += b6
		case "redeye", "redbomb":
			levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 4
			levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 4
		case "bluespike":
			levels[levNum].enm[i].crec.Y += levels[levNum].enm[i].crec.Height / 8
			levels[levNum].enm[i].crec.X += levels[levNum].enm[i].crec.Width / 8
			levels[levNum].enm[i].crec.Width -= levels[levNum].enm[i].crec.Width / 4
			levels[levNum].enm[i].crec.Height -= levels[levNum].enm[i].crec.Height / 4
		}
	}
}
func makeenemiesINITIAL() { //MARK:MAKE ENEMIES INITIAL
	//BLUE SPIKE 0
	siz := bq3
	zenm := xenm{}
	zenm.nm = "bluespike"
	zenm.nm2 = "blue dude"
	zenm.xp = 4
	zenm.hpmax = 2
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.crec.Y += zenm.crec.Height / 8
	zenm.crec.X += zenm.crec.Width / 8
	zenm.crec.Width -= zenm.crec.Width / 4
	zenm.crec.Height -= zenm.crec.Height / 4
	zenm.img = anm[23].rec
	zenm.spd = b / 16
	zenm.idl = true
	zenm.idleT = fps * RandInt32(5, 9)
	enmlist = append(enmlist, zenm)
	//RED EYE 1
	zenm = xenm{}
	zenm.nm = "redeye"
	zenm.nm2 = "red dude"
	zenm.xp = 4
	zenm.hpmax = 2
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.crec.Height -= zenm.crec.Height / 4
	zenm.crec.Y += zenm.rec.Height / 4
	zenm.img = anm[26].rec
	zenm.spd = b / 16
	zenm.idl = true
	zenm.idleT = fps * RandInt32(5, 9)
	enmlist = append(enmlist, zenm)
	//RED BOMB 2
	zenm = xenm{}
	zenm.nm = "redbomb"
	zenm.nm2 = "another red dude"
	zenm.xp = 5
	zenm.hpmax = 2
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec.Height -= zenm.crec.Height / 4
	zenm.crec.Y += zenm.rec.Height / 4
	zenm.crec = zenm.rec
	zenm.img = anm[29].rec
	zenm.spd = b / 16
	zenm.idl = true
	zenm.idleT = fps * RandInt32(5, 9)
	enmlist = append(enmlist, zenm)
	//GHOST 3
	siz = b
	zenm = xenm{}
	zenm.fly = true
	zenm.nm = "ghost"
	zenm.nm2 = "kasper"
	zenm.xp = 10
	zenm.hpmax = 5
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.crec.X += zenm.crec.Width / 8
	zenm.crec.Y += zenm.crec.Height / 8
	zenm.crec.Width -= zenm.crec.Width / 4
	zenm.crec.Height -= zenm.crec.Height / 4
	zenm.img = anm[32].rec
	zenm.spd = b / 12
	zenm.hitImgR = rl.NewRectangle(943, 65, 18, 18)
	zenm.hitImgL = rl.NewRectangle(961, 65, 18, 18)
	enmlist = append(enmlist, zenm)
	//RED ANTENNA 4
	siz = b
	zenm = xenm{}
	zenm.nm = "redantenna"
	zenm.nm2 = "yet another red dude"
	zenm.xp = 8
	zenm.hpmax = 5
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.crec.Y += zenm.crec.Height / 3
	zenm.crec.Height -= zenm.crec.Height / 3
	zenm.crec.X += zenm.crec.Width / 6
	zenm.crec.Width -= zenm.crec.Width / 3
	zenm.img = anm[34].rec
	zenm.spd = b / 14
	zenm.moveChangeT = fps * RandInt32(1, 4)
	zenm.hitImgR = rl.NewRectangle(955, 84, 22, 22)
	zenm.hitImgL = rl.NewRectangle(977, 84, 22, 22)
	zenm.atkT = fps * RandInt32(1, 5)
	enmlist = append(enmlist, zenm)
	//BALLOON 5
	siz = b + b/2
	zenm = xenm{}
	zenm.fly = true
	zenm.nm = "balloon"
	zenm.nm2 = "i lost my balloon"
	zenm.xp = 2
	zenm.hpmax = 1
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.crec.X += zenm.crec.Width / 4
	zenm.crec.Width -= zenm.crec.Width / 2
	zenm.crec.Y += 4
	zenm.crec.Height -= zenm.crec.Height / 2
	zenm.img = anm[36].rec
	zenm.spd = b / 24
	zenm.hitImgR = rl.NewRectangle(955, 84, 22, 22)
	zenm.hitImgL = rl.NewRectangle(977, 84, 22, 22)
	zenm.animFrameT = RandInt32(10, 25)
	enmlist = append(enmlist, zenm)
	//CROCODILE 6
	siz = b + b/2
	zenm = xenm{}
	zenm.nm = "crocodile"
	zenm.nm2 = "dundee"
	zenm.xp = 12
	zenm.hpmax = 5
	zenm.hp = zenm.hpmax
	zenm.crec = zenm.rec
	zenm.crec.Y += (zenm.crec.Height / 12) * 7
	zenm.crec.Height = (zenm.crec.Height / 12) * 5
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.img = anm[38].rec
	zenm.spd = b / 20
	zenm.hitImgR = rl.NewRectangle(1237, 301, 32, 32)
	zenm.hitImgL = rl.NewRectangle(1652, 301, 32, 32)
	enmlist = append(enmlist, zenm)
	//PINK CARTWHEEL 7
	siz = b + b/2
	zenm = xenm{}
	zenm.nm = "pinkcart"
	zenm.nm2 = "random pink dude"
	zenm.xp = 12
	zenm.hpmax = 5
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.crec.X += zenm.crec.Width / 4
	zenm.crec.Width = zenm.crec.Width / 2
	zenm.crec.Y += -zenm.crec.Height / 2
	zenm.crec.Height = zenm.crec.Height / 2
	zenm.img = anm[40].rec
	zenm.spd = b / 20
	zenm.idl = true
	zenm.idleT = fps * RandInt32(5, 9)
	zenm.atkT = fps * RandInt32(1, 3)
	enmlist = append(enmlist, zenm)
	//GREEN PLANT 8
	siz = b + bq
	zenm = xenm{}
	zenm.nm = "greenplant"
	zenm.nm2 = "mutant basil plant"
	zenm.xp = 10
	zenm.hpmax = 5
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.crec.Y += (zenm.crec.Height / 3) * 2
	zenm.crec.Height = zenm.crec.Height / 3
	zenm.crec.X += zenm.crec.Width / 3
	zenm.crec.Width = zenm.crec.Width / 3
	zenm.img = anm[43].rec
	zenm.spd = b / 14
	zenm.idl = true
	zenm.idleT = fps * RandInt32(5, 9)
	zenm.moveChangeT = fps * RandInt32(2, 5)
	enmlist = append(enmlist, zenm)
	//YELLOW DINO 9
	siz = b + bq
	zenm = xenm{}
	zenm.nm = "yellowdino"
	zenm.nm2 = "tera-giga-flopo-saurus"
	zenm.xp = 12
	zenm.hpmax = 7
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.crec.X += zenm.crec.Width / 8
	zenm.crec.Width -= zenm.crec.Width / 4
	zenm.crec.Y += zenm.crec.Height / 3
	zenm.crec.Height = (zenm.crec.Height / 3) * 2
	zenm.img = anm[46].rec
	zenm.spd = b / 16
	zenm.moveChangeT = fps * RandInt32(2, 4)
	zenm.atkT = fps * RandInt32(1, 5)
	enmlist = append(enmlist, zenm)
	//BLACK DOT 10
	siz = b / 2
	zenm = xenm{}
	zenm.nm = "blackdot"
	zenm.nm2 = "ink smudge"
	zenm.xp = 2
	zenm.hpmax = 3
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.img = anm[49].rec
	zenm.spd = b / 16
	zenm.hitImgR = rl.NewRectangle(1413, 19, 12, 12)
	zenm.hitImgL = rl.NewRectangle(1425, 19, 12, 12)
	enmlist = append(enmlist, zenm)
	//WORM 11
	siz = b
	zenm = xenm{}
	zenm.nm = "worm"
	zenm.nm2 = "jim"
	zenm.xp = 4
	zenm.hpmax = 2
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.crec.Y += (zenm.crec.Height / 4) * 3
	zenm.crec.Height = zenm.crec.Height / 4
	zenm.img = anm[51].rec
	zenm.spd = 0.7
	enmlist = append(enmlist, zenm)
	//FLY 12
	siz = be5
	zenm = xenm{}
	zenm.fly = true
	zenm.nm = "fly"
	zenm.nm2 = "the"
	zenm.xp = 7
	zenm.hpmax = 3
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.crec.X += zenm.crec.Width / 8
	zenm.crec.Width -= zenm.crec.Width / 4
	zenm.crec.Y += zenm.crec.Height / 8
	zenm.crec.Height -= zenm.crec.Height / 4
	zenm.img = anm[53].rec
	zenm.spd = b / 20
	enmlist = append(enmlist, zenm)
	//FLAMEHEAD 13
	siz = b
	zenm = xenm{}
	zenm.fly = true
	zenm.nm = "flamehead"
	zenm.nm2 = "light my fire"
	zenm.xp = 4
	zenm.hpmax = 2
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.img = anm[63].rec
	zenm.spd = b / 20
	enmlist = append(enmlist, zenm)
	//ORANGE 14
	siz = b
	zenm = xenm{}
	zenm.nm = "orange"
	zenm.nm2 = "eat fruit everyday"
	zenm.xp = 7
	zenm.hpmax = 2
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.img = anm[65].rec
	zenm.spd = b / 12
	enmlist = append(enmlist, zenm)
	//SKELETON 15
	siz = b
	zenm = xenm{}
	zenm.nm = "skeleton"
	zenm.nm2 = "ubiquitous dungeon fiend"
	zenm.xp = 12
	zenm.hpmax = 8
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.img = anm[67].rec
	zenm.spd = b / 16
	zenm.atkT = fps * RandInt32(1, 5)
	enmlist = append(enmlist, zenm)
	//RED BLOB 16
	siz = b
	zenm = xenm{}
	zenm.nm = "redblob"
	zenm.nm2 = "too many red dudes in this game"
	zenm.xp = 10
	zenm.hpmax = 5
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.img = anm[69].rec
	zenm.spd = b / 30
	zenm.moveChangeT = fps * RandInt32(1, 3)
	zenm.atkT = fps * RandInt32(1, 5)
	enmlist = append(enmlist, zenm)
	//CARROT 17
	siz = bq3
	zenm = xenm{}
	zenm.nm = "carrot"
	zenm.nm2 = "also eat vegetables everyday"
	zenm.xp = 5
	zenm.hpmax = 3
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.carec = zenm.rec
	zenm.carec.X -= b
	zenm.carec.Y -= b
	zenm.carec.Width += b2
	zenm.carec.Height += b2
	zenm.img = anm[156].rec
	zenm.spd = 2
	enmlist = append(enmlist, zenm)
	//ROBOT 18
	siz = b
	zenm = xenm{}
	zenm.nm = "robot"
	zenm.nm2 = "stand back"
	zenm.xp = 15
	zenm.hpmax = 8
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.crec.Y += zenm.crec.Height / 2
	zenm.crec.X += zenm.crec.Width / 4
	zenm.crec.Width = zenm.crec.Width / 2
	zenm.img = anm[160].rec
	zenm.spd = 1
	zenm.moveChangeT = fps * RandInt32(1, 3)
	zenm.atkT = int32(RandInt(int(fps), int(fps*3)))
	enmlist = append(enmlist, zenm)
	//GREEN PIG 19
	siz = b2
	zenm.fly = true
	zenm = xenm{}
	zenm.nm = "greenpig"
	zenm.nm2 = "pigs might fly"
	zenm.xp = 12
	zenm.hpmax = 5
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.crec.Y += zenm.crec.Height / 2
	zenm.crec.X += zenm.crec.Width / 4
	zenm.crec.Width = zenm.crec.Width / 2
	zenm.img = anm[158].rec
	zenm.spd = 2
	zenm.moveChangeT = fps * RandInt32(1, 3)
	zenm.atkT = fps * 2
	enmlist = append(enmlist, zenm)
	//RED DEVIL 20
	siz = be7
	zenm = xenm{}
	zenm.nm = "reddevil"
	zenm.nm2 = "smoking hot"
	zenm.xp = 15
	zenm.hpmax = 5
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.crec.Y += zenm.crec.Height / 2
	zenm.crec.X += zenm.crec.Width / 4
	zenm.crec.Width = zenm.crec.Width / 2
	zenm.img = anm[162].rec
	zenm.spd = 5
	zenm.dirX = zenm.spd
	if FlipCoin() {
		zenm.dirX = -zenm.dirX
	}
	zenm.dirY = zenm.spd / RandF32(2, 9)
	if FlipCoin() {
		zenm.dirY = -zenm.dirY
	}
	zenm.atkT = fps / 2
	enmlist = append(enmlist, zenm)
	//ROCK GUY 21
	siz = b
	zenm = xenm{}
	zenm.nm = "bush"
	zenm.nm2 = "hide n seek"
	zenm.xp = 15
	zenm.hpmax = 5
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.crec.Y += zenm.crec.Height / 2
	zenm.crec.X += zenm.crec.Width / 4
	zenm.crec.Width = zenm.crec.Width / 2
	zenm.img = etc[151]
	zenm.spd = 4
	enmlist = append(enmlist, zenm)
	//BIRD 22
	siz = b
	zenm = xenm{}
	zenm.fly = true
	zenm.nm = "bird"
	zenm.nm2 = "humpty dumpty"
	zenm.xp = 15
	zenm.hpmax = 4
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.crec.Y += zenm.crec.Height / 2
	zenm.crec.X += zenm.crec.Width / 4
	zenm.crec.Width = zenm.crec.Width / 2
	zenm.img = anm[164].rec
	zenm.spd = 2
	zenm.moveChangeT = fps * 2
	zenm.dirX = RandF32(-zenm.spd, zenm.spd)
	zenm.dirY = RandF32(-zenm.spd, zenm.spd)
	enmlist = append(enmlist, zenm)
	//GREEN JERSEY 23
	siz = b + be
	zenm = xenm{}
	zenm.nm = "jersey"
	zenm.nm2 = "originally from scotland"
	zenm.xp = 15
	zenm.hpmax = 8
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.crec.Y += zenm.crec.Height / 2
	zenm.crec.X += zenm.crec.Width / 4
	zenm.crec.Width = zenm.crec.Width / 2
	zenm.img = anm[166].rec
	zenm.spd = 3
	zenm.moveChangeT = fps * 2
	zenm.dirX = RandF32(-zenm.spd, zenm.spd)
	zenm.dirY = RandF32(-zenm.spd, zenm.spd)
	zenm.atkT = fps * 2
	enmlist = append(enmlist, zenm)
	//MOVING SPIKE 24
	siz = b + b/2
	zenm = xenm{}
	zenm.nm = "spike"
	zenm.nm2 = "mr snuggles mince machine"
	zenm.xp = 100
	zenm.hpmax = 99
	zenm.hp = zenm.hpmax
	zenm.rec = rl.NewRectangle(0, 0, siz, siz)
	zenm.crec = zenm.rec
	zenm.img = anm[184].rec
	zenm.spd = 2
	zenm.moveChangeT = fps * 2
	zenm.dirX = RandF32(-zenm.spd, zenm.spd)
	zenm.dirY = RandF32(-zenm.spd, zenm.spd)
	enmlist = append(enmlist, zenm)
}

func makePotionList() { //MARK:MAKE POTION LIST
	potionList = nil
	for i := 0; i < 18; i++ {
		potionList = append(potionList, itmlist[i])
	}
	for i := 0; i < len(potionList); i++ {
		for j := 0; j < 6; j++ {
			potionList[i].costPotion = append(potionList[i].costPotion, 0)
		}
	}

	potionList[0].costPotion[0] = 30
	potionList[0].costPotion[2] = 30
	potionList[0].costPotion[3] = 30 //HP FULL

	potionList[1].costPotion[2] = 20
	potionList[1].costPotion[3] = 20 //HP HALF

	potionList[2].costPotion[2] = 10
	potionList[2].costPotion[3] = 10 //HP QUARTER

	potionList[3].costPotion[1] = 30
	potionList[3].costPotion[4] = 30
	potionList[3].costPotion[5] = 30 //MANA FULL

	potionList[4].costPotion[4] = 20
	potionList[4].costPotion[5] = 20 //MANA HALF

	potionList[5].costPotion[4] = 10
	potionList[5].costPotion[5] = 10 //MANA QUARTER

	potionList[6].costPotion[1] = 30
	potionList[6].costPotion[3] = 30
	potionList[6].costPotion[4] = 30 //RESIST FIRE FULL

	potionList[7].costPotion[1] = 20
	potionList[7].costPotion[3] = 20
	potionList[7].costPotion[4] = 20 //RESIST FIRE HALF

	potionList[8].costPotion[1] = 15
	potionList[8].costPotion[4] = 15 //RESIST FIRE QUARTER

	potionList[9].costPotion[1] = 30
	potionList[9].costPotion[4] = 30
	potionList[9].costPotion[5] = 30 //RESIST POISON FULL

	potionList[10].costPotion[1] = 20
	potionList[10].costPotion[4] = 20
	potionList[10].costPotion[5] = 20 //RESIST POISON HALF

	potionList[11].costPotion[1] = 15
	potionList[11].costPotion[5] = 15 //RESIST POISON QUARTER

	potionList[12].costPotion[0] = 30
	potionList[12].costPotion[2] = 30
	potionList[12].costPotion[3] = 30
	potionList[12].costPotion[5] = 30 //INVISIBILTY FULL

	potionList[13].costPotion[0] = 20
	potionList[13].costPotion[3] = 20
	potionList[13].costPotion[5] = 20 //INVISIBILTY HALF

	potionList[14].costPotion[0] = 15
	potionList[14].costPotion[3] = 15
	potionList[14].costPotion[5] = 15 //INVISIBILTY QUARTER

	potionList[15].costPotion[0] = 30
	potionList[15].costPotion[1] = 30
	potionList[15].costPotion[2] = 30
	potionList[15].costPotion[3] = 30
	potionList[15].costPotion[4] = 30
	potionList[15].costPotion[5] = 30 //ARMOR FULL

	potionList[16].costPotion[1] = 20
	potionList[16].costPotion[2] = 20
	potionList[16].costPotion[3] = 20
	potionList[16].costPotion[4] = 20
	potionList[16].costPotion[5] = 20 //ARMOR HALF

	potionList[17].costPotion[2] = 15
	potionList[17].costPotion[3] = 15
	potionList[17].costPotion[4] = 15
	potionList[17].costPotion[5] = 15 //ARMOR QUARTER

}
func makeScrollList() { //MARK:MAKE SCROLL LIST
	scrollList = nil
	for i := 18; i < 26; i++ {
		scrollList = append(scrollList, itmlist[i])
	}
	for i := 0; i < len(scrollList); i++ {
		scrollList[i].costScroll = append(scrollList[i].costScroll, 0)
		scrollList[i].costScroll = append(scrollList[i].costScroll, 0)
	}
	for i := 0; i < len(scrollList); i++ {
		switch i {
		case 0:
			scrollList[i].costScroll[0] = 15
			scrollList[i].costScroll[1] = 15 //POISON GAS
		case 1:
			scrollList[i].costScroll[0] = 20
			scrollList[i].costScroll[1] = 20 //FROGS
		case 2:
			scrollList[i].costScroll[0] = 10
			scrollList[i].costScroll[1] = 10 //INTANGIBILITY
		case 3:
			scrollList[i].costScroll[0] = 15
			scrollList[i].costScroll[1] = 15 //DETECTION
		case 4:
			scrollList[i].costScroll[0] = 15
			scrollList[i].costScroll[1] = 15 //HOME
		case 5:
			scrollList[i].costScroll[0] = 10
			scrollList[i].costScroll[1] = 10 //BEGINNING
		case 6:
			scrollList[i].costScroll[0] = 25
			scrollList[i].costScroll[1] = 25 //INFLICT
		case 7:
			scrollList[i].costScroll[0] = 40
			scrollList[i].costScroll[1] = 40 //POWER
		}

	}
}

func makedarts(tile xtile) { //MARK:MAKE DARTS
	x := tile.cnt.X
	y := tile.cnt.Y
	spd := b / 4
	siz := b / 2
	xl := levels[levNum].recs[tile.room].X
	xr := levels[levNum].recs[tile.room].X + levels[levNum].recs[tile.room].Width
	yt := levels[levNum].recs[tile.room].Y
	yb := levels[levNum].recs[tile.room].Y + levels[levNum].recs[tile.room].Height
	side := RandInt(1, 5)
	switch side {
	case 1:
		//TOP WALL
		zproj := xweap{}
		zproj.dirY = spd
		zproj.rec = rl.NewRectangle(x-siz/2, yt, siz, siz)
		zproj.crec = zproj.rec
		zproj.img = etc[138]
		zproj.dmg = 1
		zproj.nm = "dart"
		zproj.col = rl.White
		zproj.ro = 135
		zproj.fd = 1
		projEn = append(projEn, zproj)
		zproj.rec.X -= zproj.rec.Height
		zproj.crec = zproj.rec
		projEn = append(projEn, zproj)
		zproj.rec.X += zproj.rec.Height * 2
		zproj.crec = zproj.rec
		projEn = append(projEn, zproj)
	case 2:
		//RIGHT WALL
		zproj := xweap{}
		zproj.dirX = -spd
		zproj.rec = rl.NewRectangle(xr-siz, y-siz/2, siz, siz)
		zproj.crec = zproj.rec
		zproj.img = etc[138]
		zproj.dmg = 1
		zproj.nm = "dart"
		zproj.col = rl.White
		zproj.ro = -135
		zproj.fd = 1
		projEn = append(projEn, zproj)
		zproj.rec.Y -= zproj.rec.Height
		zproj.crec = zproj.rec
		projEn = append(projEn, zproj)
		zproj.rec.Y += zproj.rec.Height * 2
		zproj.crec = zproj.rec
		projEn = append(projEn, zproj)
	case 3:
		//BOTTOM WALL
		zproj := xweap{}
		zproj.dirY = -spd
		zproj.rec = rl.NewRectangle(x-siz/2, yb-siz, siz, siz)
		zproj.crec = zproj.rec
		zproj.img = etc[138]
		zproj.dmg = 1
		zproj.nm = "dart"
		zproj.col = rl.White
		zproj.ro = -45
		zproj.fd = 1
		projEn = append(projEn, zproj)
		zproj.rec.X -= zproj.rec.Height
		zproj.crec = zproj.rec
		projEn = append(projEn, zproj)
		zproj.rec.X += zproj.rec.Height * 2
		zproj.crec = zproj.rec
		projEn = append(projEn, zproj)
	case 4:
		//LEFT WALL
		zproj := xweap{}
		zproj.dirX = spd
		zproj.rec = rl.NewRectangle(xl, y-siz/2, siz, siz)
		zproj.crec = zproj.rec
		zproj.img = etc[138]
		zproj.dmg = 1
		zproj.nm = "dart"
		zproj.col = rl.White
		zproj.ro = 45
		zproj.fd = 1
		projEn = append(projEn, zproj)
		zproj.rec.Y -= zproj.rec.Height
		zproj.crec = zproj.rec
		projEn = append(projEn, zproj)
		zproj.rec.Y += zproj.rec.Height * 2
		zproj.crec = zproj.rec
		projEn = append(projEn, zproj)
	}
}
func makeEnDeathFx(enNum int) { //MARK:MAKE ENEMY DEATH FX
	levels[levNum].enNum--
	//MUG
	if mugnum > 0 {
		if Roll6() <= mugnum {
			zitm := itmlist[43]
			zitm.rec = rl.NewRectangle(levels[levNum].enm[enNum].cnt.X-zitm.rec.Width/2, levels[levNum].enm[enNum].cnt.Y-zitm.rec.Height/2, zitm.rec.Width, zitm.rec.Height)
			levels[levNum].itm = append(levels[levNum].itm, zitm)
		}
	}
	//FRISBEE
	if frisbee {
		frisbeecount++
		if frisbeecount == 7 {
			frisbeecount = 0
			frisbeeT = fps * 10
			zfx := xfx{}
			zfx.nm = "frisbee"
			zfx.rec = pl.rec
			zfx.rec.X -= b
			zfx.rec.Y -= b
			zfx.rec.Width += b2
			zfx.rec.Height += b2
			zfx.crec = zfx.rec
			zfx.crec.X += zfx.crec.Width / 8
			zfx.crec.Y += zfx.crec.Width / 8
			zfx.crec.Width -= zfx.crec.Width / 4
			zfx.crec.Height -= zfx.crec.Width / 4
			zfx.spd = 5
			countbreak := 100
			for {
				zfx.dirX = RandF32(-zfx.spd, zfx.spd)
				zfx.dirY = RandF32(-zfx.spd, zfx.spd)
				if Abs(zfx.dirX) > 2 || Abs(zfx.dirY) > 2 {
					break
				}
				countbreak--
				if countbreak == 0 {
					break
				}
			}
			zfx.cnt = makecnt(zfx.rec)
			zfx.img = anm[93].rec
			fx = append(fx, zfx)
		}
	}
	//PURPLE RAIN
	if purplerain {
		purpleraincount++
		if purpleraincount == 4 {
			purpleraincount = 0
			purplerainT = fps
			zfx := xfx{}
			zfx.nm = "purplerain"
			num := 20
			countbreak := 100
			for num > 0 {
				x2 := RandF32(-b5, b5)
				y2 := RandF32(-b5, b5)
				v2 := rl.NewVector2(pl.cnt.X+x2, pl.cnt.Y+y2)
				if checkV2inRooms(v2) {
					siz := b2
					zfx.recs2 = append(zfx.recs2, rl.NewRectangle(v2.X-siz/2, v2.Y-siz/2, siz, siz))
					num--
				}
				countbreak--
				if countbreak <= 0 {
					break
				}
			}
			zfx.img = anm[92].rec
			fx = append(fx, zfx)
		}
	}
	//TESLA
	if tesla {
		teslacount++
		if teslacount == 5 {
			teslacount = 0
			teslaT = fps
			zfx := xfx{}
			zfx.nm = "tesla"
			zfx.rec = pl.rec
			zfx.rec.X -= b5
			zfx.rec.Y -= b5
			zfx.rec.Width += b10
			zfx.rec.Height += b10
			zfx.img = anm[91].rec
			fx = append(fx, zfx)
		}
	}
	//BOTTLE OF DEATH
	if deathbottlenum > 0 {
		pl.xp += deathbottlenum * 3
	}
	//GARLIC
	if garlicnum > 0 {
		if Roll12() <= garlicnum {
			if pl.hp < pl.hpmax {
				pl.hp++
				admsg("garlic +1 hp", rl.Green)
			}
		}
	}
	fxmade := false
	switch levels[levNum].enm[enNum].nm {
	case "balloon":
		rl.PlaySound(audfx[94])
		fxmade = true
		//FX
		zfx := xfx{}
		zfx.nm = "balloonexplode"
		zfx.T = fps / 4
		zfx.img = anm[57].rec
		siz2 := b8
		zfx.rec = rl.NewRectangle(levels[levNum].enm[enNum].cnt.X-siz2/2, levels[levNum].enm[enNum].cnt.Y-siz2/2, siz2, siz2)
		fx = append(fx, zfx)
	case "redbomb":
		rl.PlaySound(audfx[104])
		zenm := xenm{}
		zenm.nm = "fire"
		zenm.stat = true
		zenm.nodmg = true
		zenm.hpmax = 100
		zenm.hp = zenm.hpmax
		zenm.img = anm[55].rec
		siz := b2
		zenm.rec = rl.NewRectangle(levels[levNum].enm[enNum].cnt.X-siz/2, levels[levNum].enm[enNum].cnt.Y-(siz), siz, siz)
		zenm.crec = zenm.rec
		zenm.crec.X += zenm.crec.Width / 3
		zenm.crec.Width = zenm.crec.Width / 3
		zenm.crec.Y += zenm.crec.Height / 2
		zenm.crec.Height = zenm.crec.Height / 2
		zenm.cnt = levels[levNum].enm[enNum].cnt
		levels[levNum].enm = append(levels[levNum].enm, zenm)
		countbreak := 100
		num := RandInt(4, 8)
		for num > 0 {
			siz2 := b3
			cntr := zenm.cnt
			cntr.X += RandF32(-siz2, siz2)
			cntr.Y += RandF32(-siz2, siz2)
			if checkV2Walls(cntr) && checkV2inRooms(cntr) && checkV2water(cntr) && checkV2chest(cntr) {
				zenm.rec = rl.NewRectangle(cntr.X-siz/2, cntr.Y-(siz), siz, siz)
				zenm.crec = zenm.rec
				zenm.crec.X += zenm.crec.Width / 3
				zenm.crec.Width = zenm.crec.Width / 3
				zenm.crec.Y += zenm.crec.Height / 2
				zenm.crec.Height = zenm.crec.Height / 2
				zenm.cnt = levels[levNum].enm[enNum].cnt
				levels[levNum].enm = append(levels[levNum].enm, zenm)
				num--
			}
			countbreak--
			if countbreak == 0 {
				break
			}
		}
	case "redeye":
		zproj := xweap{}
		zproj.nm = "redspikeproj"
		zproj.dmg = 1
		zproj.img = etc[30]
		siz := be3
		zproj.rec = rl.NewRectangle(levels[levNum].enm[enNum].cnt.X-siz/2, levels[levNum].enm[enNum].cnt.Y-siz/2, siz, siz)
		zproj.crec = zproj.rec
		zproj.col = RandRed()
		zproj.fd = 1
		zproj.spd = b / 8
		zproj.ro = 90
		zproj.dirX = zproj.spd
		projEn = append(projEn, zproj)
		zproj.ro = 270
		zproj.dirX = -zproj.spd
		projEn = append(projEn, zproj)
		zproj.dirX = 0
		zproj.ro = 0
		zproj.dirY = -zproj.spd
		projEn = append(projEn, zproj)
		zproj.ro = 180
		zproj.dirY = zproj.spd
		projEn = append(projEn, zproj)
		zproj.ro = 45
		zproj.dirX = zproj.spd
		zproj.dirY = -zproj.spd
		projEn = append(projEn, zproj)
		zproj.ro = 135
		zproj.dirX = zproj.spd
		zproj.dirY = +zproj.spd
		projEn = append(projEn, zproj)
		zproj.ro = -45
		zproj.dirX = -zproj.spd
		zproj.dirY = -zproj.spd
		projEn = append(projEn, zproj)
		zproj.ro = -135
		zproj.dirX = -zproj.spd
		zproj.dirY = +zproj.spd
		projEn = append(projEn, zproj)
	case "bluespike":
		zproj := xweap{}
		zproj.nm = "bluespikeproj"
		zproj.dmg = 1
		zproj.img = etc[30]
		siz := be3
		zproj.rec = rl.NewRectangle(levels[levNum].enm[enNum].cnt.X-siz/2, levels[levNum].enm[enNum].cnt.Y-siz/2, siz, siz)
		zproj.crec = zproj.rec
		zproj.col = rl.SkyBlue
		zproj.fd = 1
		zproj.spd = b / 8
		zproj.ro = 90
		zproj.dirX = zproj.spd
		projEn = append(projEn, zproj)
		zproj.ro = 270
		zproj.dirX = -zproj.spd
		projEn = append(projEn, zproj)
		zproj.dirX = 0
		zproj.ro = 0
		zproj.dirY = -zproj.spd
		projEn = append(projEn, zproj)
		zproj.ro = 180
		zproj.dirY = zproj.spd
		projEn = append(projEn, zproj)
	}
	//FX
	if !fxmade {
		zfx := xfx{}
		zfx.nm = "enm"
		zfx.T = fps
		num := RandInt(40, 55)
		for num > 0 {
			zcirc := xcirc{}
			zcirc.cnt = levels[levNum].enm[enNum].cnt
			zcirc.rad = RandF32(b/8, b/2)
			zcirc.col = RandRed()
			switch levels[levNum].enm[enNum].nm {
			case "bluespike", "robot":
				zcirc.col = RandBlue()
			case "redbomb", "orange", "flamehead", "carrot":
				zcirc.col = RandOrange()
			case "ghost", "skeleton":
				zcirc.col = RandGrey()
			case "pinkcart":
				zcirc.col = RandPink()
			case "blackdot", "bird":
				zcirc.col = rl.Black
			case "crocodile", "greenplant", "greenpig", "bush":
				zcirc.col = RandGreen()
			}
			zcirc.fd = RandF32(0.5, 0.8)
			zcirc.spd = b / 2
			countbreak := 100
			for {
				zcirc.dirX = RandF32(-zcirc.spd, zcirc.spd)
				zcirc.dirY = RandF32(-zcirc.spd, zcirc.spd)
				if Abs(zcirc.dirX) > 0.5 && Abs(zcirc.dirY) > 0.5 {
					break
				}
				countbreak--
				if countbreak == 0 {
					break
				}
			}
			zfx.circs = append(zfx.circs, zcirc)
			num--
		}
		fx = append(fx, zfx)
	}
	if gascannum > 0 {
		if Roll6() <= gascannum {
			siz := b7
			cntr := levels[levNum].enm[enNum].cnt
			zfx := xfx{}
			zfx.rec = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
			zfx.img = anm[57].rec
			zfx.nm = "gascanExplode"
			fx = append(fx, zfx)
		}
	}

	choose := RandInt(1, 4)
	switch choose {
	case 1:
		rl.PlaySound(audfx[9])
	case 2:
		rl.PlaySound(audfx[10])
	case 3:
		rl.PlaySound(audfx[11])
	}
}
func makebgi() { //MARK:MAKE BACKGROUND IMG
	for i := 0; i < len(levels[levNum].recs); i++ {
		//BGI
		if Roll6() > 3 {
			siz := RandF32(b+b/2, b2)
			x := levels[levNum].recs[i].X + b/2
			x += RandF32(0, levels[levNum].recs[i].Width-(siz+b))
			y := levels[levNum].recs[i].Y + b/2
			y += RandF32(0, levels[levNum].recs[i].Height-(siz+b))
			rec := rl.NewRectangle(x, y, siz, siz)
			zbgi := bgilist[RandInt(0, len(bgilist))]
			zbgi.rec = rec
			zbgi.fd = 1
			levels[levNum].bgi = append(levels[levNum].bgi, zbgi)
		}
		//BGI 2
		num := RandInt(1, 5)
		countbreak := 100
		for {
			siz := RandF32(be5, b+be3)
			side := RandInt(1, 5)
			zbgi := bgilist2[RandInt(0, len(bgilist2))]
			zbgi.fd = 1
			switch side {
			case 4: //LEFT
				x := levels[levNum].recs[i].X - 2
				y := levels[levNum].recs[i].Y + b/4
				y += RandF32(0, levels[levNum].recs[i].Height-(siz+b/2))
				rec := rl.NewRectangle(x, y, siz, siz)
				zbgi.rec = rec
				zbgi.ro = 270
			case 3: //BOTTOM
				x := levels[levNum].recs[i].X + b/4
				x += RandF32(0, levels[levNum].recs[i].Width-(siz+b/2))
				y := levels[levNum].recs[i].Y + levels[levNum].recs[i].Height - siz + 2
				rec := rl.NewRectangle(x, y, siz, siz)
				zbgi.rec = rec
				zbgi.ro = 180
			case 2: //RIGHT
				x := levels[levNum].recs[i].X + levels[levNum].recs[i].Width - siz + 2
				y := levels[levNum].recs[i].Y + b/4
				y += RandF32(0, levels[levNum].recs[i].Height-(siz+b/2))
				rec := rl.NewRectangle(x, y, siz, siz)
				zbgi.rec = rec
				zbgi.ro = 90
			case 1: //TOP
				x := levels[levNum].recs[i].X + b/4
				x += RandF32(0, levels[levNum].recs[i].Width-(siz+b/2))
				y := levels[levNum].recs[i].Y - 2
				rec := rl.NewRectangle(x, y, siz, siz)
				zbgi.rec = rec
			}
			if checkRecDoors(zbgi.rec) {
				canadd := true
				for j := 0; j < len(levels[levNum].bgi2); j++ {
					if rl.CheckCollisionRecs(zbgi.rec, levels[levNum].bgi2[j].rec) {
						canadd = false
					}
				}
				if canadd {
					num--
					levels[levNum].bgi2 = append(levels[levNum].bgi2, zbgi)
				}
			}
			countbreak--
			if num == 0 || countbreak == 0 {
				break
			}
		}
	}
	//FLOWERS
	num := RandInt(5, 11)
	for num > 0 {
		cntr := findRanCnt()
		siz := RandF32(be3, b/2)
		zbgi := xbgi{}
		zbgi.rec = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
		zbgi.img = flowers[RandInt(0, len(flowers))]
		levels[levNum].flowers = append(levels[levNum].flowers, zbgi)
		num--
	}
}

func makecnt(rec rl.Rectangle) rl.Vector2 { //MARK:MAKE CENTER
	return rl.NewVector2(rec.X+rec.Width/2, rec.Y+rec.Height/2)
}
func makeinnerbloksetc(lev x1scr) x1scr { //MARK:MAKE INNER BLOKS ETC
	min := 5
	size := b
	for i := 0; i < len(lev.recs); i++ {
		//INNER BLOK SHAPES
		if lev.inf[i].numW > min+3 && lev.inf[i].numH > min+3 {
			ztile := xtile{}
			ztile.img = walltile
			ztile.color = rl.White
			ztile.col2 = RandColor()
			ztile.fade = RandF32(0.3, 0.9)
			choose := RandInt(1, 5)
			//choose =4
			switch choose {
			case 4: //FOUR BLOKS
				x := lev.recs[i].X + b3
				y := lev.recs[i].Y + b3
				x2 := x + lev.recs[i].Width - b6
				y2 := y + lev.recs[i].Height - b6
				ztile.col2 = RandColor()
				ztile.rec = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
				if checkaddtilerecInner(ztile.rec, lev) {
					lev.walls = append(lev.walls, ztile)
				}
				choose2 := RandInt(1, 5)
				switch choose2 {
				case 1:
					ztile.rec.Y -= size
					if checkaddtilerecInner(ztile.rec, lev) {
						ztile.col2 = RandColor()
						lev.walls = append(lev.walls, ztile)
					}
					if FlipCoin() {
						ztile.rec.X += size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rec.X -= size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
					if FlipCoin() {
						ztile.rec.Y += size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rec.Y -= size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
				case 2:
					ztile.rec.X += size
					if checkaddtilerecInner(ztile.rec, lev) {
						ztile.col2 = RandColor()
						lev.walls = append(lev.walls, ztile)
					}
					if FlipCoin() {
						ztile.rec.Y += size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rec.Y -= size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
					if FlipCoin() {
						ztile.rec.X += size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rec.X -= size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
				case 3:
					ztile.rec.Y += size
					if checkaddtilerecInner(ztile.rec, lev) {
						ztile.col2 = RandColor()
						lev.walls = append(lev.walls, ztile)
					}
					if FlipCoin() {
						ztile.rec.X += size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rec.X -= size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
					if FlipCoin() {
						ztile.rec.Y += size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rec.Y -= size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
				case 4:
					ztile.rec.X -= size
					if checkaddtilerecInner(ztile.rec, lev) {
						ztile.col2 = RandColor()
						lev.walls = append(lev.walls, ztile)
					}
					if FlipCoin() {
						ztile.rec.Y += size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rec.Y -= size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
					if FlipCoin() {
						ztile.rec.X += size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rec.X -= size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
				}
			case 3: //THREE BLOKS
				x := lev.recs[i].X + b3
				y := lev.recs[i].Y + b3
				x2 := x + lev.recs[i].Width - b6
				y2 := y + lev.recs[i].Height - b6
				ztile.col2 = RandColor()
				ztile.rec = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
				if checkaddtilerecInner(ztile.rec, lev) {
					lev.walls = append(lev.walls, ztile)
				}
				choose2 := RandInt(1, 5)
				switch choose2 {
				case 1:
					ztile.rec.Y -= size
					if checkaddtilerecInner(ztile.rec, lev) {
						ztile.col2 = RandColor()
						lev.walls = append(lev.walls, ztile)
					}
					if FlipCoin() {
						ztile.rec.X += size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rec.X -= size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
				case 2:
					ztile.rec.X += size
					if checkaddtilerecInner(ztile.rec, lev) {
						ztile.col2 = RandColor()
						lev.walls = append(lev.walls, ztile)
					}
					if FlipCoin() {
						ztile.rec.Y += size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rec.Y -= size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
				case 3:
					ztile.rec.Y += size
					if checkaddtilerecInner(ztile.rec, lev) {
						ztile.col2 = RandColor()
						lev.walls = append(lev.walls, ztile)
					}
					if FlipCoin() {
						ztile.rec.X += size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rec.X -= size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
				case 4:
					ztile.rec.X -= size
					if checkaddtilerecInner(ztile.rec, lev) {
						ztile.col2 = RandColor()
						lev.walls = append(lev.walls, ztile)
					}
					if FlipCoin() {
						ztile.rec.Y += size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rec.Y -= size
						if checkaddtilerecInner(ztile.rec, lev) {
							ztile.col2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
				}
			case 2: //TWO BLOKS
				x := lev.recs[i].X + b3
				y := lev.recs[i].Y + b3
				x2 := x + lev.recs[i].Width - b6
				y2 := y + lev.recs[i].Height - b6
				ztile.col2 = RandColor()
				ztile.rec = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
				if checkaddtilerecInner(ztile.rec, lev) {
					lev.walls = append(lev.walls, ztile)
				}
				choose2 := RandInt(1, 5)
				switch choose2 {
				case 1:
					ztile.rec.Y -= size
					if checkaddtilerecInner(ztile.rec, lev) {
						lev.walls = append(lev.walls, ztile)
					}
				case 2:
					ztile.rec.X += size
					if checkaddtilerecInner(ztile.rec, lev) {
						lev.walls = append(lev.walls, ztile)
					}
				case 3:
					ztile.rec.Y += size
					if checkaddtilerecInner(ztile.rec, lev) {
						lev.walls = append(lev.walls, ztile)
					}
				case 4:
					ztile.rec.X -= size
					if checkaddtilerecInner(ztile.rec, lev) {
						lev.walls = append(lev.walls, ztile)
					}
				}
			case 1: //SINGLE BLOK
				x := lev.recs[i].X + b2
				y := lev.recs[i].Y + b2
				x2 := x + lev.recs[i].Width - b4
				y2 := y + lev.recs[i].Height - b4
				ztile.col2 = RandColor()
				ztile.rec = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
				if checkaddtilerecInner(ztile.rec, lev) {
					lev.walls = append(lev.walls, ztile)
				}
			}
		}
		//MOVING BLOKS
		if Roll6() > 4 {
			x := lev.recs[i].X + size
			y := lev.recs[i].Y + size
			x2 := x + lev.recs[i].Width - size*2
			y2 := y + lev.recs[i].Height - size*2
			ztile := xtile{}
			ztile.img = walltile
			ztile.col2 = RandColor()
			ztile.color = rl.White
			ztile.fade = RandF32(0.3, 0.9)
			ztile.rec = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
			ztile.spikes = FlipCoin()
			if ztile.spikes {
				for j := 0; j < 4; j++ {
					ztile.col2 = RandColor()
					rec2 := ztile.rec
					rec2.X += ztile.rec.Width / 4
					rec2.Y += ztile.rec.Height / 4
					rec2.Width -= ztile.rec.Width / 2
					rec2.Height -= ztile.rec.Height / 2
					ztile.spikerecs = append(ztile.spikerecs, rec2)
				}
			}
			if checkaddtilerecInner(ztile.rec, lev) && checkRecPlayer(ztile.rec) {
				ztile.spd = RandF32(b/12, b/7)
				if FlipCoin() {
					ztile.dirX = ztile.spd
					if FlipCoin() {
						ztile.dirX = -ztile.dirX
					}
				} else {
					ztile.dirY = ztile.spd
					if FlipCoin() {
						ztile.dirY = -ztile.dirY
					}
				}
				lev.walls = append(lev.walls, ztile)
			}
		}
		//MARK: MAKE ETC
		//CRATES
		x := lev.recs[i].X
		y := lev.recs[i].Y
		x2 := x + lev.recs[i].Width - size
		y2 := y + lev.recs[i].Height - size
		ztile := xtile{}
		ztile.nm = "crate"
		choose := RandInt(1, 5)
		switch choose {
		case 1:
			ztile.hp = 3
		case 2:
			ztile.hp = 1
		case 3:
			ztile.hp = 4
		case 4:
			ztile.hp = 2
		}
		ztile.img = etc[choose]
		ztile.solid = true
		ztile.color = rl.White
		ztile.fade = 1
		ztile.rec = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), be7, be7)
		if checkaddtilerecInner(ztile.rec, lev) && checkaddetc(ztile.rec, lev) {
			ztile.cnt = makecnt(ztile.rec)
			lev.etc = append(lev.etc, ztile)
		}
		//WATER
		if Roll6() == 6 {
			x := lev.recs[i].X + size
			y := lev.recs[i].Y + size
			x2 := x + lev.recs[i].Width - size*3
			y2 := y + lev.recs[i].Height - size*3
			ztile := xtile{}
			ztile.nm = "water"
			ztile.img = anm[0].rec
			ztile.color = rl.DarkBlue
			ztile.fade = RandF32(0.2, 0.5)
			ztile.rec = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
			ztile.img2 = splat[RandInt(0, len(splat))]
			ztile.rec2 = ztile.rec
			ztile.rec2.X -= b / 2
			ztile.rec2.Y -= b / 2
			ztile.rec2.Width += b
			ztile.rec2.Height += b
			if checkaddtilerecInner(ztile.rec, lev) && checkaddetc(ztile.rec, lev) {
				ztile.cnt = makecnt(ztile.rec)
				lev.etc = append(lev.etc, ztile)
			}
		}
		//SPIKE TRAPS
		if Roll6() == 6 {
			x := lev.recs[i].X + b/2
			y := lev.recs[i].Y + b/2
			x2 := x + lev.recs[i].Width - (size + b)
			y2 := y + lev.recs[i].Height - (size + b)
			ztile := xtile{}
			ztile.nm = "spiketrap"
			ztile.img = anm[1].rec
			ztile.color = rl.White
			ztile.fade = 1
			ztile.rec = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
			if checkaddtilerecInner(ztile.rec, lev) && checkaddetc(ztile.rec, lev) {
				ztile.cnt = makecnt(ztile.rec)
				lev.etc = append(lev.etc, ztile)
			}
		}
		//FLAME TRAPS
		if Roll6() == 6 {
			x := lev.recs[i].X + b/2
			y := lev.recs[i].Y + b/2
			x2 := x + lev.recs[i].Width - (size + b)
			y2 := y + lev.recs[i].Height - (size + b)
			ztile := xtile{}
			ztile.nm = "flametrap"
			ztile.img = anm[2].rec
			ztile.color = rl.White
			ztile.fade = 1
			ztile.rec = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
			if checkaddtilerecInner(ztile.rec, lev) && checkaddetc(ztile.rec, lev) {
				ztile.rec2 = ztile.rec
				ztile.rec2.Height = 32
				ztile.rec2.Y += 4.5
				ztile.cnt = makecnt(ztile.rec)
				lev.etc = append(lev.etc, ztile)
			}
		}
	}
	countbreak := 100
	for {
		choose := RandInt(1, len(lev.recs))
		siz := b2 + b/2
		ztile := xtile{}
		ztile.nm = "teleporter"
		ztile.img = anm[88].rec
		x := lev.recs[choose].X + b
		y := lev.recs[choose].Y + b
		x += RandF32(0, lev.recs[choose].Width-b-siz)
		y += RandF32(0, lev.recs[choose].Height-b-siz)
		ztile.rec = rl.NewRectangle(x, y, siz, siz)
		canadd := checkaddtilerecInner(ztile.rec, lev)
		if canadd {
			canadd = checkaddetc(ztile.rec, lev)
		}
		if canadd || countbreak == 0 {
			if canadd {
				ztile.crec = ztile.rec
				ztile.crec.X += ztile.crec.Width / 3
				ztile.crec.Width = ztile.crec.Width / 3
				lev.etc = append(lev.etc, ztile)
			}
			break
		}
		countbreak--
	}
	return lev
}
func makelevel() { //MARK:MAKE LEVEL

	//MUSHROOM TIMER
	for i := 0; i < len(base.nm); i++ {
		if base.nm[i] == "mushroom patch" {
			if base.unlock[i] {
				if mushroomTimer < mushroomTimerMax {
					mushroomTimer++
				}
			}
		}
	}
	//MOVE CHEST ITEMS TO STORE END OF LEVEL
	if levNumDis >= 1 && storeunlocked {
		found := false
		for i := 0; i < len(levels[levNum].chst[0].itm); i++ {
			if !levels[levNum].chst[0].itm[i].noChestMove && levels[levNum].chst[0].itm[i].nm != "" {
				for j := 0; j < len(storeItm); j++ {
					if storeItm[j].nm == levels[levNum].chst[0].itm[i].nm {
						storeItm[j].numof += levels[levNum].chst[0].itm[i].numof
						found = true
						break
					}
				}
				if !found {
					for j := 0; j < len(storeItm); j++ {
						if storeItm[j].nm == "" {
							storeItm[j] = levels[levNum].chst[0].itm[i]
							found = true
							break
						}
					}
				}
			}
		}
		if found {
			admsg("chest items moved to store room", rl.Magenta)
		}
		if storeunlocked {
			savestore()
			saveT = fps * 2
		}
	}
	//CLEAR NO CHEST MOVE
	for i := 0; i < len(pl.invn); i++ {
		if pl.invn[i].noChestMove {
			pl.invn[i].noChestMove = false
		}
	}
	//CLEAR ENEMIES XP +100
	if levNumDis >= 1 {
		if levels[levNum].enNum == 0 && !bosson {
			pl.xp += 100
			xpadded = true
		}
	}

	completed := false

	levels = nil
	projPL = nil
	projEn = nil
	fx = nil
	lightningEnm = nil

	if levNumDis == 0 && bosson {
		rl.StopMusicStream(music[currentMusic])
		currentMusic = musicNumPrev
		rl.PlayMusicStream(music[currentMusic])
		bosson = false
		bosslevon = false
		pl.hp = pl.hpmax
		pl.mana = pl.manamax
		baseon = true
		pause = true
		saveT = fps * 2
		if vineRing {
			for i := 0; i < len(pl.art); i++ {
				if pl.art[i].nm == "ring of vine" {
					pl.art[i].off = false
				}
			}
		}
		if batty {
			batcomp.cnt = cnt
			batcomp.rec = rl.NewRectangle(batcomp.cnt.X-batcomp.rec.Width/2, batcomp.rec.Height/2, batcomp.rec.Width, batcomp.rec.Height)
			batcomp.moveChangeT = fps * 3
		}
		if rollo {
			rollocomp.cnt = cnt
			rollocomp.rec = rl.NewRectangle(rollocomp.cnt.X-rollocomp.rec.Width/2, rollocomp.cnt.Y-rollocomp.rec.Height/2, rollocomp.rec.Width, rollocomp.rec.Height)
		}
	}

	if !treasureroom {
		levNumDis++
		if levNumDis == 11 {
			bossKeyChanged = false
			bosson = true
			bosslevon = true
		}
	}

	msg = nil
	pl.freezeT = 0
	pl.burnT = 0
	pl.poisonT = 0
	pl.atkT = 0
	pl.enCollisT = 0
	pl.dampT = 0
	pl.pushT = 0
	msgT = 0
	teleportT = 0
	toptxT = 0

	if bosslevon {
		makebosslev()
		makeboss()
	} else if treasureroom {
		maketreasureroom()
	} else {
		floortile = floortiles[RandInt(0, len(floortiles))]
		walltile = walltiles[RandInt(0, len(walltiles))]
		admsg("", rl.White)
		admsg("entering level "+fmt.Sprint(levNumDis), rl.White)
		admsg(fmt.Sprint(welcome[RandInt(0, len(welcome))]), rl.White)
		if xpadded {
			admsg("+100 xp cleared all enemies", rl.Green)
			xpadded = false
		}
		//CENTER ROOM
		zlev := x1scr{}
		min, max := 5, 15
		numW, numH := RandInt(min, max), RandInt(min, max)
		numWo := numW
		numHo := numH
		W, H := float32(numW)*b, float32(numH)*b
		rec := rl.NewRectangle(cnt.X-W/2, cnt.Y-H/2, W, H)
		zdbg := xdbg{}
		zdbg.conecRoom = 0
		zdbg.side = 0
		zinf := xinf{}
		zinf.num = 0
		zinf.vis = true
		zlev.recs = append(zlev.recs, rec)
		zlev.inf = append(zlev.inf, zinf)
		zlev.dbg = append(zlev.dbg, zdbg)
		//OTHER ROOMS
		num := RandInt(11, 25)
		numTotal := 1
		countbreak := 100
		for {
			choose := 0
			if len(zlev.recs) > 1 {
				choose = RandInt(0, len(zlev.recs))
				numWo = int(zlev.recs[choose].Width / b)
				numHo = int(zlev.recs[choose].Height / b)
			}
			x := zlev.recs[choose].X
			y := zlev.recs[choose].Y
			numW, numH = RandInt(min, max), RandInt(min, max)
			W, H = float32(numW)*b, float32(numH)*b
			side := RandInt(1, 5)
			//side = 3
			canadd := true
			switch side {
			case 1: //UP
				y -= float32(numH) * b
				change := RandInt(-(numW - 2), numWo-2)
				x += float32(change) * b
				rec = rl.NewRectangle(x, y, W, H)
				canadd = checkrecaddto1scr(rec, zlev.recs)
			case 2: //RIGHT
				x += float32(numWo) * b
				change := RandInt(-(numH - 2), numHo-2)
				y += float32(change) * b
				rec = rl.NewRectangle(x, y, W, H)
				canadd = checkrecaddto1scr(rec, zlev.recs)
			case 3: //DOWN
				y += float32(numHo) * b
				change := RandInt(-(numW - 2), numWo-2)
				x += float32(change) * b
				rec = rl.NewRectangle(x, y, W, H)
				canadd = checkrecaddto1scr(rec, zlev.recs)
			case 4: //LEFT
				x -= float32(numW) * b
				change := RandInt(-(numH - 2), numHo-2)
				y += float32(change) * b
				rec = rl.NewRectangle(x, y, W, H)
				canadd = checkrecaddto1scr(rec, zlev.recs)
			}
			if canadd {
				num--
				zdbg = xdbg{}
				zdbg.conecRoom = choose
				zdbg.side = side
				zinf = xinf{}
				zinf.num = numTotal
				zinf.numW = numW
				zinf.numH = numH
				zinf.W = W
				zinf.H = H
				zinf.cnt = rl.NewVector2(rec.X+rec.Width/2, rec.Y+rec.Height/2)
				zlev.doors = append(zlev.doors, makedoor(side, zlev.recs[choose], rec))
				zlev.doornums = append(zlev.doornums, numTotal)
				zlev.recs = append(zlev.recs, rec)
				zlev.inf = append(zlev.inf, zinf)
				zlev.dbg = append(zlev.dbg, zdbg)
				numTotal++
			}
			countbreak--
			//MARK: ADD LEVEL EXTRAS
			if num == 0 || countbreak == 0 {
				zlev = makeleveltiles(zlev)
				zlev = makeinnerbloksetc(zlev)
				zlev = makeswitches(zlev)
				zlev = makechest(zlev)
				zlev = makeitems(zlev)
				zlev = cleardoorblocks(zlev)
				levels = append(levels, zlev)
				makeenemies()
				makenemcollisrecs()
				makebgi()
				makerocks()
				makemushroomsink()
				completed = makeexit()
				break
			}
		}
	}
	if !completed && !bosson && !treasureroom {
		makelevel()
	}

	levT = 0
	levMins = 0
	levSecs = 0

	if levNumDis > 3 && !treasureroom {
		if Roll12() > 8 {
			makeweaponcrate()
			rl.PlaySound(audfx[117])
		}
	}
	if bosson {
		levNumDis = 0
		musicNumPrev = currentMusic
		rl.StopMusicStream(music[currentMusic])
		currentMusic = 1
		rl.PlayMusicStream(music[currentMusic])
	}

	if !bosson && dispMusic == 0 {
		rl.StopMusicStream(music[currentMusic])
		currentMusic = RandInt(4, len(music))
		rl.PlayMusicStream(music[currentMusic])
	}

	pl.hpT = fps * 3
	cursorV2 = cnt
	gameCursor = cnt

	//BAT COMPANION
	if batty {
		batcomp.cnt = cnt
		batcomp.rec = rl.NewRectangle(batcomp.cnt.X-batcomp.rec.Width/2, batcomp.rec.Height/2, batcomp.rec.Width, batcomp.rec.Height)
		batcomp.moveChangeT = fps * 3
	}
	//ROLLO COMPANION
	if rollo {
		siz2 := b / 2
		rollocomp.img = anm[153].rec
		rollocomp.cnt = cnt
		rollocomp.rec = rl.NewRectangle(rollocomp.cnt.X-siz2/2, rollocomp.cnt.Y-siz2/2, siz2, siz2)
		rollocomp.spd = 4
		for {
			rollocomp.dirX = RandF32(-rollocomp.spd, rollocomp.spd)
			if Abs(rollocomp.dirX) > rollocomp.spd/3 {
				break
			}
		}
		for {
			rollocomp.dirY = RandF32(-rollocomp.spd, rollocomp.spd)
			if Abs(rollocomp.dirY) > rollocomp.spd/3 {
				break
			}
		}
		rollocomp.atkT = fps * 3
	}

}
func makeweaponcrate() { //MARK:MAKE WEAPON CRATE

	levels[levNum].weapcrate = xweapcrate{}
	levels[levNum].weapcrate.weapnum = RandInt(1, len(weap))
	levels[levNum].weapcrate.i.img = etc[179]
	levels[levNum].weapcrate.i.rec = pl.rec
	levels[levNum].weapcrate.i.rec.X -= 10
	levels[levNum].weapcrate.i.rec.Y -= 10
	levels[levNum].weapcrate.i.rec.Width += 20
	levels[levNum].weapcrate.i.rec.Height += 20
	levels[levNum].weapcrate.i.rec = finddropside(levels[levNum].weapcrate.i.rec, 0)
	levels[levNum].weapcrate.i.crec = levels[levNum].weapcrate.i.rec
	levels[levNum].weapcrate.i.crec.Y += 8
	levels[levNum].weapcrate.i.crec.Height -= 16
	levels[levNum].weapcrate.on = true

}
func makeexit() bool { //MARK:MAKE EXIT
	found := false
	countbreak := 100
	for {
		siz := b
		ztile := xtile{}
		num := RandInt(1, len(levels[levNum].recs))
		choose := levels[levNum].recs[num]
		cntr := makecnt(choose)
		ztile.rec = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
		canadd := checkRecWalls(ztile.rec)
		if canadd {
			canadd = checkRecEtc(ztile.rec)
		}
		if canadd {
			canadd = checkRecChests(ztile.rec)
		}
		if canadd {
			exitRoomNum = num
			ztile.nm = "stairs"
			ztile.img = etc[147]
			levels[levNum].etc = append(levels[levNum].etc, ztile)
			found = true
			break
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}

	return found
}
func makemushroomsink() { //MARK:MAKE MUSHROOMS PAPER INK
	//MUSHROOMS
	num := RandInt(2, 8)
	countbreak := 100
	for num > 0 {
		siz := b / 2
		zitm := xitm{}
		choose := RandInt(1, 7)
		switch choose {
		case 1:
			zitm = itmlist[105]
		case 2:
			zitm = itmlist[106]
		case 3:
			zitm = itmlist[107]
		case 4:
			zitm = itmlist[108]
		case 5:
			zitm = itmlist[109]
		case 6:
			zitm = itmlist[110]
		}
		zitm.notquick = true
		zitm.cnt = findRanCnt()
		zitm.rec = rl.NewRectangle(zitm.cnt.X-siz/2, zitm.cnt.Y-siz/2, siz, siz)
		canadd := checkRecWalls(zitm.rec)
		if canadd {
			canadd = checkRecEtc(zitm.rec)
		}
		if canadd {
			canadd = checkRecPlayer(zitm.rec)
		}
		if canadd {
			levels[levNum].itm = append(levels[levNum].itm, zitm)
			num--
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	//PAPER INK
	num = RandInt(1, 5)
	countbreak = 100
	for num > 0 {
		siz := b / 2
		zitm := xitm{}
		choose := RandInt(1, 3)
		switch choose {
		case 1:
			zitm = itmlist[111]
		case 2:
			zitm = itmlist[112]
		}
		zitm.notquick = true
		zitm.cnt = findRanCnt()
		zitm.rec = rl.NewRectangle(zitm.cnt.X-siz/2, zitm.cnt.Y-siz/2, siz, siz)
		canadd := checkRecWalls(zitm.rec)
		if canadd {
			canadd = checkRecEtc(zitm.rec)
		}
		if canadd {
			canadd = checkRecPlayer(zitm.rec)
		}
		if canadd {
			levels[levNum].itm = append(levels[levNum].itm, zitm)
			num--
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
}
func makerocks() { //MARK:MAKE ROCKS
	for i := 0; i < len(levels[levNum].recs); i++ {
		if Roll6() > 5 {
			countbreak := 100
			for {
				siz := RandF32(be7, b+bq3)
				x := levels[levNum].recs[i].X + b/2
				y := levels[levNum].recs[i].Y + b/2
				x += RandF32(0, levels[levNum].recs[i].Width-siz-b)
				y += RandF32(0, levels[levNum].recs[i].Height-siz-b)
				rec := rl.NewRectangle(x, y, siz, siz)
				canadd := checkRecWalls(rec)
				if canadd {
					canadd = checkRecEtc(rec)
				}
				if canadd {
					canadd = checkRecPlayer(rec)
				}
				if canadd {
					ztile := xtile{}
					ztile.img = rocksI[RandInt(0, len(rocksI))]
					ztile.rec = rec
					ztile.color = rl.White
					ztile.fade = 1
					ztile.nm = "rock"
					levels[levNum].etc = append(levels[levNum].etc, ztile)
					break
				}
				countbreak--
				if countbreak == 0 {
					break
				}
			}
		}
	}
}
func makeswitches(lev x1scr) x1scr { //MARK:MAKE SWITCHES
	num := RandInt(1, 5)
	countbreak := 100
	siz := b / 2
	ztile := xtile{}
	ztile.nm = "switch"
	ztile.color = rl.White
	ztile.fade = 1
	ztile.T = fps * 3
	for num > 0 {
		ztile.numType = RandInt(1, 7)
		if ztile.numType == 4 {
			ztile.T = fps * 30
		}
		chooseImg := RandInt(1, 3)
		switch chooseImg {
		case 1:
			ztile.img = etc[132]
		case 2:
			ztile.img = etc[134]
		}
		choose := RandInt(0, len(lev.recs))
		rec2 := lev.recs[choose]
		x := rec2.X + b + b/2
		y := rec2.Y + b + b/2
		x += RandF32(0, rec2.Width-b3-siz)
		y += RandF32(0, rec2.Height-b3-siz)
		ztile.rec = rl.NewRectangle(x, y, siz, siz)
		canadd := checkaddtilerecInner(ztile.rec, lev)
		if canadd {
			canadd = checkaddetc(ztile.rec, lev)
		}
		if canadd {
			num--
			ztile.cnt = makecnt(ztile.rec)
			ztile.room = choose
			lev.etc = append(lev.etc, ztile)
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	return lev
}
func makeswitchesTreasureRoom(lev x1scr, num2 int) x1scr { //MARK:MAKE SWITCHES TREASURE ROOM
	num := RandInt(30, 41)
	if num2 == 1 {
		num = RandInt(15, 21)
	}
	countbreak := 500
	siz := b / 2
	ztile := xtile{}
	ztile.nm = "switch"
	ztile.color = rl.White
	ztile.fade = 1
	ztile.T = fps * 3
	for num > 0 {
		ztile.numType = RandInt(1, 7)
		if ztile.numType == 4 {
			ztile.T = fps * 30
		}
		chooseImg := RandInt(1, 3)
		switch chooseImg {
		case 1:
			ztile.img = etc[132]
		case 2:
			ztile.img = etc[134]
		}
		choose := RandInt(0, len(lev.recs))
		if Roll6() > 3 {
			choose = 0
		}
		rec2 := lev.recs[choose]
		x := rec2.X + b + b/2
		y := rec2.Y + b + b/2
		x += RandF32(0, rec2.Width-b3-siz)
		y += RandF32(0, rec2.Height-b3-siz)
		ztile.rec = rl.NewRectangle(x, y, siz, siz)
		canadd := checkaddtilerecInner(ztile.rec, lev)
		if canadd {
			canadd = checkaddetc(ztile.rec, lev)
		}
		if canadd {
			num--
			ztile.cnt = makecnt(ztile.rec)
			ztile.room = choose
			lev.etc = append(lev.etc, ztile)
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	return lev
}
func makeleveltiles(lev x1scr) x1scr { //MARK:MAKE LEVEL TILES
	//FLOORS
	ztile := xtile{}
	ztile.img = floortile
	ztile.fade = 0.08
	ztile.color = rl.White
	size := b
	for i := 0; i < len(lev.recs); i++ {
		x := lev.recs[i].X
		y := lev.recs[i].Y
		ztile := xtile{}
		ztile.img = floortile
		ztile.fade = 0.1
		ztile.color = rl.White
		for {
			ztile.fade = RandF32(0.04, 0.08)
			ztile.col2 = RandColor()
			ztile.rec = rl.NewRectangle(x, y, size, size)
			lev.floors = append(lev.floors, ztile)
			x += size
			if x >= lev.recs[i].X+lev.recs[i].Width {
				x = lev.recs[i].X
				y += size
			}
			if y >= lev.recs[i].Y+lev.recs[i].Height {
				break
			}
		}
	}
	//WALLS
	ztile.img = walltile
	for i := 0; i < len(lev.recs); i++ {
		//TOP BOTTOM
		size := b
		x := lev.recs[i].X
		y := lev.recs[i].Y - size
		for x < lev.recs[i].X+lev.recs[i].Width {
			ztile.fade = RandF32(0.3, 0.9)
			ztile.col2 = RandColor()
			ztile.rec = rl.NewRectangle(x, y, size, size)
			if checkaddtilerec(ztile.rec, lev) {
				lev.walls = append(lev.walls, ztile)
			}
			ztile.fade = RandF32(0.3, 0.9)
			ztile.col2 = RandColor()
			ztile.rec.Y += lev.recs[i].Height + size
			if checkaddtilerec(ztile.rec, lev) {
				lev.walls = append(lev.walls, ztile)
			}
			x += size
		}
		//RIGHT LEFT
		x = lev.recs[i].X - size
		y = lev.recs[i].Y - size
		for y <= lev.recs[i].Y+lev.recs[i].Height {
			ztile.fade = RandF32(0.3, 0.9)
			ztile.col2 = RandColor()
			ztile.rec = rl.NewRectangle(x, y, size, size)
			if checkaddtilerec(ztile.rec, lev) {
				lev.walls = append(lev.walls, ztile)
			}
			ztile.fade = RandF32(0.3, 0.9)
			ztile.col2 = RandColor()
			ztile.rec.X += lev.recs[i].Width + size
			if checkaddtilerec(ztile.rec, lev) {
				lev.walls = append(lev.walls, ztile)
			}
			y += size
		}
		lev.inf[i].wallsadded = true
	}
	//REMOVE WALLS FOR DOORS
	for i := 0; i < len(lev.doors); i++ {
		for j := 0; j < len(lev.walls); j++ {
			if rl.CheckCollisionRecs(lev.doors[i], lev.walls[j].rec) {
				lev.walls[j].off = true
			}
		}
	}
	//REMOVE TWICE SEEMS TO MISS SOME WHEN ONLY ONCE
	for i := 0; i < len(lev.walls); i++ {
		if lev.walls[i].off {
			lev.walls = RemoveTile(lev.walls, i)
		}
	}
	for i := 0; i < len(lev.walls); i++ {
		if lev.walls[i].off {
			lev.walls = RemoveTile(lev.walls, i)
		}
	}
	//REMOVE DOUBLE WALL BLOCKS
	for i := 0; i < len(lev.walls); i++ {
	}
	return lev
}
func makedoor(side int, preRec, rec rl.Rectangle) rl.Rectangle { //MARK:MAKE DOOR
	door := rl.Rectangle{}
	siz := b
	switch side {
	case 1: //UP
		if preRec.X < rec.X {
			x := rec.X
			x2 := rec.X + rec.Width
			if preRec.X+preRec.Width < x2 {
				x2 = preRec.X + preRec.Width
			}
			numbloks := int((x2-x)/b) - 1
			x += float32(RandInt(0, numbloks)) * b
			door = rl.NewRectangle(x, preRec.Y-siz*2, siz*2, siz*3)
		} else {
			x := preRec.X
			x2 := rec.X + rec.Width
			if preRec.X+preRec.Width < x2 {
				x2 = preRec.X + preRec.Width
			}
			numbloks := int((x2-x)/b) - 1
			x += float32(RandInt(0, numbloks)) * b
			door = rl.NewRectangle(x, preRec.Y-siz*2, siz*2, siz*3)
		}
	case 2: //RIGHT
		if preRec.Y < rec.Y {
			y := rec.Y
			y2 := rec.Y + rec.Height
			if preRec.Y+preRec.Height < y2 {
				y2 = preRec.Y + preRec.Height
			}
			numbloks := int((y2-y)/b) - 1
			y += float32(RandInt(0, numbloks)) * b
			door = rl.NewRectangle(rec.X-siz, y, siz*3, siz*2)
		} else {
			y := preRec.Y
			y2 := rec.Y + rec.Height
			if preRec.Y+preRec.Height < y2 {
				y2 = preRec.Y + preRec.Height
			}
			numbloks := int((y2-y)/b) - 1
			y += float32(RandInt(0, numbloks)) * b
			door = rl.NewRectangle(rec.X-siz, y, siz*3, siz*2)
		}
	case 3: //DOWN
		if preRec.X < rec.X {
			x := rec.X
			x2 := rec.X + rec.Width
			if preRec.X+preRec.Width < x2 {
				x2 = preRec.X + preRec.Width
			}
			numbloks := int((x2-x)/b) - 1
			x += float32(RandInt(0, numbloks)) * b
			door = rl.NewRectangle(x, preRec.Y+preRec.Height-siz, siz*2, siz*3)
		} else {
			x := preRec.X
			x2 := rec.X + rec.Width
			if preRec.X+preRec.Width < x2 {
				x2 = preRec.X + preRec.Width
			}
			numbloks := int((x2-x)/b) - 1
			x += float32(RandInt(0, numbloks)) * b
			door = rl.NewRectangle(x, preRec.Y+preRec.Height-siz, siz*2, siz*3)
		}
	case 4: //LEFT
		if preRec.Y < rec.Y {
			y := rec.Y
			y2 := rec.Y + rec.Height
			if preRec.Y+preRec.Height < y2 {
				y2 = preRec.Y + preRec.Height
			}
			numbloks := int((y2-y)/b) - 1
			y += float32(RandInt(0, numbloks)) * b
			door = rl.NewRectangle(preRec.X-siz*2, y, siz*3, siz*2)
		} else {
			y := preRec.Y
			y2 := rec.Y + rec.Height
			if preRec.Y+preRec.Height < y2 {
				y2 = preRec.Y + preRec.Height
			}
			numbloks := int((y2-y)/b) - 1
			y += float32(RandInt(0, numbloks)) * b
			door = rl.NewRectangle(preRec.X-siz*2, y, siz*3, siz*2)
		}
	}
	return door
}
func makebgpix() { //MARK:MAKE BG PIX

	bgpix = nil
	spd := b / 2
	dirX := RandF32(-spd, spd)
	dirY := RandF32(-spd, spd)
	num := 100
	for num > 0 {
		z := xbgpix{}
		z.col = RandColor()
		z.siz = RandF32(2, 5)
		z.dirX = dirX
		z.dirY = dirY
		z.fd = RandF32(0.5, 1)
		z.v2 = rl.NewVector2(RandF32(0, scrWF32), RandF32(0, scrHF32))
		bgpix = append(bgpix, z)
		num--
	}
}
func makescan() { //MARK:MAKE SCAN LINES
	//SCAN
	scan = nil
	scanlineSpc = float32(5)
	if med {
		scanlineSpc = 4
	}
	if lrg {
		scanlineSpc = 8
	}
	if xxl {
		scanlineSpc = 15
	}
	x := float32(0)
	y := float32(-scanlineSpc)
	for y <= scrHF32+scanlineSpc {
		scan = append(scan, rl.NewVector2(x, y))
		y += scanlineSpc
	}
}
func makeintroexitbg() { //MARK:MAKE INTRO EXIT BACKGROUND

	introbg = nil
	introbgimgnum = RandInt(1, 5)
	num := 20
	for num > 0 {
		zbg := xbgpix{}
		zbg.fd = 0.15
		zbg.spd = 2
		zbg.dirX = zbg.spd
		if FlipCoin() {
			zbg.dirX *= -1
		}
		zbg.dirY = zbg.spd
		if FlipCoin() {
			zbg.dirY *= -1
		}
		zbg.col = BrightPink()
		zbg.siz = b4
		zbg.v2 = rl.NewVector2(RandF32(0, scrWF32), RandF32(0, scrHF32))
		introbg = append(introbg, zbg)
		num--
	}
}
func makeinitial() { //MARK:MAKE INITIAL

	//END GAME
	endRec = rl.NewRectangle(cnt.X-360, cnt.Y-360, 720, 720)
	endRec.Y -= b2
	//GAME OVER
	gameoveranimRec = anm[205].rec
	makeintroexitbg()
	//MAKE OPTIONS CHARACTER SCREEN MOVING BG
	makebgpix()
	makescan()
	//BORDER SIDEBAR RECS
	W := float32(Wbloks) * b
	H := float32(Hbloks) * b
	inRec = rl.NewRectangle(cnt.X-W/2, cnt.Y-H/2, W, H)
	siz := b10 * 2
	optionsRec = rl.NewRectangle(cnt.X-siz/2, 0, siz, scrHF32*2)
	siz *= 2
	storeRec = rl.NewRectangle(cnt.X-siz/2, 0, siz, scrHF32*2)

	//STORE ROOM
	for i := 0; i < 90; i++ {
		storeItm = append(storeItm, xitm{})
	}

	//ROLLO COMPANION
	siz2 := b / 2
	rollocomp.img = anm[153].rec
	rollocomp.cnt = cnt
	rollocomp.rec = rl.NewRectangle(rollocomp.cnt.X-siz2/2, rollocomp.cnt.Y-siz2/2, siz2, siz2)
	rollocomp.spd = 4
	for {
		rollocomp.dirX = RandF32(-rollocomp.spd, rollocomp.spd)
		if Abs(rollocomp.dirX) > rollocomp.spd/3 {
			break
		}
	}
	for {
		rollocomp.dirY = RandF32(-rollocomp.spd, rollocomp.spd)
		if Abs(rollocomp.dirY) > rollocomp.spd/3 {
			break
		}
	}
	rollocomp.atkT = fps * 7

	//BAT COMPANION
	siz2 = b
	batcomp.img = anm[141].rec
	batcomp.cnt = cnt
	batcomp.rec = rl.NewRectangle(batcomp.cnt.X-siz2/2, batcomp.cnt.Y-siz2/2, siz2, siz2)
	batcomp.moveChangeT = fps * 3
	batcomp.spd = 2
	batcomp.dirX = RandF32(-batcomp.spd, batcomp.spd)
	batcomp.dirY = RandF32(-batcomp.spd, batcomp.spd)
	batcomp.atkT = fps * 7

	//RESOLUTION LISTS

	//16X9
	res169 = append(res169, "1280 x 720")
	res169 = append(res169, "1366 x 768")
	res169 = append(res169, "1600 x 900")
	res169 = append(res169, "1760 x 990")
	res169 = append(res169, "1920 x 1080")
	res169 = append(res169, "2560 x 1440")
	res169 = append(res169, "3840 x 2160")

	//16X10
	res1610 = append(res1610, "1280 x 800")
	res1610 = append(res1610, "1440 x 900")
	res1610 = append(res1610, "1680 x 1050")
	res1610 = append(res1610, "1920 x 1200")
	res1610 = append(res1610, "2560 x 1600")
	res1610 = append(res1610, "3840 x 2400")

	//16X9
	if scrW == 1280 && scrH == 720 || scrW == 1366 && scrH == 768 || scrW == 1600 && scrH == 900 || scrW == 1760 && scrH == 990 || scrW == 1920 && scrH == 1080 || scrW == 2560 && scrH == 1440 || scrW == 3840 && scrH == 2160 {
		asp169 = true
		asp1610 = false
	}
	//16X10
	if scrW == 1280 && scrH == 800 || scrW == 1440 && scrH == 900 || scrW == 1680 && scrH == 1050 || scrW == 1920 && scrH == 1200 || scrW == 2560 && scrH == 1600 || scrW == 3840 && scrH == 2400 {
		asp169 = false
		asp1610 = true
	}

	if !asp169 && !asp1610 {
		if scrH >= 720 {
			reslist = append(reslist, res169[0])
			if scrH == 720 {
				currentres = 0
			}
		}
		if scrH >= 800 {
			reslist = append(reslist, res1610[0])
			if scrH == 800 {
				currentres = 1
			}
		}
		if scrH >= 900 {
			reslist = append(reslist, res1610[1])
			reslist = append(reslist, res169[2])
			if scrH == 900 {
				currentres = 2
			}
		}
		if scrH >= 990 {
			reslist = append(reslist, res169[3])
			if scrH == 990 {
				currentres = 4
			}
		}
		if scrH >= 1050 {
			reslist = append(reslist, res1610[2])
			if scrH == 1050 {
				currentres = 5
			}
		}
		if scrH >= 1080 {
			reslist = append(reslist, res169[4])
			if scrH == 1080 {
				currentres = 6
			}
		}
		if scrH >= 1200 {
			reslist = append(reslist, res1610[3])
			if scrH == 1200 {
				currentres = 7
			}
		}
		if scrH >= 1440 {
			reslist = append(reslist, res169[5])
			if scrH == 1440 {
				currentres = 8
			}
		}
		if scrH >= 1600 {
			reslist = append(reslist, res1610[4])
			if scrH == 1600 {
				currentres = 9
			}
		}
		if scrH >= 2160 {
			reslist = append(reslist, res169[6])
			if scrH == 2160 {
				currentres = 10
			}
		}
		if scrH >= 2400 {
			reslist = append(reslist, res1610[5])
			if scrH == 2400 {
				currentres = 11
			}
		}
	} else if asp1610 {
		if scrH >= 800 {
			reslist = append(reslist, res1610[0])
			if scrH == 800 {
				currentres = 0
			}
		}
		if scrH >= 900 {
			reslist = append(reslist, res1610[1])
			if scrH == 900 {
				currentres = 1
			}
		}
		if scrH >= 1050 {
			reslist = append(reslist, res1610[2])
			if scrH == 1050 {
				currentres = 2
			}
		}
		if scrH >= 1200 {
			reslist = append(reslist, res1610[3])
			if scrH == 1200 {
				currentres = 3
			}
		}
		if scrH >= 1600 {
			reslist = append(reslist, res1610[4])
			if scrH == 1600 {
				currentres = 4
			}
		}
		if scrH >= 2400 {
			reslist = append(reslist, res1610[5])
			if scrH == 2400 {
				currentres = 5
			}
		}
	} else if asp169 {
		if scrH >= 720 {
			reslist = append(reslist, res169[0])
			if scrH == 720 {
				currentres = 0
			}
		}
		if scrH >= 768 {
			reslist = append(reslist, res169[1])
			if scrH == 768 {
				currentres = 1
			}
		}
		if scrH >= 900 {
			reslist = append(reslist, res169[2])
			if scrH == 900 {
				currentres = 2
			}
		}
		if scrH >= 990 {
			reslist = append(reslist, res169[3])
			if scrH == 990 {
				currentres = 3
			}
		}
		if scrH >= 1080 {
			reslist = append(reslist, res169[4])
			if scrH == 1080 {
				currentres = 4
			}
		}
		if scrH >= 1440 {
			reslist = append(reslist, res169[5])
			if scrH == 1440 {
				currentres = 5
			}
		}
		if scrH >= 2160 {
			reslist = append(reslist, res169[6])
			if scrH == 2160 {
				currentres = 6
			}
		}
	}

	prevres = currentres
}
func makeshaders() { //MARK:MAKE SHADERS
	if med {
		shader = rl.LoadShader("", "shaders/bloom_sml.fs")
	} else {
		shader = rl.LoadShader("", "shaders/bloom.fs")
	}
}

func makeimgs() { //MARK:MAKE IMGS
	//ETC IMGS
	etc = append(etc, rl.NewRectangle(0, 33, 13, 13))         //0 MOVING BLOK SPIKE
	etc = append(etc, rl.NewRectangle(0, 52, 32, 32))         //1 PINK CRATE
	etc = append(etc, rl.NewRectangle(32, 52, 32, 32))        //2 OLD CRATE
	etc = append(etc, rl.NewRectangle(64, 52, 32, 32))        //3 BLUE CRATE
	etc = append(etc, rl.NewRectangle(96, 52, 32, 32))        //4 NEW CRATE
	etc = append(etc, rl.NewRectangle(128, 52, 32, 32))       //5 CRATE HIT
	etc = append(etc, rl.NewRectangle(160, 52, 32, 32))       //6 OLD CRATE HIT
	etc = append(etc, rl.NewRectangle(16, 32, 16, 16))        //7 CURSOR
	etc = append(etc, rl.NewRectangle(203, 58, 21, 21))       //8 KITCHEN KNIFE
	etc = append(etc, rl.NewRectangle(517, 55, 43, 43))       //9 SCROLL 1
	etc = append(etc, rl.NewRectangle(560, 55, 43, 43))       //10 SCROLL 2
	etc = append(etc, rl.NewRectangle(603, 55, 43, 43))       //11 SCROLL 3
	etc = append(etc, rl.NewRectangle(646, 55, 43, 43))       //12 SCROLL 4
	etc = append(etc, rl.NewRectangle(689, 55, 43, 43))       //13 SCROLL 5
	etc = append(etc, rl.NewRectangle(732, 55, 43, 43))       //14 SCROLL 6
	etc = append(etc, rl.NewRectangle(775, 55, 43, 43))       //15 SCROLL 7
	etc = append(etc, rl.NewRectangle(818, 55, 43, 43))       //16 SCROLL 8
	etc = append(etc, rl.NewRectangle(228, 51, 32, 32))       //17 SCOPE
	etc = append(etc, rl.NewRectangle(392, 157, 64, 64))      //18 TOOLS
	etc = append(etc, rl.NewRectangle(659, 160, 64, 64))      //19 GAS CAN
	etc = append(etc, rl.NewRectangle(520, 157, 64, 64))      //20 BATTERY
	etc = append(etc, rl.NewRectangle(802, 159, 64, 64))      //21 MAP
	etc = append(etc, rl.NewRectangle(392, 158, 28, 28))      //22 BACKPACK
	etc = append(etc, rl.NewRectangle(712, 157, 64, 64))      //23 AMMO BOX
	etc = append(etc, rl.NewRectangle(396, 192, 26, 26))      //24 STEROIDS
	etc = append(etc, rl.NewRectangle(728, 160, 64, 64))      //25 MEDIKIT
	etc = append(etc, rl.NewRectangle(518, 159, 64, 64))      //26 BRAIN
	etc = append(etc, rl.NewRectangle(1020, 160, 64, 64))     //27 EYE
	etc = append(etc, rl.NewRectangle(430, 158, 20, 20))      //28 BEAR TRAP
	etc = append(etc, rl.NewRectangle(100, 33, 16, 16))       //29 HEART
	etc = append(etc, rl.NewRectangle(496, 59, 9, 9))         //30 MINI SPIKE
	etc = append(etc, rl.NewRectangle(1500, 20, 14, 14))      //31 SKELETON BONE
	etc = append(etc, rl.NewRectangle(117, 33, 16, 16))       //32 GREY HEART
	etc = append(etc, rl.NewRectangle(190, 1309, 114, 114))   //33 TENT
	etc = append(etc, rl.NewRectangle(565, 373, 16, 16))      //34 BASE BG 1
	etc = append(etc, rl.NewRectangle(581, 373, 16, 16))      //35 BASE BG 2
	etc = append(etc, rl.NewRectangle(597, 373, 16, 16))      //36 BASE BG 3
	etc = append(etc, rl.NewRectangle(613, 373, 16, 16))      //37 BASE BG 4
	etc = append(etc, rl.NewRectangle(629, 373, 16, 16))      //38 BASE BG 5
	etc = append(etc, rl.NewRectangle(743, 413, 135, 135))    //39 BASE ROCK
	etc = append(etc, rl.NewRectangle(908, 385, 240, 240))    //40 BASE HOBBIT
	etc = append(etc, rl.NewRectangle(528, 410, 200, 200))    //41 BASE SKULL EXIT
	etc = append(etc, rl.NewRectangle(1376, 268, 27, 27))     //42 BASE ARCADE 1
	etc = append(etc, rl.NewRectangle(1407, 268, 27, 27))     //43 BASE ARCADE 2
	etc = append(etc, rl.NewRectangle(1162, 380, 211, 240))   //44 BASE WEAPON SHED
	etc = append(etc, rl.NewRectangle(1385, 385, 207, 250))   //45 BASE APOTHECARYY
	etc = append(etc, rl.NewRectangle(1608, 412, 112, 112))   //46 BASE LOCK
	etc = append(etc, rl.NewRectangle(1492, 158, 48, 48))     //47 BASE FIRE STONE
	etc = append(etc, rl.NewRectangle(1818, 446, 98, 98))     //48 BASE TREE
	etc = append(etc, rl.NewRectangle(1615, 534, 128, 128))   //49 BASE GROUND
	etc = append(etc, rl.NewRectangle(400, 372, 24, 24))      //50 GOLD
	etc = append(etc, rl.NewRectangle(424, 372, 24, 24))      //51 SILVER
	etc = append(etc, rl.NewRectangle(448, 372, 24, 24))      //52 BRONZE
	etc = append(etc, rl.NewRectangle(472, 372, 24, 24))      //53 LEAD
	etc = append(etc, rl.NewRectangle(496, 372, 24, 24))      //54 PLATINUM
	etc = append(etc, rl.NewRectangle(524, 374, 32, 32))      //55 SCRAP
	etc = append(etc, rl.NewRectangle(485, 404, 32, 32))      //56 WATCH
	etc = append(etc, rl.NewRectangle(458, 400, 24, 24))      //57 SHRIMP
	etc = append(etc, rl.NewRectangle(434, 400, 21, 21))      //58 FLASK
	etc = append(etc, rl.NewRectangle(402, 398, 27, 27))      //59 PISTOL
	etc = append(etc, rl.NewRectangle(491, 440, 19, 19))      //60 TURTLE
	etc = append(etc, rl.NewRectangle(460, 428, 22, 22))      //61 SNEAKERS
	etc = append(etc, rl.NewRectangle(438, 428, 18, 18))      //62 SODA
	etc = append(etc, rl.NewRectangle(416, 428, 20, 20))      //63 KEY
	etc = append(etc, rl.NewRectangle(488, 462, 22, 22))      //64 SUNGLASSES
	etc = append(etc, rl.NewRectangle(462, 454, 21, 21))      //65 ICE CREAM
	etc = append(etc, rl.NewRectangle(440, 454, 21, 21))      //66 BASKETBALL
	etc = append(etc, rl.NewRectangle(415, 454, 20, 20))      //67 JAR ORANGE
	etc = append(etc, rl.NewRectangle(484, 488, 29, 29))      //68 JAR RED
	etc = append(etc, rl.NewRectangle(461, 483, 21, 21))      //69 RECORD
	etc = append(etc, rl.NewRectangle(433, 481, 24, 24))      //70 BROCCOLI
	etc = append(etc, rl.NewRectangle(400, 481, 29, 29))      //71 DRILL
	etc = append(etc, rl.NewRectangle(308, 542, 32, 32))      //72 COOK BOOK
	etc = append(etc, rl.NewRectangle(457, 512, 21, 21))      //73 ICE LOLLY
	etc = append(etc, rl.NewRectangle(435, 511, 23, 23))      //74 TOILET PAPER
	etc = append(etc, rl.NewRectangle(409, 513, 19, 19))      //75 GARLIC
	etc = append(etc, rl.NewRectangle(484, 551, 26, 26))      //76 TENDERISER
	etc = append(etc, rl.NewRectangle(455, 541, 24, 24))      //77 CLEAVER
	etc = append(etc, rl.NewRectangle(431, 542, 24, 24))      //78 SKULL BOTTLE
	etc = append(etc, rl.NewRectangle(1410, 154, 18, 18))     //79 ENEMY BURN ICON
	etc = append(etc, rl.NewRectangle(745, 556, 64, 64))      //80 ENEMY BLEED ICON
	etc = append(etc, rl.NewRectangle(1441, 275, 16, 16))     //81 ENEMY POISON ICON
	etc = append(etc, rl.NewRectangle(1460, 274, 18, 18))     //82 ENEMY STUN ICON
	etc = append(etc, rl.NewRectangle(1480, 275, 16, 16))     //83 MANA ICON
	etc = append(etc, rl.NewRectangle(1497, 275, 14, 14))     //84 RESIST FIRE ICON
	etc = append(etc, rl.NewRectangle(1512, 274, 16, 16))     //85 RESIST POISON ICON
	etc = append(etc, rl.NewRectangle(1531, 274, 16, 16))     //86 INVISIBLE ICON
	etc = append(etc, rl.NewRectangle(1549, 274, 16, 16))     //87 ARMOR ICON
	etc = append(etc, rl.NewRectangle(181, 418, 18, 18))      //88 INTANGIBLE ICON
	etc = append(etc, rl.NewRectangle(208, 411, 42, 42))      //89 STATS POWER ICON
	etc = append(etc, rl.NewRectangle(330, 592, 64, 64))      //90 DICE
	etc = append(etc, rl.NewRectangle(284, 465, 64, 64))      //91 DUMBBELL
	etc = append(etc, rl.NewRectangle(250, 412, 34, 34))      //92 BASKETBALL SNEAKERS
	etc = append(etc, rl.NewRectangle(6, 261, 19, 19))        //93 EMERALD RING
	etc = append(etc, rl.NewRectangle(30, 261, 19, 19))       //94 PEARL RING
	etc = append(etc, rl.NewRectangle(54, 261, 19, 19))       //95 GOLD RING
	etc = append(etc, rl.NewRectangle(80, 263, 17, 17))       //96 QUAIL EGG
	etc = append(etc, rl.NewRectangle(103, 259, 26, 26))      //97 TESLA COIL
	etc = append(etc, rl.NewRectangle(136, 259, 24, 24))      //98 SAPPHIRE AMULET
	etc = append(etc, rl.NewRectangle(166, 259, 24, 24))      //99 TURQUOISE AMULET
	etc = append(etc, rl.NewRectangle(196, 258, 22, 22))      //100 BELT
	etc = append(etc, rl.NewRectangle(224, 261, 20, 20))      //101 MIRROR
	etc = append(etc, rl.NewRectangle(248, 262, 28, 28))      //102 TOXIC SLUDGE
	etc = append(etc, rl.NewRectangle(283, 262, 20, 20))      //103 THROWING KNIFE
	etc = append(etc, rl.NewRectangle(309, 260, 23, 23))      //104 BEETROOT
	etc = append(etc, rl.NewRectangle(334, 259, 24, 24))      //105 MAGICIANS HAT
	etc = append(etc, rl.NewRectangle(366, 261, 16, 16))      //106 PEARL
	etc = append(etc, rl.NewRectangle(4, 284, 24, 24))        //107 CANDY CANE
	etc = append(etc, rl.NewRectangle(34, 286, 28, 28))       //108 LIGHTBULB
	etc = append(etc, rl.NewRectangle(70, 286, 20, 20))       //109 MUG
	etc = append(etc, rl.NewRectangle(97, 291, 26, 26))       //110 FEATHER
	etc = append(etc, rl.NewRectangle(130, 289, 23, 23))      //111 CAPE
	etc = append(etc, rl.NewRectangle(162, 293, 18, 18))      //112 LADYBIRD
	etc = append(etc, rl.NewRectangle(184, 289, 25, 25))      //113 MUG OF TEA
	etc = append(etc, rl.NewRectangle(214, 292, 16, 16))      //114 FLAMINGO
	etc = append(etc, rl.NewRectangle(234, 295, 23, 23))      //115 NINJA STAR
	etc = append(etc, rl.NewRectangle(264, 297, 21, 21))      //116 ORANGE SLICE
	etc = append(etc, rl.NewRectangle(291, 290, 21, 21))      //117 TV
	etc = append(etc, rl.NewRectangle(429, 199, 24, 24))      //118 TOASTER
	etc = append(etc, rl.NewRectangle(349, 287, 31, 31))      //119 LOLLIPOP
	etc = append(etc, rl.NewRectangle(3, 325, 28, 28))        //120 HONEYCOMB
	etc = append(etc, rl.NewRectangle(38, 325, 24, 24))       //121 EGGS
	etc = append(etc, rl.NewRectangle(70, 324, 21, 21))       //122 POPCORN
	etc = append(etc, rl.NewRectangle(93, 325, 29, 29))       //123 BOMB
	etc = append(etc, rl.NewRectangle(129, 328, 26, 26))      //124 OVEN GLOVE
	etc = append(etc, rl.NewRectangle(162, 324, 32, 32))      //125 NOODLES
	etc = append(etc, rl.NewRectangle(199, 324, 28, 28))      //126 GAS MASK
	etc = append(etc, rl.NewRectangle(1845, 706, 56, 56))     //127 TELEPORT CRYSTAL
	etc = append(etc, rl.NewRectangle(220, 538, 16, 16))      //128 VINE
	etc = append(etc, rl.NewRectangle(233, 323, 20, 20))      //129 CROISSANT
	etc = append(etc, rl.NewRectangle(323, 292, 24, 24))      //130 CHICKEN EGG
	etc = append(etc, rl.NewRectangle(326, 387, 64, 64))      //131 POPCORN
	etc = append(etc, rl.NewRectangle(126, 367, 18, 18))      //132 PRESSURE PLATE RED UP
	etc = append(etc, rl.NewRectangle(144, 367, 18, 18))      //133 PRESSURE PLATE RED DOWN
	etc = append(etc, rl.NewRectangle(162, 367, 18, 18))      //134 PRESSURE PLATE BLUE UP
	etc = append(etc, rl.NewRectangle(180, 367, 18, 18))      //135 PRESSURE PLATE BLUE DOWN
	etc = append(etc, rl.NewRectangle(211, 366, 14, 14))      //136 SWITCH LEFT
	etc = append(etc, rl.NewRectangle(225, 366, 14, 14))      //137 SWITCH RIGHT
	etc = append(etc, rl.NewRectangle(127, 390, 12, 12))      //138 DART
	etc = append(etc, rl.NewRectangle(1100, 943, 16, 16))     //139 MUSHROOM INVIS
	etc = append(etc, rl.NewRectangle(1116, 943, 16, 16))     //140 MUSHROOM MANA
	etc = append(etc, rl.NewRectangle(1132, 943, 16, 16))     //141 MUSHROOM FIRE
	etc = append(etc, rl.NewRectangle(1148, 943, 16, 16))     //142 MUSHROOM HEALTH
	etc = append(etc, rl.NewRectangle(1164, 943, 16, 16))     //143 MUSHROOM POISON
	etc = append(etc, rl.NewRectangle(1180, 943, 16, 16))     //144 MUSHROOM ARMOR
	etc = append(etc, rl.NewRectangle(1153, 1307, 64, 64))    //145 PAPER
	etc = append(etc, rl.NewRectangle(1241, 1309, 64, 64))    //146 INK
	etc = append(etc, rl.NewRectangle(1226, 1198, 16, 16))    //147 STAIRS
	etc = append(etc, rl.NewRectangle(1310, 1291, 58, 58))    //148 ICEMAN PROJ
	etc = append(etc, rl.NewRectangle(266, 1658, 256, 256))   //149 ICE CUBE
	etc = append(etc, rl.NewRectangle(1502, 1284, 64, 64))    //150 LANDMINE
	etc = append(etc, rl.NewRectangle(1330, 2405, 16, 16))    //151 BUSH
	etc = append(etc, rl.NewRectangle(1432, 1659, 128, 128))  //152 BIRD EGG PROJ
	etc = append(etc, rl.NewRectangle(1384, 1815, 32, 32))    //153 BIRD PROJ FRIED EGG
	etc = append(etc, rl.NewRectangle(73, 1814, 64, 64))      //154 WEAPON CARROTS
	etc = append(etc, rl.NewRectangle(0, 1835, 29, 29))       //155 WEAPON CARROTS PROJ
	etc = append(etc, rl.NewRectangle(28, 1837, 32, 32))      //156 WINDOW CLEANER
	etc = append(etc, rl.NewRectangle(4, 1878, 24, 24))       //157 RUBBER DUCK
	etc = append(etc, rl.NewRectangle(34, 1878, 28, 28))      //158 FRYING PAN
	etc = append(etc, rl.NewRectangle(74, 1884, 28, 28))      //159 ROLLING PIN
	etc = append(etc, rl.NewRectangle(104, 1882, 32, 32))     //160 MUSTARD
	etc = append(etc, rl.NewRectangle(0, 1910, 32, 32))       //161 POWER STRIP
	etc = append(etc, rl.NewRectangle(150, 1819, 15, 15))     //162 SPLINTERS
	etc = append(etc, rl.NewRectangle(172, 1818, 31, 31))     //163 MINT ICREAM
	etc = append(etc, rl.NewRectangle(158, 1868, 64, 64))     //164 LIGHTER
	etc = append(etc, rl.NewRectangle(1490, 2381, 64, 64))    //165 MAGNIFIYING GLASS
	etc = append(etc, rl.NewRectangle(412, 539, 15, 15))      //166 RASPBERRY
	etc = append(etc, rl.NewRectangle(46, 1916, 22, 22))      //167 ORBITAL LOLLY
	etc = append(etc, rl.NewRectangle(1567, 1642, 38, 38))    //168 PINEAPPLE
	etc = append(etc, rl.NewRectangle(1608, 1627, 64, 64))    //169 PINEAPPLE RING
	etc = append(etc, rl.NewRectangle(1856, 2316, 64, 64))    //170 FORK
	etc = append(etc, rl.NewRectangle(1939, 2317, 58, 58))    //171 CHILLI
	etc = append(etc, rl.NewRectangle(1763, 2318, 15, 15))    //172 EMOJI
	etc = append(etc, rl.NewRectangle(1784, 2316, 19, 19))    //173 FRENCH FRIES
	etc = append(etc, rl.NewRectangle(1812, 2313, 25, 25))    //174 SOUP LADLE
	etc = append(etc, rl.NewRectangle(1856, 2394, 22, 22))    //175 MUSIC NOTE
	etc = append(etc, rl.NewRectangle(2024, 2317, 64, 64))    //176 GUITAR
	etc = append(etc, rl.NewRectangle(2112, 2319, 64, 64))    //177 DRAWING PIN
	etc = append(etc, rl.NewRectangle(1897, 2391, 64, 64))    //178 FRENCH FRIES PROJ
	etc = append(etc, rl.NewRectangle(1925, 0, 128, 128))     //179 WEAPON CRATE
	etc = append(etc, rl.NewRectangle(1941, 206, 256, 256))   //180 BOOK
	etc = append(etc, rl.NewRectangle(2254, 224, 128, 128))   //181 STAR
	etc = append(etc, rl.NewRectangle(2227, 1, 25, 25))       //182 PSYCHEDELICS
	etc = append(etc, rl.NewRectangle(2257, 3, 24, 24))       //183 BOOTS
	etc = append(etc, rl.NewRectangle(2283, 1, 28, 28))       //184 FART GAS
	etc = append(etc, rl.NewRectangle(2311, 1, 28, 28))       //185 MACHINE
	etc = append(etc, rl.NewRectangle(2346, 1, 32, 32))       //186 SALT
	etc = append(etc, rl.NewRectangle(2085, 70, 18, 18))      //187 UMBRELLA
	etc = append(etc, rl.NewRectangle(2109, 71, 28, 28))      //188 WEAPON CASE
	etc = append(etc, rl.NewRectangle(2145, 69, 40, 40))      //189 BOSS STATUE
	etc = append(etc, rl.NewRectangle(1325, 2771, 1075, 229)) //190 UNKLNIK LOGO
	etc = append(etc, rl.NewRectangle(905, 2839, 400, 157))   //191 GO LOGO
	etc = append(etc, rl.NewRectangle(1888, 1658, 500, 500))  //192 MR SNUGGLES LOGO
	etc = append(etc, rl.NewRectangle(2249, 374, 128, 128))   //193 INTRO BG STAR
	etc = append(etc, rl.NewRectangle(2245, 530, 146, 146))   //194 INTRO BG YINYANG
	etc = append(etc, rl.NewRectangle(2139, 705, 152, 152))   //195 INTRO BG SMILEY
	etc = append(etc, rl.NewRectangle(1959, 708, 143, 143))   //196 INTRO BG CLOVER
	etc = append(etc, rl.NewRectangle(1960, 527, 18, 18))     //197 XP UPDATE
	etc = append(etc, rl.NewRectangle(1984, 527, 16, 16))     //198 SWITCH WEAPON
	etc = append(etc, rl.NewRectangle(2043, 539, 128, 128))   //199 CONTROLLER
	etc = append(etc, rl.NewRectangle(1983, 2403, 64, 64))    //200 ICEMAN CRYSTAL BOSS ITEM
	etc = append(etc, rl.NewRectangle(456, 3326, 48, 48))     //201 ICEMAN ICE RING BOSS ITEM EFFECT
	etc = append(etc, rl.NewRectangle(2266, 1054, 128, 128))  //202 MR FRISBEE FRISBEE BOSS ITEM
	etc = append(etc, rl.NewRectangle(1696, 1701, 64, 64))    //203 SPINNA BOSS ITEM
	etc = append(etc, rl.NewRectangle(2182, 1061, 64, 64))    //204 SPACEMAN HELMET BOSS ITEM
	etc = append(etc, rl.NewRectangle(1385, 1299, 31, 31))    //205 PYRO PIG BOSS ITEM
	etc = append(etc, rl.NewRectangle(2106, 1061, 64, 64))    //206 ZOMBO BOSS ITEM
	etc = append(etc, rl.NewRectangle(10, 2257, 43, 43))      //207 BATTY BOSS ITEM
	etc = append(etc, rl.NewRectangle(80, 1794, 16, 16))      //208 ROLLO BOSS ITEM
	etc = append(etc, rl.NewRectangle(1257, 1199, 16, 16))    //209 ARROW WEAPON SPECIAL
	etc = append(etc, rl.NewRectangle(1279, 1201, 14, 14))    //210 FIREWORK
	etc = append(etc, rl.NewRectangle(1297, 1190, 32, 32))    //211 ROCKET
	etc = append(etc, rl.NewRectangle(1733, 3671, 667, 129))  //212 THE END
	etc = append(etc, rl.NewRectangle(1981, 1067, 88, 88))    //213 WEAPON STAND

	//MARK: IMGS RECTANGLE SLICES
	//ROCKS
	rocksI = append(rocksI, rl.NewRectangle(777, 1251, 96, 96))
	rocksI = append(rocksI, rl.NewRectangle(879, 1253, 82, 82))
	rocksI = append(rocksI, rl.NewRectangle(979, 1250, 79, 79))
	rocksI = append(rocksI, rl.NewRectangle(764, 1347, 111, 111))
	rocksI = append(rocksI, rl.NewRectangle(878, 1333, 136, 136))
	rocksI = append(rocksI, rl.NewRectangle(1018, 1351, 103, 103))
	//FLOWERS
	flowers = append(flowers, rl.NewRectangle(1695, 383, 18, 18))
	flowers = append(flowers, rl.NewRectangle(1693, 317, 18, 18))
	flowers = append(flowers, rl.NewRectangle(1694, 342, 18, 18))
	flowers = append(flowers, rl.NewRectangle(1693, 363, 18, 18))
	flowers = append(flowers, rl.NewRectangle(1716, 300, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1717, 322, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1716, 344, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1716, 365, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1740, 300, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1741, 322, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1740, 344, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1740, 365, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1764, 300, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1765, 322, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1764, 344, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1764, 365, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1719, 385, 13, 13))
	flowers = append(flowers, rl.NewRectangle(1743, 387, 11, 11))
	flowers = append(flowers, rl.NewRectangle(1767, 386, 12, 12))
	//BGI
	zbgi := xbgi{}
	zbgi.img = rl.NewRectangle(1629, 52, 63, 63)
	zbgi.sml = true
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(1561, 116, 63, 63)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(1630, 116, 63, 63)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(419, 1087, 73, 73)
	bgilist = append(bgilist, zbgi)
	zbgi.sml = false
	zbgi.img = rl.NewRectangle(1694, 63, 114, 114)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(1795, 66, 120, 120)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(1581, 182, 120, 120)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(1706, 187, 105, 105)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(1812, 187, 105, 105)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(1805, 298, 113, 113)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(34, 938, 115, 115)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(155, 945, 102, 102)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(271, 933, 120, 120)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(419, 940, 127, 127)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(553, 941, 117, 117)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(38, 1059, 117, 117)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(158, 1057, 120, 120)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(290, 1063, 105, 105)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(506, 1072, 120, 120)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(641, 1087, 120, 120)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(46, 1196, 120, 120)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(178, 1184, 120, 120)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(328, 1194, 125, 125)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(477, 1224, 125, 125)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(609, 1229, 125, 125)
	bgilist = append(bgilist, zbgi)
	zbgi.img = rl.NewRectangle(45, 1330, 125, 125)
	bgilist = append(bgilist, zbgi)
	//BGI 2
	zbgi = xbgi{}
	zbgi.img = rl.NewRectangle(1292, 153, 22, 22)
	bgilist2 = append(bgilist2, zbgi)
	zbgi.img = rl.NewRectangle(1315, 153, 15, 15)
	bgilist2 = append(bgilist2, zbgi)
	zbgi.img = rl.NewRectangle(1293, 176, 16, 16)
	bgilist2 = append(bgilist2, zbgi)
	zbgi.img = rl.NewRectangle(1310, 176, 12, 12)
	bgilist2 = append(bgilist2, zbgi)
	zbgi.img = rl.NewRectangle(1323, 173, 18, 18)
	bgilist2 = append(bgilist2, zbgi)
	zbgi.img = rl.NewRectangle(1341, 154, 36, 36)
	bgilist2 = append(bgilist2, zbgi)
	zbgi.img = rl.NewRectangle(1377, 154, 30, 30)
	bgilist2 = append(bgilist2, zbgi)
	//ANIMS
	//0 WATER
	zanim := xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(273, 17, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim) //0 WATER
	//1 SPIKE TRAP
	zanim = xanim{}
	zanim.frames = 9
	zanim.rec = rl.NewRectangle(340, 17, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//2 FLAME TRAP
	zanim = xanim{}
	zanim.frames = 13
	zanim.rec = rl.NewRectangle(900, 1, 32, 41)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//3 PLAYER SMOKE
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(32, 32, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//4 CHEST
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(1216, 46, 48, 48)
	zanim.W = 48
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//5 POTION HP FULL
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(0, 152, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//6 POTION HP HALF
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(128, 152, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//7 POTION HP QUARTER
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(256, 152, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//8 POTION MANA FULL
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(0, 169, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//9 POTION MANA HALF
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(128, 169, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//10 POTION MANA QUARTER
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(256, 169, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//11 POTION RESIST FIRE FULL
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(0, 186, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//12 POTION RESIST FIRE HALF
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(128, 186, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//13 POTION RESIST FIRE QUARTER
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(256, 186, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//14 POTION RESIST POISON FULL
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(0, 203, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//15 POTION RESIST POISON HALF
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(128, 203, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//16 POTION RESIST POISON QUARTER
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(256, 203, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//17 POTION INVISIBILITY FULL
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(0, 220, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//18 POTION INVISIBILITY HALF
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(128, 220, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//19 POTION INVISIBILITY QUARTER
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(256, 220, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//20 POTION ARMOR FULL
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(0, 237, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//21 POTION ARMOR HALF
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(128, 237, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//22 POTION ARMOR QUARTER
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(256, 237, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//23 ENEMY 0 BLUE SPIKE RIGHT
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(269, 55, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//24 ENEMY 0 BLUE SPIKE LEFT
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(445, 55, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//25 ENEMY 0 BLUE SPIKE IDLE
	zanim = xanim{}
	zanim.frames = 1
	zanim.rec = rl.NewRectangle(462, 55, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//26 ENEMY 1 RED EYE RIGHT
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1352, 0, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//27 ENEMY 1 RED EYE LEFT
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1528, 0, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//28 ENEMY 1 RED EYE IDLE
	zanim = xanim{}
	zanim.frames = 1
	zanim.rec = rl.NewRectangle(1544, 0, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//29 ENEMY 2 RED BOMB RIGHT
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(871, 45, 18, 18)
	zanim.W = 18
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//30 ENEMY 2 RED BOMB LEFT
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1069, 45, 18, 18)
	zanim.W = 18
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//31 ENEMY 2 RED BOMB IDLE
	zanim = xanim{}
	zanim.frames = 1
	zanim.rec = rl.NewRectangle(1087, 45, 18, 18)
	zanim.W = 18
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//32 ENEMY 3 GHOST RIGHT
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(871, 65, 18, 18)
	zanim.W = 18
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//33 ENEMY 3 GHOST LEFT
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1033, 65, 18, 18)
	zanim.W = 18
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//34 ENEMY 4 RED ANTENNA RIGHT
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(867, 84, 22, 22)
	zanim.W = 22
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//35 ENEMY 4 RED ANTENNA LEFT
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1065, 84, 22, 22)
	zanim.W = 22
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//36 ENEMY 5 BALLOON RIGHT
	zanim = xanim{}
	zanim.frames = 1
	zanim.rec = rl.NewRectangle(1088, 66, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//37 ENEMY 5 BALLOON LEFT
	zanim = xanim{}
	zanim.frames = 1
	zanim.rec = rl.NewRectangle(1184, 66, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//38 ENEMY 6 CROCODILE RIGHT
	zanim = xanim{}
	zanim.frames = 6
	zanim.rec = rl.NewRectangle(789, 301, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//39 ENEMY 6 CROCODILE LEFT
	zanim = xanim{}
	zanim.frames = 6
	zanim.rec = rl.NewRectangle(1205, 301, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//40 ENEMY 7 PINK CARTWHEEL RIGHT
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(392, 226, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//41 ENEMY 7 PINK CARTWHEEL LEFT
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(872, 226, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//42 ENEMY 7 PINK CARTWHEEL IDLE
	zanim = xanim{}
	zanim.frames = 9
	zanim.rec = rl.NewRectangle(904, 226, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//43 ENEMY 8 GREEN PLANT RIGHT
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(395, 261, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//44 ENEMY 8 GREEN PLANT LEFT
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(747, 261, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//45 ENEMY 8 GREEN PLANT IDLE
	zanim = xanim{}
	zanim.frames = 11
	zanim.rec = rl.NewRectangle(779, 261, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//46 ENEMY 9 YELLOW DINO RIGHT
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1096, 191, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//47 ENEMY 9 YELLOW DINO LEFT
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1448, 191, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//48 ENEMY 9 YELLOW DINO IDLE
	zanim = xanim{}
	zanim.frames = 8
	zanim.rec = rl.NewRectangle(1228, 227, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//49 ENEMY 10 BLACK DOT RIGHT
	zanim = xanim{}
	zanim.frames = 4
	zanim.rec = rl.NewRectangle(1353, 19, 12, 12)
	zanim.W = 12
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//50 ENEMY 10 BLACK DOT LEFT
	zanim = xanim{}
	zanim.frames = 4
	zanim.rec = rl.NewRectangle(1485, 19, 12, 12)
	zanim.W = 12
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//51 ENEMY 11 WORM RIGHT
	zanim = xanim{}
	zanim.frames = 2
	zanim.rec = rl.NewRectangle(1167, 264, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//52 ENEMY 11 WORM LEFT
	zanim = xanim{}
	zanim.frames = 2
	zanim.rec = rl.NewRectangle(1327, 264, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//53 ENEMY 12 FLY RIGHT
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(462, 298, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//54 ENEMY 12 FLY LEFT
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(686, 298, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//55 FIRE RED BOMB
	zanim = xanim{}
	zanim.frames = 18
	zanim.rec = rl.NewRectangle(0, 664, 96, 96)
	zanim.W = 96
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//56 RED ANTENNA BULLET
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(792, 20, 12, 12)
	zanim.W = 12
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//57 BALLOON EXPLOSION
	zanim = xanim{}
	zanim.frames = 4
	zanim.rec = rl.NewRectangle(1582, 2, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//58 ENEMY 6 CROCODILE ATK RIGHT
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1269, 301, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//59 ENEMY 6 CROCODILE ATK LEFT
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1620, 301, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//60 PINK CART WHEEL BULLET
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1754, 2, 41, 41)
	zanim.W = 41
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//61 GREEN PLANT BULLET
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1096, 162, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//62 FIRE YELLOW DINO
	zanim = xanim{}
	zanim.frames = 4
	zanim.rec = rl.NewRectangle(0, 596, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//63 FLAMEHEAD RIGHT
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(1176, 336, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//64 FLAMEHEAD LEFT
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(1656, 336, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//65 ORANGE RIGHT
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(796, 338, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//66 ORANGE LEFT
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1148, 336, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//67 SKELETON RIGHT
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(393, 333, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//68 SKELETON LEFT
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(745, 333, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//69 RED BLOB RIGHT
	zanim = xanim{}
	zanim.frames = 2
	zanim.rec = rl.NewRectangle(654, 370, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//70 RED BLOB LEFT
	zanim = xanim{}
	zanim.frames = 2
	zanim.rec = rl.NewRectangle(814, 370, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//71 RED BLOB BULLET
	zanim = xanim{}
	zanim.frames = 4
	zanim.rec = rl.NewRectangle(0, 538, 42, 42)
	zanim.W = 42
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//72 CAMPFIRE
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(1722, 416, 24, 24)
	zanim.W = 24
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//73 PIGEON RIGHT
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1788, 550, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//74 PIGEON LEFT
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1900, 550, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//75 TURTLE SHIELD
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1, 468, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//76 POISON GAS
	zanim = xanim{}
	zanim.frames = 14
	zanim.rec = rl.NewRectangle(0, 1480, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//77 ARMOR SHIELD
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(0, 418, 44, 44)
	zanim.W = 44
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//78 FROG IDLE R
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(916, 818, 48, 48)
	zanim.W = 48
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//79 FROG IDLE L
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(1636, 818, 48, 48)
	zanim.W = 48
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//80 FROG JUMP R
	zanim = xanim{}
	zanim.frames = 6
	zanim.rec = rl.NewRectangle(912, 770, 48, 48)
	zanim.W = 48
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//81 FROG JUMP L
	zanim = xanim{}
	zanim.frames = 6
	zanim.rec = rl.NewRectangle(1536, 770, 48, 48)
	zanim.W = 48
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//82 FROG EXIT
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1583, 779, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//83 TELEPORT
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(926, 869, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//84 INFLICT
	zanim = xanim{}
	zanim.frames = 4
	zanim.rec = rl.NewRectangle(1464, 867, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//85 REVIVE
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1629, 857, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//86 BEAR TRAP
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(0, 375, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//87 BEAR TRAP
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1656, 926, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//88 CRYSTAL TELEPORT
	zanim = xanim{}
	zanim.frames = 23
	zanim.rec = rl.NewRectangle(0, 1572, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//89 THORNS
	zanim = xanim{}
	zanim.frames = 8
	zanim.rec = rl.NewRectangle(1344, 992, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//90 TORNADO
	zanim = xanim{}
	zanim.frames = 4
	zanim.rec = rl.NewRectangle(1692, 822, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//91 TESLA
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(839, 943, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//92 PURPLE RAIN
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(1405, 1059, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//93 FRISBEE
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1445, 906, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//94 BELT
	zanim = xanim{}
	zanim.frames = 4
	zanim.rec = rl.NewRectangle(353, 1364, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//95 BEETROOT EXPLODE
	zanim = xanim{}
	zanim.frames = 8
	zanim.rec = rl.NewRectangle(1344, 1133, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//96 CLOAK SPARKS
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1664, 1210, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//97 LADYBUG TURRET PROJ
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1783, 780, 13, 13)
	zanim.W = 13
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//98 FLAMINGO FLAME
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1447, 949, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//99 SHOCKWAVE
	zanim = xanim{}
	zanim.frames = 4
	zanim.rec = rl.NewRectangle(1016, 1008, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//100 BEE LEFT
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(432, 589, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//101 BEE RIGHT
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(432, 605, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//102 CHICKEN LEFT
	zanim = xanim{}
	zanim.frames = 13
	zanim.rec = rl.NewRectangle(1237, 1143, 34, 34)
	zanim.W = 34
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//103 CHICKEN RIGHT
	zanim = xanim{}
	zanim.frames = 13
	zanim.rec = rl.NewRectangle(792, 1101, 34, 34)
	zanim.W = 34
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//104 EGG EXPLODE
	zanim = xanim{}
	zanim.frames = 8
	zanim.rec = rl.NewRectangle(1095, 1222, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//105 BOMB FUSE
	zanim = xanim{}
	zanim.frames = 4
	zanim.rec = rl.NewRectangle(1600, 1288, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//106 BOMB EXPLODE
	zanim = xanim{}
	zanim.frames = 4
	zanim.rec = rl.NewRectangle(855, 1014, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//107 STUN STARS
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(777, 1183, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//108 SUMMON ITEM
	zanim = xanim{}
	zanim.frames = 4
	zanim.rec = rl.NewRectangle(1048, 1193, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//109 ICEMAN CHANGE
	zanim = xanim{}
	zanim.frames = 8
	zanim.rec = rl.NewRectangle(1344, 1367, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//110 MR FRISBEE IDLE R
	zanim = xanim{}
	zanim.frames = 8
	zanim.rec = rl.NewRectangle(552, 1658, 48, 48)
	zanim.W = 48
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//111 MR FRISBEE IDLE L
	zanim = xanim{}
	zanim.frames = 8
	zanim.rec = rl.NewRectangle(1368, 1658, 48, 48)
	zanim.W = 48
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//112 MR FRISBEE WALK R
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(600, 1706, 48, 48)
	zanim.W = 48
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//113 MR FRISBEE WALK L
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(1320, 1706, 48, 48)
	zanim.W = 48
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//114 MR FRISBEE ATK R
	zanim = xanim{}
	zanim.frames = 8
	zanim.rec = rl.NewRectangle(552, 1754, 48, 48)
	zanim.W = 48
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//115 MR FRISBEE ATK L
	zanim = xanim{}
	zanim.frames = 8
	zanim.rec = rl.NewRectangle(1368, 1754, 48, 48)
	zanim.W = 48
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//116 MR FRISBEE PROJ
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(970, 1477, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//117 MR FRISBEE NEAR HIT
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(1408, 1444, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//118 SPINNA IDLE R
	zanim = xanim{}
	zanim.frames = 4
	zanim.rec = rl.NewRectangle(568, 1816, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//119 SPINNA IDLE L
	zanim = xanim{}
	zanim.frames = 4
	zanim.rec = rl.NewRectangle(856, 1816, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//120 SPINNA SPIN START
	zanim = xanim{}
	zanim.frames = 4
	zanim.rec = rl.NewRectangle(888, 1816, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//121 SPINNA SPIN
	zanim = xanim{}
	zanim.frames = 6
	zanim.rec = rl.NewRectangle(1048, 1816, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//122 SPINNA SPIN END
	zanim = xanim{}
	zanim.frames = 6
	zanim.rec = rl.NewRectangle(1048, 1816, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//123 SPINNA PROJ
	zanim = xanim{}
	zanim.frames = 2
	zanim.rec = rl.NewRectangle(1568, 1702, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//124 SPACEMAN IDLE R
	zanim = xanim{}
	zanim.frames = 4
	zanim.rec = rl.NewRectangle(560, 1860, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//125 SPACEMAN IDLE L
	zanim = xanim{}
	zanim.frames = 4
	zanim.rec = rl.NewRectangle(848, 1860, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//126 SPACEMAN SHOOT R
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(880, 1860, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//127 SPACEMAN SHOOT L
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1232, 1860, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//128 SPACEMAN HIT R
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1264, 1860, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//129 SPACEMAN HIT L
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1616, 1860, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//130 SPACEMAN DEATH
	zanim = xanim{}
	zanim.frames = 6
	zanim.rec = rl.NewRectangle(1648, 1860, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//131 SPACEMAN PROJ
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1159, 1398, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//132 BLOCK PROJ
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(1100, 967, 14, 14)
	zanim.W = 14
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//133 PYRO PIG R
	zanim = xanim{}
	zanim.frames = 9
	zanim.rec = rl.NewRectangle(0, 1940, 90, 90)
	zanim.W = 90
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//134 PYRO PIG L
	zanim = xanim{}
	zanim.frames = 9
	zanim.rec = rl.NewRectangle(1710, 1940, 90, 90)
	zanim.W = 90
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//135 PYRO PIG PROJ
	zanim = xanim{}
	zanim.frames = 2
	zanim.rec = rl.NewRectangle(1385, 1298, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//136 ZOMBO ATK R
	zanim = xanim{}
	zanim.frames = 11
	zanim.rec = rl.NewRectangle(0, 2048, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//137 ZOMBO ATK L
	zanim = xanim{}
	zanim.frames = 11
	zanim.rec = rl.NewRectangle(1472, 2048, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//138 ZOMBO WALK R
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(0, 2116, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//139 ZOMBO WALK L
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(960, 2116, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//140 ZOMBO PROJ
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(0, 1692, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//141 RED BAT FLY R
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(0, 2180, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//142 RED BAT FLY L
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(960, 2180, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//143 RED BAT ATK R
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(0, 2244, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//144 RED BAT ATK L
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(960, 2244, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//145 RED BAT IDLE R
	zanim = xanim{}
	zanim.frames = 11
	zanim.rec = rl.NewRectangle(0, 2308, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//146 RED BAT IDLE L
	zanim = xanim{}
	zanim.frames = 11
	zanim.rec = rl.NewRectangle(1472, 2308, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//147 RED BAT PROJ
	zanim = xanim{}
	zanim.frames = 2
	zanim.rec = rl.NewRectangle(0, 1725, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//148 MUSHROOM WALK R
	zanim = xanim{}
	zanim.frames = 9
	zanim.rec = rl.NewRectangle(1036, 2244, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//149 MUSHROOM WALK L
	zanim = xanim{}
	zanim.frames = 9
	zanim.rec = rl.NewRectangle(2252, 2244, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//150 MUSHROOM ATK R
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(1032, 2181, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//151 MUSHROOM ATK L
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(1992, 2181, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//152 MUSHROOM PROJ
	zanim = xanim{}
	zanim.frames = 15
	zanim.rec = rl.NewRectangle(0, 2374, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	zanim.YT = zanim.rec.Y
	anm = append(anm, zanim)
	//153 ROLLO R
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(0, 1794, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//154 ROLLO L
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(176, 1794, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//155 ROLLO PROJ
	zanim = xanim{}
	zanim.frames = 14
	zanim.rec = rl.NewRectangle(1044, 2126, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//156 CARROT R
	zanim = xanim{}
	zanim.frames = 1
	zanim.rec = rl.NewRectangle(996, 2373, 20, 20)
	zanim.W = 20
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//157 CARROT L
	zanim = xanim{}
	zanim.frames = 1
	zanim.rec = rl.NewRectangle(1056, 2373, 20, 20)
	zanim.W = 20
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//158 GREEN PIG R
	zanim = xanim{}
	zanim.frames = 9
	zanim.rec = rl.NewRectangle(0, 2463, 90, 90)
	zanim.W = 90
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//159 GREEN PIG L
	zanim = xanim{}
	zanim.frames = 9
	zanim.rec = rl.NewRectangle(1710, 2463, 90, 90)
	zanim.W = 90
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//160 BLUE ROBOT R
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1090, 2364, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//161 BLUE ROBOT L
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1442, 2364, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//162 RED DEVIL R
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(998, 2405, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//163 RED DEVIL L
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1110, 2405, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//164 BLACKBIRD R
	zanim = xanim{}
	zanim.frames = 2
	zanim.rec = rl.NewRectangle(1000, 2431, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//165 BLACKBIRD L
	zanim = xanim{}
	zanim.frames = 2
	zanim.rec = rl.NewRectangle(1080, 2431, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//166 GREEN JERSEY R
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1110, 2427, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//167 GREEN JERSEY L
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1334, 2427, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//168 ROBOT SHOCK
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1555, 1579, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//169 RED DEVIL FLAME
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(0, 1816, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//170 BUSH R
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1138, 2405, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//171 BUSH L
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1314, 2405, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//172 JERSEY SPELL
	zanim = xanim{}
	zanim.frames = 16
	zanim.rec = rl.NewRectangle(0, 2691, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//173 BUSH PROJ
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1562, 2060, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//174 POISON BUBBLES
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1243, 1398, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//175 MAP PIN
	zanim = xanim{}
	zanim.frames = 25
	zanim.rec = rl.NewRectangle(0, 2568, 48, 48)
	zanim.W = 48
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//176 CHEST PIN
	zanim = xanim{}
	zanim.frames = 25
	zanim.rec = rl.NewRectangle(0, 2624, 48, 48)
	zanim.W = 48
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//177 KITCHEN SPRAY PROJ
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1373, 2439, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//178 FRYING PAN SHOCK
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1556, 2323, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//179 PINEAPPLE RING EXPLODE
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1583, 2366, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//180 FLOOR SWITCH FX COLLECT ITEM
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1599, 2433, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//181 WEAPON CRATE OPEN
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1929, 124, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//182 WHITE MOUSE
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(2085, 0, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//183 BROWN MOUSE
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(2151, 0, 16, 16)
	zanim.W = 16
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//184 SPINNING TRAP
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(1958, 483, 32, 32)
	zanim.W = 32
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//185 FART FIREBALL
	zanim = xanim{}
	zanim.frames = 3
	zanim.rec = rl.NewRectangle(1777, 581, 48, 48)
	zanim.W = 48
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//186 USE SCROLL FX
	zanim = xanim{}
	zanim.frames = 8
	zanim.rec = rl.NewRectangle(0, 2781, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//187 ROTATING TREASURE EXIT COIN
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1941, 899, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//188 USE POTION FX
	zanim = xanim{}
	zanim.frames = 5
	zanim.rec = rl.NewRectangle(1952, 987, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//189 ICEMAN DEATH FX
	zanim = xanim{}
	zanim.frames = 17
	zanim.rec = rl.NewRectangle(0, 3240, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//190 MR FRISBEE DEATH FX
	zanim = xanim{}
	zanim.frames = 10
	zanim.rec = rl.NewRectangle(1275, 2633, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//191 SPINNA DEATH FX
	zanim = xanim{}
	zanim.frames = 17
	zanim.rec = rl.NewRectangle(0, 3024, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//192 SPZMAN DEATH FX
	zanim = xanim{}
	zanim.frames = 16
	zanim.rec = rl.NewRectangle(0, 3100, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//193 PYRO PIG DEATH FX
	zanim = xanim{}
	zanim.frames = 16
	zanim.rec = rl.NewRectangle(0, 3172, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//194 ZOMBO DEATH FX
	zanim = xanim{}
	zanim.frames = 16
	zanim.rec = rl.NewRectangle(1283, 2566, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//195 RED BAT DEATH FX
	zanim = xanim{}
	zanim.frames = 15
	zanim.rec = rl.NewRectangle(1331, 3035, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//196 MUSHROOM DEATH FX
	zanim = xanim{}
	zanim.frames = 17
	zanim.rec = rl.NewRectangle(1235, 3104, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//197 ROLLO DEATH FX
	zanim = xanim{}
	zanim.frames = 14
	zanim.rec = rl.NewRectangle(0, 3318, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//198 SAVE ANIMATION
	zanim = xanim{}
	zanim.frames = 11
	zanim.rec = rl.NewRectangle(0, 2860, 50, 50)
	zanim.W = 50
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//199 BASE UNLOCK FX
	zanim = xanim{}
	zanim.frames = 13
	zanim.rec = rl.NewRectangle(1504, 3193, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//200 BASE UPGRADE FX
	zanim = xanim{}
	zanim.frames = 19
	zanim.rec = rl.NewRectangle(1115, 3335, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//201 FIREWORKS FIRE
	zanim = xanim{}
	zanim.frames = 6
	zanim.rec = rl.NewRectangle(1945, 1517, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//202 RING OF FIRE
	zanim = xanim{}
	zanim.frames = 13
	zanim.rec = rl.NewRectangle(0, 3396, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//203 SLUDGE GEYSER
	zanim = xanim{}
	zanim.frames = 7
	zanim.rec = rl.NewRectangle(0, 3467, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//204 INTRO ANIM
	zanim = xanim{}
	zanim.frames = 15
	zanim.rec = rl.NewRectangle(1376, 3416, 64, 64)
	zanim.W = 64
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)
	//205 DEATH ANIM
	zanim = xanim{}
	zanim.frames = 19
	zanim.rec = rl.NewRectangle(0, 3548, 96, 96)
	zanim.W = 96
	zanim.X = zanim.rec.X
	anm = append(anm, zanim)

	//MARK: IMG ANIMATIONS
	//FLOOR
	x := float32(0)
	y := float32(0)
	for {
		floortiles = append(floortiles, rl.NewRectangle(x, y, 16, 16))
		x += 16
		if x >= 896 {
			break
		}
	}
	x = float32(0)
	y = float32(1660)
	for {
		floortiles = append(floortiles, rl.NewRectangle(x, y, 16, 16))
		x += 16
		if x >= 256 {
			break
		}
	}
	//INNER WALLS
	x = 0
	y = 16
	for {
		walltiles = append(walltiles, rl.NewRectangle(x, y, 16, 16))
		x += 16
		if x >= 256 {
			break
		}
	}
	x = 0
	y = 1676
	for {
		walltiles = append(walltiles, rl.NewRectangle(x, y, 16, 16))
		x += 16
		if x >= 112 {
			break
		}
	}
	//SPLAT
	x = 0
	y = 772
	for {
		splat = append(splat, rl.NewRectangle(x, y, 128, 128))
		x += 128
		if x > 768 {
			break
		}
	}

	for i := 0; i < 57; i++ {
		txt := fmt.Sprint(i) + ".png"
		if i < 10 {
			txt = "0" + txt
		}
		txt = "img/raylib_logo/" + txt
		raylibAnim = append(raylibAnim, rl.LoadTexture(txt))
	}

}

// MARK: CORE CORE CORE CORE CORE CORE CORE CORE CORE CORE CORE CORE CORE CORE CORE CORE CORE
func inp() { //MARK:INP
	//CONTROLLER DISCONNECT
	if controllerINITIAL {
		if !rl.IsGamepadAvailable(0) {
			if !options && !exit && !credits && !intro && !startScreen && !endgame {
				pause = true
				options = true
				disconnectT = fps * 3
				controllerINITIAL = false
			}
		}
	}
	//MOUSE LEFT CLICK GAMEPAD R TRIGGER & A
	if rl.IsMouseButtonPressed(rl.MouseLeftButton) || rl.IsGamepadButtonPressed(0, 12) || rl.IsGamepadButtonPressed(0, 7) {
		inpL = true
	} else {
		inpL = false
	}
	//MOUSE RIGHT CLICK GAMEPAD L TRIGGER & X
	if rl.IsMouseButtonPressed(rl.MouseButtonRight) || rl.IsGamepadButtonPressed(0, 10) || rl.IsGamepadButtonPressed(0, 8) {
		inpR = true
	} else {
		inpR = false
	}
	//MOUSE GAMEPAD ON/OFF
	if rl.GetMousePosition() != mouseoffpos {
		mouseoff = false
	}
	if mouseoff {
		cursorV2 = gameCursor
	}
	//GAMEPAD QUICK SLOTS
	if rl.IsGamepadButtonPressed(0, 1) {
		if pl.quik[0].nm != "" {
			useitm(0, 1)
		}
	}
	if rl.IsGamepadButtonPressed(0, 2) {
		if pl.quik[1].nm != "" {
			useitm(1, 1)
		}
	}
	if rl.IsGamepadButtonPressed(0, 3) {
		if pl.quik[2].nm != "" {
			useitm(2, 1)
		}
	}
	if rl.IsGamepadButtonPressed(0, 4) {
		if pl.quik[3].nm != "" {
			useitm(3, 1)
		}
	}
	//KEYS QUICK SLOTS
	if rl.IsKeyPressed(rl.KeyOne) {
		if pl.quik[0].nm != "" {
			useitm(0, 1)
		}
	}
	if rl.IsKeyPressed(rl.KeyTwo) {
		if pl.quik[1].nm != "" {
			useitm(1, 1)
		}
	}
	if rl.IsKeyPressed(rl.KeyThree) {
		if pl.quik[2].nm != "" {
			useitm(2, 1)
		}
	}
	if rl.IsKeyPressed(rl.KeyFour) {
		if pl.quik[3].nm != "" {
			useitm(3, 1)
		}
	}
	//GAMEPAD MOUSE CURSOR
	if rl.GetGamepadAxisMovement(0, 2) != 0 { //LR
		controllerINITIAL = true
		if !mouseoff {
			mouseoffpos = rl.GetMousePosition()
			gameCursor = rl.GetMousePosition()
		}
		mouseoff = true
		change := rl.GetGamepadAxisMovement(0, 2)
		if Abs(change) > deadZ {
			change *= 100
			change *= stickMov
			gameCursor.X += change + delta
		}
		if gameCursor.X > scrWF32 {
			gameCursor.X = scrWF32
		}
		if gameCursor.X < 0 {
			gameCursor.X = 0
		}

	}
	if rl.GetGamepadAxisMovement(0, 3) != 0 { //UD
		if !mouseoff {
			mouseoffpos = rl.GetMousePosition()
			gameCursor = rl.GetMousePosition()
		}
		mouseoff = true
		change := rl.GetGamepadAxisMovement(0, 3)
		if Abs(change) > deadZ {
			change *= 100
			change *= stickMov
			gameCursor.Y += change + delta
		}
		if gameCursor.Y > scrHF32 {
			gameCursor.Y = scrHF32
		}
		if gameCursor.Y < 0 {
			gameCursor.Y = 0
		}
	}

	//CHAR SCR OPTIONS
	if rl.IsKeyPressed(rl.KeyTab) && !options && !exit && !credits && !intro && !startScreen && !endgame || rl.IsGamepadButtonPressed(0, 5) && !options && !exit && !credits && !intro && !startScreen && !endgame {
		makebgpix()
		charscr = !charscr
		if !baseon {
			pause = !pause
		}
		invenInfo = false
		inMenuOn = false
		inMenuItm = blankint
		invDisTxtT = 0
		rl.PlaySound(audfx[17])
	}
	if rl.IsKeyPressed(rl.KeyEscape) && !helpon && !charscr && !exit && !credits && !intro && !startScreen && !endgame || rl.IsGamepadButtonPressed(0, 15) && !helpon && !charscr && !exit && !credits && !intro && !startScreen && !endgame {
		makebgpix()
		options = !options
		if !baseon {
			pause = !pause
		}
		rl.PlaySound(audfx[19])
	}
	//CURSOR
	if mouseoff {
		cursorV2 = gameCursor
		cursorV2cam = rl.GetScreenToWorld2D(gameCursor, cam2)
		cursorV2Base = rl.GetScreenToWorld2D(gameCursor, camBase)
		cursorV2camInven = rl.GetScreenToWorld2D(gameCursor, camInven)
		cursorV2Strucs = rl.GetScreenToWorld2D(gameCursor, camStrucs)
	} else {
		cursorV2 = rl.GetMousePosition()
		cursorV2cam = rl.GetScreenToWorld2D(cursorV2, cam2)
		cursorV2Base = rl.GetScreenToWorld2D(cursorV2, camBase)
		cursorV2camInven = rl.GetScreenToWorld2D(cursorV2, camInven)
		cursorV2Strucs = rl.GetScreenToWorld2D(cursorV2, camStrucs)
	}

	//DEBUG
	/*
		if rl.IsKeyPressed(rl.KeyF7) {
			if mushroomTimer > 0 {
				mushroomTimer--
			}
		}
		if rl.IsKeyPressed(rl.KeyF6) {
			weaponshedon = !weaponshedon
		}
		if rl.IsKeyPressed(rl.KeyF5) {
			bookon = !bookon
		}
		if rl.IsKeyPressed(rl.KeyF4) {
			makeweaponcrate()
		}
		if rl.IsKeyPressed(rl.KeyF3) {
			baseon = !baseon
			pause = !pause
		}
		if rl.IsKeyPressed(rl.KeyF2) {
			pl.cnt = cnt
			pl.hp = pl.hpmax
			pl.mana = pl.manamax
			if bosson {
				bosslevon = false
				bosson = false
			}
			upplayerrec()
			makelevel()
		}
		if rl.IsKeyPressed(rl.KeyF1) {
			debug = !debug
		}
		//ZOOM
		if rl.IsKeyPressed(rl.KeyKpAdd) {
			if cam2.Zoom == 1 {
				cam2.Zoom = 2
			} else if cam2.Zoom == 2 {
				cam2.Zoom = 3
			} else if cam2.Zoom == 3 {
				cam2.Zoom = 4
			} else if cam2.Zoom == 4 {
				cam2.Zoom = 1
			}
			if camBase.Zoom == 1 {
				camBase.Zoom = 2
			} else if camBase.Zoom == 2 {
				camBase.Zoom = 3
			} else if camBase.Zoom == 3 {
				camBase.Zoom = 4
			} else if camBase.Zoom == 4 {
				camBase.Zoom = 1
			}
			if camBoss.Zoom == 1 {
				camBoss.Zoom = 2
			} else if camBoss.Zoom == 2 {
				camBoss.Zoom = 3
			} else if camBoss.Zoom == 3 {
				camBoss.Zoom = 4
			} else if camBoss.Zoom == 4 {
				camBoss.Zoom = 1
			}
			cams()
		}
		if rl.IsKeyPressed(rl.KeyKpSubtract) {
			if cam2.Zoom == 1 {
				cam2.Zoom = 4
			} else if cam2.Zoom == 2 {
				cam2.Zoom = 1
			} else if cam2.Zoom == 3 {
				cam2.Zoom = 2
			} else if cam2.Zoom == 4 {
				cam2.Zoom = 3
			}
			if camBase.Zoom == 1 {
				camBase.Zoom = 4
			} else if camBase.Zoom == 2 {
				camBase.Zoom = 1
			} else if camBase.Zoom == 3 {
				camBase.Zoom = 2
			} else if camBase.Zoom == 4 {
				camBase.Zoom = 3
			}
			if camBoss.Zoom == 1 {
				camBoss.Zoom = 4
			} else if camBoss.Zoom == 2 {
				camBoss.Zoom = 1
			} else if camBoss.Zoom == 3 {
				camBoss.Zoom = 2
			} else if camBoss.Zoom == 4 {
				camBoss.Zoom = 3
			}
			cams()
		}
	*/

}
func timers() { //MARK:TIMERS

	if frames%15 == 0 {
		onoff15 = !onoff15
	}

	//OUTSIDE PAUSE
	if clickT > 0 {
		clickT--
	}
	//IN PAUSE
	if !pause {
		if landmineT > 0 {
			landmineT--
			if landmineT == 1 {
				siz := b / 2
				ztile := xtile{}
				ztile.img = etc[150]
				ztile.rec = rl.NewRectangle(pl.cnt.X-siz/2, pl.cnt.Y-siz/2, siz, siz)
				ztile.crec = ztile.rec
				ztile.nm = "landmine"
				ztile.cnt = makecnt(ztile.rec)
				canadd := true
				for i := 0; i < len(levels[levNum].etc); i++ {
					if levels[levNum].etc[i].nm == "landmine" {
						if rl.CheckCollisionRecs(levels[levNum].etc[i].rec, ztile.rec) {
							canadd = false
						}
					}
				}
				if canadd {
					levels[levNum].etc = append(levels[levNum].etc, ztile)
				}
				landmineT = fps * 7
			}
		}
		if pyroballT > 0 {
			pyroballT--
			if pyroballT == 1 {
				zproj := xweap{}
				zproj.dmg = 2
				zproj.nm = "pigProj"
				siz := b + b/2
				zproj.spd = 4
				cntr2 := makecnt(pl.rec)
				zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
				zproj.crec = zproj.rec
				zproj.crec.Y += zproj.crec.Height / 4
				zproj.crec.Height = zproj.crec.Height / 2
				zproj.crec.X += zproj.crec.Width / 4
				zproj.crec.Width = zproj.crec.Width / 2
				zproj.img = anm[135].rec
				zproj.dirY = -zproj.spd
				zproj.ro = 180
				projPL = append(projPL, zproj)
				zproj.ro = 0
				zproj.dirY = zproj.spd
				projPL = append(projPL, zproj)
				zproj.ro = -90
				zproj.dirY = 0
				zproj.dirX = zproj.spd
				projPL = append(projPL, zproj)
				zproj.ro = 90
				zproj.dirX = -zproj.spd
				projPL = append(projPL, zproj)
				zproj.ro = -45
				zproj.dirX = zproj.spd
				zproj.dirY = zproj.spd
				projPL = append(projPL, zproj)
				zproj.ro = -135
				zproj.dirX = zproj.spd
				zproj.dirY = -zproj.spd
				projPL = append(projPL, zproj)
				zproj.ro = 45
				zproj.dirX = -zproj.spd
				zproj.dirY = zproj.spd
				projPL = append(projPL, zproj)
				zproj.ro = 135
				zproj.dirX = -zproj.spd
				zproj.dirY = -zproj.spd
				projPL = append(projPL, zproj)

				pyroballT = fps * 7
			}
		}
		if spinnaT > 0 {
			spinnaT--
			if spinnaT == 1 {
				spinnaT2 = fps * 3
				pl.bosseffectrec = anm[123].rec
			}
		}
		if mrfrisbeeT > 0 {
			mrfrisbeeT--
			if mrfrisbeeT == 1 {
				zproj := xweap{}
				zproj.nm = "mrfrisbeeProj"
				zproj.img = anm[116].rec
				zproj.dmg = 2
				zproj.bounce = 12
				zproj.spd = 8
				siz := b
				zproj.rec = rl.NewRectangle(pl.cnt.X-siz/2, pl.cnt.Y-siz/2, siz, siz)
				zproj.crec = zproj.rec
				zproj.WOrig = zproj.rec.Width
				if pl.cnt.X > pl.cnt.X {
					zproj.dirX = zproj.spd
				} else {
					zproj.dirX = -zproj.spd
				}
				if pl.cnt.Y > pl.cnt.Y {
					zproj.dirY = zproj.spd / 4
				} else {
					zproj.dirY = -zproj.spd / 4
				}
				zproj.fd = 1
				zproj.col = rl.White
				projPL = append(projPL, zproj)
				if Roll6() > 2 {
					zproj.dirY = zproj.spd
					if FlipCoin() {
						if FlipCoin() {
							zproj.dirX = zproj.spd / 4
						} else {
							zproj.dirX -= zproj.spd / 4
						}
					}
					projPL = append(projPL, zproj)
				}
				if Roll6() > 2 {
					zproj.dirY = -zproj.spd
					if FlipCoin() {
						if FlipCoin() {
							zproj.dirX = zproj.spd / 4
						} else {
							zproj.dirX -= zproj.spd / 4
						}
					}
					projPL = append(projPL, zproj)
				}

				mrfrisbeeT = fps * 7
			}
		}
		if icecrystalT > 0 {
			icecrystalT--
			if icecrystalT == 1 {
				siz := b3
				zfx := xfx{}
				zfx.nm = "icecrystal"
				zfx.cnt = pl.cnt
				zfx.rec = rl.NewRectangle(zfx.cnt.X-siz/2, zfx.cnt.Y-siz/2, siz, siz)
				zfx.img = etc[201]
				fx = append(fx, zfx)
				icecrystalT = fps * 5
			}
		}
		if fartT > 0 {
			fartT--
			if fartT%30 == 0 {
				choose := RandInt(1, 5)
				switch choose {
				case 1:
					rl.PlaySound(audfx[98])
				case 2:
					rl.PlaySound(audfx[99])
				case 3:
					rl.PlaySound(audfx[100])
				case 4:
					rl.PlaySound(audfx[101])
				}

				siz := bq3
				zproj := xweap{}
				zproj.dmg = 1
				zproj.nm = "fartfire"
				zproj.col = rl.White
				zproj.fd = 1
				zproj.spd = 4
				zproj.ro = AngleBetweenTwoPoints(pl.cnt, cursorV2cam) + 180
				xdiff := AbsDiff(pl.cnt.X, cursorV2cam.X)
				ydiff := AbsDiff(pl.cnt.Y, cursorV2cam.Y)
				if xdiff > ydiff {
					zproj.dirX = zproj.spd
					zproj.dirY = ydiff / (xdiff / zproj.dirX)
				} else {
					zproj.dirY = zproj.spd
					zproj.dirX = xdiff / (ydiff / zproj.dirY)
				}
				if pl.cnt.X > cursorV2cam.X {
					zproj.dirX = -zproj.dirX
				}
				if pl.cnt.Y > cursorV2cam.Y {
					zproj.dirY = -zproj.dirY
				}
				zproj.dirX *= -1
				zproj.dirY *= -1
				zproj.rec = rl.NewRectangle(pl.cnt.X-siz/2, pl.cnt.Y-siz/2, siz, siz)
				zproj.crec = zproj.rec
				zproj.crec.X += b / 4
				zproj.crec.Y += b / 4
				zproj.crec.Width -= b / 2
				zproj.crec.Height -= b / 2
				zproj.img = anm[185].rec
				projPL = append(projPL, zproj)
			}
			if fartT == 1 {
				admsg("flatulence ended", rl.Yellow)
			}
		}
		if saltT > 0 {
			saltT--
			if saltT == 1 {
				admsg("salt ended", rl.Yellow)
			}
		}
		if bootsT > 0 {
			bootsT--
			if bootsT == 1 {
				admsg("no more boots", rl.Yellow)
			}
		}
		if psychedelicsT > 0 {
			psychedelicsT--
			if psychedelicsT == 1 {
				admsg("back to dull gray", rl.Yellow)
			}
		}
		if gasmaskT > 0 {
			gasmaskT--
			if gasmaskT == 1 && poisongasCount <= 10 {
				zproj := xweap{}
				zproj.T = fps * 30
				siz := b4
				zproj.rec = rl.NewRectangle(pl.cnt.X-siz/2, pl.cnt.Y-siz/2, siz, siz)
				zproj.crec = zproj.rec
				zproj.crec.X += zproj.crec.Width / 4
				zproj.crec.Y += zproj.crec.Height / 4
				zproj.crec.Width = zproj.crec.Width / 2
				zproj.crec.Height = zproj.crec.Height / 2
				zproj.img = anm[76].rec
				zproj.cnt = makecnt(zproj.rec)
				zproj.fd = 1
				zproj.col = rl.White
				zproj.rospd = RandF32(2, 4)
				if FlipCoin() {
					zproj.rospd = -zproj.rospd
				}
				zproj.dmg = 1
				zproj.spd = 4
				zproj.dirX = RandF32(-zproj.spd, zproj.spd)
				zproj.dirY = RandF32(-zproj.spd, zproj.spd)
				zproj.nm = "poisongas"
				projPL = append(projPL, zproj)
				gasmaskT = fps*8 - (gasmasknum * fps)
			}
		}
		if eggsT > 0 {
			eggsT--
			if frames%2 == 0 {
				anm[103].rec.X += anm[103].W
				if anm[103].rec.X > anm[103].X+anm[103].frames*anm[103].W {
					anm[103].rec.X = anm[103].X
				}
				anm[102].rec.X -= anm[102].W
				if anm[102].rec.X < anm[102].X-anm[102].frames*anm[102].W {
					anm[102].rec.X = anm[102].X
				}
			}
		}
		if honeycombT > 0 {
			honeycombT--
			if frames%3 == 0 {
				anm[101].rec.X += anm[101].W
				if anm[101].rec.X > anm[101].X+anm[101].frames*anm[101].W {
					anm[101].rec.X = anm[101].X
				}
				anm[100].rec.X += anm[100].W
				if anm[100].rec.X > anm[100].X+anm[100].frames*anm[100].W {
					anm[100].rec.X = anm[100].X
				}
			}
		}
		if lollipopT > 0 {
			lollipopT--
			if frames%300 == 0 {
				if pl.mana < pl.manamax {
					pl.mana++
				}
			}
		}
		if orangeT > 0 {
			orangeT--
			if frames%300 == 0 {
				if pl.hp < pl.hpmax {
					pl.hp++
				}
			}
		}
		if tvT > 0 {
			tvT--
		}
		if flamingoT > 0 {
			flamingoT--
			if flamingoT == 0 {
				if pl.aninum != 0 && pl.aninum != 1 {
					zfx := xfx{}
					zfx.nm = "flamingoflame"
					zfx.fade = 0.8
					zfx.img = anm[98].rec
					zfx.rec = pl.rec
					zfx.rec.X -= b / 4
					zfx.rec.Y -= b / 4
					zfx.rec.Width += b / 2
					zfx.rec.Height += b / 2
					zfx.crec = zfx.rec
					zfx.crec.X += zfx.crec.Width / 8
					zfx.crec.Y += zfx.crec.Height / 8
					zfx.crec.Width -= zfx.crec.Width / 4
					zfx.crec.Height -= zfx.crec.Height / 4
					zfx.T = fps * 3
					zfx.below = true
					fx = append(fx, zfx)
				}
				flamingoT = (fps + fps/2) / flamingonum
			}
		}
		if cloakT > 0 {
			cloakT--
		}
		if beetrootT > 0 {
			beetrootT--
		}
		if throwingknifenum > 0 {
			spd := pl.spd + 2
			siz := b / 2
			if frames%int(fps*3) == 0 {
				zproj := xweap{}
				zproj.dmg = 1
				zproj.img = etc[103]
				zproj.rec = rl.NewRectangle(pl.cnt.X-siz/2, pl.cnt.Y-siz/2, siz, siz)
				zproj.fd = 1
				zproj.col = rl.White
				zproj.crec = zproj.rec
				if throwingknifenum >= 1 {
					zproj.dirY = -spd
					zproj.ro = -45
					projPL = append(projPL, zproj)
				}
				if throwingknifenum >= 2 {
					zproj.dirY = spd
					zproj.ro = 135
					projPL = append(projPL, zproj)
				}
				if throwingknifenum >= 3 {
					zproj.dirY = 0
					zproj.dirX = spd
					zproj.ro = 45
					projPL = append(projPL, zproj)
				}
				if throwingknifenum >= 4 {
					zproj.dirY = 0
					zproj.dirX = -spd
					zproj.ro = -135
					projPL = append(projPL, zproj)
				}
				if throwingknifenum >= 5 {
					zproj.dirY = -spd
					zproj.dirX = spd
					zproj.ro = 0
					projPL = append(projPL, zproj)
				}
				if throwingknifenum >= 6 {
					zproj.dirY = spd
					zproj.dirX = -spd
					zproj.ro = 180
					projPL = append(projPL, zproj)
				}
				if throwingknifenum >= 7 {
					zproj.dirY = spd
					zproj.dirX = spd
					zproj.ro = 90
					projPL = append(projPL, zproj)
				}
				if throwingknifenum == 8 {
					zproj.dirY = -spd
					zproj.dirX = -spd
					zproj.ro = 270
					projPL = append(projPL, zproj)
				}
			}
		}
		if toxic {
			if frames%int(fps*3) == 0 {
				zfx := xfx{}
				zfx.img = splat[RandInt(0, len(splat))]
				zfx.nm = "toxic"
				zfx.rec = pl.rec
				zfx.rec.X -= b
				zfx.rec.Y -= b
				zfx.rec.Width += b2
				zfx.rec.Height += b2
				zfx.crec = zfx.rec
				zfx.crec.X += zfx.crec.Width / 8
				zfx.crec.Y += zfx.crec.Height / 8
				zfx.crec.Width -= zfx.crec.Width / 4
				zfx.crec.Height -= zfx.crec.Height / 4
				zfx.fade = 0.7
				zfx.below = true
				fx = append(fx, zfx)
			}
		}
		if frisbeeT > 0 {
			frisbeeT--
		}
		if purplerainT > 0 {
			purplerainT--
		}
		if teslaT > 0 {
			teslaT--
		}
		if quailT > 0 {
			quailT--
		}
		if beartrapT > 0 {
			beartrapT--
			if beartrapT == 1 {
				siz := b + bq
				ztile := xtile{}
				ztile.img = anm[86].rec
				ztile.rec = rl.NewRectangle(pl.cnt.X-siz/2, pl.cnt.Y-siz/2, siz, siz)
				ztile.crec = ztile.rec
				ztile.crec.Height = ztile.crec.Height / 2
				ztile.crec.Y += 12
				ztile.crec.X += 8
				ztile.crec.Width -= 16
				ztile.nm = "beartrap"
				ztile.cnt = makecnt(ztile.rec)
				canadd := true
				for i := 0; i < len(levels[levNum].etc); i++ {
					if levels[levNum].etc[i].nm == "beartrap" {
						if rl.CheckCollisionRecs(levels[levNum].etc[i].rec, ztile.rec) {
							canadd = false
						}
					}
				}
				if canadd {
					levels[levNum].etc = append(levels[levNum].etc, ztile)
				}
				beartrapT = (fps * 12) - (int32(beartrapnum*2) * fps)
			}
		}
		if reviveT > 0 {
			reviveT--
		}
		if steroidsT > 0 {
			steroidsT--
			if steroidsT == 1 {
				stats.str = stats.str2
			}
		}
		if powerT > 0 {
			powerT--
			if powerT == 1 {
				stats.dex = stats.dex2
				stats.int = stats.int2
				stats.luk = stats.luk2
				stats.per = stats.per2
				stats.str = stats.str2
			}
		}
		if inflictT > 0 {
			inflictT--
		}
		if teleportT > 0 {
			teleportT--
			if teleportT == 1 {
				if telBase {
					pause = true
					baseon = true
					telBase = false
					if pl.hp < pl.hpmax {
						pl.hp += 2
						if pl.hp > pl.hpmax {
							pl.hp = pl.hpmax
						}
						admsg("+2 hp @ camp", rl.Green)
					}
					rl.StopMusicStream(music[currentMusic])
					currentMusic = 2
					rl.PlayMusicStream(music[currentMusic])
					if vineRing {
						for i := 0; i < len(pl.art); i++ {
							if pl.art[i].nm == "ring of vine" {
								pl.art[i].off = false
							}
						}
					}
					if batty {
						batcomp.cnt = cnt
						batcomp.rec = rl.NewRectangle(batcomp.cnt.X-batcomp.rec.Width/2, batcomp.rec.Height/2, batcomp.rec.Width, batcomp.rec.Height)
						batcomp.moveChangeT = fps * 3
					}
					if rollo {
						rollocomp.cnt = cnt
						rollocomp.rec = rl.NewRectangle(rollocomp.cnt.X-rollocomp.rec.Width/2, rollocomp.cnt.Y-rollocomp.rec.Height/2, rollocomp.rec.Width, rollocomp.rec.Height)
					}
				}
				if telCntr {
					pl.cnt = cnt
					upplayerrec()
					telCntr = false
				}
			}
		}
		if intangibleT > 0 {
			intangibleT--
			if intangibleT == 1 {
				telCntr = true
				teleportT = fps / 2
			}
		}
		if icelollyT > 0 {
			icelollyT--
		}
		if bloodT > 0 {
			bloodT--
		}
		if gasT > 0 {
			gasT--
		}
		if icecreamT > 0 {
			icecreamT--
		}
		if sodaT > 0 {
			sodaT--
		}
		if msgT > 0 {
			msgT--
		}
		if turtleT > 0 {
			turtleT--
		}
		if pistolT > 0 {
			pistolT--
		}
		if slugT > 0 {
			slugT--
		}
		if watchT > 0 {
			watchT--
		}
		if toptxT > 0 {
			toptxT--
		}
	}
}
func cams() { //MARK:CAMS
	cam2.Target = pl.cnt
	camBase.Target = cnt
	camBoss.Target = cnt
	cam2.Offset.X = scrWF32 / 2
	cam2.Offset.Y = scrHF32 / 2
	camBase.Offset.X = scrWF32 / 2
	camBase.Offset.Y = scrHF32 / 2
	camBoss.Offset.X = scrWF32 / 2
	camBoss.Offset.Y = scrHF32 / 2

	if scopeon {
		if cam2.Zoom > scopeZmax {
			cam2.Zoom -= 0.1
		} else {
			scopeT--
			if scopeT == 0 {
				scopeon = false
			}
		}
	} else {
		if cam2.Zoom < cam2Zorig {
			cam2.Zoom += 0.1
			if cam2.Zoom > cam2Zorig {
				cam2.Zoom = cam2Zorig
			}
		}
	}
	W := scrWF32 / cam2.Zoom
	H := scrHF32 / cam2.Zoom
	screenBordRec = rl.NewRectangle(pl.cnt.X-W/2, pl.cnt.Y-H/2, W, H)
	drawRec = rl.NewRectangle(pl.cnt.X-W/2, pl.cnt.Y-H/2, W, H)
	drawRec.X -= b2
	drawRec.Y -= b2
	drawRec.Width += b4
	drawRec.Height += b4
}
func initialWindow() { //MARK:INITIAL WINDOW
	rl.SetExitKey(rl.KeyNull)
	renderTarget = rl.LoadRenderTexture(scrW32, scrH32)
	imgs = rl.LoadTexture("img/imgs.png")
	endimg = rl.LoadTexture("img/end.png")
	helpimg = rl.LoadTexture("img/help.png")
	controlsimg = rl.LoadTexture("img/controls.png")
	//rl.HideCursor()
	shaderon = true
	makeshaders()
	makeimgs()
	cams()

	rl.SetMousePosition(int(cnt.X+b2), int(cnt.Y))

	introAnim = anm[204].rec

	//treasureroom = true
	makeinitial()
	makesound()
	makeweaponsINTIIAL()
	makeitemsINITAL()
	makeenemiesINITIAL()
	makeplayer()
	makebase()
	makelevel()
	makePotionList()
	makeScrollList()
	ReadSaves()

	if rl.IsGamepadAvailable(0) {
		controllerINITIAL = true
	}

	//currentMusic = 2
	rl.SetMasterVolume(float32(volume) / 10)
	rl.SetMusicVolume(music[currentMusic], float32(volume)/10)
	rl.PlayMusicStream(music[currentMusic])

	musicon = true
	//rl.SetMasterVolume(0)

	exitmsg = exitTxt[RandInt(0, len(exitTxt))]

	scanlines = true
	pixels = true

	if med {
		scanlines = false
		pixels = false
	}

	//bosskey1 = true
	//bosskey2 = true
	pause = true
	//helpon = true
	//endgame = true
	//startScreen = true
	intro = true
	//options = true
	//exit = true
	//baseon = true
	//apothercaryon = true
	//weaponshedon = true
	//storeon = true
	//bookon = true
	//options = true
	//loadon = true
	//credits = true
	//charscr = true
	//stats.str = 6
	//pl.xp = 100
	//invincible = true

}
func unload() { //MARK:UNLOAD
	rl.UnloadShader(shader)
	rl.UnloadRenderTexture(renderTarget)
	rl.UnloadTexture(imgs)
	rl.UnloadTexture(controlsimg)
	rl.UnloadTexture(endimg)
	rl.UnloadTexture(bossATK)
	rl.UnloadTexture(bossIDL)
	rl.UnloadTexture(bossWALKL)
	rl.UnloadTexture(bossWALKR)
	for i := 0; i < len(raylibAnim); i++ {
		rl.UnloadTexture(raylibAnim[i])
	}
	for i := 0; i < len(audfx); i++ {
		rl.UnloadSound(audfx[i])
	}
	for i := 0; i < len(music); i++ {
		rl.UnloadMusicStream(music[i])
	}
}
func main() { //MARK:MAIN
	rl.SetConfigFlags(rl.FlagMsaa4xHint | rl.FlagVsyncHint)
	rl.SetTraceLogLevel(rl.LogError)
	rl.InitWindow(0, 0, "Mr Snuggles Dungeon Adventure")
	rl.InitAudioDevice()
	rl.SetWindowState(rl.FlagBorderlessWindowedMode)
	scrW, scrH = rl.GetScreenWidth(), rl.GetScreenHeight()
	scrW32, scrH32 = int32(scrW), int32(scrH)
	scrWF32, scrHF32 = float32(scrW), float32(scrH)
	cnt = rl.NewVector2(scrWF32/2, scrHF32/2)

	siz := b10 * 2
	optionsRec = rl.NewRectangle(cnt.X-siz/2, 0, siz, scrHF32*2)
	siz *= 2
	storeRec = rl.NewRectangle(cnt.X-siz/2, 0, siz, scrHF32)

	if scrH >= 2160 {
		cam2.Zoom = 4
		xxl = true
	} else if scrH >= 1440 && scrH < 2160 {
		cam2.Zoom = 3
		xl = true
	} else if scrH > 1050 && scrH < 1440 {
		cam2.Zoom = 2.5
		lrg = true
	} else if scrH >= 900 && scrH <= 1050 {
		cam2.Zoom = 2
		lrg = true
	} else if scrH >= 720 && scrH < 900 {
		cam2.Zoom = 1.75
		med = true
	} else if scrH < 720 {
		cam2.Zoom = 1
		med = true
	}

	//CAM STRUCTURES
	camStrucs.Zoom = 1
	camStrucs.Target = cnt
	camStrucs.Offset.X = scrWF32 / 2
	camStrucs.Offset.Y = scrHF32 / 2
	if xl {
		camStrucs.Zoom = 1.5
		camStrucs.Offset.Y = scrHF32 / 1.35
	} else if xxl {
		camStrucs.Zoom = 2.25
		camStrucs.Offset.Y = scrHF32 / 0.89
	} else if med {
		camStrucs.Zoom = 0.75
		camStrucs.Offset.Y = scrHF32 / 2.7
	}

	//CAM MAP
	camMap.Zoom = 0.1
	if xxl {
		camMap.Zoom = 0.2
	}
	if xl {
		camMap.Zoom = 0.15
	}

	//CAM INVEN
	camInven.Zoom = 1
	camInven.Target = cnt
	camInven.Offset.X = scrWF32 / 2
	camInven.Offset.Y = optionsRec.Height / 4.05
	if xl {
		camInven.Zoom = 1.5
		camInven.Offset.Y = scrHF32 / 1.35
	} else if xxl {
		camInven.Zoom = 2.25
		camInven.Offset.Y = scrHF32 / 0.89
	} else if med {
		camInven.Zoom = 0.8
		camInven.Offset.Y = optionsRec.Height / 5
	}

	//CAM BASE
	if scrHF32 > 720 {
		diff := scrHF32 - 720
		diff = diff / 720
		camBase.Zoom = 1 + diff
	} else if scrHF32 == 720 {
		camBase.Zoom = 1
	}

	camBase.Target = cnt
	camBase.Offset.X = scrWF32 / 2
	camBase.Offset.Y = scrHF32 / 2

	camBoss.Target = cnt
	camBoss.Zoom = 3
	camBoss.Offset.X = scrWF32 / 2
	camBoss.Offset.Y = scrHF32 / 2

	//CAM END GAME
	camEnd.Zoom = 1
	if xl {
		camEnd.Zoom = 1.5
	}
	if xxl {
		camEnd.Zoom = 2.5
	}
	if med {
		camEnd.Zoom = 0.75
	}
	camEnd.Target = cnt
	camEnd.Offset.X = scrWF32 / 2
	camEnd.Offset.Y = scrHF32 / 2

	initialWindow() //INITIAL INSIDE WINDOW
	rl.SetTargetFPS(fps)
	for !rl.WindowShouldClose() {
		delta = rl.GetFrameTime()
		frames++
		rl.BeginDrawing()
		rl.ClearBackground(rl.Black)
		if shaderon { //BLOOM SHADER
			rl.BeginTextureMode(renderTarget) // Enable drawing to texture
			rl.ClearBackground(rl.Black)

			rl.BeginMode2D(cam2)
			drawcam()
			rl.EndMode2D()
			drawnocam()
			rl.EndTextureMode()
			rl.BeginShaderMode(shader)
			rl.DrawTextureRec(renderTarget.Texture, rl.NewRectangle(0, 0, float32(renderTarget.Texture.Width), float32(-renderTarget.Texture.Height)), rl.NewVector2(0, 0), rl.White)
			rl.EndShaderMode()
		} else { //NO BLOOM SHADER
			rl.ClearBackground(rl.Black)

			rl.BeginMode2D(cam2)
			drawcam()
			rl.EndMode2D()
			drawnocam()
		}
		drawnoRender()
		up() //UPDATE
		rl.EndDrawing()
	}
	unload() //UNLOAD
	rl.CloseAudioDevice()
	rl.CloseWindow()
}
