package main

import (
	"fmt"
	"math"
	"os"
	"strconv"
	"strings"

	rl "github.com/gen2brain/raylib-go/raylib"
)

// 01.2024-002 - MR SNUGGLES DUNGEON ADVENTURE
// MARK: VAR
var (

	//HELP
	helpon, help1        bool
	helpimgrec           = rl.NewRectangle(0, 0, 720, 720)
	controlsimg, helpimg rl.Texture2D

	//END GAME
	endgame, end1, end2, endgameclose bool
	endfd, endfd2                     = float32(0), float32(0)
	endimg                            rl.Texture2D
	endRec                            rl.Rectangle
	endtextureRec                     = rl.NewRectangle(0, 0, 800, 800)

	//GAME OVER
	gameOverRec, gameoveranimRec   rl.Rectangle
	gameOver, gameOverReset        bool
	gameOverFade, gameoverRotation float32

	//SAVES LOAD DIFF
	loadtxT, loadedT                   int32
	loadon                             bool
	save1, save2, save3, delsave       bool
	savestore1, savestore2, savestore3 []Item
	selSave, currentSave, delsaveNum   int

	//SPECIAL BONUS WEAPON PROJ
	lightningEnm   []int
	lightningCount int32

	//SOUND
	musicNumPrev, currentMusic int
	audfx                      []rl.Sound
	music                      []rl.Music
	musicon                    bool
	volumemax                  = 10
	volume                     = 5
	prevol                     = volume
	dispMusic                  = 3
	prevMusic                  = dispMusic

	//INTRO START
	gamestartT            = fps
	savenum               int
	startScreen, endIntro bool
	introbgimgnum         int
	introbg               []BackgroundPicture
	intro                 bool
	raylibAnim            []rl.Texture2D
	raylibFrameNum        int
	raylibRec             = rl.NewRectangle(0, 0, 288, 288)
	unklnikLogoF          = float32(0)
	introT1               = fps * 2
	introT2               = fps * 2
	introT3               = fps * 2
	unklnikRec            rl.Rectangle
	goLogoRec             rl.Rectangle
	introfd               = float32(0)
	introfd2              = float32(0)
	introAnim             rl.Rectangle

	//BOSS
	bossSkillList                          []int
	bosskey1, bosskey2, bosskey3           bool
	hasBossKeyChanged                      bool
	boss                                   Enemy
	bossNum                                int
	isBossOn, isBossLevelOn                bool
	camBoss                                rl.Camera2D
	bossBordRectangle                      rl.Rectangle
	bossIDL, bossWALKL, bossWALKR, bossATK rl.Texture2D

	//ITEM
	rollocomp              = Enemy{}
	batcomp                = Enemy{}
	crateItmLen, unlockNum int
	invisItm               []Item

	scopeon, drillon, telBase, telCntr, medikiton, vineon, vineon2, vineRing, thornson, twin, tesla, purplerain, frisbee, mirror, toxic, feather, cloak, toaster, noodles, mappin, chestpin, umbrella, treasureRoom, icecrystal, mrfrisbee, spinna, pyroball, zombiehead, batty, landmine, rollo bool

	shrimpnum, basketballnum, broccolinum, garlicnum, tenderisernum, cleavernum, deathbottlenum, gascannum, beartrapnum, toiletpapernum, vineRingArtNum, teslacount, purpleraincount, frisbeecount, beltnum, beltAtk, throwingknifenum, magicianshatnum, pearlnum, lightbulbnum, mugnum, teanum, ninjanum, ovenglovenum, poisongasCount, medikitnum, sneakersnum, weaponcasenum, spacehelmetnum, zombienum int

	candycanenum            = int32(4)
	candycanemax            = int32(12)
	flamingonum, gasmasknum int32
	flamingomax, gasmaskmax = int32(5), int32(5)
	teamax, ninjamax        = 2, 2
	basketballmax           = 10
	garlicmax               = 12
	throwingknifemax        = 8
	medikitmax              = 1

	sneakersmax, weaponcasemax, spacehelmetmax = 4, 4, 4

	deathbottlemax, beartrapmax, beltmax, magicianshatmax, pearlmax, lightbulbmax, ovenglovemax = 5, 5, 5, 5, 5, 5, 5

	broccolimax, cleavermax, gascanmax, toiletpapermax, mugmax, tenderisermax = 6, 6, 6, 6, 6, 6

	watchT, scopeT, slugT, pistolT, turtleT, sodaT, icecreamT, gasT, bloodT, icelollyT, intangibleT, teleportT, inflictT, powerT, steroidsT, reviveT, beartrapT, quailT, teslaT, purplerainT, frisbeeT, beetrootT, cloakT, flamingoT, orangeT, tvT, lollipopT, honeycombT, eggsT, gasmaskT, psychedelicsT, bootsT, fartT, teleportPauseT, exitPauseT, saltT, icecrystalT, mrfrisbeeT, spinnaT, spinnaT2, pyroballT, landmineT int32

	scopeZ               = float32(2)
	scopeZmax, cam2Zorig float32
	itemList             []Item

	//CAMP
	exitCollision             bool
	weaponStandOn             = true
	weaponStandRotation       float32
	campfximgrecs2            []rl.Rectangle
	campEffectRectangles2     []rl.Rectangle
	campEffectImageRectangles []rl.Rectangle
	campEffectRectangles      []rl.Rectangle

	exiting bool

	notenoughscrapT, weapchangedT    int32
	apothTxt, weaponUpgradeText      string
	selnumWeap                       int
	mushCol                          rl.Color
	storeItm, potionList, scrollList []Item
	bgpix                            []BackgroundPicture
	base                             = Base{}
	baseBG                           []BackgroundInformation
	scrapNum, nxStoreNum             int
	baseBordRec, storeRec            rl.Rectangle

	storetxT, storetxT2, storetxT3, saveT int32

	mushroomTimer, mushroomTimerMax, mushroomPause int

	isBaseOn, isBookOn, isStoreOn, isWeaponShedOn, isApothercaryOn, isStoreUnlocked bool

	//ENEMIES
	xpadded       bool
	enmlist       []Enemy
	blackdotCount int
	//INVEN QUICK WEAPON SLOTS
	disTxt1, disTxt2                             string
	inquick, inweapslots, weapInfon              bool
	nxInvnNum, nxQuikNum, inMenuItm              int
	inventoryMax                                 = 27
	inMenuOn, inMenuOn2, invenInfo, inWeapMenuOn bool
	inMenuRec                                    rl.Rectangle
	invDisTxtT, invInfoT, inMenuExitT, cantmoveT int32
	//CHESTS CRATES
	inchest, inchestslot bool
	crateitm             []Item
	//CHAR SCR OPTIONS SIDEBAR
	sideY            float32
	charscr, options bool
	optionsRec       rl.Rectangle
	//WEAPONS PROJECTILES
	weapons, playerProjectiles, enemyProjectiles []Weapon
	maxWeapDmg                                   int
	//OPTIONS
	disconnectT              int32
	deadZ                    = float32(0.30)
	stickMov                 = float32(0.55)
	stickMovdis, deadZDis    int
	scan                     []rl.Vector2
	res169, res1610, reslist []string

	currentres, windowType, prevres, prevWindowType int

	scanlines, pixels, asp169, asp1610, credits, exit bool

	creditList = []string{"grafxkid", "kenney", "clementpanchout", "greatdocbrown", "ilkaytobello", "crumpaloo", "engvee", "segel2d", "pixelboyz", "stealthix", "piiixl", "free-game-assets", "flippurgatory", "ateliermagicae", "dusk-games", "ragnapixel", "bdragon1727", "0x72", "that-gray-guy", "analogstudios", "the-outlander", "luquigames", "ninjikin", "thkaspar", "im-dagon", "ladyluck", "eternalpixel", "ateliermagicae", "ghostpixxells", "jpcu", "admurin", "verzatiledev", "ssugmi", "pixelfrog-assets", "ahninniah", "wildlifestudios", "karsiori", "flixberry-entertainment", "osmic", "nushio", "mumu", "alexander123", "hapiel", "imogiagames", "ludicarts", "saint11", "anarres", "pch-vector", "freepik", "publicdomainvectors", "pixabay"}

	//MSG
	msgT    int32
	msg     []Message
	exitmsg string

	exitText = []string{"leaving so soon", "ready to go", "we'll miss you", "too much dungeoneering", "goodbye kind sir", "try and get some fresh air", "exit or not to exit that is the question", "i'll be waiting", "tell your friends", "buy 1k fb likes for $1", "advertise here contact me", "we only just met", "slogans r us", "that's all folks"}

	welcome = []string{"welcome back", "so we meet again", "ciao", "more dungeon fun", "clever phrase here", "these are dumb", "i am not an ai", "quote of the day", "back again i see", "enter at your periwinkle", "not a 1 bit game", "asdf", "qwerty", "better than cga", "yet another rogue game awaits", "better than ascii"}

	//FX
	effect      []Effect
	fireson     bool
	scanlineSpc float32
	//PLAYER
	player, player2, player3 = Player{}, Player{}, Player{}
	playerRoom               int
	stats                    = Stats{}
	atkV2, atkCNT            rl.Vector2
	prevplayHP               int
	invincible               bool
	//GAME
	controllerINITIAL                 bool
	mouseoffpos, gameCursor           rl.Vector2
	mouseoff                          bool
	onoff15                           bool
	teleporting                       bool
	levMins, levSecs                  int32
	levT                              int32
	levels                            []x1scr
	levNum, exitRoomNum, chestRoomNum int
	levNumDis                         = 0
	Wbloks, Hbloks                    = 58, 31
	inRec, drawRec, screenBordRec     rl.Rectangle
	curRo                             float32
	toptx                             string
	toptxT                            int32
	//IMGS
	animation                                                 []Animation
	bgilist, bgilist2                                         []BackgroundInformation
	floortile, walltile, floorBoss, wallBoss                  rl.Rectangle
	floorTiles, wallTiles, otherTiles, splat, flowers, rocksI []rl.Rectangle
	//BLANKS
	blankint = 777777777
	blankRec rl.Rectangle
	//CORE
	inpL, inpR, xxl, xl, large, medium bool
	fadeblink, fadeblink2              bool
	fadeblinkF                         = float32(0.7)
	fadeblinkF2                        = float32(1)
	delta                              float32
	imgs                               rl.Texture2D
	shader                             rl.Shader
	renderTarget                       rl.RenderTexture2D
	frames, scrW, scrH                 int
	screenWidth32, screenHeight32      int32
	screenWidthF32, screenHeightF32    float32
	fps                                = int32(60)
	ori                                = rl.NewVector2(0, 0)
	debug, pause, shaderon             bool
	clickT                             int32

	cam2, camMap, camInventory, camBase, camStructures, camEnd rl.Camera2D

	cursorV2camInven, cursorV2, cursorV2cam, cursorV2Base, currentPosition, cursorV2Strucs rl.Vector2
	//UNITS TXT
	tx = int32(10)
	b  = float32(32)

	tx2, tx3, tx4, tx5, tx6, tx7, tx8, tx9, tx10 = tx * 2, tx * 3, tx * 4, tx * 5, tx * 6, tx * 7, tx * 8, tx * 9, tx * 10

	b2, b3, b4, b5, b6, b7, b8, b9, b10 = b * 2, b * 3, b * 4, b * 5, b * 6, b * 7, b * 8, b * 9, b * 10

	bq  = b / 4
	bq3 = bq * 3
	be  = b / 8
	be3 = be * 3
	be5 = be * 5
	be7 = be * 7
)

// MARK: DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW DRAW
func drawhelp() { //MARK: DRAW HELP
	W := screenHeightF32 - b4
	rec := rl.NewRectangle(currentPosition.X-W/2, currentPosition.Y-W/2, W, W)

	if help1 {
		rl.DrawRectangle(0, 0, screenWidth32, screenHeight32, rl.Yellow)
		rl.DrawTexturePro(helpimg, helpimgrec, rec, rl.Vector2Zero(), 0, rl.White)
		if inpL || inpR {
			help1 = false
			helpon = false
		}
	} else {
		rl.DrawRectangle(0, 0, screenWidth32, screenHeight32, rl.Magenta)
		rl.DrawTexturePro(controlsimg, helpimgrec, rec, rl.Vector2Zero(), 0, rl.White)
		if inpL || inpR {
			help1 = true
		}
	}
}
func drawendgame() { //MARK: DRAW END GAME

	if end1 {
		if endfd > 0 {
			endfd -= 0.004
		} else {
			end2 = true
		}
	} else {
		if endfd < 1 {
			endfd += 0.01
		} else {
			end1 = true
		}
	}

	if end2 {
		rl.BeginMode2D(camEnd)
		rl.DrawTexturePro(endimg, endtextureRec, endRec, rl.Vector2Zero(), 0, rl.Fade(rl.White, endfd2))
		txs := tx3
		txt := "the last known picture of mr snuggles, taken from a passing hang glider."
		txlen := rl.MeasureText(txt, txs)
		y := endRec.ToInt32().Y + endRec.ToInt32().Height + int32(b/2)
		x := int32(currentPosition.X) - txlen/2
		rl.DrawText(txt, x-2, y+2, txs, rl.Fade(rl.Magenta, endfd2))
		rl.DrawText(txt, x-1, y+1, txs, rl.Fade(rl.Black, endfd2))
		rl.DrawText(txt, x, y, txs, rl.Fade(rl.White, endfd2))
		y += txs + txs/4
		txt = "he had escaped the dungeon only to find himself on a desert island and"
		txlen = rl.MeasureText(txt, txs)
		x = int32(currentPosition.X) - txlen/2
		rl.DrawText(txt, x-2, y+2, txs, rl.Fade(rl.Magenta, endfd2))
		rl.DrawText(txt, x-1, y+1, txs, rl.Fade(rl.Black, endfd2))
		rl.DrawText(txt, x, y, txs, rl.Fade(rl.White, endfd2))
		y += txs + txs/4
		txt = "is preparing to dive in and swim home - good luck mr snuggles!"
		txlen = rl.MeasureText(txt, txs)
		x = int32(currentPosition.X) - txlen/2
		rl.DrawText(txt, x-2, y+2, txs, rl.Fade(rl.Magenta, endfd2))
		rl.DrawText(txt, x-1, y+1, txs, rl.Fade(rl.Black, endfd2))
		rl.DrawText(txt, x, y, txs, rl.Fade(rl.White, endfd2))
		if endfd2 < 0.7 {
			endfd2 += 0.01
		} else {
			if inpL || inpR {
				clickT = fps
				pause = true
				endgame = false
				endgameclose = true
				options = true
				credits = true
			}
		}
		rl.EndMode2D()
	} else {
		multi := float32(2)
		if medium {
			multi = 1.4
		}
		W := otherTiles[212].Width * multi
		H := otherTiles[212].Height * multi
		rec2 := rl.NewRectangle(currentPosition.X-W/2, currentPosition.Y-H/2, W, H)
		rl.DrawTexturePro(imgs, otherTiles[212], rec2, rl.Vector2Zero(), 0, rl.Fade(rl.Magenta, endfd))
	}

}
func drawload() { //MARK: DRAW LOAD
	rl.DrawRectangleRec(optionsRec, rl.Fade(rl.Yellow, 0.9))
	txs := tx7
	txlen := rl.MeasureText("load save", txs)
	y := tx7
	x := int32(currentPosition.X) - txlen/2
	rl.DrawText("load save", x-5, y+5, txs, DarkRed())
	rl.DrawText("load save", x-2, y+2, txs, rl.White)
	rl.DrawText("load save", x, y, txs, rl.Black)

	W := b8
	H := b2
	txt := "empty"
	if save1 {
		txt = "one"
	}
	rec2 := rl.NewRectangle(currentPosition.X-W/2, b5, W, H)
	txs = tx4
	txlen = rl.MeasureText(txt, txs)
	x = int32(currentPosition.X) - txlen/2
	y = rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
	if savenum == 0 {
		rl.DrawRectangleRec(rec2, rl.Black)
		rl.DrawRectangleRec(rec2, rl.Fade(rl.Magenta, fadeblinkF))
		rl.DrawText(txt, x-4, y+4, txs, BrightPink())
		rl.DrawText(txt, x-2, y+2, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, rl.White)
	} else {
		rl.DrawRectangleRec(rec2, rl.Blue)
		rl.DrawText(txt, x-1, y+1, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, rl.Black)
	}
	rl.DrawRectangleLinesEx(rec2, 4, rl.Black) //0

	if rl.CheckCollisionPointRec(cursorV2camInven, rec2) {
		savenum = 0
		if inpL {
			if save1 {
				selSave = 1
			} else {
				loadtxT = fps * 2
			}
		}
	}

	txt = "empty"
	if save2 {
		txt = "two"
	}
	txlen = rl.MeasureText(txt, txs)
	rec2.Y += H + b/2
	x = int32(currentPosition.X) - txlen/2
	y = rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2

	if savenum == 1 {
		rl.DrawRectangleRec(rec2, rl.Black)
		rl.DrawRectangleRec(rec2, rl.Fade(rl.Magenta, fadeblinkF))
		rl.DrawText(txt, x-4, y+4, txs, BrightPink())
		rl.DrawText(txt, x-2, y+2, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, rl.White)
	} else {
		rl.DrawRectangleRec(rec2, rl.Blue)
		rl.DrawText(txt, x-1, y+1, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, rl.Black)
	}
	rl.DrawRectangleLinesEx(rec2, 4, rl.Black) //1

	if rl.CheckCollisionPointRec(cursorV2camInven, rec2) {
		savenum = 1
		if inpL {
			if save2 {
				selSave = 2
			} else {
				loadtxT = fps * 2
			}
		}
	}

	rec2.Y += H + b/2
	txt = "empty"
	if save3 {
		txt = "three"
	}
	txlen = rl.MeasureText(txt, txs)
	x = int32(currentPosition.X) - txlen/2
	y = rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
	if savenum == 2 {
		rl.DrawRectangleRec(rec2, rl.Black)
		rl.DrawRectangleRec(rec2, rl.Fade(rl.Magenta, fadeblinkF))
		rl.DrawText(txt, x-4, y+4, txs, BrightPink())
		rl.DrawText(txt, x-2, y+2, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, rl.White)
	} else {
		rl.DrawRectangleRec(rec2, rl.Blue)
		rl.DrawText(txt, x-1, y+1, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, rl.Black)
	}
	rl.DrawRectangleLinesEx(rec2, 4, rl.Black) //2

	if rl.CheckCollisionPointRec(cursorV2camInven, rec2) {
		savenum = 2
		if inpL {
			if save3 {
				selSave = 3
			} else {
				loadtxT = fps * 2
			}
		}
	}

	txt = "slot is empty"
	txlen = rl.MeasureText(txt, txs)
	y += int32(b2)
	x = int32(currentPosition.X) - txlen/2

	if loadtxT > 0 {
		loadtxT--
		rl.DrawText("slot is empty", x-1, y+1, txs, rl.Black)
		rl.DrawText("slot is empty", x, y, txs, rl.Black)
	}

	if selSave != 0 {
		currentSave = selSave
		Reset()
		for i := 0; i < len(storeItm); i++ {
			storeItm[i] = Item{}
		}
		switch selSave {
		case 1:
			if save1 {
				copy(storeItm, savestore1)
			}
			isStoreUnlocked = true
			for i := 0; i < len(base.name); i++ {
				if base.name[i] == "store room" {
					base.isUnlocked[i] = true
				}
			}
		case 2:
			if save2 {
				copy(storeItm, savestore2)
			}
			isStoreUnlocked = true
			for i := 0; i < len(base.name); i++ {
				if base.name[i] == "store room" {
					base.isUnlocked[i] = true
				}
			}
		case 3:
			if save3 {
				copy(storeItm, savestore3)
			}
			isStoreUnlocked = true
			for i := 0; i < len(base.name); i++ {
				if base.name[i] == "store room" {
					base.isUnlocked[i] = true
				}
			}
		}

		options = false
		isBaseOn = true
		savenum = 0
		selSave = 0
		loadedT = fps * 2
		loadon = false
	}

	//CLOSE REC
	siz2 := b2
	closerec := rl.NewRectangle(optionsRec.X+optionsRec.Width-siz2, optionsRec.Y+bq, siz2, siz2)
	closerec.X += 16
	closerec.Y += 16
	closerec.Width -= 32
	closerec.Height -= 32
	v1 := rl.NewVector2(closerec.X, closerec.Y)
	v1.X += 8
	v1.Y += 8
	v2 := v1
	v2.X += closerec.Width - 16
	v3 := v2
	v3.Y += closerec.Width - 16
	v4 := v3
	v4.X -= closerec.Width - 16
	if rl.CheckCollisionPointRec(cursorV2camInven, closerec) {
		rl.DrawRectangleRec(closerec, DarkRed())
		rl.DrawLineEx(v1, v3, 4, rl.Black)
		rl.DrawLineEx(v2, v4, 4, rl.Black)
		if inpL {
			rl.PlaySound(audfx[41])
			loadon = false
		}
	} else {
		rl.DrawRectangleRec(closerec, rl.Black)
		rl.DrawLineEx(v1, v3, 4, rl.Orange)
		rl.DrawLineEx(v2, v4, 4, rl.Orange)
	}
	if rl.IsGamepadButtonPressed(0, 6) {
		rl.PlaySound(audfx[41])
		loadon = false
	}

}
func drawOptions() { //MARK:DRAW OPTIONS
	//cnt = rl.NewVector2(scrWF32/2,scrHF32/2)
	if !exit {
		for i := 0; i < len(bgpix); i++ {
			rec := rl.NewRectangle(bgpix[i].vector2.X, bgpix[i].vector2.Y, bgpix[i].siz, bgpix[i].siz)
			rl.DrawRectangleRec(rec, rl.Fade(bgpix[i].color, bgpix[i].fd))
			bgpix[i].vector2.X += bgpix[i].dirX
			bgpix[i].vector2.Y += bgpix[i].dirY

			if bgpix[i].vector2.X < 0 {
				bgpix[i].vector2.X = screenWidthF32
			}
			if bgpix[i].vector2.X > screenWidthF32 {
				bgpix[i].vector2.X = 0
			}
			if bgpix[i].vector2.Y < 0 {
				bgpix[i].vector2.Y = screenHeightF32
			}
			if bgpix[i].vector2.Y > screenHeightF32 {
				bgpix[i].vector2.Y = 0
			}

			if bgpix[i].fd > 0 {
				bgpix[i].fd -= 0.005
			} else {
				bgpix[i].fd = RandF32(0.5, 1)
			}
		}
	}

	rl.BeginMode2D(camInventory) //CHANGE ZOOM FOR SCREEN RES
	if credits {
		drawcredits()
	} else if exit {
		drawexit()
	} else if loadon {
		drawload()
	} else {
		rl.DrawRectangleRec(optionsRec, rl.Fade(rl.Yellow, 0.9))
		cursorV2camInven = rl.GetScreenToWorld2D(cursorV2, camInventory)
		//CLOSE REC
		siz2 := b2
		closerec := rl.NewRectangle(optionsRec.X+optionsRec.Width-siz2, optionsRec.Y+bq, siz2, siz2)
		closerec.X += 16
		closerec.Y += 16
		closerec.Width -= 32
		closerec.Height -= 32
		v1 := rl.NewVector2(closerec.X, closerec.Y)
		v1.X += 8
		v1.Y += 8
		v2 := v1
		v2.X += closerec.Width - 16
		v3 := v2
		v3.Y += closerec.Width - 16
		v4 := v3
		v4.X -= closerec.Width - 16
		if rl.CheckCollisionPointRec(cursorV2camInven, closerec) {
			rl.DrawRectangleRec(closerec, DarkRed())
			rl.DrawLineEx(v1, v3, 4, rl.Black)
			rl.DrawLineEx(v2, v4, 4, rl.Black)
			if inpL {
				rl.PlaySound(audfx[41])
				if !isBaseOn {
					pause = false
				}
				options = false
			}
		} else {
			rl.DrawRectangleRec(closerec, rl.Black)
			rl.DrawLineEx(v1, v3, 4, rl.Orange)
			rl.DrawLineEx(v2, v4, 4, rl.Orange)
		}

		if rl.IsGamepadButtonPressed(0, 6) {
			rl.PlaySound(audfx[41])
			if !isBaseOn {
				pause = false
			}
			options = false
		}
		txlen := rl.MeasureText("options", tx10)
		x := int32(currentPosition.X) - txlen/2
		y := tx4
		rl.DrawText("options", x-5, y+5, tx10, DarkRed())
		rl.DrawText("options", x-1, y+1, tx10, rl.White)
		rl.DrawText("options", x, y, tx10, rl.Black)
		y += tx10
		y += tx2
		x = optionsRec.ToInt32().X + 32
		txs := tx4

		swchX := (optionsRec.X + optionsRec.Width/2) - b2
		swchY := float32(y + 3)

		backrec := rl.NewRectangle(optionsRec.X+4, swchY-2, optionsRec.Width/2-12, b+bq)
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if inpL {
				rl.PlaySound(audfx[44])
				scanlines = !scanlines
			}
		}
		rl.DrawText("scan lines", x-3, y+3, txs, DarkRed())
		rl.DrawText("scan lines", x-1, y+1, txs, rl.Black)
		rl.DrawText("scan lines", x, y, txs, rl.Black)
		opswch(swchX, swchY, scanlines)

		x = optionsRec.ToInt32().X + optionsRec.ToInt32().Width/2 + 12
		swchX = (optionsRec.X + optionsRec.Width) - b2
		backrec.X = optionsRec.X + optionsRec.Width/2 - 2
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if inpL {
				rl.PlaySound(audfx[44])
				pixels = !pixels
			}
		}
		rl.DrawText("pixl noise", x-3, y+3, txs, DarkRed())
		rl.DrawText("pixl noise", x-1, y+1, txs, rl.Black)
		rl.DrawText("pixl noise", x, y, txs, rl.Black)
		opswch(swchX, swchY, pixels)

		y += txs + txs/4
		x = optionsRec.ToInt32().X + 32

		swchY = float32(y)
		swchX = (optionsRec.X + optionsRec.Width/2) - b2
		backrec = rl.NewRectangle(optionsRec.X+4, swchY-2, optionsRec.Width/2-12, b+bq)
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if inpL {
				rl.PlaySound(audfx[44])
				musicon = !musicon
			}
		}
		rl.DrawText("music on", x-3, y+3, txs, DarkRed())
		rl.DrawText("music on", x-1, y+1, txs, rl.Black)
		rl.DrawText("music on", x, y, txs, rl.Black)
		opswch(swchX, swchY, musicon)

		x = optionsRec.ToInt32().X + optionsRec.ToInt32().Width/2 + 12
		swchX = (optionsRec.X + optionsRec.Width) - b2
		backrec.X = optionsRec.X + optionsRec.Width/2 - 2
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if rl.IsKeyPressed(rl.KeyA) || rl.IsKeyPressed(rl.KeyLeft) || rl.GetGamepadAxisMovement(0, 0) < 0 || rl.IsGamepadButtonPressed(0, 4) {
				if volume > 0 {
					volume--
				}
			}
			if rl.IsKeyPressed(rl.KeyD) || rl.IsKeyPressed(rl.KeyRight) || rl.GetGamepadAxisMovement(0, 0) > 0 || rl.IsGamepadButtonPressed(0, 2) {
				if volume < volumemax {
					volume++
				}
			}
		}
		rl.DrawText("volume", x-3, y+3, txs, DarkRed())
		rl.DrawText("volume", x-1, y+1, txs, rl.Black)
		rl.DrawText("volume", x, y, txs, rl.Black)
		volume = opadj(volume, volumemax, swchX, swchY, false, 0)
		if prevol != volume {
			rl.PlaySound(audfx[44])
			rl.SetMasterVolume(float32(volume) / 10)
			rl.SetMusicVolume(music[currentMusic], float32(volume)/10)
			prevol = volume
		}

		y += txs + txs/4
		x = optionsRec.ToInt32().X + 32

		swchY = float32(y)
		backrec = rl.NewRectangle(optionsRec.X+4, swchY-2, optionsRec.Width/2+b3, b+bq)
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if rl.IsKeyPressed(rl.KeyA) || rl.IsKeyPressed(rl.KeyLeft) || rl.GetGamepadAxisMovement(0, 0) < 0 || rl.IsGamepadButtonPressed(0, 4) {
				if dispMusic > 0 {
					dispMusic--
				}
			}
			if rl.IsKeyPressed(rl.KeyD) || rl.IsKeyPressed(rl.KeyRight) || rl.GetGamepadAxisMovement(0, 0) > 0 || rl.IsGamepadButtonPressed(0, 2) {
				if dispMusic < 3 {
					dispMusic++
				}
			}
		}
		rl.DrawText("music track", x-3, y+3, txs, DarkRed())
		rl.DrawText("music track", x-1, y+1, txs, rl.Black)
		rl.DrawText("music track", x, y, txs, rl.Black)
		txlen = rl.MeasureText("music track", txs)
		swchX = float32(x+txlen) + b3
		x = int32(swchX + b2 + b/2)
		dispMusic = opadj(dispMusic, 3, swchX, swchY, false, 0)
		if prevMusic != dispMusic {
			rl.PlaySound(audfx[44])
			switch dispMusic {
			case 0:
				rl.StopMusicStream(music[currentMusic])
				currentMusic = RandInt(4, len(music))
				rl.PlayMusicStream(music[currentMusic])
			case 1:
				rl.StopMusicStream(music[currentMusic])
				currentMusic = 4
				rl.PlayMusicStream(music[currentMusic])
			case 2:
				rl.StopMusicStream(music[currentMusic])
				currentMusic = 5
				rl.PlayMusicStream(music[currentMusic])
			case 3:
				rl.StopMusicStream(music[currentMusic])
				currentMusic = 6
				rl.PlayMusicStream(music[currentMusic])
			}
			prevMusic = dispMusic
		}
		if dispMusic == 0 {
			rl.DrawText("random", x-3, y+3, txs, DarkRed())
			rl.DrawText("random", x-1, y+1, txs, rl.Black)
			rl.DrawText("random", x, y, txs, rl.Black)
		} else if dispMusic == 1 {
			rl.DrawText("skool", x-3, y+3, txs, DarkRed())
			rl.DrawText("skool", x-1, y+1, txs, rl.Black)
			rl.DrawText("skool", x, y, txs, rl.Black)
		} else if dispMusic == 2 {
			rl.DrawText("raver", x-3, y+3, txs, DarkRed())
			rl.DrawText("raver", x-1, y+1, txs, rl.Black)
			rl.DrawText("raver", x, y, txs, rl.Black)
		} else if dispMusic == 3 {
			rl.DrawText("funky", x-3, y+3, txs, DarkRed())
			rl.DrawText("funky", x-1, y+1, txs, rl.Black)
			rl.DrawText("funky", x, y, txs, rl.Black)
		}

		y += txs + txs/4
		x = optionsRec.ToInt32().X + 32

		swchY = float32(y)
		swchX = (optionsRec.X + optionsRec.Width/2) - b2

		backrec = rl.NewRectangle(optionsRec.X+4, swchY-2, optionsRec.Width-8, b+bq)
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if rl.IsKeyPressed(rl.KeyA) || rl.IsKeyPressed(rl.KeyLeft) || rl.GetGamepadAxisMovement(0, 0) < 0 || rl.IsGamepadButtonPressed(0, 4) {
				if currentres > 0 {
					currentres--
				}
			}
			if rl.IsKeyPressed(rl.KeyD) || rl.IsKeyPressed(rl.KeyRight) || rl.GetGamepadAxisMovement(0, 0) > 0 || rl.IsGamepadButtonPressed(0, 2) {
				if currentres < len(reslist)-1 {
					currentres++
				}
			}
		}

		rl.DrawText("resolution >>", x-3, y+3, txs, DarkRed())
		rl.DrawText("resolution >>", x-1, y+1, txs, rl.Black)
		rl.DrawText("resolution >>", x, y, txs, rl.Black)
		x = int32(swchX)
		x += txs
		rl.DrawText(reslist[currentres], x-3, y+3, txs, DarkRed())
		rl.DrawText(reslist[currentres], x-1, y+1, txs, rl.Black)
		rl.DrawText(reslist[currentres], x, y, txs, rl.Black)
		swchX = (optionsRec.X + optionsRec.Width) - b2
		currentres = oplr(currentres, len(reslist)-1, swchX, swchY)
		//CHANGE RESOLUTION
		if prevres != currentres {
			rl.PlaySound(audfx[44])
			makeintroexitbg()
			if !rl.IsWindowFullscreen() {
				windowType = 1
			}
			if asp1610 {
				if reslist[currentres] == res1610[0] {
					scrW, scrH = 1280, 800
				} else if reslist[currentres] == res1610[1] {
					scrW, scrH = 1440, 900
				} else if reslist[currentres] == res1610[2] {
					scrW, scrH = 1680, 1050
				} else if reslist[currentres] == res1610[3] {
					scrW, scrH = 1920, 1200
				} else if reslist[currentres] == res1610[4] {
					scrW, scrH = 2560, 1600
				} else if reslist[currentres] == res1610[5] {
					scrW, scrH = 3840, 2400
				}
				screenWidth32, screenHeight32 = int32(scrW), int32(scrH)
				screenWidthF32, screenHeightF32 = float32(scrW), float32(scrH)

				rl.UnloadShader(shader)
				if medium {
					shader = rl.LoadShader("", "shaders/bloom_sml.fs")
				} else {
					shader = rl.LoadShader("", "shaders/bloom.fs")
				}
				renderTarget = rl.LoadRenderTexture(screenWidth32, screenHeight32)

				rl.SetWindowSize(scrW, scrH)
				rl.SetWindowPosition(int(currentPosition.X)-scrW/2, int(currentPosition.Y)-scrH/2)
				xxl = false
				xl = false
				medium = false
				if scrH >= 2160 {
					cam2.Zoom = 4
					xxl = true
				} else if scrH >= 1440 && scrH < 2160 {
					cam2.Zoom = 3
					xl = true
				} else if scrH > 1050 && scrH <= 1200 {
					cam2.Zoom = 2.5
					large = true
				} else if scrH >= 990 && scrH <= 1050 {
					cam2.Zoom = 2
					large = true
				} else if scrH >= 900 && scrH < 990 {
					cam2.Zoom = 2
					large = true
				} else if scrH >= 720 && scrH < 900 {
					cam2.Zoom = 1.75
					medium = true
				} else if scrH >= 600 && scrH < 720 {
					cam2.Zoom = 0.8

				} else if scrH < 600 && scrH > 300 {
					cam2.Zoom = 0.5
				} else if scrH < 300 {
					cam2.Zoom = 0.2
				}

				if medium {
					scanlines = false
					pixels = false
				}
				//CAM STRUCTURES
				cntr := rl.NewVector2(screenWidthF32/2, screenHeightF32)
				camStructures.Zoom = 1
				camStructures.Target.Y = cntr.Y
				camStructures.Offset.X = screenWidthF32 / 2
				camStructures.Offset.Y = screenHeightF32 / 2
				if xl {
					camStructures.Zoom = 1.5
					camStructures.Offset.Y = screenHeightF32 / 0.67
				} else if xxl {
					camStructures.Zoom = 2.25
					camStructures.Offset.Y = screenHeightF32 / 0.89
				} else if medium {
					camStructures.Zoom = 0.75
					camStructures.Offset.Y = screenHeightF32 / 1.34
				} else if large {
					camStructures.Zoom = 1
					camStructures.Offset.Y = screenHeightF32
				}
				//CAM MAP
				camMap.Zoom = 0.1
				if xxl {
					camMap.Zoom = 0.2
				}
				if xl {
					camMap.Zoom = 0.15
				}
				//CAM INVEN
				camInventory.Zoom = 1
				camInventory.Target = currentPosition
				camInventory.Offset.X = screenWidthF32 / 2
				camInventory.Offset.Y = optionsRec.Height / 4.05
				if xl {
					camInventory.Zoom = 1.5
					camInventory.Offset.Y = screenHeightF32 / 1.35
				} else if xxl {
					camInventory.Zoom = 2.25
					camInventory.Offset.Y = screenHeightF32 / 0.89
				} else if medium {
					camInventory.Zoom = 0.8
					camInventory.Offset.Y = optionsRec.Height / 5
				}
				//CAM BASE
				if screenHeightF32 > 720 {
					diff := screenHeightF32 - 720
					diff = diff / 720
					camBase.Zoom = 1 + diff
				} else if screenHeightF32 == 720 {
					camBase.Zoom = 1
				}
				camBase.Target = currentPosition
				camBase.Offset.X = screenWidthF32 / 2
				camBase.Offset.Y = screenHeightF32 / 2
				camBoss.Target = currentPosition
				camBoss.Zoom = 3
				camBoss.Offset.X = screenWidthF32 / 2
				camBoss.Offset.Y = screenHeightF32 / 2

				//CAM END GAME
				camEnd.Zoom = 1
				if xl {
					camEnd.Zoom = 1.5
				}
				if xxl {
					camEnd.Zoom = 2.5
				}
				if medium {
					camEnd.Zoom = 0.75
				}
				camEnd.Target = currentPosition
				camEnd.Offset.X = screenWidthF32 / 2
				camEnd.Offset.Y = screenHeightF32 / 2

			} else if asp169 {
				if reslist[currentres] == res169[0] {
					scrW, scrH = 1280, 720
				} else if reslist[currentres] == res169[1] {
					scrW, scrH = 1366, 768
				} else if reslist[currentres] == res169[2] {
					scrW, scrH = 1600, 900
				} else if reslist[currentres] == res169[3] {
					scrW, scrH = 1760, 990
				} else if reslist[currentres] == res169[4] {
					scrW, scrH = 1920, 1080
				} else if reslist[currentres] == res169[5] {
					scrW, scrH = 2560, 1440
				} else if reslist[currentres] == res169[5] {
					scrW, scrH = 3840, 3840
				}
				screenWidth32, screenHeight32 = int32(scrW), int32(scrH)
				screenWidthF32, screenHeightF32 = float32(scrW), float32(scrH)

				rl.SetWindowSize(scrW, scrH)
				rl.SetWindowPosition(int(currentPosition.X)-scrW/2, int(currentPosition.Y)-scrH/2)
				xxl = false
				xl = false
				medium = false
				if scrH >= 2160 {
					cam2.Zoom = 4
					xxl = true
				} else if scrH >= 1440 && scrH < 2160 {
					cam2.Zoom = 3
					xl = true
				} else if scrH == 1200 {
					cam2.Zoom = 1.65
					large = true
				} else if scrH > 1050 && scrH < 1200 {
					cam2.Zoom = 2.5
					large = true
				} else if scrH >= 990 && scrH <= 1050 {
					cam2.Zoom = 2
					large = true
				} else if scrH >= 900 && scrH < 990 {
					cam2.Zoom = 2
					large = true
				} else if scrH >= 720 && scrH < 900 {
					cam2.Zoom = 1.75
					medium = true
				} else if scrH >= 600 && scrH < 720 {
					cam2.Zoom = 0.8
				} else if scrH < 600 && scrH > 300 {
					cam2.Zoom = 0.5
				} else if scrH < 300 {
					cam2.Zoom = 0.2
				}
				if medium {
					scanlines = false
					pixels = false
				}
				//CAM STRUCTURES
				cntr := rl.NewVector2(screenWidthF32/2, screenHeightF32)
				camStructures.Zoom = 1
				camStructures.Target.Y = cntr.Y
				camStructures.Offset.X = screenWidthF32 / 2
				camStructures.Offset.Y = screenHeightF32 / 2
				if xl {
					camStructures.Zoom = 1.5
					camStructures.Offset.Y = screenHeightF32 / 0.67
				} else if xxl {
					camStructures.Zoom = 2.25
					camStructures.Offset.Y = screenHeightF32 / 0.89
				} else if medium {
					camStructures.Zoom = 0.75
					camStructures.Offset.Y = screenHeightF32 / 1.34
				} else if large {
					camStructures.Zoom = 1
					camStructures.Offset.Y = screenHeightF32
				}
				//CAM MAP
				camMap.Zoom = 0.1
				if xxl {
					camMap.Zoom = 0.2
				}
				if xl {
					camMap.Zoom = 0.15
				}
				//CAM INVEN
				camInventory.Zoom = 1
				camInventory.Target = currentPosition
				camInventory.Offset.X = screenWidthF32 / 2
				camInventory.Offset.Y = optionsRec.Height / 4.05
				if xl {
					camInventory.Zoom = 1.5
					camInventory.Offset.Y = screenHeightF32 / 1.35
				} else if xxl {
					camInventory.Zoom = 2.25
					camInventory.Offset.Y = screenHeightF32 / 0.89
				} else if medium {
					camInventory.Zoom = 0.8
					camInventory.Offset.Y = optionsRec.Height / 5
				}
				//CAM BASE
				if screenHeightF32 > 720 {
					diff := screenHeightF32 - 720
					diff = diff / 720
					camBase.Zoom = 1 + diff
				} else if screenHeightF32 == 720 {
					camBase.Zoom = 1
				}
				camBase.Target = currentPosition
				camBase.Offset.X = screenWidthF32 / 2
				camBase.Offset.Y = screenHeightF32 / 2
				camBoss.Target = currentPosition
				camBoss.Zoom = 3
				camBoss.Offset.X = screenWidthF32 / 2
				camBoss.Offset.Y = screenHeightF32 / 2

				//CAM END GAME
				camEnd.Zoom = 1
				if xl {
					camEnd.Zoom = 1.5
				}
				if xxl {
					camEnd.Zoom = 2.5
				}
				if medium {
					camEnd.Zoom = 0.75
				}
				camEnd.Target = currentPosition
				camEnd.Offset.X = screenWidthF32 / 2
				camEnd.Offset.Y = screenHeightF32 / 2

			}
			makescan()

			prevres = currentres
		}

		y += txs + txs/4
		x = optionsRec.ToInt32().X + 32

		swchY = float32(y)
		swchX = (optionsRec.X + optionsRec.Width) - b2
		backrec = rl.NewRectangle(optionsRec.X+4, swchY-2, optionsRec.Width-8, b+bq)
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if rl.IsKeyPressed(rl.KeyA) || rl.IsKeyPressed(rl.KeyLeft) || rl.GetGamepadAxisMovement(0, 0) < 0 || rl.IsGamepadButtonPressed(0, 4) {
				if windowType == 1 {
					windowType = 0
				} else {
					windowType = 1
				}
			}
			if rl.IsKeyPressed(rl.KeyD) || rl.IsKeyPressed(rl.KeyRight) || rl.GetGamepadAxisMovement(0, 0) > 0 || rl.IsGamepadButtonPressed(0, 2) {
				if windowType == 1 {
					windowType = 0
				} else {
					windowType = 1
				}
			}
		}
		rl.DrawText("display >>", x-3, y+3, txs, DarkRed())
		rl.DrawText("display >>", x-1, y+1, txs, rl.Black)
		rl.DrawText("display >>", x, y, txs, rl.Black)
		txtlen := rl.MeasureText("display >>", txs)
		x += txtlen + txs
		switch windowType {
		case 0:
			rl.DrawText("fullscreen", x-3, y+3, txs, DarkRed())
			rl.DrawText("fullscreen", x-1, y+1, txs, rl.Black)
			rl.DrawText("fullscreen", x, y, txs, rl.Black)
		case 1:
			rl.DrawText("window", x-3, y+3, txs, DarkRed())
			rl.DrawText("window", x-1, y+1, txs, rl.Black)
			rl.DrawText("window", x, y, txs, rl.Black)
		}

		windowType = oplr(windowType, 1, swchX, swchY)
		if prevWindowType != windowType {
			rl.PlaySound(audfx[44])
			switch windowType {
			case 0:
				if rl.IsWindowState(rl.FlagBorderlessWindowedMode) {
					rl.ClearWindowState(rl.FlagBorderlessWindowedMode)
				}
				if !rl.IsWindowFullscreen() {
					rl.ToggleFullscreen()
				}
			case 1:
				if rl.IsWindowFullscreen() {
					rl.ToggleFullscreen()
				}
				if rl.IsWindowState(rl.FlagBorderlessWindowedMode) {
					rl.ClearWindowState(rl.FlagBorderlessWindowedMode)
				}
				rl.SetWindowSize(scrW, scrH)
				rl.SetWindowPosition(int(currentPosition.X)-scrW/2, int(currentPosition.Y)-scrH/2)
			}
			prevWindowType = windowType
		}

		y += txs + txs/4
		x = optionsRec.ToInt32().X + 32

		//CONTROLLER IMG
		x2 := float32(x)
		y2 := float32(y) - b/3
		siz := b4
		rec3 := rl.NewRectangle(x2, y2, siz, siz)
		rl.DrawTexturePro(imgs, otherTiles[199], rec3, rl.Vector2Zero(), 0, rl.White)
		x += int32(siz + b/2)
		xorig := x
		swchY = float32(y)
		swchX = (optionsRec.X + optionsRec.Width) - b2
		backrec = rl.NewRectangle(optionsRec.X+optionsRec.Width/4, swchY-2, ((optionsRec.Width/4)*3)-4, b+bq)
		txt2 := fmt.Sprintf("%.2f", stickMov)
		txt2 = strings.TrimLeft(txt2, "0.")
		num2, err := strconv.Atoi(txt2)
		if err != nil {

		}
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if rl.IsKeyPressed(rl.KeyA) || rl.IsKeyPressed(rl.KeyLeft) || rl.GetGamepadAxisMovement(0, 0) < 0 || rl.IsGamepadButtonPressed(0, 4) {
				if num2 > 0 {
					rl.PlaySound(audfx[44])
					num2--
					if stickMov > 0 {
						stickMov -= 0.01
					}
					stickMovdis = num2
				}
			}
			if rl.IsKeyPressed(rl.KeyD) || rl.IsKeyPressed(rl.KeyRight) || rl.GetGamepadAxisMovement(0, 0) > 0 || rl.IsGamepadButtonPressed(0, 2) {
				if num2 < 99 {
					rl.PlaySound(audfx[44])
					num2++
					if stickMov < 0.99 {
						stickMov += 0.01
					}
					stickMovdis = num2
				}
			}
		}
		rl.DrawText("cursor speed", x-3, y+3, txs, DarkRed())
		rl.DrawText("cursor speed", x-1, y+1, txs, rl.Black)
		rl.DrawText("cursor speed", x, y, txs, rl.Black)

		stickMovdis = opadj(num2, 99, swchX, swchY, true, 1)

		y += txs + txs/4
		x = xorig

		swchY = float32(y)
		swchX = (optionsRec.X + optionsRec.Width) - b2
		backrec = rl.NewRectangle(optionsRec.X+optionsRec.Width/4, swchY-2, ((optionsRec.Width/4)*3)-4, b+bq)
		txt2 = fmt.Sprintf("%.2f", deadZ)
		txt2 = strings.TrimLeft(txt2, "0.")
		num2, err = strconv.Atoi(txt2)
		if err != nil {

		}
		if rl.CheckCollisionPointRec(cursorV2camInven, backrec) {
			rl.DrawRectangleRec(backrec, RandColor())
			if rl.IsKeyPressed(rl.KeyA) || rl.IsKeyPressed(rl.KeyLeft) || rl.GetGamepadAxisMovement(0, 0) < 0 || rl.IsGamepadButtonPressed(0, 4) {
				if num2 > 0 {
					rl.PlaySound(audfx[44])
					num2--
					if deadZ > 0 {
						deadZ -= 0.01
					}
					deadZDis = num2
				}
			}
			if rl.IsKeyPressed(rl.KeyD) || rl.IsKeyPressed(rl.KeyRight) || rl.GetGamepadAxisMovement(0, 0) > 0 || rl.IsGamepadButtonPressed(0, 2) {
				if num2 < 99 {
					rl.PlaySound(audfx[44])
					num2++
					if deadZ < 0.99 {
						deadZ += 0.01
					}
					deadZDis = num2
				}
			}
		}
		rl.DrawText("dead zone", x-3, y+3, txs, DarkRed())
		rl.DrawText("dead zone", x-1, y+1, txs, rl.Black)
		rl.DrawText("dead zone", x, y, txs, rl.Black)
		deadZDis = opadj(num2, 99, swchX, swchY, true, 2)

		//MOUSE + KEYB
		y += txs + (txs/12)*9
		txt := ">> mouse+keyb recommended"
		txlen = rl.MeasureText(txt, txs)
		x = int32(currentPosition.X) - txlen/2
		rl.DrawText(txt, x-3, y+3, txs, DarkRed())
		rl.DrawText(txt, x-1, y+1, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, rl.Black)

		//HELP
		y += txs + txs/2
		y2 = float32(y)
		//txs = tx6
		H := float32(txs) + b/2
		siz2 = b7
		spc := b / 2

		rec := rl.NewRectangle(currentPosition.X-(siz2+spc/2), y2, siz2, H)
		if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
			rl.DrawRectangleRec(rec, rl.Pink)
			if inpL {
				rl.PlaySound(audfx[44])
				helpon = true
			}
		} else {
			rl.DrawRectangleRec(rec, rl.Blue)
		}
		rl.DrawRectangleLinesEx(rec, 4, rl.Black)
		txt = "help"
		txlen = rl.MeasureText(txt, txs)
		xtx := int32(rec.X+rec.Width/2) - txlen/2
		ytx := int32(rec.Y+rec.Height/2) - txs/2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)

		//CREDITS
		rec.X += rec.Width + spc
		if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
			rl.DrawRectangleRec(rec, rl.Pink)
			if inpL {
				rl.PlaySound(audfx[44])
				credits = true
			}
		} else {
			rl.DrawRectangleRec(rec, rl.Blue)
		}
		rl.DrawRectangleLinesEx(rec, 4, rl.Black)
		txt = "credits"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(rec.X+rec.Width/2) - txlen/2
		ytx = int32(rec.Y+rec.Height/2) - txs/2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)

		//LOAD
		rec.Y += rec.Height + spc
		rec.X = currentPosition.X - (siz2 + spc/2)
		if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
			rl.DrawRectangleRec(rec, rl.Pink)
			if inpL {
				rl.PlaySound(audfx[44])
				ReadSaves()
				savenum = 0
				loadon = true
			}
		} else {
			rl.DrawRectangleRec(rec, rl.Blue)
		}
		rl.DrawRectangleLinesEx(rec, 4, rl.Black)
		txt = "load"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(rec.X+rec.Width/2) - txlen/2
		ytx = int32(rec.Y+rec.Height/2) - txs/2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)

		//EXIT
		rec.X += rec.Width + spc
		if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
			rl.DrawRectangleRec(rec, rl.Pink)
			if inpL {
				rl.PlaySound(audfx[44])
				exitmsg = exitText[RandInt(0, len(exitText))]
				exit = true
			}
		} else {
			rl.DrawRectangleRec(rec, rl.Blue)
		}
		rl.DrawRectangleLinesEx(rec, 4, rl.Black)
		txt = "exit"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(rec.X+rec.Width/2) - txlen/2
		ytx = int32(rec.Y+rec.Height/2) - txs/2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)

		//DISCONNECT TXT
		if disconnectT > 0 {
			ytx = rec.ToInt32().Y + rec.ToInt32().Height + tx
			txt := "controller disconnected"
			txlen = rl.MeasureText(txt, txs)
			x = int32(currentPosition.X) - txlen/2
			rl.DrawText(txt, x-3, ytx+3, txs, DarkRed())
			rl.DrawText(txt, x-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, x, ytx, txs, RandColor())
			disconnectT--
		}

	}

	rl.EndMode2D()
}
func drawgameover() { //MARK:DRAW GAME OVER
	rl.DrawRectangle(0, 0, screenWidth32, screenHeight32, rl.Fade(rl.Black, gameOverFade))
	if gameOverFade < 1 && !isBaseOn {
		gameOverFade += 0.02
	} else {
		pause = true

	}
	cntr := rl.NewVector2(screenWidthF32/2, screenHeightF32/2)
	gameOverRec = rl.NewRectangle(cntr.X-gameOverRec.Width/2, cntr.Y-gameOverRec.Height/2, gameOverRec.Width, gameOverRec.Height)
	if !isBaseOn {
		rl.DrawTexturePro(imgs, gameoveranimRec, drec(gameOverRec), orgn(gameOverRec), gameoverRotation, rl.White)
		gameoverRotation += 12
	}

	if gameOverRec.Y > -screenHeightF32/2 {
		if frames%2 == 0 {
			chng := float32(24)
			gameOverRec.Y -= chng
			gameOverRec.X -= chng
			gameOverRec.Width += chng * 2
			gameOverRec.Height += chng * 2
		}
	} else {
		if !gameOverReset {
			Reset()
			gameOverReset = true
		}
		isBaseOn = true
	}

	if isBaseOn {
		if gameOverFade > 0 {
			gameOverFade -= 0.01
		} else {
			gameOver = false
		}
	}

	gameoveranimRec.X += animation[205].width
	if gameoveranimRec.X > animation[205].x+animation[205].frames*animation[205].width {
		gameoveranimRec.X = animation[205].x
	}

}
func drawStartScreen() { //MARK:DRAW START SCREEN
	//BG
	for i := 0; i < len(introbg); i++ {
		rec := rl.NewRectangle(introbg[i].vector2.X-introbg[i].siz/2, introbg[i].vector2.Y-introbg[i].siz/2, introbg[i].siz, introbg[i].siz)
		if xxl {
			rec = rl.NewRectangle(introbg[i].vector2.X-introbg[i].siz, introbg[i].vector2.Y-introbg[i].siz, introbg[i].siz*2, introbg[i].siz*2)
		}
		switch introbgimgnum {
		case 1:
			rl.DrawTexturePro(imgs, otherTiles[193], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].color, introbg[i].fd))
		case 2:
			rl.DrawTexturePro(imgs, otherTiles[194], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].color, introbg[i].fd))
		case 3:
			rl.DrawTexturePro(imgs, otherTiles[195], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].color, introbg[i].fd))
		case 4:
			rl.DrawTexturePro(imgs, otherTiles[196], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].color, introbg[i].fd))
		}

		introbg[i].vector2.X += introbg[i].dirX + delta
		introbg[i].vector2.Y += introbg[i].dirY + delta

		if introbg[i].vector2.X > screenWidthF32+introbg[i].siz {
			introbg[i].vector2.X = -introbg[i].siz
		}
		if introbg[i].vector2.Y > screenHeightF32+introbg[i].siz {
			introbg[i].vector2.Y = -introbg[i].siz
		}
		if introbg[i].vector2.X < -introbg[i].siz {
			introbg[i].vector2.X = screenWidthF32 + introbg[i].siz
		}
		if introbg[i].vector2.Y < -introbg[i].siz {
			introbg[i].vector2.Y = screenHeightF32 + introbg[i].siz
		}
		introbg[i].ro += 4
	}
	txs := tx10
	if medium {
		txs = tx7
	}
	if xxl {
		txs = tx10 * 2
	}
	txlen := rl.MeasureText("select save", txs)
	x := int32(currentPosition.X) - txlen/2
	y := tx10 + tx5
	if medium {
		y -= tx4
	}
	if xxl {
		y += tx4
	}
	rl.DrawText("select save", x-5, y+5, txs, rl.Magenta)
	rl.DrawText("select save", x-2, y+2, txs, rl.Black)
	rl.DrawText("select save", x, y, txs, RandColor())

	W := b10 + b4
	H := b3
	if medium {
		W = b10
		H = b2 + b/2
	}
	if xxl {
		W = b10 * 2
		H = b5
	}
	y2 := float32(y+txs) + b
	if xxl {
		y2 += b
	}

	rec2 := rl.NewRectangle(currentPosition.X-W/2, y2, W, H)
	if savenum == 0 {
		rl.DrawRectangleRec(rec2, rl.Fade(rl.Magenta, fadeblinkF))
	}
	rl.DrawRectangleLinesEx(rec2, 4, rl.Orange) //0
	txt := "empty"
	if save1 {
		txt = "one"
		if delsave && delsaveNum == 1 {
			txt = "delete?"
		}
	}
	txs = tx6
	if medium {
		txs = tx4
	}
	if xxl {
		txs = tx10
	}
	txlen = rl.MeasureText(txt, txs)
	x = int32(currentPosition.X) - txlen/2
	y = rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
	rl.DrawText(txt, x-4, y+4, txs, BrightPink())
	rl.DrawText(txt, x-2, y+2, txs, rl.Black)
	rl.DrawText(txt, x, y, txs, rl.White)
	if rl.CheckCollisionPointRec(cursorV2, rec2) {
		if savenum != 0 {
			rl.PlaySound(audfx[40])
		}
		savenum = 0
		if inpL {
			if delsave && delsaveNum == 1 {
				clearsave(1)
				delsave = false
				rl.PlaySound(audfx[43])
				delsaveNum = 0
			} else if delsave && delsaveNum != 1 {
				delsave = false
				rl.PlaySound(audfx[43])
				delsaveNum = 0
			} else {
				rl.PlaySound(audfx[41])
				selSave = 1
			}
		}
		if inpR && save1 {
			if !delsave {
				delsaveNum = 1
				rl.PlaySound(audfx[42])
			} else {
				delsaveNum = 0
			}
			delsave = !delsave
		}
	}
	rec2.Y += H + b
	if xxl {
		rec2.Y += b
	}
	if savenum == 1 {
		rl.DrawRectangleRec(rec2, rl.Fade(rl.Magenta, fadeblinkF))
	}
	rl.DrawRectangleLinesEx(rec2, 4, rl.Orange) //1
	txt = "empty"
	if save2 {
		txt = "two"
		if delsave && delsaveNum == 2 {
			txt = "delete?"
		}
	}
	txlen = rl.MeasureText(txt, txs)
	x = int32(currentPosition.X) - txlen/2
	y = rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
	rl.DrawText(txt, x-4, y+4, txs, BrightPink())
	rl.DrawText(txt, x-2, y+2, txs, rl.Black)
	rl.DrawText(txt, x, y, txs, rl.White)
	if rl.CheckCollisionPointRec(cursorV2, rec2) {
		if savenum != 1 {
			rl.PlaySound(audfx[40])
		}
		savenum = 1
		if inpL {
			if delsave && delsaveNum == 2 {
				clearsave(2)
				delsave = false
				rl.PlaySound(audfx[43])
				delsaveNum = 0
			} else if delsave && delsaveNum != 2 {
				delsave = false
				rl.PlaySound(audfx[43])
				delsaveNum = 0
			} else {
				rl.PlaySound(audfx[41])
				selSave = 2
			}
		}
		if inpR && save2 {
			if !delsave {
				rl.PlaySound(audfx[42])
				delsaveNum = 2
			} else {
				delsaveNum = 0
			}
			delsave = !delsave
		}
	}
	rec2.Y += H + b
	if xxl {
		rec2.Y += b
	}
	if savenum == 2 {
		rl.DrawRectangleRec(rec2, rl.Fade(rl.Magenta, fadeblinkF))
	}
	rl.DrawRectangleLinesEx(rec2, 4, rl.Orange) //2
	txt = "empty"
	if save3 {
		txt = "three"
		if delsave && delsaveNum == 3 {
			txt = "delete?"
		}
	}
	txlen = rl.MeasureText(txt, txs)
	x = int32(currentPosition.X) - txlen/2
	y = rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
	rl.DrawText(txt, x-4, y+4, txs, BrightPink())
	rl.DrawText(txt, x-2, y+2, txs, rl.Black)
	rl.DrawText(txt, x, y, txs, rl.White)
	if rl.CheckCollisionPointRec(cursorV2, rec2) {
		if savenum != 2 {
			rl.PlaySound(audfx[40])
		}
		savenum = 2
		if inpL {
			if delsave && delsaveNum == 3 {
				clearsave(3)
				delsave = false
				rl.PlaySound(audfx[43])
				delsaveNum = 0
			} else if delsave && delsaveNum != 3 {
				delsave = false
				rl.PlaySound(audfx[43])
				delsaveNum = 0
			} else {
				rl.PlaySound(audfx[41])
				selSave = 3
			}
		}
		if inpR && save3 {
			if !delsave {
				rl.PlaySound(audfx[42])
				delsaveNum = 3
			} else {
				delsaveNum = 0
			}
			delsave = !delsave
		}
	}
	//DELETE TXT
	if save1 || save2 || save3 {

		y += rec2.ToInt32().Height + txs/2
		txt = "right click to delete"
		txt2 := ""
		if mouseoff {
			txt = "xbox x / l trigger to delete"
		}
		if delsave {
			txt = "left click confirm"
			txt2 = "right click cancel"
			if mouseoff {
				txt = "xbox a & r trigger confirm"
				txt2 = "xbox x & l trigger cancel"
			}
		}
		txlen = rl.MeasureText(txt, txs)
		x = int32(currentPosition.X) - txlen/2
		rl.DrawText(txt, x-4, y+4, txs, BrightPink())
		rl.DrawText(txt, x-2, y+2, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, rl.White)
		y += txs + txs/4
		txlen = rl.MeasureText(txt2, txs)
		x = int32(currentPosition.X) - txlen/2
		rl.DrawText(txt2, x-4, y+4, txs, BrightPink())
		rl.DrawText(txt2, x-2, y+2, txs, rl.Black)
		rl.DrawText(txt2, x, y, txs, rl.White)
	}

	//FADE IN REC
	if introfd > 0 {
		rec := rl.NewRectangle(0, 0, screenWidthF32, screenHeightF32)
		introfd -= 0.02
		rl.DrawRectangleRec(rec, rl.Fade(rl.Black, introfd))
	}

	if rl.IsKeyPressed(rl.KeyDown) || rl.IsKeyPressed(rl.KeyS) {
		savenum++
		if savenum > 2 {
			savenum = 0
		}
	}
	if rl.IsKeyPressed(rl.KeyUp) || rl.IsKeyPressed(rl.KeyW) {
		savenum--
		if savenum < 0 {
			savenum = 2
		}
	}

	if selSave != 0 {
		currentSave = selSave
		rl.DrawRectangle(0, 0, screenWidth32, screenHeight32, rl.Black)
		if introAnim.X < animation[204].x+animation[204].frames*animation[204].width {
			siz2 := b10 * 2
			if large {
				siz2 = b10 * 3
			}
			if xl {
				siz2 = b10 * 4
			}
			if xxl {
				siz2 = b10 * 7
			}
			rec2 := rl.NewRectangle(currentPosition.X-siz2/2, currentPosition.Y-siz2/2, siz2, siz2)
			rl.DrawTexturePro(imgs, introAnim, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.5, 0.7)))
			rl.DrawTexturePro(imgs, introAnim, brec(rec2, 7), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.3, 0.5)))
			rl.DrawTexturePro(imgs, introAnim, brec(rec2, 12), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.1, 0.3)))
			if frames%3 == 0 {
				introAnim.X += animation[204].width
			}
		} else {
			introAnim.X = animation[204].x

			switch selSave {
			case 1:
				if save1 {
					copy(storeItm, savestore1)
					isStoreUnlocked = true
					for i := 0; i < len(base.name); i++ {
						if base.name[i] == "store room" {
							base.isUnlocked[i] = true
						}
					}
				}
			case 2:
				if save2 {
					copy(storeItm, savestore2)
					isStoreUnlocked = true
					for i := 0; i < len(base.name); i++ {
						if base.name[i] == "store room" {
							base.isUnlocked[i] = true
						}
					}
				}
			case 3:
				if save3 {
					copy(storeItm, savestore3)
					isStoreUnlocked = true
					for i := 0; i < len(base.name); i++ {
						if base.name[i] == "store room" {
							base.isUnlocked[i] = true
						}
					}
				}
			}

			rl.StopMusicStream(music[currentMusic])
			currentMusic = 2
			rl.PlayMusicStream(music[currentMusic])
			selSave = 0
			savenum = 0
			startScreen = false
			isBaseOn = true

		}
	}

}
func drawIntro() { //MARK:DRAW INTRO

	if gamestartT > 0 {
		gamestartT--
	} else {

		if introT1 > 0 { //UNKLNIK LOGO
			W := otherTiles[190].Width
			H := otherTiles[190].Height
			if large || xl {
				W = W / 1.5
				H = H / 1.5
			}
			if medium {
				W = W / 2.5
				H = H / 2.5
			}
			unklnikRec = rl.NewRectangle(currentPosition.X-W/2, currentPosition.Y-H/2, W, H)
			rl.DrawTexturePro(imgs, otherTiles[190], unklnikRec, rl.Vector2Zero(), 0, rl.Fade(rl.White, unklnikLogoF))
			if unklnikLogoF < 1 {
				unklnikLogoF += 0.005
			}
			introT1--
			if introT1 == 1 {
				W2 := otherTiles[191].Width
				H2 := otherTiles[191].Height
				if medium {
					W2 = W2 / 2
					H2 = H2 / 2
				}
				if xxl {
					W2 = W2 * 1.5
					H2 = H2 * 1.5
				}
				goLogoRec = rl.NewRectangle(0-W2, currentPosition.Y-H2/2, W2, H2)
			}
		} else if introT2 > 0 { //GO LOGO
			rl.DrawTexturePro(imgs, otherTiles[190], unklnikRec, rl.Vector2Zero(), 0, rl.White)
			rl.DrawTexturePro(imgs, otherTiles[191], goLogoRec, rl.Vector2Zero(), 0, rl.White)
			if unklnikRec.X < screenWidthF32 {
				unklnikRec.X += 20
			}
			if goLogoRec.X < currentPosition.X-goLogoRec.Width/2 {
				goLogoRec.X += 20
			} else {
				introT2--
			}
		} else if introT3 > 0 { //RAYLIB LOGO
			siz := b10
			if medium {
				siz = b5
			}
			if xxl {
				siz = siz + b5
			}
			rec := rl.NewRectangle(currentPosition.X-siz/2, currentPosition.Y-siz/2, siz, siz)
			rl.DrawTexturePro(raylibAnim[raylibFrameNum], raylibRec, rec, rl.Vector2Zero(), 0, rl.White)

			if raylibFrameNum < len(raylibAnim)-1 {
				if frames%3 == 0 {
					raylibFrameNum++
				}
			} else {
				introT3--
			}
		} else { //MR SNUGGLES LOGO

			if inpL || rl.IsKeyPressed(rl.KeySpace) || rl.IsKeyPressed(rl.KeyEnter) {
				endIntro = true
				rl.PlaySound(audfx[44])
			}
			//BG
			for i := 0; i < len(introbg); i++ {
				rec := rl.NewRectangle(introbg[i].vector2.X-introbg[i].siz/2, introbg[i].vector2.Y-introbg[i].siz/2, introbg[i].siz, introbg[i].siz)
				if xxl {
					rec = rl.NewRectangle(introbg[i].vector2.X-introbg[i].siz, introbg[i].vector2.Y-introbg[i].siz, introbg[i].siz*2, introbg[i].siz*2)
				}
				switch introbgimgnum {
				case 1:
					rl.DrawTexturePro(imgs, otherTiles[193], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].color, introbg[i].fd))
				case 2:
					rl.DrawTexturePro(imgs, otherTiles[194], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].color, introbg[i].fd))
				case 3:
					rl.DrawTexturePro(imgs, otherTiles[195], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].color, introbg[i].fd))
				case 4:
					rl.DrawTexturePro(imgs, otherTiles[196], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].color, introbg[i].fd))
				}

				introbg[i].vector2.X += introbg[i].dirX + delta
				introbg[i].vector2.Y += introbg[i].dirY + delta

				if introbg[i].vector2.X > screenWidthF32+introbg[i].siz {
					introbg[i].vector2.X = -introbg[i].siz
				}
				if introbg[i].vector2.Y > screenHeightF32+introbg[i].siz {
					introbg[i].vector2.Y = -introbg[i].siz
				}
				if introbg[i].vector2.X < -introbg[i].siz {
					introbg[i].vector2.X = screenWidthF32 + introbg[i].siz
				}
				if introbg[i].vector2.Y < -introbg[i].siz {
					introbg[i].vector2.Y = screenHeightF32 + introbg[i].siz
				}
				introbg[i].ro += 4
			}

			siz := b10 * 2
			if medium {
				siz = b10 + b2
			}
			if xxl {
				siz = b10 * 4
			}

			rec2 := rl.NewRectangle(currentPosition.X-siz/2, currentPosition.Y-siz/2, siz, siz)
			rec2.Y -= b2
			rl.DrawTexturePro(imgs, otherTiles[192], rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, introfd))
			if introfd < 1 {
				introfd += 0.01
			}
			txt := "press start"
			txs := tx6
			if medium {
				txs = tx3
			}
			if xxl {
				txs = tx10
			}
			txlen := rl.MeasureText(txt, txs)
			xtx := int32(currentPosition.X) - txlen/2
			ytx := int32(rec2.Y + rec2.Height + b)
			if onoff15 {
				rl.DrawText(txt, xtx-4, ytx+4, txs, rl.Yellow)
			} else {
				rl.DrawText(txt, xtx-4, ytx+4, txs, rl.Orange)
			}
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
			if onoff15 {
				rl.DrawText(txt, xtx, ytx, txs, rl.Magenta)
			} else {
				rl.DrawText(txt, xtx, ytx, txs, BrightPink())
			}

			//VERSION
			txt = "v1.00"
			txs = tx2
			if medium {
				txs = tx
			}
			if xxl {
				txs = tx4
			}
			txlen = rl.MeasureText(txt, txs)
			xtx = screenWidth32 - (txlen * 2)
			ytx = screenHeight32 - (txs * 2)
			rl.DrawText(txt, xtx, ytx, txs, rl.Magenta)

			if endIntro {
				rec3 := rl.NewRectangle(0, 0, screenWidthF32, screenHeightF32)
				rl.DrawRectangleRec(rec3, rl.Fade(rl.Black, introfd2))
				if introfd2 < 1 {
					introfd2 += 0.02
				} else {
					intro = false
					startScreen = true
					introfd2 = 0
					introfd = 1
				}
			}

		}
		if introT3 > 0 {
			if rl.IsKeyPressed(rl.KeySpace) || inpL {
				introT1 = 0
				introT2 = 0
				introT3 = 0
			}
		}
	}
}

func drawexit() { //MARK:DRAW EXIT

	rl.DrawRectangleRec(optionsRec, rl.Black)
	//BG
	for i := 0; i < len(introbg); i++ {
		rec := rl.NewRectangle(introbg[i].vector2.X-introbg[i].siz/2, introbg[i].vector2.Y-introbg[i].siz/2, introbg[i].siz, introbg[i].siz)
		switch introbgimgnum {
		case 1:
			rl.DrawTexturePro(imgs, otherTiles[193], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].color, introbg[i].fd))
		case 2:
			rl.DrawTexturePro(imgs, otherTiles[194], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].color, introbg[i].fd))
		case 3:
			rl.DrawTexturePro(imgs, otherTiles[195], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].color, introbg[i].fd))
		case 4:
			rl.DrawTexturePro(imgs, otherTiles[196], rec, orgn(rec), introbg[i].ro, rl.Fade(introbg[i].color, introbg[i].fd))
		}

		introbg[i].vector2.X += introbg[i].dirX + delta
		introbg[i].vector2.Y += introbg[i].dirY + delta

		if introbg[i].vector2.X > screenWidthF32+introbg[i].siz {
			introbg[i].vector2.X = -introbg[i].siz
		}
		if introbg[i].vector2.Y > screenHeightF32+introbg[i].siz {
			introbg[i].vector2.Y = -introbg[i].siz
		}
		if introbg[i].vector2.X < -introbg[i].siz {
			introbg[i].vector2.X = screenWidthF32 + introbg[i].siz
		}
		if introbg[i].vector2.Y < -introbg[i].siz {
			introbg[i].vector2.Y = screenHeightF32 + introbg[i].siz
		}
		introbg[i].ro += 4
	}

	cntr := rl.NewVector2(screenWidthF32/2, screenHeightF32/2)
	txs := tx5
	txlen := rl.MeasureText(exitmsg, txs)

	camCnt := rl.GetScreenToWorld2D(cntr, camInventory)
	xtx := int32(camCnt.X) - txlen/2
	ytx := int32(camCnt.Y - b4)
	rl.DrawText(exitmsg, xtx, ytx, txs, rl.White)

	siz := b4
	txs = tx3
	H := float32(txs) + b
	spc := b
	x := camCnt.X - siz - spc/2
	y := camCnt.Y - b2

	rec := rl.NewRectangle(x, y, siz, H)
	txs = tx4
	ytx = int32(rec.Y+rec.Height/2) - txs/2
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		rl.DrawRectangleRec(rec, rl.Magenta)
		txlen = rl.MeasureText("yes", txs)
		xtx = int32(rec.X+rec.Width/2) - txlen/2
		rl.DrawText("yes", xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText("yes", xtx, ytx, txs, rl.Black)
		if inpL {
			if isStoreUnlocked {
				savestore()
			}
			rl.StopMusicStream(music[currentMusic])
			rl.EndMode2D()
			rl.EndTextureMode()
			rl.EndShaderMode()
			rl.EndDrawing()
			unload()
			rl.CloseAudioDevice()
			rl.CloseWindow()
			os.Exit(0)
		}
	} else {
		txlen = rl.MeasureText("yes", txs)
		xtx = int32(rec.X+rec.Width/2) - txlen/2
		rl.DrawText("yes", xtx, ytx, txs, rl.White)
	}
	rl.DrawRectangleLinesEx(rec, 4, rl.Orange)

	rec.X += rec.Width + spc
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		rl.DrawRectangleRec(rec, rl.Magenta)
		txlen = rl.MeasureText("no", txs)
		xtx = int32(rec.X+rec.Width/2) - txlen/2
		rl.DrawText("no", xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText("no", xtx, ytx, txs, rl.Black)
		if inpL {
			rl.PlaySound(audfx[44])
			exit = false
		}
	} else {
		txlen = rl.MeasureText("no", txs)
		xtx = int32(rec.X+rec.Width/2) - txlen/2
		rl.DrawText("no", xtx, ytx, txs, rl.White)
	}
	rl.DrawRectangleLinesEx(rec, 4, rl.Orange)

	txs = tx2
	ytx = int32(y + H + b/2)
	txlen = rl.MeasureText("progress is saved up to last camp", txs)
	xtx = int32(camCnt.X) - txlen/2
	rl.DrawText("progress is saved up to last camp", xtx, ytx, txs, rl.White)

}

func drawWeaponShed() { //MARK:DRAW WEAPON SHED

	levStruc := 0
	for i := 0; i < len(base.name); i++ {
		if base.name[i] == "weapon shed" {
			levStruc = base.level[i]
			break
		}
	}

	for i := 0; i < len(bgpix); i++ {
		rec := rl.NewRectangle(bgpix[i].vector2.X, bgpix[i].vector2.Y, bgpix[i].siz, bgpix[i].siz)
		rl.DrawRectangleRec(rec, rl.Fade(bgpix[i].color, bgpix[i].fd))
		bgpix[i].vector2.X += bgpix[i].dirX
		bgpix[i].vector2.Y += bgpix[i].dirY

		if bgpix[i].vector2.X < 0 {
			bgpix[i].vector2.X = screenWidthF32
		}
		if bgpix[i].vector2.X > screenWidthF32 {
			bgpix[i].vector2.X = 0
		}
		if bgpix[i].vector2.Y < 0 {
			bgpix[i].vector2.Y = screenHeightF32
		}
		if bgpix[i].vector2.Y > screenHeightF32 {
			bgpix[i].vector2.Y = 0
		}

		if bgpix[i].fd > 0 {
			bgpix[i].fd -= 0.005
		} else {
			bgpix[i].fd = RandF32(0.5, 1)
		}
	}

	rl.BeginMode2D(camStructures)

	rl.DrawRectangleRec(storeRec, rl.Black)
	rl.DrawRectangleRec(storeRec, rl.Fade(rl.Orange, 0.7))

	//DRAW ORE
	leadnum, bronzenum, silvernum, goldnum, platinumnum := 0, 0, 0, 0, 0
	for i := 0; i < len(storeItm); i++ {
		if storeItm[i].name == "lead" {
			leadnum += storeItm[i].numof
		}
		if storeItm[i].name == "bronze" {
			bronzenum += storeItm[i].numof
		}
		if storeItm[i].name == "silver" {
			silvernum += storeItm[i].numof
		}
		if storeItm[i].name == "gold" {
			goldnum += storeItm[i].numof
		}
		if storeItm[i].name == "platinum" {
			platinumnum += storeItm[i].numof
		}
	}
	for i := 0; i < len(player.inventory); i++ {
		if player.inventory[i].name == "lead" {
			leadnum += player.inventory[i].numof
		}
		if player.inventory[i].name == "bronze" {
			bronzenum += player.inventory[i].numof
		}
		if player.inventory[i].name == "silver" {
			silvernum += player.inventory[i].numof
		}
		if player.inventory[i].name == "gold" {
			goldnum += player.inventory[i].numof
		}
		if player.inventory[i].name == "platinum" {
			platinumnum += player.inventory[i].numof
		}
	}
	siz := b2
	spc := float32(8)
	W := (siz + spc) * 15
	x := currentPosition.X - W/2
	y := b4
	for i := 0; i < 5; i++ {
		rec := rl.NewRectangle(x, y, siz, siz)
		rec2 := rec
		rec2.X -= 4
		rec2.Y += 4
		rl.DrawRectangleRec(rec2, rl.Black)
		rl.DrawRectangleRec(rec, rl.Black)
		rl.DrawRectangleRec(rec, rl.Fade(rl.DarkGray, 0.5))
		xtx := rec.ToInt32().X + rec.ToInt32().Width/2
		ytx := rec.ToInt32().Y + rec.ToInt32().Height + 4
		xtx2 := rec.ToInt32().X + rec.ToInt32().Width + 12
		ytx2 := rec.ToInt32().Y + 8
		txs := tx3
		txs2 := tx5
		txt := ""
		switch i {
		case 0:
			rl.DrawTexturePro(imgs, otherTiles[53], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[53], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "lead"
			rl.DrawText(fmt.Sprint(leadnum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(leadnum), xtx2, ytx2, txs2, rl.Black)
		case 1:
			rl.DrawTexturePro(imgs, otherTiles[52], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[52], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "bronze"
			rl.DrawText(fmt.Sprint(bronzenum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(bronzenum), xtx2, ytx2, txs2, rl.Black)
		case 2:
			rl.DrawTexturePro(imgs, otherTiles[51], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[51], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "silver"
			rl.DrawText(fmt.Sprint(silvernum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(silvernum), xtx2, ytx2, txs2, rl.Black)
		case 3:
			rl.DrawTexturePro(imgs, otherTiles[50], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[50], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "gold"
			rl.DrawText(fmt.Sprint(goldnum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(goldnum), xtx2, ytx2, txs2, rl.Black)
		case 4:
			rl.DrawTexturePro(imgs, otherTiles[54], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[54], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "platinum"
			rl.DrawText(fmt.Sprint(platinumnum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(platinumnum), xtx2, ytx2, txs2, rl.Black)
		}
		txlen := rl.MeasureText(txt, txs)
		xtx -= txlen / 2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		x += (siz + spc) * 3
	}

	//WEAPONS
	var changeWeaps []bool
	changeWeaps = append(changeWeaps, false)
	for i := 0; i < 6; i++ {
		changeWeaps = append(changeWeaps, false)
	}
	if player.weapon.name != "" {
		changeWeaps[0] = true

	}
	if player.weapon2.name != "" {
		changeWeaps[1] = true

	}
	if len(player.weapons) > 0 {
		if len(player.weapons) >= 1 {
			if player.weapons[0].name != "" {
				changeWeaps[2] = true
			}
		}
		if len(player.weapons) >= 2 {
			if player.weapons[1].name != "" {
				changeWeaps[3] = true
			}
		}
		if len(player.weapons) >= 3 {
			if player.weapons[2].name != "" {
				changeWeaps[4] = true
			}
		}
		if len(player.weapons) == 4 {
			if player.weapons[3].name != "" {
				changeWeaps[5] = true
			}
		}
	}
	count := float32(0)
	for i := 0; i < len(changeWeaps); i++ {
		if changeWeaps[i] {
			count++
		}
	}
	siz = b3
	spc = 16
	W = count * (siz + spc)
	x = currentPosition.X - W/2
	y += b4
	selweapnm := ""
	selweaplev := 0
	for i := 0; i < len(changeWeaps); i++ {
		if changeWeaps[i] {
			rec := rl.NewRectangle(x, y, siz, siz)
			rec2 := rec
			rec2.X += 8
			rec2.Y += 8
			rec2.Width -= 16
			rec2.Height -= 16
			rec3 := rec2
			rec3.X -= 8
			rec3.Y += 8
			rl.DrawRectangleRec(rec3, rl.Magenta)
			rl.DrawRectangleRec(rec2, rl.Black)
			if selnumWeap == i {
				rl.DrawRectangleRec(rec2, rl.Fade(RandColor(), fadeblinkF))
			} else {
				if rl.CheckCollisionPointRec(cursorV2Strucs, rec) {
					if inpL {
						selnumWeap = i
					}
					rl.DrawRectangleRec(rec2, rl.Fade(rl.Green, fadeblinkF))
				} else {
					rl.DrawRectangleRec(rec2, rl.Fade(rl.DarkGray, 0.5))
				}
				rl.DrawRectangleLinesEx(rec2, 2, rl.Black)
			}
			if i == 0 {
				rl.DrawTexturePro(imgs, player.weapon.image, shrec(rec, 12), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, player.weapon.image, rec, rl.Vector2Zero(), 0, rl.White)
				if selnumWeap == i {
					selweapnm = player.weapon.name
					selweaplev = player.weapon.level
				}
				//BONUS STARS
				if player.weapon.special != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
				if player.weapon.special2 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					if player.weapon.special != 0 {
						rec3.X -= (siz / 12) * 9
					}
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
			}
			if i == 1 {
				rl.DrawTexturePro(imgs, player.weapon2.image, shrec(rec, 12), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, player.weapon2.image, rec, rl.Vector2Zero(), 0, rl.White)
				if selnumWeap == i {
					selweapnm = player.weapon2.name
					selweaplev = player.weapon2.level
				}
				//BONUS STARS
				if player.weapon2.special != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
				if player.weapon2.special2 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					if player.weapon2.special != 0 {
						rec3.X -= (siz / 12) * 9
					}
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
			}
			if i == 2 {
				rl.DrawTexturePro(imgs, player.weapons[0].image, shrec(rec, 12), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, player.weapons[0].image, rec, rl.Vector2Zero(), 0, rl.White)
				if selnumWeap == i {
					selweapnm = player.weapons[0].name
					selweaplev = player.weapons[0].level
				}
				//BONUS STARS
				if player.weapons[0].special != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
				if player.weapons[0].special2 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					if player.weapons[0].special != 0 {
						rec3.X -= (siz / 12) * 9
					}
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
			}
			if i == 3 {
				rl.DrawTexturePro(imgs, player.weapons[1].image, shrec(rec, 12), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, player.weapons[1].image, rec, rl.Vector2Zero(), 0, rl.White)
				if selnumWeap == i {
					selweapnm = player.weapons[1].name
					selweaplev = player.weapons[1].level
				}
				//BONUS STARS
				if player.weapons[1].special != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
				if player.weapons[1].special2 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					if player.weapons[1].special != 0 {
						rec3.X -= (siz / 12) * 9
					}
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
			}
			if i == 4 {
				rl.DrawTexturePro(imgs, player.weapons[2].image, shrec(rec, 12), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, player.weapons[2].image, rec, rl.Vector2Zero(), 0, rl.White)
				if selnumWeap == i {
					selweapnm = player.weapons[2].name
					selweaplev = player.weapons[2].level
				}
				//BONUS STARS
				if player.weapons[2].special != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
				if player.weapons[2].special2 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					if player.weapons[2].special != 0 {
						rec3.X -= (siz / 12) * 9
					}
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
			}
			if i == 5 {
				rl.DrawTexturePro(imgs, player.weapons[3].image, shrec(rec, 12), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, player.weapons[3].image, rec, rl.Vector2Zero(), 0, rl.White)
				if selnumWeap == i {
					selweapnm = player.weapons[3].name
					selweaplev = player.weapons[3].level
				}
				//BONUS STARS
				if player.weapons[3].special != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
				if player.weapons[3].special2 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					if player.weapons[3].special != 0 {
						rec3.X -= (siz / 12) * 9
					}
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
			}
			x += siz + spc
		}
	}

	txs := tx6
	ytx := int32(y + b4)
	txt := selweapnm + " > level " + fmt.Sprint(selweaplev)
	txlen := rl.MeasureText(txt, txs)
	xtx := int32(currentPosition.X) - txlen/2
	rl.DrawText(txt, xtx-3, ytx+3, txs, rl.Magenta)
	rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
	rl.DrawText(txt, xtx, ytx, txs, rl.Black)
	ytx += txs + 24
	xtx = storeRec.ToInt32().X + 32
	txs = tx4
	linespc := txs + txs/2
	if storetxT > 0 {
		storetxT--
	}
	if storetxT2 > 0 {
		storetxT2--
	}
	if storetxT3 > 0 {
		storetxT3--
	}
	if selweaplev == 1 { //LEVEL 1
		txt = "level 2 > " + fmt.Sprint(LEAD_PRICE) + " lead > +1 dmg"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(currentPosition.X) - txlen/2
		bgrec2 := rl.NewRectangle(storeRec.X, float32(ytx-4), storeRec.Width, float32(txs+8))
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if leadnum >= LEAD_PRICE {
					upWeapon(selnumWeap, 2)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else {
					rl.PlaySound(audfx[43])
					storetxT = fps * 2
				}
			}
		}
		if leadnum >= LEAD_PRICE {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 3 > " + fmt.Sprint(BRONZE_PRICE) + " bronze > +2 dmg"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(currentPosition.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if bronzenum >= BRONZE_PRICE {
					upWeapon(selnumWeap, 3)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else {
					rl.PlaySound(audfx[43])
					storetxT = fps * 2
				}
			}
		}
		if bronzenum >= BRONZE_PRICE {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 4 > " + fmt.Sprint(SILVER_PRICE) + " silver > +3 dmg"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(currentPosition.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if silvernum >= SILVER_PRICE && levStruc >= 2 {
					upWeapon(selnumWeap, 4)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if silvernum >= SILVER_PRICE && levStruc < 2 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if silvernum < SILVER_PRICE {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if silvernum >= SILVER_PRICE {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 5 > " + fmt.Sprint(GOLD_PRICE) + " gold > +3 dmg +1 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(currentPosition.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if goldnum >= GOLD_PRICE && levStruc >= 2 {
					upWeapon(selnumWeap, 5)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if goldnum >= GOLD_PRICE && levStruc < 2 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if goldnum < GOLD_PRICE {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if goldnum >= GOLD_PRICE {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 6 > " + fmt.Sprint(PLATINUM_PRICE) + " platinum > +3 dmg +2 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(currentPosition.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if platinumnum >= PLATINUM_PRICE && levStruc == 3 {
					upWeapon(selnumWeap, 6)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if platinumnum >= PLATINUM_PRICE && levStruc < 3 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if platinumnum < PLATINUM_PRICE {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if platinumnum >= PLATINUM_PRICE {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
	} else if selweaplev == 2 { //LEVEL 2
		txt = "level 3 > " + fmt.Sprint(BRONZE_PRICE) + " bronze > +2 dmg"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(currentPosition.X) - txlen/2
		bgrec2 := rl.NewRectangle(storeRec.X, float32(ytx-4), storeRec.Width, float32(txs+8))
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if bronzenum >= BRONZE_PRICE {
					upWeapon(selnumWeap, 3)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else {
					rl.PlaySound(audfx[43])
					storetxT = fps * 2
				}
			}
		}
		if bronzenum >= BRONZE_PRICE {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 4 > " + fmt.Sprint(SILVER_PRICE) + " silver > +3 dmg +1 hp"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(currentPosition.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if silvernum >= SILVER_PRICE && levStruc >= 2 {
					upWeapon(selnumWeap, 4)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if silvernum >= SILVER_PRICE && levStruc < 2 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if silvernum < SILVER_PRICE {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if silvernum >= SILVER_PRICE {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 5 > " + fmt.Sprint(GOLD_PRICE) + " gold > +3 dmg +1 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(currentPosition.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if goldnum >= GOLD_PRICE && levStruc >= 2 {
					upWeapon(selnumWeap, 5)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if goldnum >= GOLD_PRICE && levStruc < 2 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if goldnum < GOLD_PRICE {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if goldnum >= GOLD_PRICE {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 6 > " + fmt.Sprint(PLATINUM_PRICE) + " platinum > +3 dmg +2 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(currentPosition.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if platinumnum >= PLATINUM_PRICE && levStruc == 3 {
					upWeapon(selnumWeap, 6)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if platinumnum >= PLATINUM_PRICE && levStruc < 3 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if platinumnum < PLATINUM_PRICE {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if platinumnum >= PLATINUM_PRICE {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
	} else if selweaplev == 3 { //LEVEL 3
		txt = "level 4 > " + fmt.Sprint(SILVER_PRICE) + " silver > +3 dmg +1 hp"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(currentPosition.X) - txlen/2
		bgrec2 := rl.NewRectangle(storeRec.X, float32(ytx-4), storeRec.Width, float32(txs+8))
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if silvernum >= SILVER_PRICE && levStruc >= 2 {
					upWeapon(selnumWeap, 4)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if silvernum >= SILVER_PRICE && levStruc < 2 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if silvernum < SILVER_PRICE {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if silvernum >= SILVER_PRICE {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 5 > " + fmt.Sprint(GOLD_PRICE) + " gold > +3 dmg +1 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(currentPosition.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if goldnum >= GOLD_PRICE && levStruc >= 2 {
					upWeapon(selnumWeap, 5)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if goldnum >= GOLD_PRICE && levStruc < 2 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if goldnum < GOLD_PRICE {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if goldnum >= GOLD_PRICE {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 6 > " + fmt.Sprint(PLATINUM_PRICE) + " platinum > +3 dmg +2 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(currentPosition.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if platinumnum >= PLATINUM_PRICE && levStruc == 3 {
					upWeapon(selnumWeap, 6)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if platinumnum >= PLATINUM_PRICE && levStruc < 3 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if platinumnum < PLATINUM_PRICE {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if platinumnum >= PLATINUM_PRICE {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
	} else if selweaplev == 4 { //LEVEL 4
		txt = "level 5 > " + fmt.Sprint(GOLD_PRICE) + " gold > +3 dmg +1 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(currentPosition.X) - txlen/2
		bgrec2 := rl.NewRectangle(storeRec.X, float32(ytx-4), storeRec.Width, float32(txs+8))
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if goldnum >= GOLD_PRICE && levStruc >= 2 {
					upWeapon(selnumWeap, 5)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if goldnum >= GOLD_PRICE && levStruc < 2 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if goldnum < GOLD_PRICE {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if goldnum >= GOLD_PRICE {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
		ytx += linespc
		bgrec2.Y += float32(linespc)
		txt = "level 6 > " + fmt.Sprint(PLATINUM_PRICE) + " platinum > +3 dmg +2 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(currentPosition.X) - txlen/2
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if platinumnum >= PLATINUM_PRICE && levStruc == 3 {
					upWeapon(selnumWeap, 6)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if platinumnum >= PLATINUM_PRICE && levStruc < 3 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if platinumnum < PLATINUM_PRICE {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if platinumnum >= PLATINUM_PRICE {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
	} else if selweaplev == 5 { //LEVEL 5
		txt = "level 6 > " + fmt.Sprint(PLATINUM_PRICE) + " platinum > +3 dmg +2 random bonus"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(currentPosition.X) - txlen/2
		bgrec2 := rl.NewRectangle(storeRec.X, float32(ytx-4), storeRec.Width, float32(txs+8))
		if rl.CheckCollisionPointRec(cursorV2Strucs, bgrec2) {
			rl.DrawRectangleRec(bgrec2, RandColor())
			if inpL {
				if platinumnum >= PLATINUM_PRICE && levStruc == 3 {
					upWeapon(selnumWeap, 6)
					storetxT3 = fps * 2
					storetxT = 0
					storetxT2 = 0
				} else if platinumnum >= PLATINUM_PRICE && levStruc < 3 {
					rl.PlaySound(audfx[43])
					storetxT2 = fps * 2
					storetxT = 0
				} else if platinumnum < PLATINUM_PRICE {
					rl.PlaySound(audfx[43])
					storetxT2 = 0
					storetxT = fps * 2
				}
			}
		}
		if platinumnum >= PLATINUM_PRICE {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		} else {
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, DarkRed2())
		}
	} else if selweaplev == 6 {
		txt = "weapon is max level > no further upgrades"
		txlen = rl.MeasureText(txt, txs)
		xtx = int32(currentPosition.X) - txlen/2
		rl.DrawText(txt, xtx-2, ytx+2, txs, rl.White)
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)
	}

	ytx += tx5
	txs = tx4

	if storetxT > 0 {
		txt := "not enough ore > keep exploring"
		xtx2 := storeRec.ToInt32().X + 16
		ytx2 := storeRec.ToInt32().Y + 16
		rl.DrawText(txt, xtx2-1, ytx2+1, tx3, rl.Black)
		rl.DrawText(txt, xtx2, ytx2, tx3, rl.Black)
	} else if storetxT2 > 0 {
		txt := "structure not required level > upgrade with scrap"
		xtx2 := storeRec.ToInt32().X + 16
		ytx2 := storeRec.ToInt32().Y + 16
		rl.DrawText(txt, xtx2-1, ytx2+1, tx3, rl.Black)
		rl.DrawText(txt, xtx2, ytx2, tx3, rl.Black)
	} else if storetxT3 > 0 {
		txt := "weapon upgraded " + weaponUpgradeText
		xtx2 := storeRec.ToInt32().X + 16
		ytx2 := storeRec.ToInt32().Y + 16
		rl.DrawText(txt, xtx2-1, ytx2+1, tx3, rl.Black)
		rl.DrawText(txt, xtx2, ytx2, tx3, rl.Black)
	}

	//CLOSE REC
	siz2 := b2
	closerec := rl.NewRectangle(storeRec.X+storeRec.Width-siz2, storeRec.Y+bq, siz2, siz2)
	closerec.X += 16
	closerec.Y += 16
	closerec.Width -= 32
	closerec.Height -= 32
	v1 := rl.NewVector2(closerec.X, closerec.Y)
	v1.X += 8
	v1.Y += 8
	v2 := v1
	v2.X += closerec.Width - 16
	v3 := v2
	v3.Y += closerec.Width - 16
	v4 := v3
	v4.X -= closerec.Width - 16
	if rl.CheckCollisionPointRec(cursorV2Strucs, closerec) {
		rl.DrawRectangleRec(closerec, DarkRed())
		rl.DrawLineEx(v1, v3, 4, rl.Black)
		rl.DrawLineEx(v2, v4, 4, rl.Black)
		if inpL {
			rl.PlaySound(audfx[41])
			isWeaponShedOn = false
		}
	} else {
		rl.DrawRectangleRec(closerec, rl.Black)
		rl.DrawLineEx(v1, v3, 4, rl.Orange)
		rl.DrawLineEx(v2, v4, 4, rl.Orange)
	}
	if rl.IsGamepadButtonPressed(0, 6) {
		rl.PlaySound(audfx[41])
		isWeaponShedOn = false
	}

	rl.EndMode2D()

}

func drawApothecary() { //MARK:DRAW APOTHECARY

	for i := 0; i < len(bgpix); i++ {
		rec := rl.NewRectangle(bgpix[i].vector2.X, bgpix[i].vector2.Y, bgpix[i].siz, bgpix[i].siz)
		rl.DrawRectangleRec(rec, rl.Fade(bgpix[i].color, bgpix[i].fd))
		bgpix[i].vector2.X += bgpix[i].dirX
		bgpix[i].vector2.Y += bgpix[i].dirY

		if bgpix[i].vector2.X < 0 {
			bgpix[i].vector2.X = screenWidthF32
		}
		if bgpix[i].vector2.X > screenWidthF32 {
			bgpix[i].vector2.X = 0
		}
		if bgpix[i].vector2.Y < 0 {
			bgpix[i].vector2.Y = screenHeightF32
		}
		if bgpix[i].vector2.Y > screenHeightF32 {
			bgpix[i].vector2.Y = 0
		}

		if bgpix[i].fd > 0 {
			bgpix[i].fd -= 0.005
		} else {
			bgpix[i].fd = RandF32(0.5, 1)
		}
	}
	rl.BeginMode2D(camStructures)
	rl.DrawRectangleRec(storeRec, rl.Black)
	rl.DrawRectangleRec(storeRec, rl.Fade(rl.Orange, 0.7))

	if storetxT > 0 {
		if apothTxt != "" {
			xtx2 := storeRec.ToInt32().X + 16
			ytx2 := storeRec.ToInt32().Y + 16
			rl.DrawText(apothTxt, xtx2-1, ytx2+1, tx3, rl.Black)
			rl.DrawText(apothTxt, xtx2, ytx2, tx3, rl.Black)
		}
		storetxT--
	}

	apothLev := 0
	for i := 0; i < len(base.name); i++ {
		if base.name[i] == "apothecary" {
			apothLev = base.level[i]
		}
	}

	//DRAW MUSROOMS
	amethystnum, zirconnum, topaznum, rubelitenum, jadenum, larimarnum := 0, 0, 0, 0, 0, 0
	for i := 0; i < len(storeItm); i++ {
		if storeItm[i].name == "amethyst mushroom" {
			amethystnum += storeItm[i].numof
		}
		if storeItm[i].name == "zircon mushroom" {
			zirconnum += storeItm[i].numof
		}
		if storeItm[i].name == "topaz mushroom" {
			topaznum += storeItm[i].numof
		}
		if storeItm[i].name == "rubelite mushroom" {
			rubelitenum += storeItm[i].numof
		}
		if storeItm[i].name == "jade mushroom" {
			jadenum += storeItm[i].numof
		}
		if storeItm[i].name == "larimar mushroom" {
			larimarnum += storeItm[i].numof
		}
	}
	for i := 0; i < len(player.inventory); i++ {
		if player.inventory[i].name == "amethyst mushroom" {
			amethystnum += player.inventory[i].numof
		}
		if player.inventory[i].name == "zircon mushroom" {
			zirconnum += player.inventory[i].numof
		}
		if player.inventory[i].name == "topaz mushroom" {
			topaznum += player.inventory[i].numof
		}
		if player.inventory[i].name == "rubelite mushroom" {
			rubelitenum += player.inventory[i].numof
		}
		if player.inventory[i].name == "jade mushroom" {
			jadenum += player.inventory[i].numof
		}
		if player.inventory[i].name == "larimar mushroom" {
			larimarnum += player.inventory[i].numof
		}
	}
	siz := b2
	spc := float32(8)
	W := (siz + spc) * 15
	x := (currentPosition.X - W/2) - b
	xorig := x
	y := b3
	//DRAW MUSHROOMS
	for i := 0; i < 6; i++ {
		rec := rl.NewRectangle(x, y, siz, siz)
		rec2 := rec
		rec2.X -= 4
		rec2.Y += 4
		rl.DrawRectangleRec(rec2, rl.Black)
		rl.DrawRectangleRec(rec, rl.Black)
		rl.DrawRectangleRec(rec, rl.Fade(rl.DarkGray, 0.5))
		xtx := rec.ToInt32().X + rec.ToInt32().Width/2
		ytx := rec.ToInt32().Y + rec.ToInt32().Height + 4
		xtx2 := rec.ToInt32().X + rec.ToInt32().Width + 12
		ytx2 := rec.ToInt32().Y + 8
		txs := tx3
		txs2 := tx5
		txt := ""
		switch i {
		case 0:
			rl.DrawTexturePro(imgs, otherTiles[139], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[139], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "amethyst"
			rl.DrawText(fmt.Sprint(amethystnum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(amethystnum), xtx2, ytx2, txs2, rl.Black)
		case 1:
			rl.DrawTexturePro(imgs, otherTiles[140], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[140], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "zircon"
			rl.DrawText(fmt.Sprint(zirconnum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(zirconnum), xtx2, ytx2, txs2, rl.Black)
		case 2:
			rl.DrawTexturePro(imgs, otherTiles[141], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[141], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "topaz"
			rl.DrawText(fmt.Sprint(topaznum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(topaznum), xtx2, ytx2, txs2, rl.Black)
		case 3:
			rl.DrawTexturePro(imgs, otherTiles[142], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[142], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "rubelite"
			rl.DrawText(fmt.Sprint(rubelitenum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(rubelitenum), xtx2, ytx2, txs2, rl.Black)
		case 4:
			rl.DrawTexturePro(imgs, otherTiles[143], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[143], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "jade"
			rl.DrawText(fmt.Sprint(jadenum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(jadenum), xtx2, ytx2, txs2, rl.Black)
		case 5:
			rl.DrawTexturePro(imgs, otherTiles[144], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[144], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "larimar"
			rl.DrawText(fmt.Sprint(larimarnum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(larimarnum), xtx2, ytx2, txs2, rl.Black)
		}
		txlen := rl.MeasureText(txt, txs)
		xtx -= txlen / 2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		x += (siz + spc) * 2.7
	}
	//DRAW POTIONS
	y += b4
	siz = b3
	spc = float32(24)
	txt, txt2 := "", ""
	W = float32(len(potionList)/2) * (siz + spc)
	x = currentPosition.X - W/2
	x = xorig
	for i := 0; i < len(potionList); i++ {
		rec := rl.NewRectangle(x, y, siz, siz)
		if rl.CheckCollisionPointRec(cursorV2Strucs, rec) {
			txt = potionList[i].name
			rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.5))
			for j := 0; j < len(potionList[i].potionPrice); j++ {
				if potionList[i].potionPrice[j] != 0 {
					switch j {
					case 0:
						txt2 = txt2 + fmt.Sprint(potionList[i].potionPrice[j]) + " amethyst  "
					case 1:
						txt2 = txt2 + fmt.Sprint(potionList[i].potionPrice[j]) + " zircon  "
					case 2:
						txt2 = txt2 + fmt.Sprint(potionList[i].potionPrice[j]) + " topaz  "
					case 3:
						txt2 = txt2 + fmt.Sprint(potionList[i].potionPrice[j]) + " rubelite  "
					case 4:
						txt2 = txt2 + fmt.Sprint(potionList[i].potionPrice[j]) + " jade  "
					case 5:
						txt2 = txt2 + fmt.Sprint(potionList[i].potionPrice[j]) + " larimar"
					}
				}
			}
			if inpL && clickT == 0 {
				canmake := true
				for j := 0; j < len(potionList[i].potionPrice); j++ {
					if potionList[i].potionPrice[j] != 0 {
						switch j {
						case 0:
							if amethystnum < potionList[i].potionPrice[j] {
								canmake = false
							}
						case 1:
							if zirconnum < potionList[i].potionPrice[j] {
								canmake = false
							}
						case 2:
							if topaznum < potionList[i].potionPrice[j] {
								canmake = false
							}
						case 3:
							if rubelitenum < potionList[i].potionPrice[j] {
								canmake = false
							}
						case 4:
							if jadenum < potionList[i].potionPrice[j] {
								canmake = false
							}
						case 5:
							if larimarnum < potionList[i].potionPrice[j] {
								canmake = false
							}
						}
					}
				}
				if canmake {

					switch potionList[i].name {
					case "resist fire full", "resist fire half", "resist fire quarter", "resist poison full", "resist poison half", "resist poison quarter":
						if apothLev == 1 {
							canmake = false
						}
					case "invisibility full", "invisibility half", "invisibility quarter", "armor potion full", "armor potion half", "armor potion quarter":
						if apothLev == 1 || apothLev == 2 {
							canmake = false
						}
					}
					if !canmake {
						rl.PlaySound(audfx[43])
						apothTxt = "structure not required level > upgrade with scrap"
						storetxT = fps * 3
					} else {
						clickT = fps / 3
						apothTxt = makePotion(i)
						storetxT = fps * 2
					}
				} else {
					rl.PlaySound(audfx[43])
					apothTxt = "not enough mushrooms > continue exploring or use mushroom patch"
					storetxT = fps * 3
				}
			}
		} else {
			rl.DrawRectangleRec(rec, rl.Fade(rl.DarkGray, 0.7))
		}
		rl.DrawTexturePro(imgs, potionList[i].image, shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
		rl.DrawTexturePro(imgs, potionList[i].image, rec, rl.Vector2Zero(), 0, rl.White)
		x += siz + spc
		if x >= storeRec.X+storeRec.Width-(siz*2) {
			x = xorig
			y += siz + spc
		}

	}

	if txt != "" {
		txs := tx4
		txlen := rl.MeasureText(txt, txs)
		xtx := int32(currentPosition.X) - txlen/2
		ytx := int32(y) - 4
		rl.DrawText(txt, xtx-3, ytx+3, txs, rl.Magenta)
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		ytx += txs + 8
		txs = tx3
		txlen = rl.MeasureText(txt2, txs)
		xtx = int32(currentPosition.X) - txlen/2
		rl.DrawText(txt2, xtx-2, ytx+2, txs, rl.Magenta)
		rl.DrawText(txt2, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt2, xtx, ytx, txs, rl.Black)
	}

	//DRAW INK & PAPER
	inknum, papernum := 0, 0
	for i := 0; i < len(storeItm); i++ {
		if storeItm[i].name == "scroll ink" {
			inknum += storeItm[i].numof
		}
		if storeItm[i].name == "scroll paper" {
			papernum += storeItm[i].numof
		}
	}
	for i := 0; i < len(player.inventory); i++ {
		if player.inventory[i].name == "scroll ink" {
			inknum += player.inventory[i].numof
		}
		if player.inventory[i].name == "scroll paper" {
			papernum += player.inventory[i].numof
		}
	}
	siz = b2
	spc = float32(8)
	W = (siz + spc) * 15
	x = (currentPosition.X - W/2) - b
	y += b4
	for i := 0; i < 2; i++ {
		rec := rl.NewRectangle(x, y, siz, siz)
		rec2 := rec
		rec2.X -= 4
		rec2.Y += 4
		rl.DrawRectangleRec(rec2, rl.Black)
		rl.DrawRectangleRec(rec, rl.Black)
		rl.DrawRectangleRec(rec, rl.Fade(rl.DarkGray, 0.5))
		xtx := rec.ToInt32().X + rec.ToInt32().Width/2
		ytx := rec.ToInt32().Y + rec.ToInt32().Height + 4
		xtx2 := rec.ToInt32().X + rec.ToInt32().Width + 12
		ytx2 := rec.ToInt32().Y + 8
		txs := tx3
		txs2 := tx5
		txt := ""
		switch i {
		case 0:
			rl.DrawTexturePro(imgs, otherTiles[145], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[145], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "paper"
			rl.DrawText(fmt.Sprint(papernum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(papernum), xtx2, ytx2, txs2, rl.Black)
		case 1:
			rl.DrawTexturePro(imgs, otherTiles[146], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[146], rec, rl.Vector2Zero(), 0, rl.White)
			txt = "ink"
			rl.DrawText(fmt.Sprint(inknum), xtx2-1, ytx2+1, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(inknum), xtx2, ytx2, txs2, rl.Black)
		}
		txlen := rl.MeasureText(txt, txs)
		xtx -= txlen / 2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		x += (siz + spc) * 2.7
	}
	//DRAW SCROLLS
	y += b4
	siz = b3
	spc = float32(24)
	txt, txt2 = "", ""
	W = float32(len(scrollList)) * (siz + spc)
	x = currentPosition.X - W/2
	for i := 0; i < len(scrollList); i++ {
		rec := rl.NewRectangle(x, y, siz, siz)
		if rl.CheckCollisionPointRec(cursorV2Strucs, rec) {
			txt = scrollList[i].name
			txt2 = fmt.Sprint(scrollList[i].scrollprice[0]) + " paper " + fmt.Sprint(scrollList[i].scrollprice[1]) + " ink"
			rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.5))
			if inpL && clickT == 0 {
				canmake := true
				for j := 0; j < len(scrollList[i].scrollprice); j++ {
					switch j {
					case 0:
						if papernum < scrollList[i].scrollprice[j] {
							canmake = false
						}
					case 1:
						if inknum < scrollList[i].scrollprice[j] {
							canmake = false
						}
					}
				}
				if canmake {
					switch scrollList[i].name {
					case "scroll of poison gas", "scroll of detection", "scroll of home":
						if apothLev == 1 {
							canmake = false
						}
					case "scroll of frogs", "scroll of inflict", "scroll of power":
						if apothLev == 1 || apothLev == 2 {
							canmake = false
						}
					}

					if !canmake {
						rl.PlaySound(audfx[43])
						apothTxt = "structure not required level > upgrade with scrap"
						storetxT = fps * 3
					} else {
						clickT = fps / 3
						apothTxt = makeScroll(i)
						storetxT = fps * 2
					}

				} else {
					rl.PlaySound(audfx[43])
					apothTxt = "not enough scroll components > continue exploring"
					storetxT = fps * 3
				}
			}

		} else {
			rl.DrawRectangleRec(rec, rl.Fade(rl.DarkGray, 0.7))
		}
		rl.DrawTexturePro(imgs, scrollList[i].image, shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
		rl.DrawTexturePro(imgs, scrollList[i].image, rec, rl.Vector2Zero(), 0, rl.White)
		x += siz + spc
		if x >= storeRec.X+storeRec.Width-(siz*2) {
			x = xorig
			y += siz + spc
		}

	}

	if txt != "" {
		txs := tx4
		txlen := rl.MeasureText(txt, txs)
		xtx := int32(currentPosition.X) - txlen/2
		ytx := int32(y) - 10
		rl.DrawText(txt, xtx-3, ytx+3, txs, rl.Magenta)
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		ytx += txs + 8
		txs = tx3
		txlen = rl.MeasureText(txt2, txs)
		xtx = int32(currentPosition.X) - txlen/2
		rl.DrawText(txt2, xtx-2, ytx+2, txs, rl.Magenta)
		rl.DrawText(txt2, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt2, xtx, ytx, txs, rl.Black)
	}

	//CLOSE REC
	siz2 := b2
	closerec := rl.NewRectangle(storeRec.X+storeRec.Width-siz2, storeRec.Y+bq, siz2, siz2)
	closerec.X += 16
	closerec.Y += 16
	closerec.Width -= 32
	closerec.Height -= 32
	v1 := rl.NewVector2(closerec.X, closerec.Y)
	v1.X += 8
	v1.Y += 8
	v2 := v1
	v2.X += closerec.Width - 16
	v3 := v2
	v3.Y += closerec.Width - 16
	v4 := v3
	v4.X -= closerec.Width - 16
	if rl.CheckCollisionPointRec(cursorV2Strucs, closerec) {
		rl.DrawRectangleRec(closerec, DarkRed())
		rl.DrawLineEx(v1, v3, 4, rl.Black)
		rl.DrawLineEx(v2, v4, 4, rl.Black)
		if inpL {
			rl.PlaySound(audfx[41])
			isApothercaryOn = false
		}
	} else {
		rl.DrawRectangleRec(closerec, rl.Black)
		rl.DrawLineEx(v1, v3, 4, rl.Orange)
		rl.DrawLineEx(v2, v4, 4, rl.Orange)
	}
	if rl.IsGamepadButtonPressed(0, 6) {
		rl.PlaySound(audfx[41])
		isApothercaryOn = false
	}

	rl.EndMode2D()

	for i := 0; i < len(potionList); i++ {
		switch potionList[i].name {
		//POTION ANIM
		case "armor potion full":
			if frames%6 == 0 {
				potionList[i].image.X += animation[20].width
				if potionList[i].image.X > animation[20].x+animation[20].frames*animation[20].width {
					potionList[i].image.X = animation[20].x
				}
			}
		case "armor potion half":
			if frames%6 == 0 {
				potionList[i].image.X += animation[18].width
				if potionList[i].image.X > animation[18].x+animation[18].frames*animation[18].width {
					potionList[i].image.X = animation[18].x
				}
			}
		case "armor potion quarter":
			if frames%6 == 0 {
				potionList[i].image.X += animation[19].width
				if potionList[i].image.X > animation[19].x+animation[19].frames*animation[19].width {
					potionList[i].image.X = animation[19].x
				}
			}
		case "invisibility full":
			if frames%6 == 0 {
				potionList[i].image.X += animation[17].width
				if potionList[i].image.X > animation[17].x+animation[17].frames*animation[17].width {
					potionList[i].image.X = animation[17].x
				}
			}
		case "invisibility half":
			if frames%6 == 0 {
				potionList[i].image.X += animation[18].width
				if potionList[i].image.X > animation[18].x+animation[18].frames*animation[18].width {
					potionList[i].image.X = animation[18].x
				}
			}
		case "invisibility quarter":
			if frames%6 == 0 {
				potionList[i].image.X += animation[19].width
				if potionList[i].image.X > animation[19].x+animation[19].frames*animation[19].width {
					potionList[i].image.X = animation[19].x
				}
			}
		case "resist poison full":
			if frames%6 == 0 {
				potionList[i].image.X += animation[14].width
				if potionList[i].image.X > animation[14].x+animation[14].frames*animation[14].width {
					potionList[i].image.X = animation[14].x
				}
			}
		case "resist poison half":
			if frames%6 == 0 {
				potionList[i].image.X += animation[15].width
				if potionList[i].image.X > animation[15].x+animation[15].frames*animation[15].width {
					potionList[i].image.X = animation[15].x
				}
			}
		case "resist poison quarter":
			if frames%6 == 0 {
				potionList[i].image.X += animation[16].width
				if potionList[i].image.X > animation[16].x+animation[16].frames*animation[16].width {
					potionList[i].image.X = animation[16].x
				}
			}
		case "resist fire full":
			if frames%6 == 0 {
				potionList[i].image.X += animation[11].width
				if potionList[i].image.X > animation[11].x+animation[11].frames*animation[11].width {
					potionList[i].image.X = animation[11].x
				}
			}
		case "resist fire half":
			if frames%6 == 0 {
				potionList[i].image.X += animation[12].width
				if potionList[i].image.X > animation[12].x+animation[12].frames*animation[12].width {
					potionList[i].image.X = animation[12].x
				}
			}
		case "resist fire quarter":
			if frames%6 == 0 {
				potionList[i].image.X += animation[13].width
				if potionList[i].image.X > animation[13].x+animation[13].frames*animation[13].width {
					potionList[i].image.X = animation[13].x
				}
			}
		case "mana potion full":
			if frames%6 == 0 {
				potionList[i].image.X += animation[8].width
				if potionList[i].image.X > animation[8].x+animation[8].frames*animation[8].width {
					potionList[i].image.X = animation[8].x
				}
			}
		case "mana potion half":
			if frames%6 == 0 {
				potionList[i].image.X += animation[9].width
				if potionList[i].image.X > animation[9].x+animation[9].frames*animation[9].width {
					potionList[i].image.X = animation[9].x
				}
			}
		case "mana potion quarter":
			if frames%6 == 0 {
				potionList[i].image.X += animation[10].width
				if potionList[i].image.X > animation[10].x+animation[10].frames*animation[10].width {
					potionList[i].image.X = animation[10].x
				}
			}
		case "hp potion full":
			if frames%6 == 0 {
				potionList[i].image.X += animation[5].width
				if potionList[i].image.X > animation[5].x+animation[5].frames*animation[5].width {
					potionList[i].image.X = animation[5].x
				}
			}
		case "hp potion half":
			if frames%6 == 0 {
				potionList[i].image.X += animation[6].width
				if potionList[i].image.X > animation[6].x+animation[6].frames*animation[6].width {
					potionList[i].image.X = animation[6].x
				}
			}
		case "hp potion quarter":
			if frames%6 == 0 {
				potionList[i].image.X += animation[7].width
				if potionList[i].image.X > animation[7].x+animation[7].frames*animation[7].width {
					potionList[i].image.X = animation[7].x
				}
			}
		}
	}

}

func drawcredits() { //MARK:DRAW CREDITS

	txlen := rl.MeasureText("thanks to all these people...", tx5)
	x := int32(currentPosition.X) - txlen/2
	y := tx4
	rl.DrawText("thanks to all these people...", x-4, y+4, tx5, rl.Yellow)
	rl.DrawText("thanks to all these people...", x-2, y+2, tx5, rl.Black)
	rl.DrawText("thanks to all these people...", x, y, tx5, rl.Magenta)

	xtx := int32(storeRec.X)
	xorig := xtx
	ytx := int32(y) + tx7
	txs := tx3

	for i := 0; i < len(creditList); i++ {
		txlen = rl.MeasureText(creditList[i], txs)
		if xtx+txlen > int32(storeRec.X+storeRec.Width) {
			ytx += txs + txs/3
			xtx = xorig
		}
		rl.DrawText(creditList[i], xtx-2, ytx+2, txs, rl.Magenta)
		rl.DrawText(creditList[i], xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(creditList[i], xtx, ytx, txs, rl.White)
		xtx += txlen + txs*2
	}

	if clickT == 0 {
		if inpL || inpR {

			if endgameclose {
				if isStoreUnlocked {
					savestore()
				}
				rl.StopMusicStream(music[currentMusic])
				rl.EndMode2D()
				rl.EndTextureMode()
				rl.EndShaderMode()
				rl.EndDrawing()
				unload()
				rl.CloseAudioDevice()
				rl.CloseWindow()
				os.Exit(0)
			} else {
				credits = false
			}
		}
	}

}

func drawBook() { //MARK:DRAW BOOK
	for i := 0; i < len(bgpix); i++ {
		rec := rl.NewRectangle(bgpix[i].vector2.X, bgpix[i].vector2.Y, bgpix[i].siz, bgpix[i].siz)
		rl.DrawRectangleRec(rec, rl.Fade(bgpix[i].color, bgpix[i].fd))
		bgpix[i].vector2.X += bgpix[i].dirX
		bgpix[i].vector2.Y += bgpix[i].dirY

		if bgpix[i].vector2.X < 0 {
			bgpix[i].vector2.X = screenWidthF32
		}
		if bgpix[i].vector2.X > screenWidthF32 {
			bgpix[i].vector2.X = 0
		}
		if bgpix[i].vector2.Y < 0 {
			bgpix[i].vector2.Y = screenHeightF32
		}
		if bgpix[i].vector2.Y > screenHeightF32 {
			bgpix[i].vector2.Y = 0
		}

		if bgpix[i].fd > 0 {
			bgpix[i].fd -= 0.005
		} else {
			bgpix[i].fd = RandF32(0.5, 1)
		}
	}

	txt := ""
	txt2 := ""
	txtT := int32(0)

	numW := float32(14)
	numH := float32(9)
	spc := float32(12)
	H := screenHeightF32 - b2
	siz := H / numH
	W := siz * numW
	siz -= spc
	cntr := rl.NewVector2(screenWidthF32/2, screenHeightF32/2)
	xl2 := cntr.X - W/2
	yt := cntr.Y - H/2
	yt += b
	if large {
		yt += b
	}
	if xxl || xl {
		yt += b2
	}
	xr := xl2 + W

	x := xl2
	y := yt
	count := float32(0)

	//CLOSE REC
	siz2 := b2 + b/2
	if xxl {
		siz2 = b3
	}
	if medium {
		siz2 = b2
	}
	closerec := rl.NewRectangle(xr-siz2, 2, siz2, siz2)
	closerec.X += 16
	closerec.Y += 16
	closerec.Width -= 32
	closerec.Height -= 32
	v1 := rl.NewVector2(closerec.X, closerec.Y)
	v1.X += 8
	v1.Y += 8
	v2 := v1
	v2.X += closerec.Width - 16
	v3 := v2
	v3.Y += closerec.Width - 16
	v4 := v3
	v4.X -= closerec.Width - 16
	if rl.CheckCollisionPointRec(cursorV2, closerec) {
		rl.DrawRectangleRec(closerec, DarkRed())
		rl.DrawLineEx(v1, v3, 4, rl.Black)
		rl.DrawLineEx(v2, v4, 4, rl.Black)
		if inpL {
			rl.PlaySound(audfx[41])
			upunlocks()
			isBookOn = false
		}
	} else {
		rl.DrawRectangleRec(closerec, rl.Magenta)
		rl.DrawLineEx(v1, v3, 4, rl.Black)
		rl.DrawLineEx(v2, v4, 4, rl.Black)
	}
	if rl.IsGamepadButtonPressed(0, 6) {
		rl.PlaySound(audfx[41])
		upunlocks()
		isBookOn = false
	}
	//BG RECS
	for i := 0; i < crateItmLen; i++ {
		rec := rl.NewRectangle(x, y, siz, siz)
		rl.DrawRectangleRec(rec, rl.Black)
		rl.DrawRectangleRec(rec, rl.Fade(rl.DarkPurple, 0.1))
		rl.DrawRectangleLinesEx(rec, 2, rl.Magenta)
		x += siz + spc
		count++
		if count == numW {
			count = 0
			x = xl2
			y += siz + spc
		}
	}

	//COOK BOOK
	foundCookbook := false
	for i := 0; i < len(player.inventory); i++ {
		if player.inventory[i].name == "cook book" {
			foundCookbook = true
			break
		}
	}
	if !foundCookbook {
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].name == "cook book" {
				foundCookbook = true
				break
			}
		}
	}

	x = xl2
	y = yt
	count = float32(0)
	//UNLOCKED
	for i := 0; i < len(itemList); i++ {
		if !itemList[i].isNoCrate {
			if itemList[i].isUnlocked {
				rec := rl.NewRectangle(x, y, siz, siz)
				rec.X += 2
				rec.Y += 2
				rec.Width -= 4
				rec.Height -= 4
				rl.DrawTexturePro(imgs, itemList[i].image, shrec(rec, 7), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, itemList[i].image, rec, rl.Vector2Zero(), 0, rl.White)

				//POTION ANIM
				switch itemList[i].name {
				//ANIM
				case "armor potion full":
					if frames%6 == 0 {
						itemList[i].image.X += animation[20].width
						if itemList[i].image.X > animation[20].x+animation[20].frames*animation[20].width {
							itemList[i].image.X = animation[20].x
						}
					}
				case "armor potion half":
					if frames%6 == 0 {
						itemList[i].image.X += animation[18].width
						if itemList[i].image.X > animation[18].x+animation[18].frames*animation[18].width {
							itemList[i].image.X = animation[18].x
						}
					}
				case "armor potion quarter":
					if frames%6 == 0 {
						itemList[i].image.X += animation[19].width
						if itemList[i].image.X > animation[19].x+animation[19].frames*animation[19].width {
							itemList[i].image.X = animation[19].x
						}
					}
				case "invisibility full":
					if frames%6 == 0 {
						itemList[i].image.X += animation[17].width
						if itemList[i].image.X > animation[17].x+animation[17].frames*animation[17].width {
							itemList[i].image.X = animation[17].x
						}
					}
				case "invisibility half":
					if frames%6 == 0 {
						itemList[i].image.X += animation[18].width
						if itemList[i].image.X > animation[18].x+animation[18].frames*animation[18].width {
							itemList[i].image.X = animation[18].x
						}
					}
				case "invisibility quarter":
					if frames%6 == 0 {
						itemList[i].image.X += animation[19].width
						if itemList[i].image.X > animation[19].x+animation[19].frames*animation[19].width {
							itemList[i].image.X = animation[19].x
						}
					}
				case "resist poison full":
					if frames%6 == 0 {
						itemList[i].image.X += animation[14].width
						if itemList[i].image.X > animation[14].x+animation[14].frames*animation[14].width {
							itemList[i].image.X = animation[14].x
						}
					}
				case "resist poison half":
					if frames%6 == 0 {
						itemList[i].image.X += animation[15].width
						if itemList[i].image.X > animation[15].x+animation[15].frames*animation[15].width {
							itemList[i].image.X = animation[15].x
						}
					}
				case "resist poison quarter":
					if frames%6 == 0 {
						itemList[i].image.X += animation[16].width
						if itemList[i].image.X > animation[16].x+animation[16].frames*animation[16].width {
							itemList[i].image.X = animation[16].x
						}
					}
				case "resist fire full":
					if frames%6 == 0 {
						itemList[i].image.X += animation[11].width
						if itemList[i].image.X > animation[11].x+animation[11].frames*animation[11].width {
							itemList[i].image.X = animation[11].x
						}
					}
				case "resist fire half":
					if frames%6 == 0 {
						itemList[i].image.X += animation[12].width
						if itemList[i].image.X > animation[12].x+animation[12].frames*animation[12].width {
							itemList[i].image.X = animation[12].x
						}
					}
				case "resist fire quarter":
					if frames%6 == 0 {
						itemList[i].image.X += animation[13].width
						if itemList[i].image.X > animation[13].x+animation[13].frames*animation[13].width {
							itemList[i].image.X = animation[13].x
						}
					}
				case "mana potion full":
					if frames%6 == 0 {
						itemList[i].image.X += animation[8].width
						if itemList[i].image.X > animation[8].x+animation[8].frames*animation[8].width {
							itemList[i].image.X = animation[8].x
						}
					}
				case "mana potion half":
					if frames%6 == 0 {
						itemList[i].image.X += animation[9].width
						if itemList[i].image.X > animation[9].x+animation[9].frames*animation[9].width {
							itemList[i].image.X = animation[9].x
						}
					}
				case "mana potion quarter":
					if frames%6 == 0 {
						itemList[i].image.X += animation[10].width
						if itemList[i].image.X > animation[10].x+animation[10].frames*animation[10].width {
							itemList[i].image.X = animation[10].x
						}
					}
				case "hp potion full":
					if frames%6 == 0 {
						itemList[i].image.X += animation[5].width
						if itemList[i].image.X > animation[5].x+animation[5].frames*animation[5].width {
							itemList[i].image.X = animation[5].x
						}
					}
				case "hp potion half":
					if frames%6 == 0 {
						itemList[i].image.X += animation[6].width
						if itemList[i].image.X > animation[6].x+animation[6].frames*animation[6].width {
							itemList[i].image.X = animation[6].x
						}
					}
				case "hp potion quarter":
					if frames%6 == 0 {
						itemList[i].image.X += animation[7].width
						if itemList[i].image.X > animation[7].x+animation[7].frames*animation[7].width {
							itemList[i].image.X = animation[7].x
						}
					}
				}

				//CURSOR
				if rl.CheckCollisionPointRec(cursorV2, rec) {
					txtT = fps * 2
					txt = itemList[i].name
					txt2 = "unlocked"
				}

				x += siz + spc
				count++
				if count == numW {
					count = 0
					x = xl2
					y += siz + spc
				}
			}
		}
	}
	//LOCKED
	foundLowerPrice := false
	currentItmNum := blankint
	for i := 0; i < len(itemList); i++ {
		if !itemList[i].isNoCrate {
			if !itemList[i].isUnlocked {
				rec := rl.NewRectangle(x, y, siz, siz)
				rec.X += 2
				rec.Y += 2
				rec.Width -= 4
				rec.Height -= 4
				if player.xp >= itemList[i].price {
					foundLowerPrice = true
					rec = rl.NewRectangle(x, y, siz, siz)
					if medium {
						rl.DrawRectangleLinesEx(rec, 4, RandColor())
					} else {
						rl.DrawRectangleLinesEx(rec, 8, RandColor())
					}

					rl.DrawTexturePro(imgs, itemList[i].image, rec, rl.Vector2Zero(), 0, rl.White)
					rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.3))
				} else {
					if foundCookbook && itemList[i].price <= 100 {
						rec = rl.NewRectangle(x, y, siz, siz)
						if medium {
							rl.DrawRectangleLinesEx(rec, 4, RandColor())
						} else {
							rl.DrawRectangleLinesEx(rec, 8, RandColor())
						}
						rl.DrawTexturePro(imgs, itemList[i].image, rec, rl.Vector2Zero(), 0, rl.White)
						rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.3))
					} else {
						rl.DrawTexturePro(imgs, itemList[i].image, rec, rl.Vector2Zero(), 0, rl.White)
						rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.8))
					}
				}
				//CURSOR
				if rl.CheckCollisionPointRec(cursorV2, rec) {
					txtT = fps * 2
					txt = itemList[i].name
					txt2 = fmt.Sprint(itemList[i].price) + "xp to unlock"
					currentItmNum = i
					if player.xp >= itemList[i].price && clickT == 0 && !itemList[i].isUnlocked && inpL {
						rl.PlaySound(audfx[44])
						clickT = fps / 4
						itemList[i].isUnlocked = true
						if foundCookbook && itemList[i].price <= 100 {
							found := false
							for i := 0; i < len(player.inventory); i++ {
								if player.inventory[i].name == "cook book" {
									found = true
									foundCookbook = false
									if player.inventory[i].numof > 1 {
										player.inventory[i].numof--
									} else {
										player.inventory[i] = Item{}
									}
									break
								}
							}
							if !found {
								for i := 0; i < len(storeItm); i++ {
									if storeItm[i].name == "cook book" {
										found = true
										foundCookbook = false
										if storeItm[i].numof > 1 {
											storeItm[i].numof--
										} else {
											storeItm[i] = Item{}
										}
										break
									}
								}
							}
						} else {
							player.xp -= itemList[i].price
						}
					} else if player.xp < itemList[i].price && clickT == 0 && !itemList[i].isUnlocked && foundCookbook && inpL {
						rl.PlaySound(audfx[44])
						clickT = fps / 4
						itemList[i].isUnlocked = true
						if foundCookbook && itemList[i].price <= 100 {
							found := false
							for i := 0; i < len(player.inventory); i++ {
								if player.inventory[i].name == "cook book" {
									found = true
									foundCookbook = false
									if player.inventory[i].numof > 1 {
										player.inventory[i].numof--
									} else {
										player.inventory[i] = Item{}
									}
									break
								}
							}
							if !found {
								for i := 0; i < len(storeItm); i++ {
									if storeItm[i].name == "cook book" {
										found = true
										foundCookbook = false
										if storeItm[i].numof > 1 {
											storeItm[i].numof--
										} else {
											storeItm[i] = Item{}
										}
										break
									}
								}
							}
						}
					} else if inpL {
						rl.PlaySound(audfx[43])
					}
				}
				x += siz + spc
				count++
				if count == numW {
					count = 0
					x = xl2
					y += siz + spc
				}
			}
		}
	}

	//TOP TXT
	txs := tx5
	if xxl {
		txs = tx7
	}
	if large {
		txs = tx4
	}
	if medium {
		txs = tx2
	}
	xtx := int32(xl2)
	ytx := int32(20)
	if txtT > 0 && txt != "" {
		rl.DrawText(txt, xtx, ytx, txs, rl.White)
		txlen := rl.MeasureText(txt, txs)
		txlen += txs
		xtx += txlen
		if txt2 == "unlocked" {
			rl.DrawText(txt2, xtx, ytx, txs, rl.Green)
		} else {
			if currentItmNum != blankint {
				if player.xp >= itemList[currentItmNum].price {
					rl.DrawText(txt2, xtx, ytx, txs, rl.Green)
				} else {
					rl.DrawText(txt2, xtx, ytx, txs, rl.Red)
				}
			} else {
				rl.DrawText(txt2, xtx, ytx, txs, rl.Red)
			}

		}
	}

	//PLAYER XP
	ytx = int32(20)
	txt = fmt.Sprint(player.xp) + "xp to spend"
	if foundCookbook {
		txt = txt + " + cook book"
	}
	txtlen := rl.MeasureText(txt, txs)
	xtx = int32(xr-spc) - txtlen
	xtx -= int32(siz2 + b/4)
	rl.DrawText(txt, xtx-3, ytx+3, txs, rl.Magenta)
	rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
	rl.DrawText(txt, xtx-1, ytx+1, txs, rl.White)
	rl.DrawText(txt, xtx, ytx, txs, rl.White)

	ytx = screenHeight32 - (txs + txs/2)
	if !foundLowerPrice {
		txt = "not enough xp to unlock > kill some enemies..."
		txtlen = rl.MeasureText(txt, txs)
		xtx = int32(cntr.X) - txtlen/2
		rl.DrawText(txt, xtx, ytx, txs, DarkRed())
	} else {
		txt = "unlocked items will drop from crates"
		txtlen = rl.MeasureText(txt, txs)
		xtx = int32(cntr.X) - txtlen/2
		rl.DrawText(txt, xtx, ytx, txs, rl.Green)
	}

}
func drawStore() { //MARK:DRAW STORE ROOM
	findnextstoreslotnum()
	if invDisTxtT > 0 {
		invDisTxtT--
	}
	if invInfoT > 0 {
		invInfoT--
	}
	if storetxT > 0 {
		storetxT--
	}
	txt := ""

	for i := 0; i < len(bgpix); i++ {
		rec := rl.NewRectangle(bgpix[i].vector2.X, bgpix[i].vector2.Y, bgpix[i].siz, bgpix[i].siz)
		rl.DrawRectangleRec(rec, rl.Fade(bgpix[i].color, bgpix[i].fd))
		bgpix[i].vector2.X += bgpix[i].dirX
		bgpix[i].vector2.Y += bgpix[i].dirY

		if bgpix[i].vector2.X < 0 {
			bgpix[i].vector2.X = screenWidthF32
		}
		if bgpix[i].vector2.X > screenWidthF32 {
			bgpix[i].vector2.X = 0
		}
		if bgpix[i].vector2.Y < 0 {
			bgpix[i].vector2.Y = screenHeightF32
		}
		if bgpix[i].vector2.Y > screenHeightF32 {
			bgpix[i].vector2.Y = 0
		}

		if bgpix[i].fd > 0 {
			bgpix[i].fd -= 0.005
		} else {
			bgpix[i].fd = RandF32(0.5, 1)
		}
	}
	rl.BeginMode2D(camStructures)
	//MARK: DRAW STORE ROOM INVEN INFO
	if invenInfo {

		invInfoT++
		if invInfoT > fps*2 {
			invInfoT = fps
		}
		//BG REC
		rl.DrawRectangleRec(optionsRec, rl.Magenta)
		bgtxrec := rl.NewRectangle(optionsRec.X, optionsRec.Y+b/2, optionsRec.Width, b2+b/4)
		rl.DrawRectangleRec(bgtxrec, rl.Orange)
		rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
		closeY := bgtxrec.Y
		closeH := bgtxrec.Height
		//IMG
		irec := rl.NewRectangle(optionsRec.X+optionsRec.Width/4, b3+b/2, optionsRec.Width/2, optionsRec.Width/2)
		rl.DrawRectangleRec(irec, rl.Fade(rl.Black, 0.8))
		rl.DrawRectangleLinesEx(irec, 8, rl.Black)
		irec.X += b
		irec.Y += b
		irec.Width -= b2
		irec.Height -= b2

		if inMenuOn2 {

			rl.DrawTexturePro(imgs, player.inventory[inMenuItm].image, shrec(irec, 8), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, player.inventory[inMenuItm].image, irec, rl.Vector2Zero(), 0, rl.White)
			//TITLE TX
			txs := tx4
			txlen := rl.MeasureText(player.inventory[inMenuItm].name, txs)
			xtx := int32(currentPosition.X) - txlen/2
			ytx := bgtxrec.ToInt32().Y + bgtxrec.ToInt32().Height/2 - txs/2
			rl.DrawText(player.inventory[inMenuItm].name, xtx, ytx, txs, rl.Black)

			//DESC
			txs = tx4
			txlen = rl.MeasureText(player.inventory[inMenuItm].des, txs)
			xtx = int32(currentPosition.X) - txlen/2
			ytx = irec.ToInt32().Y + irec.ToInt32().Height + tx6
			bgtxrec.Y = float32(ytx) - 4
			bgtxrec.Height = float32(txs) + 12
			rl.DrawRectangleRec(bgtxrec, rl.Orange)
			rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
			rl.DrawText(player.inventory[inMenuItm].des, xtx, ytx, txs, rl.Black)

			bgtxrec = rl.NewRectangle(optionsRec.X, bgtxrec.Y+bgtxrec.Height+b/2, optionsRec.Width, b10+b/2)
			rl.DrawRectangleRec(bgtxrec, rl.Black)
			rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Orange)
			rl.DrawText(">> more info...", optionsRec.ToInt32().X+tx3, bgtxrec.ToInt32().Y+tx, tx5, rl.Orange)

			txs = tx2
			ytx = int32(bgtxrec.Y) + tx5

			//DESC
			if player.inventory[inMenuItm].des2 != "" {
				txlen := rl.MeasureText(player.inventory[inMenuItm].des2, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(player.inventory[inMenuItm].des2, xtx, ytx, txs, rl.Yellow)
			}
			if player.inventory[inMenuItm].des3 != "" {
				txlen := rl.MeasureText(player.inventory[inMenuItm].des3, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(player.inventory[inMenuItm].des3, xtx, ytx, txs, rl.Yellow)
			}
			if player.inventory[inMenuItm].des4 != "" {
				txlen := rl.MeasureText(player.inventory[inMenuItm].des4, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(player.inventory[inMenuItm].des4, xtx, ytx, txs, rl.Yellow)
			}
			if player.inventory[inMenuItm].des5 != "" {
				txlen := rl.MeasureText(player.inventory[inMenuItm].des5, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(player.inventory[inMenuItm].des5, xtx, ytx, txs, rl.Yellow)
			}
			if player.inventory[inMenuItm].des6 != "" {
				txlen := rl.MeasureText(player.inventory[inMenuItm].des6, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(player.inventory[inMenuItm].des6, xtx, ytx, txs, rl.Yellow)
			}
			if player.inventory[inMenuItm].des7 != "" {
				txlen := rl.MeasureText(player.inventory[inMenuItm].des7, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(player.inventory[inMenuItm].des7, xtx, ytx, txs, rl.Yellow)
			}

		} else if inMenuOn {
			rl.DrawTexturePro(imgs, storeItm[inMenuItm].image, shrec(irec, 8), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, storeItm[inMenuItm].image, irec, rl.Vector2Zero(), 0, rl.White)
			//TITLE TX
			txs := tx4
			txlen := rl.MeasureText(storeItm[inMenuItm].name, txs)
			xtx := int32(currentPosition.X) - txlen/2
			ytx := bgtxrec.ToInt32().Y + bgtxrec.ToInt32().Height/2 - txs/2
			rl.DrawText(storeItm[inMenuItm].name, xtx, ytx, txs, rl.Black)

			//DESC
			txs = tx4
			txlen = rl.MeasureText(storeItm[inMenuItm].des, txs)
			xtx = int32(currentPosition.X) - txlen/2
			ytx = irec.ToInt32().Y + irec.ToInt32().Height + tx6
			bgtxrec.Y = float32(ytx) - 4
			bgtxrec.Height = float32(txs) + 12
			rl.DrawRectangleRec(bgtxrec, rl.Orange)
			rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
			rl.DrawText(storeItm[inMenuItm].des, xtx, ytx, txs, rl.Black)

			bgtxrec = rl.NewRectangle(optionsRec.X, bgtxrec.Y+bgtxrec.Height+b/2, optionsRec.Width, b10+b/2)
			rl.DrawRectangleRec(bgtxrec, rl.Black)
			rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Orange)
			rl.DrawText(">> more info...", optionsRec.ToInt32().X+tx3, bgtxrec.ToInt32().Y+tx, tx5, rl.Orange)

			txs = tx2
			ytx = int32(bgtxrec.Y) + tx5

			//DESC
			if storeItm[inMenuItm].des2 != "" {
				txlen := rl.MeasureText(storeItm[inMenuItm].des2, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(storeItm[inMenuItm].des2, xtx, ytx, txs, rl.Yellow)
			}
			if storeItm[inMenuItm].des3 != "" {
				txlen := rl.MeasureText(storeItm[inMenuItm].des3, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(storeItm[inMenuItm].des3, xtx, ytx, txs, rl.Yellow)
			}
			if storeItm[inMenuItm].des4 != "" {
				txlen := rl.MeasureText(storeItm[inMenuItm].des4, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(storeItm[inMenuItm].des4, xtx, ytx, txs, rl.Yellow)
			}
			if storeItm[inMenuItm].des5 != "" {
				txlen := rl.MeasureText(storeItm[inMenuItm].des5, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(storeItm[inMenuItm].des5, xtx, ytx, txs, rl.Yellow)
			}
			if storeItm[inMenuItm].des6 != "" {
				txlen := rl.MeasureText(storeItm[inMenuItm].des6, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(storeItm[inMenuItm].des6, xtx, ytx, txs, rl.Yellow)
			}
			if storeItm[inMenuItm].des7 != "" {
				txlen := rl.MeasureText(storeItm[inMenuItm].des7, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(storeItm[inMenuItm].des7, xtx, ytx, txs, rl.Yellow)
			}
		}

		//EXIT
		if inpR {
			invenInfo = false
			weapInfon = false
			inMenuOn = false
			inMenuOn2 = false
			inWeapMenuOn = false
		}
		//CLOSE REC
		siz2 := closeH
		closerec := rl.NewRectangle(optionsRec.X+optionsRec.Width-siz2, closeY, siz2, siz2)
		closerec.X += 16
		closerec.Y += 16
		closerec.Width -= 32
		closerec.Height -= 32
		v1 := rl.NewVector2(closerec.X, closerec.Y)
		v1.X += 8
		v1.Y += 8
		v2 := v1
		v2.X += closerec.Width - 16
		v3 := v2
		v3.Y += closerec.Width - 16
		v4 := v3
		v4.X -= closerec.Width - 16
		if rl.CheckCollisionPointRec(cursorV2camInven, closerec) {
			rl.DrawRectangleRec(closerec, DarkRed())
			rl.DrawLineEx(v1, v3, 4, rl.Black)
			rl.DrawLineEx(v2, v4, 4, rl.Black)
			if clickT == 0 {
				if inpL {
					rl.PlaySound(audfx[41])
					clickT = fps / 4
					invInfoT = fps / 2
					weapInfon = false
					invenInfo = false
					inMenuOn = false
					inMenuOn2 = false
					inWeapMenuOn = false
				}
			}
		} else {
			rl.DrawRectangleRec(closerec, rl.Black)
			rl.DrawLineEx(v1, v3, 4, rl.Orange)
			rl.DrawLineEx(v2, v4, 4, rl.Orange)
		}
	} else {
		rl.DrawRectangleRec(storeRec, rl.Fade(rl.Magenta, 0.9))
		bgtxrec := rl.NewRectangle(storeRec.X, storeRec.Y+b/2, storeRec.Width, b2+b/4)
		rl.DrawRectangleRec(bgtxrec, rl.Orange)
		rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
		rl.DrawText(">> inventory", storeRec.ToInt32().X+tx3-1, bgtxrec.ToInt32().Y+9, tx5, rl.Black)
		rl.DrawText(">> inventory", storeRec.ToInt32().X+tx3, bgtxrec.ToInt32().Y+8, tx5, rl.Black)
		//CLOSE REC
		siz2 := bgtxrec.Height
		closerec := rl.NewRectangle(storeRec.X+storeRec.Width-siz2, bgtxrec.Y, siz2, siz2)
		closerec.X += 16
		closerec.Y += 16
		closerec.Width -= 32
		closerec.Height -= 32
		v1 := rl.NewVector2(closerec.X, closerec.Y)
		v1.X += 8
		v1.Y += 8
		v2 := v1
		v2.X += closerec.Width - 16
		v3 := v2
		v3.Y += closerec.Width - 16
		v4 := v3
		v4.X -= closerec.Width - 16
		if rl.CheckCollisionPointRec(cursorV2Strucs, closerec) {
			rl.DrawRectangleRec(closerec, DarkRed())
			rl.DrawLineEx(v1, v3, 4, rl.Black)
			rl.DrawLineEx(v2, v4, 4, rl.Black)
			if invInfoT == 0 {
				if clickT == 0 {
					if inpL {
						rl.PlaySound(audfx[41])
						isStoreOn = false
					}
				}
			}
		} else {
			rl.DrawRectangleRec(closerec, rl.Black)
			rl.DrawLineEx(v1, v3, 4, rl.Orange)
			rl.DrawLineEx(v2, v4, 4, rl.Orange)
		}
		if rl.IsGamepadButtonPressed(0, 6) {
			rl.PlaySound(audfx[41])
			isStoreOn = false
		}
		//INVEN
		siz := b2
		x := storeRec.X + bq3
		y := bgtxrec.Y + bgtxrec.Height + b
		spc := float32(4)
		for i := 0; i < len(player.inventory); i++ {
			rec := rl.NewRectangle(x, y, siz, siz)
			if rl.CheckCollisionPointRec(cursorV2Strucs, rec) {
				rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.7))
				if player.inventory[i].name != "" {
					storetxT = fps * 2
					txt = player.inventory[i].name
					if inpL && !inMenuOn2 { //MOVE INVEN TO STORE
						found := false
						for j := 0; j < len(storeItm); j++ {
							if storeItm[j].name == player.inventory[i].name {
								rl.PlaySound(audfx[18])
								storeItm[j].numof += player.inventory[i].numof
								player.inventory[i] = Item{}
								found = true
								break
							}
						}
						if !found {
							for j := 0; j < len(storeItm); j++ {
								if storeItm[j].name == "" {
									rl.PlaySound(audfx[18])
									storeItm[j] = player.inventory[i]
									player.inventory[i] = Item{}
									found = true
									break
								}
							}
						}
						if !found {
							rl.PlaySound(audfx[43])
							storetxT = fps * 2
							txt = "no more space in store room"
						}
					}

					//MENU
					if clickT == 0 {
						if inpR && !inMenuOn2 {
							rl.PlaySound(audfx[44])
							clickT = fps / 4
							inMenuOn2 = true
							siz2 := (siz + spc) * 2
							siz2 -= spc
							inMenuRec = rl.NewRectangle(rec.X+rec.Width+spc, rec.Y, siz2, siz2)
							if player.inventory[i].numof == 1 {
								inMenuRec.Height -= siz / 2
							}
							if cursorV2.X > currentPosition.X+siz2 {
								inMenuRec.X -= siz2 + siz + spc
							}
							inMenuItm = i
						}
					}

				}
			} else {
				rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
			}
			rl.DrawRectangleLinesEx(rec, 4, rl.Fade(rl.Purple, 0.7))
			if player.inventory[i].name != "" {
				rl.DrawTexturePro(imgs, player.inventory[i].image, shrec(rec, 7), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, player.inventory[i].image, rec, rl.Vector2Zero(), 0, rl.White)
				if player.inventory[i].numof > 1 {
					txlen := rl.MeasureText(fmt.Sprint(player.inventory[i].numof), tx2)
					xtx := int32(rec.X+rec.Width) - (txlen + 4)
					ytx := int32(rec.Y+rec.Height) - tx2
					rl.DrawText(fmt.Sprint(player.inventory[i].numof), xtx-2, ytx+2, tx2, rl.Black)
					rl.DrawText(fmt.Sprint(player.inventory[i].numof), xtx, ytx, tx2, rl.Gold)
				}
			}
			x += siz + spc
			if x+siz >= storeRec.X+storeRec.Width-b {
				x = storeRec.X + bq3
				y += siz + spc
			}
		}
		//QUIK SLOTS
		y += spc * 3
		x = storeRec.X + bq3
		for i := 0; i < len(player.quik); i++ {
			rec := rl.NewRectangle(x, y, siz, siz)
			if rl.CheckCollisionPointRec(cursorV2Strucs, rec) {
				rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.7))
				if player.quik[i].name != "" {
					storetxT = fps * 2
					txt = player.quik[i].name
					if inpL && !inMenuOn2 {
						found := false
						for j := 0; j < len(storeItm); j++ { //MOVE QUIK TO STORE
							if storeItm[j].name == player.quik[i].name {
								rl.PlaySound(audfx[18])
								storeItm[j].numof += player.quik[i].numof
								player.quik[i] = Item{}
								found = true
								break
							}
						}
						if !found {
							for j := 0; j < len(storeItm); j++ {
								if storeItm[j].name == "" {
									rl.PlaySound(audfx[18])
									storeItm[j] = player.quik[i]
									player.quik[i] = Item{}
									found = true
									break
								}
							}
						}
						if !found {
							rl.PlaySound(audfx[43])
							storetxT = fps * 2
							txt = "no more space in store room"
						}
					}
				}
			} else {
				rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
			}
			rl.DrawRectangleLinesEx(rec, 4, rl.Fade(rl.Purple, 0.7))
			if player.quik[i].name != "" {
				rl.DrawTexturePro(imgs, player.quik[i].image, shrec(rec, 7), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, player.quik[i].image, rec, rl.Vector2Zero(), 0, rl.White)
				if player.quik[i].numof > 1 {
					txlen := rl.MeasureText(fmt.Sprint(player.quik[i].numof), tx2)
					xtx := int32(rec.X+rec.Width) - (txlen + 4)
					ytx := int32(rec.Y+rec.Height) - tx2
					rl.DrawText(fmt.Sprint(player.quik[i].numof), xtx-2, ytx+2, tx2, rl.Black)
					rl.DrawText(fmt.Sprint(player.quik[i].numof), xtx, ytx, tx2, rl.Gold)
				}
			}
			x += siz + spc
			if x+siz >= storeRec.X+storeRec.Width-b {
				x = storeRec.X + bq3
				y += siz + spc
			}
		}
		xtx := int32(x + b/2)
		ytx := int32(y + 4)
		rl.DrawText("<< quick slots", xtx-1, ytx+1, tx5, rl.Black)
		rl.DrawText("<< quick slots", xtx, ytx, tx5, rl.Black)

		//STORE ALL
		txt3 := "store all"
		txlen := rl.MeasureText(txt3, tx3)
		W2 := float32(txlen) + b2
		x = storeRec.X + storeRec.Width - W2 - b
		rec3 := rl.NewRectangle(x, y+b/2, W2, b+b/2)
		if rl.CheckCollisionPointRec(cursorV2Strucs, rec3) {
			rl.DrawRectangleRec(rec3, DarkRed())
			rl.DrawRectangleLinesEx(rec3, 4, rl.Black)
			xtx = ((rec3.ToInt32().X + rec3.ToInt32().Width/2) - txlen/2)
			ytx = rec3.ToInt32().Y + rec3.ToInt32().Height/2 - tx3/2
			rl.DrawText(txt3, xtx, ytx, tx3, rl.White)
			if inpL {
				rl.PlaySound(audfx[18])
				for i := 0; i < len(player.inventory); i++ {
					found := false
					for j := 0; j < len(storeItm); j++ {
						if storeItm[j].name == player.inventory[i].name {
							storeItm[j].numof += player.inventory[i].numof
							player.inventory[i] = Item{}
							found = true
							break
						}
					}
					if !found {
						for j := 0; j < len(storeItm); j++ {
							if storeItm[j].name == "" {
								storeItm[j] = player.inventory[i]
								player.inventory[i] = Item{}
								found = true
								break
							}
						}
					}
					if !found {
						rl.PlaySound(audfx[43])
						storetxT = fps * 2
						txt = "no more space in store room"
					}
				}
			}
		} else {
			rl.DrawRectangleRec(rec3, rl.Orange)
			rl.DrawRectangleLinesEx(rec3, 4, rl.Black)
			xtx = ((rec3.ToInt32().X + rec3.ToInt32().Width/2) - txlen/2)
			ytx = rec3.ToInt32().Y + rec3.ToInt32().Height/2 - tx3/2
			rl.DrawText(txt3, xtx-1, ytx+1, tx3, rl.Black)
			rl.DrawText(txt3, xtx, ytx, tx3, rl.Black)
		}

		//STORE
		bgtxrec = rl.NewRectangle(storeRec.X, y+b3, storeRec.Width, b2+b/4)
		rl.DrawRectangleRec(bgtxrec, rl.Orange)
		rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
		if mouseoff {
			rl.DrawText(">> store room > x for menu", storeRec.ToInt32().X+tx3-1, bgtxrec.ToInt32().Y+9, tx5, rl.Black)
			rl.DrawText(">> store room > x for menu", storeRec.ToInt32().X+tx3, bgtxrec.ToInt32().Y+8, tx5, rl.Black)
		} else {
			rl.DrawText(">> store room > right click for menu", storeRec.ToInt32().X+tx3-1, bgtxrec.ToInt32().Y+9, tx5, rl.Black)
			rl.DrawText(">> store room > right click for menu", storeRec.ToInt32().X+tx3, bgtxrec.ToInt32().Y+8, tx5, rl.Black)
		}

		x = storeRec.X + bq3
		y = bgtxrec.Y + bgtxrec.Height + b
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].name == "map" && player.inventory[i].notquick {
				storeItm[i].notquick = false
			}
			rec := rl.NewRectangle(x, y, siz, siz)
			if rl.CheckCollisionPointRec(cursorV2Strucs, rec) {
				rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.7))
				if storeItm[i].name != "" {
					storetxT = fps * 2
					txt = storeItm[i].name
					if inpL && !inMenuOn {
						found := movestoreitm(i)
						if !found {
							rl.PlaySound(audfx[43])
							storetxT = fps * 2
							txt = "no more space in inventory"
						} else {
							rl.PlaySound(audfx[18])
						}
					}
					//MENU
					if storeItm[i].name != "" && clickT == 0 {
						if inpR && !inMenuOn {
							rl.PlaySound(audfx[44])
							clickT = fps / 4
							inMenuOn = true
							siz2 := (siz + spc) * 2
							siz2 -= spc
							inMenuRec = rl.NewRectangle(rec.X+rec.Width+spc, rec.Y, siz2, siz2)
							if storeItm[i].numof == 1 {
								inMenuRec.Height -= siz / 2
							}
							if cursorV2.X > currentPosition.X+siz2 {
								inMenuRec.X -= siz2 + siz + spc
							}
							inMenuItm = i
						}
					}
				}
			} else {
				rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
			}
			rl.DrawRectangleLinesEx(rec, 4, rl.Fade(rl.Purple, 0.7))
			if storeItm[i].name != "" {
				rl.DrawTexturePro(imgs, storeItm[i].image, shrec(rec, 7), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, storeItm[i].image, rec, rl.Vector2Zero(), 0, rl.White)
				if storeItm[i].numof > 1 {
					txlen := rl.MeasureText(fmt.Sprint(storeItm[i].numof), tx2)
					xtx := int32(rec.X+rec.Width) - (txlen + 4)
					ytx := int32(rec.Y+rec.Height) - tx2
					rl.DrawText(fmt.Sprint(storeItm[i].numof), xtx-2, ytx+2, tx2, rl.Black)
					rl.DrawText(fmt.Sprint(storeItm[i].numof), xtx, ytx, tx2, rl.Gold)
				}
			}
			x += siz + spc
			if x+siz >= storeRec.X+storeRec.Width-b {
				x = storeRec.X + bq3
				y += siz + spc
			}
		}

		//STACK
		y += b
		siz = b4
		rec2 := rl.NewRectangle(storeRec.X+storeRec.Width-((siz*2)+b+b/4), y, b4, b+b/2)
		if rl.CheckCollisionPointRec(cursorV2Strucs, rec2) {
			rl.DrawRectangleRec(rec2, DarkRed())
			rl.DrawRectangleLinesEx(rec2, 4, rl.Black)
			txt := "stack"
			txs := tx3
			txlen := rl.MeasureText(txt, txs)
			ytx := rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
			xtx := rec2.ToInt32().X + rec2.ToInt32().Width/2 - txlen/2
			rl.DrawText(txt, xtx, ytx, txs, rl.White)
			if clickT == 0 {
				if inpL {
					rl.PlaySound(audfx[44])
					clickT = fps / 4
					stackStore()
				}
			}
		} else {
			rl.DrawRectangleRec(rec2, rl.Orange)
			rl.DrawRectangleLinesEx(rec2, 4, rl.Black)
			txt := "stack"
			txs := tx3
			txlen := rl.MeasureText(txt, txs)
			ytx := rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
			xtx := rec2.ToInt32().X + rec2.ToInt32().Width/2 - txlen/2
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		}
		//PACK
		rec2.X += rec2.Width + b/4
		if rl.CheckCollisionPointRec(cursorV2Strucs, rec2) {
			rl.DrawRectangleRec(rec2, DarkRed())
			rl.DrawRectangleLinesEx(rec2, 4, rl.Black)
			txt := "pack"
			txs := tx3
			txlen := rl.MeasureText(txt, txs)
			ytx := rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
			xtx := rec2.ToInt32().X + rec2.ToInt32().Width/2 - txlen/2
			rl.DrawText(txt, xtx, ytx, txs, rl.White)
			if clickT == 0 {
				if inpL {
					rl.PlaySound(audfx[44])
					clickT = fps / 4
					packStore()
				}
			}
		} else {
			rl.DrawRectangleRec(rec2, rl.Orange)
			rl.DrawRectangleLinesEx(rec2, 4, rl.Black)
			txt := "pack"
			txs := tx3
			txlen := rl.MeasureText(txt, txs)
			ytx := rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
			xtx := rec2.ToInt32().X + rec2.ToInt32().Width/2 - txlen/2
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		}
		//STORE TXT
		if storetxT > 0 {
			txs := tx4
			xtx := int32(storeRec.X + b)
			ytx := int32(y) - txs/2
			txt = ">> " + txt
			rl.DrawText(txt, xtx-3, ytx+3, txs, rl.Yellow)
			rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Black)
		}

		//MENU INVEN ITEMS
		if inMenuOn2 {
			rl.DrawRectangleRec(inMenuRec, rl.Magenta)
			rl.DrawRectangleRec(inMenuRec, rl.Fade(rl.Black, 0.7))
			rl.DrawRectangleLinesEx(inMenuRec, 4, rl.Fade(rl.Purple, 0.7))
			if !rl.CheckCollisionPointRec(cursorV2Strucs, inMenuRec) {
				inMenuExitT++
				if inMenuExitT >= (fps/3)*2 {
					inMenuExitT = 0
					inMenuOn2 = false
				}
			} else {
				inMenuExitT = 0
			}
			xtx := int32(inMenuRec.X) + 12
			ytx := int32(inMenuRec.Y) + 12
			txs := tx3
			txrecy := float32(ytx) - 2
			if player.inventory[inMenuItm].numof > 1 {
				for i := 0; i < 3; i++ {
					txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
					if rl.CheckCollisionPointRec(cursorV2Strucs, txrec) {
						rl.DrawRectangleRec(txrec, RandColor())
						if inpL {
							switch i {
							case 0: //INFO
								inMenuOn2 = false
								rl.PlaySound(audfx[40])
								invInfoT = fps
								invenInfo = true
							case 1: //SCRAP
								inMenuOn2 = false
								rl.PlaySound(audfx[40])
								num := player.inventory[inMenuItm].numof
								player.inventory[inMenuItm] = Item{}
								player.inventory[inMenuItm].name = ""
								found := false
								for j := 0; j < len(player.inventory); j++ {
									if j != inMenuItm {
										if player.inventory[j].name == "scrap" {
											player.inventory[j].numof += num
											found = true
											break
										}
									}
								}
								if !found {
									player.inventory[inMenuItm] = itemList[43]
									player.inventory[inMenuItm].numof = num
								}

							case 2: //SPLIT
								inMenuOn2 = false
								if nxInvnNum != blankint {
									rl.PlaySound(audfx[40])
									num1, num2 := 0, 0
									if player.inventory[inMenuItm].numof%2 == 0 {
										num1 = player.inventory[inMenuItm].numof / 2
										num2 = num1
									} else {
										num2 = player.inventory[inMenuItm].numof / 2
										num1 = num2 + 1
									}
									newItm := player.inventory[inMenuItm]
									newItm.numof = num1
									player.inventory[inMenuItm].numof = num2
									player.inventory[nxInvnNum] = newItm
								} else {
									rl.PlaySound(audfx[43])
									admsg("no free store room slots", rl.Red)
								}
							}
						}
					}
					txrecy += txrec.Height
				}
				rl.DrawText("info", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("scrap", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("split", xtx, ytx, txs, rl.Black)
			} else {
				for i := 0; i < 2; i++ {
					txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
					if rl.CheckCollisionPointRec(cursorV2Strucs, txrec) {
						rl.DrawRectangleRec(txrec, RandColor())
						if inpL {
							switch i {
							case 0: //INFO
								rl.PlaySound(audfx[40])
								invInfoT = fps
								invenInfo = true
							case 1: //SCRAP
								rl.PlaySound(audfx[40])
								num := player.inventory[inMenuItm].numof
								player.inventory[inMenuItm] = Item{}
								player.inventory[inMenuItm].name = ""
								found := false
								for j := 0; j < len(player.inventory); j++ {
									if j != inMenuItm {
										if player.inventory[j].name == "scrap" {
											player.inventory[j].numof += num
											found = true
											break
										}
									}
								}
								if !found {
									player.inventory[inMenuItm] = itemList[43]
									player.inventory[inMenuItm].numof = num
								}
								inMenuOn = false
							}
						}
					}
					txrecy += txrec.Height
				}
				rl.DrawText("info", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("scrap", xtx, ytx, txs, rl.Black)
			}

			if clickT == 0 {
				if inpR {
					clickT = fps / 3
					inMenuOn2 = false
				}
			}
		}

		//MENU STORE ITEMS
		if inMenuOn {
			rl.DrawRectangleRec(inMenuRec, rl.Magenta)
			rl.DrawRectangleRec(inMenuRec, rl.Fade(rl.Black, 0.7))
			rl.DrawRectangleLinesEx(inMenuRec, 4, rl.Fade(rl.Purple, 0.7))
			if !rl.CheckCollisionPointRec(cursorV2Strucs, inMenuRec) {
				inMenuExitT++
				if inMenuExitT >= (fps/3)*2 {
					inMenuExitT = 0
					inMenuOn = false
				}
			} else {
				inMenuExitT = 0
			}
			xtx := int32(inMenuRec.X) + 12
			ytx := int32(inMenuRec.Y) + 12
			txs := tx3
			txrecy := float32(ytx) - 2
			if storeItm[inMenuItm].numof > 1 {
				for i := 0; i < 3; i++ {
					txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
					if rl.CheckCollisionPointRec(cursorV2Strucs, txrec) {
						rl.DrawRectangleRec(txrec, RandColor())
						if inpL {
							switch i {
							case 0: //INFO
								rl.PlaySound(audfx[40])
								invInfoT = fps
								invenInfo = true
							case 1: //SCRAP
								rl.PlaySound(audfx[40])
								num := storeItm[inMenuItm].numof
								storeItm[inMenuItm] = Item{}
								storeItm[inMenuItm].name = ""
								found := false
								for j := 0; j < len(storeItm); j++ {
									if j != inMenuItm {
										if storeItm[j].name == "scrap" {
											storeItm[j].numof += num
											found = true
											break
										}
									}
								}
								if !found {
									storeItm[inMenuItm] = itemList[43]
									storeItm[inMenuItm].numof = num
								}
								inMenuOn = false
							case 2: //SPLIT
								findnextstoreslotnum()
								if nxStoreNum != blankint {
									rl.PlaySound(audfx[40])
									num1, num2 := 0, 0
									if storeItm[inMenuItm].numof%2 == 0 {
										num1 = storeItm[inMenuItm].numof / 2
										num2 = num1
									} else {
										num2 = storeItm[inMenuItm].numof / 2
										num1 = num2 + 1
									}
									newItm := storeItm[inMenuItm]
									newItm.numof = num1
									storeItm[inMenuItm].numof = num2
									storeItm[nxStoreNum] = newItm
									inMenuOn = false
								} else {
									rl.PlaySound(audfx[43])
									admsg("no free store room slots", rl.Red)
									inMenuOn = false
								}
							}
						}
					}
					txrecy += txrec.Height
				}
				rl.DrawText("info", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("scrap", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("split", xtx, ytx, txs, rl.Black)
			} else {
				for i := 0; i < 2; i++ {
					txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
					if rl.CheckCollisionPointRec(cursorV2Strucs, txrec) {
						rl.DrawRectangleRec(txrec, RandColor())
						if inpL {
							switch i {
							case 0: //INFO
								rl.PlaySound(audfx[40])
								invInfoT = fps
								invenInfo = true
							case 1: //SCRAP
								rl.PlaySound(audfx[40])
								num := storeItm[inMenuItm].numof
								storeItm[inMenuItm] = Item{}
								storeItm[inMenuItm].name = ""
								found := false
								for j := 0; j < len(storeItm); j++ {
									if j != inMenuItm {
										if storeItm[j].name == "scrap" {
											storeItm[j].numof += num
											found = true
											break
										}
									}
								}
								if !found {
									player.inventory[inMenuItm] = itemList[43]
									player.inventory[inMenuItm].numof = num
								}
								inMenuOn = false
							}
						}
					}
					txrecy += txrec.Height
				}
				rl.DrawText("info", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("scrap", xtx, ytx, txs, rl.Black)
			}

			if clickT == 0 {
				if inpR {
					clickT = fps / 3
					inMenuOn = false
				}
			}
		}
	}
	rl.EndMode2D()
}

func drawBase() { //MARK:DRAW BASE

	if isBookOn {
		drawBook()
	} else if isWeaponShedOn {
		drawWeaponShed()
	} else if isStoreOn {
		drawStore()
	} else if isApothercaryOn {
		drawApothecary()
	} else {

		if mushroomPause > 0 {
			mushroomPause--
		}

		//SCRAPNUM
		scrapNum = 0
		for i := 0; i < len(player.inventory); i++ {
			if player.inventory[i].name == "scrap" {
				scrapNum += player.inventory[i].numof
			}
		}
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].name == "scrap" {
				scrapNum += storeItm[i].numof
			}
		}

		rl.BeginMode2D(camBase)

		//BG
		if !exiting {
			for i := 0; i < len(baseBG); i++ {
				rl.DrawTexturePro(imgs, baseBG[i].imageRectangle, baseBG[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.9))
			}
		}

		//MOUSE
		if !exiting {
			rl.DrawTexturePro(imgs, base.mouse.image, shrec(base.mouse.rectangle, 2), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, base.mouse.image, base.mouse.rectangle, rl.Vector2Zero(), 0, rl.White)
		}
		if checkmovemouse() {
			base.mouse.rectangle.X += base.mouse.dirX
			base.mouse.rectangle.Y += base.mouse.dirY
		} else {
			base.mouse.dirX = RandF32(-base.mouse.speed, base.mouse.speed)
			base.mouse.dirY = RandF32(-base.mouse.speed, base.mouse.speed)
		}
		if frames%4 == 0 {
			if base.mouse.onoff {
				base.mouse.image.X += animation[183].width
				if base.mouse.image.X > animation[183].x+animation[183].frames*animation[183].width {
					base.mouse.image.X = animation[183].x
				}
			} else {
				base.mouse.image.X += animation[182].width
				if base.mouse.image.X > animation[182].x+animation[182].frames*animation[182].width {
					base.mouse.image.X = animation[182].x
				}
			}
		}
		if Abs(base.mouse.dirX) > Abs(base.mouse.dirY) {
			if base.mouse.dirX < 0 {
				base.mouse.image.Y = 0
			} else {
				base.mouse.image.Y = 16
			}
		} else {
			if base.mouse.dirY < 0 {
				base.mouse.image.Y = 48
			} else {
				base.mouse.image.Y = 32
			}
		}

		//IMG
		for i := 0; i < len(base.rectangle); i++ {
			if base.isUnlocked[i] {
				if !exiting {
					rl.DrawTexturePro(imgs, base.imageRectangle[i], shrec(base.rectangle[i], 4), rl.Vector2Zero(), 0, ShadowColor())
					if base.name[i] == "mushroom patch" && mushroomTimer == mushroomTimerMax {
						if frames%10 == 0 {
							mushCol = RandColor()
						}
						rl.DrawTexturePro(imgs, base.imageRectangle[i], base.rectangle[i], rl.Vector2Zero(), 0, mushCol)
					} else if base.name[i] == "boss key 1" && bosskey1 {
						rl.DrawTexturePro(imgs, base.imageRectangle[i], base.rectangle[i], rl.Vector2Zero(), 0, rl.White)
						rl.DrawTexturePro(imgs, base.imageRectangle[i], base.rectangle[i], rl.Vector2Zero(), 0, rl.Fade(rl.Orange, fadeblinkF2))
					} else if base.name[i] == "boss key 2" && bosskey2 {
						rl.DrawTexturePro(imgs, base.imageRectangle[i], base.rectangle[i], rl.Vector2Zero(), 0, rl.White)
						rl.DrawTexturePro(imgs, base.imageRectangle[i], base.rectangle[i], rl.Vector2Zero(), 0, rl.Fade(rl.Orange, fadeblinkF2))
					} else if base.name[i] == "boss key 3" && bosskey3 {
						rl.DrawTexturePro(imgs, base.imageRectangle[i], base.rectangle[i], rl.Vector2Zero(), 0, rl.White)
						rl.DrawTexturePro(imgs, base.imageRectangle[i], base.rectangle[i], rl.Vector2Zero(), 0, rl.Fade(rl.Orange, fadeblinkF2))
					} else if base.name[i] == "weapon stand" {
						if weaponStandOn {
							rl.DrawTexturePro(imgs, base.imageRectangle[i], base.rectangle[i], rl.Vector2Zero(), 0, rl.Black)
							rl.DrawTexturePro(imgs, base.imageRectangle[i], base.rectangle[i], rl.Vector2Zero(), 0, rl.Fade(rl.White, fadeblinkF2))
							if base.fade[i] < 1 {
								base.fade[i] += 0.02
							}
						} else {
							rl.DrawTexturePro(imgs, base.imageRectangle[i], base.rectangle[i], rl.Vector2Zero(), 0, rl.Black)
							rl.DrawTexturePro(imgs, base.imageRectangle[i], base.rectangle[i], rl.Vector2Zero(), 0, rl.Fade(RandRed(), fadeblinkF2))
							if base.fade[i] < 1 {
								base.fade[i] += 0.02
							}
						}

						siz2 := b + bq
						cntr2 := makecnt(base.rectangle[i])
						rec2 := rl.NewRectangle(cntr2.X-siz2/2, cntr2.Y-siz2/2, siz2, siz2)
						rec2.Y += b / 2
						rl.DrawTexturePro(imgs, player.weapon.image, shrec(drec(rec2), 5), orgn(rec2), weaponStandRotation, ShadowColor())
						rl.DrawTexturePro(imgs, player.weapon.image, drec(rec2), orgn(rec2), weaponStandRotation, rl.White)
						weaponStandRotation += 4

					} else {
						rl.DrawTexturePro(imgs, base.imageRectangle[i], base.rectangle[i], rl.Vector2Zero(), 0, rl.Fade(rl.White, base.fade[i]))
						if base.fade[i] < 1 {
							base.fade[i] += 0.02
						}
					}
				}

				if rl.CheckCollisionPointRec(cursorV2Base, base.rectangle[i]) {
					toptx = base.name[i]
					if base.name[i] == "weapon stand" && weaponStandOn {
						toptx = toptx + " > 1 random weapon change per run"
						if inpL {
							choose := RandInt(1, 6)
							switch choose {
							case 1:
								rl.PlaySound(audfx[124])
							case 2:
								rl.PlaySound(audfx[125])
							case 3:
								rl.PlaySound(audfx[126])
							case 4:
								rl.PlaySound(audfx[127])
							case 5:
								rl.PlaySound(audfx[128])
							}
							weapchangedT = fps * 2
							for {
								choose := weapons[RandInt(0, len(weapons))]
								if player.weapon != choose {
									player.weapon = choose
									break
								}
							}
							weaponStandOn = false
							campEffectRectangles2 = append(campEffectRectangles2, base.rectangle[i])
							campfximgrecs2 = append(campfximgrecs2, animation[200].rectangle)
						}
					} else if base.name[i] == "weapon stand" && !weaponStandOn {
						toptx = "unavailable till next run"
					}
					if base.name[i] == "to the dungeon" && treasureRoom {
						toptx = "the treasure room awaits"
					}
					if base.level[i] != 0 {
						toptx += " > level " + fmt.Sprint(base.level[i])
					}
					if base.level[i] > 0 && base.level[i] < 3 {
						toptx = toptx + " > 20 scrap to upgrade"
					}
					toptxT = fps
				}

				//MUSHROOM TIMER
				if base.name[i] == "mushroom patch" {
					if !exiting {
						siz2 := b / 3
						W := float32(mushroomTimerMax) * siz2
						x2 := (base.rectangle[i].X + base.rectangle[i].Width/2) - W/2
						y2 := base.rectangle[i].Y + base.rectangle[i].Height + 12
						bgrec := rl.NewRectangle(x2-2, y2-2, W+4, siz2+4)
						rl.DrawRectangleRec(bgrec, rl.Fade(rl.Black, 0.9))
						x2 = (base.rectangle[i].X + base.rectangle[i].Width/2) - W/2
						y2 = base.rectangle[i].Y + base.rectangle[i].Height + 12
						for j := 0; j < mushroomTimer; j++ {
							rec := rl.NewRectangle(x2, y2, siz2, siz2)
							rl.DrawRectangleRec(rec, rl.DarkPurple)
							x2 += siz2
						}
					}
				}

				//TREASURE ROOM COIN
				if base.name[i] == "to the dungeon" && treasureRoom {
					if !exiting {
						siz := b + b/2
						x2 := base.rectangle[i].X + base.rectangle[i].Width/2 - (siz/4)*3
						y2 := base.rectangle[i].Y - siz/4
						rec3 := rl.NewRectangle(x2, y2, siz, siz)
						rl.DrawTexturePro(imgs, animation[187].rectangle, rec3, rl.Vector2Zero(), 0, rl.White)
						//rl.DrawRectangleRec(rec3, RandColor())
						if frames%5 == 0 {
							animation[187].rectangle.X += animation[187].width
							if animation[187].rectangle.X > animation[187].x+animation[187].frames*animation[187].width {
								animation[187].rectangle.X = animation[187].x
							}
						}
					}
				}

				//DRAW LEVEL STARS
				if base.level[i] >= 1 {
					if !exiting {
						siz := bq3
						x2 := base.rectangle[i].X
						y2 := base.rectangle[i].Y
						if base.name[i] == "mushroom patch" {
							y2 -= siz
						} else if base.name[i] == "weapon shed" {
							y2 -= siz / 3
						}
						for j := 1; j < 4; j++ {
							rec := rl.NewRectangle(x2, y2, siz, siz)
							rec2 := rec
							rec2.X -= 2
							rec2.Y -= 2
							rec2.Width += 4
							rec2.Height += 4
							rl.DrawTexturePro(imgs, otherTiles[181], rec2, rl.Vector2Zero(), 0, rl.Fade(rl.Black, 0.7))
							if j <= base.level[i] {
								rl.DrawTexturePro(imgs, otherTiles[181], rec, rl.Vector2Zero(), 0, rl.White)
							}
							x2 += rec2.Width
						}
					}
				}

				if base.name[i] == "campfire" {
					if frames%6 == 0 {
						base.imageRectangle[i].X += animation[72].width
						if base.imageRectangle[i].X > animation[72].x+animation[72].frames*animation[72].width {
							base.imageRectangle[i].X = animation[72].x
						}
					}
				}

				//UPGRADE STRUCTURE LEVEL
				if base.level[i] < 3 && base.level[i] > 0 {
					if rl.CheckCollisionPointRec(cursorV2Base, base.rectangle[i]) {
						if scrapNum >= base.price[i] {
							if inpL {
								rl.PlaySound(audfx[47])
								base.level[i]++
								total := base.price[i]
								for j := 0; j < len(storeItm); j++ {
									if storeItm[j].name == "scrap" {
										if storeItm[j].numof > total {
											storeItm[j].numof -= total
											total = 0
										} else {
											total -= storeItm[j].numof
											storeItm[j].isOff = true
											storeItm[j] = Item{}
										}
										if total == 0 {
											break
										}
									}
								}
								if total != 0 {
									for j := 0; j < len(player.inventory); j++ {
										if player.inventory[j].name == "scrap" {
											if player.inventory[j].numof > total {
												player.inventory[j].numof -= total
												total = 0
											} else {
												total -= player.inventory[j].numof
												player.inventory[j].isOff = true
												player.inventory[j] = Item{}
											}
											if total == 0 {
												break
											}
										}
									}
								}
								campEffectRectangles2 = append(campEffectRectangles2, base.rectangle[i])
								campfximgrecs2 = append(campfximgrecs2, animation[200].rectangle)
							}
						} else {
							if inpL {
								notenoughscrapT = fps * 2
								rl.PlaySound(audfx[43])
							}
						}
					}
				}

			} else {
				if !exiting {
					if base.name[i] == "boss key 1" {
						rl.DrawTexturePro(imgs, base.imageRectangle[i], shrec(base.rectangle[i], 4), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, base.imageRectangle[i], base.rectangle[i], rl.Vector2Zero(), 0, DarkRed())
					} else if base.name[i] == "boss key 2" {
						rl.DrawTexturePro(imgs, base.imageRectangle[i], shrec(base.rectangle[i], 4), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, base.imageRectangle[i], base.rectangle[i], rl.Vector2Zero(), 0, DarkRed())
					} else if base.name[i] == "boss key 3" {
						rl.DrawTexturePro(imgs, base.imageRectangle[i], shrec(base.rectangle[i], 4), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, base.imageRectangle[i], base.rectangle[i], rl.Vector2Zero(), 0, DarkRed())
					} else {
						rl.DrawTexturePro(imgs, base.imageRectangle[i], base.rectangle[i], rl.Vector2Zero(), 0, rl.Fade(rl.Black, 0.8))
						cntr := rl.NewVector2(base.rectangle[i].X+base.rectangle[i].Width/2, base.rectangle[i].Y+base.rectangle[i].Height/2)
						siz2 := b + bq3
						if base.name[i] == "weapon stand" {
							siz2 = b + bq
						}
						rec3 := rl.NewRectangle(cntr.X-siz2/2, cntr.Y-siz2/2, siz2, siz2)
						rec4 := rec3
						rec4.X -= 3
						rec4.Y += 3
						rl.DrawTexturePro(imgs, otherTiles[46], rec4, rl.Vector2Zero(), 0, rl.Fade(rl.Black, 0.7))
						rl.DrawTexturePro(imgs, otherTiles[46], rec3, rl.Vector2Zero(), 0, rl.White)
					}
				}

				//BASE UNLOCK
				if rl.CheckCollisionPointRec(cursorV2Base, base.rectangle[i]) && base.name[i] != "boss key 1" && base.name[i] != "boss key 2" && base.name[i] != "boss key 3" {
					toptx = fmt.Sprint(base.price[i]) + " scrap to unlock "
					toptxT = fps
					if scrapNum >= base.price[i] {
						if inpL {
							rl.PlaySound(audfx[46])
							base.isUnlocked[i] = true
							if base.name[i] == "store room" {
								isStoreUnlocked = true
							}
							total := base.price[i]
							for j := 0; j < len(storeItm); j++ {
								if storeItm[j].name == "scrap" {
									if storeItm[j].numof > total {
										storeItm[j].numof -= total
										total = 0
									} else {
										total -= storeItm[j].numof
										storeItm[j].isOff = true
										storeItm[j] = Item{}
									}
									if total == 0 {
										break
									}
								}
							}
							if total != 0 {
								for j := 0; j < len(player.inventory); j++ {
									if player.inventory[j].name == "scrap" {
										if player.inventory[j].numof > total {
											player.inventory[j].numof -= total
											total = 0
										} else {
											total -= player.inventory[j].numof
											player.inventory[j].isOff = true
											player.inventory[j] = Item{}
										}
										if total == 0 {
											break
										}
									}
								}
							}

							campEffectRectangles = append(campEffectRectangles, base.rectangle[i])
							campEffectImageRectangles = append(campEffectImageRectangles, animation[199].rectangle)

						}
					} else {
						if inpL {
							notenoughscrapT = fps * 2
							rl.PlaySound(audfx[43])
						}
					}
				} else if rl.CheckCollisionPointRec(cursorV2Base, base.rectangle[i]) {
					toptx = base.name[i]
					toptxT = fps
				}
			}

			//PLAYER BASE STRUCTURE COLLISIONS
			if rl.CheckCollisionRecs(player2.collisionRectangle, base.caRectangle[i]) && !exitCollision {
				switch base.name[i] {
				case "apothecary":
					if base.isUnlocked[i] {
						rl.PlaySound(audfx[49])
						makebgpix()
						makePotionList()
						makeScrollList()
						isApothercaryOn = true
						player2.center = currentPosition
						updatePlayerRectangle()
					}
				case "mushroom patch":
					if base.isUnlocked[i] {
						if mushroomTimer == mushroomTimerMax && isStoreUnlocked {
							rl.PlaySound(audfx[65])
							num := 0
							if base.level[i] == 1 {
								num = 20
							} else if base.level[i] == 2 {
								num = 30
							} else if base.level[i] == 3 {
								num = 40
							}

							var newMush []Item
							div := num / 10
							for div > 0 {
								choose := RandInt(1, 7)
								switch choose {
								case 1:
									zitm := itemList[105]
									zitm.numof = 10
									newMush = append(newMush, zitm)
								case 2:
									zitm := itemList[106]
									zitm.numof = 10
									newMush = append(newMush, zitm)
								case 3:
									zitm := itemList[107]
									zitm.numof = 10
									newMush = append(newMush, zitm)
								case 4:
									zitm := itemList[108]
									zitm.numof = 10
									newMush = append(newMush, zitm)
								case 5:
									zitm := itemList[109]
									zitm.numof = 10
									newMush = append(newMush, zitm)
								case 6:
									zitm := itemList[110]
									zitm.numof = 10
									newMush = append(newMush, zitm)
								}
								div--
							}
							full := false
							for i := 0; i < len(newMush); i++ {
								for j := 0; j < len(storeItm); j++ {
									if storeItm[j].name == "" {
										storeItm[j] = newMush[i]
										break
									}
								}
							}
							if full {
								toptx = "store room is full > mushrooms disposed"
								toptxT = fps * 2
							} else {
								toptx = "mushrooms placed in store room"
								toptxT = fps * 2
							}
							mushroomPause = 600
							mushroomTimer = 0
						} else if mushroomTimer == mushroomTimerMax && !isStoreUnlocked {
							if toptxT == 0 {
								toptx = "store room is locked"
								toptxT = fps * 2
							}
						} else {
							if mushroomPause == 0 {
								rl.PlaySound(audfx[43])
								toptx = "go back to the dungeons > mushrooms not ready"
								toptxT = fps * 2
							}
						}
					}
				case "weapon shed":
					if base.isUnlocked[i] {
						rl.PlaySound(audfx[49])
						makebgpix()
						isWeaponShedOn = true
						if player.weapon.name != "" {
							selnumWeap = 0
						} else {
							selnumWeap = 1
						}

						player2.center = currentPosition
						updatePlayerRectangle()
					}
				case "store room":
					if base.isUnlocked[i] {
						rl.PlaySound(audfx[49])
						makebgpix()
						isStoreOn = true
						player2.center = currentPosition
						updatePlayerRectangle()
					}
				case "book of unlock things":
					choose := RandInt(1, 9)
					switch choose {
					case 1:
						rl.PlaySound(audfx[58])
					case 2:
						rl.PlaySound(audfx[59])
					case 3:
						rl.PlaySound(audfx[60])
					case 4:
						rl.PlaySound(audfx[61])
					case 5:
						rl.PlaySound(audfx[62])
					case 6:
						rl.PlaySound(audfx[63])
					case 7:
						rl.PlaySound(audfx[64])
					}
					makebgpix()
					isBookOn = true
					player2.center = currentPosition
					updatePlayerRectangle()
				case "to the dungeon":
					exitCollision = true
				}
			}
			if debug {
				rl.DrawRectangleLinesEx(base.rectangle[i], 1, rl.White)
				rl.DrawRectangleLinesEx(base.collisionRectangle[i], 1, rl.Magenta)
				rl.DrawRectangleLinesEx(base.caRectangle[i], 1, rl.Blue)
			}
		}

		//EXIT ANIMATION
		if exitCollision {
			if !exiting {
				choose := RandInt(1, 9)
				switch choose {
				case 1:
					rl.PlaySound(audfx[50])
				case 2:
					rl.PlaySound(audfx[51])
				case 3:
					rl.PlaySound(audfx[52])
				case 4:
					rl.PlaySound(audfx[53])
				case 5:
					rl.PlaySound(audfx[54])
				case 6:
					rl.PlaySound(audfx[55])
				case 7:
					rl.PlaySound(audfx[56])
				case 8:
					rl.PlaySound(audfx[57])
				}
				introAnim.X = animation[204].x
				exiting = true

			}

			if introAnim.X < animation[204].x+animation[204].frames*animation[204].width {
				siz2 := (b10 * 2) + 5
				if xxl {
					siz2 = b10 * 4
				}
				rec2 := rl.NewRectangle(currentPosition.X-siz2/2, currentPosition.Y-siz2/2, siz2, siz2)
				rl.DrawTexturePro(imgs, introAnim, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.5, 0.7)))
				rl.DrawTexturePro(imgs, introAnim, brec(rec2, 7), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.3, 0.5)))
				rl.DrawTexturePro(imgs, introAnim, brec(rec2, 12), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.1, 0.3)))
				if frames%3 == 0 {
					introAnim.X += animation[204].width
				}
			} else {
				player2.center = currentPosition
				updatePlayerRectangle()
				if treasureRoom {
					makelevel()
					if isStoreUnlocked {
						savestore()
					}
					isBaseOn = false
					pause = false
					saveT = fps * 2
					rl.StopMusicStream(music[currentMusic])
					currentMusic = 3
					rl.PlayMusicStream(music[currentMusic])

				} else {
					if isStoreUnlocked {
						savestore()
					}
					isBaseOn = false
					pause = false
					saveT = fps * 2
					rl.StopMusicStream(music[currentMusic])
					switch dispMusic {
					case 0:
						rl.StopMusicStream(music[currentMusic])
						currentMusic = RandInt(4, len(music))
						rl.PlayMusicStream(music[currentMusic])
					case 1:
						rl.StopMusicStream(music[currentMusic])
						currentMusic = 4
						rl.PlayMusicStream(music[currentMusic])
					case 2:
						rl.StopMusicStream(music[currentMusic])
						currentMusic = 5
						rl.PlayMusicStream(music[currentMusic])
					case 3:
						rl.StopMusicStream(music[currentMusic])
						currentMusic = 6
						rl.PlayMusicStream(music[currentMusic])
					}
				}

				introAnim.X = animation[204].x
				exitCollision = false
			}
		}

		//UNLOCK FX
		if len(campEffectRectangles) > 0 {
			clear := false
			num := 0
			for i := 0; i < len(campEffectRectangles); i++ {
				rl.DrawTexturePro(imgs, campEffectImageRectangles[i], shrec(campEffectRectangles[i], 30), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, campEffectImageRectangles[i], campEffectRectangles[i], rl.Vector2Zero(), 0, rl.White)
				rl.DrawTexturePro(imgs, campEffectImageRectangles[i], brec(campEffectRectangles[i], 7), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.3, 0.5)))
				rl.DrawTexturePro(imgs, campEffectImageRectangles[i], brec(campEffectRectangles[i], 12), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.1, 0.3)))
				if frames%3 == 0 {
					if campEffectImageRectangles[i].X < animation[199].x+animation[199].frames*animation[199].width {
						campEffectImageRectangles[i].X += animation[199].width
					} else {
						clear = true
						num = i
					}
				}
			}
			if clear {
				campEffectRectangles = RemoveRectangle(campEffectRectangles, num)
				campEffectImageRectangles = RemoveRectangle(campEffectImageRectangles, num)
			}
		}
		if len(campEffectRectangles2) > 0 {
			clear := false
			num := 0
			for i := 0; i < len(campEffectRectangles2); i++ {
				rl.DrawTexturePro(imgs, campfximgrecs2[i], shrec(campEffectRectangles2[i], 30), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, campfximgrecs2[i], campEffectRectangles2[i], rl.Vector2Zero(), 0, rl.White)
				rl.DrawTexturePro(imgs, campfximgrecs2[i], brec(campEffectRectangles2[i], 7), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.3, 0.5)))
				rl.DrawTexturePro(imgs, campfximgrecs2[i], brec(campfximgrecs2[i], 12), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.1, 0.3)))
				if frames%3 == 0 {
					if campfximgrecs2[i].X < animation[200].x+animation[200].frames*animation[200].width {
						campfximgrecs2[i].X += animation[200].width
					} else {
						clear = true
						num = i
					}
				}
			}
			if clear {
				campEffectRectangles2 = RemoveRectangle(campEffectRectangles2, num)
				campfximgrecs2 = RemoveRectangle(campfximgrecs2, num)
			}
		}
		//DRAW ROLLO COMPANION

		if rollo {
			if !exiting {
				rec3 := rollocomp.rectangle
				rec3.X -= 4
				rec3.Y -= 4
				rec3.Width += 8
				rec3.Height += 8
				rl.DrawTexturePro(imgs, rollocomp.image, shrec(rec3, 5), rl.Vector2Zero(), 0, ShadowColor())
				rec2 := rec3
				rec2.X += (rollocomp.dirX * 2) * -1
				rec2.Y += (rollocomp.dirY * 2) * -1
				rec2.X += rec2.Width / 16
				rec2.Y += rec2.Height / 16
				rec2.Width -= rec2.Width / 8
				rec2.Height -= rec2.Height / 8
				rl.DrawTexturePro(imgs, rollocomp.image, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.2))
				rec2.X += (rollocomp.dirX * 2) * -1
				rec2.Y += (rollocomp.dirY * 2) * -1
				rec2.X += rec2.Width / 16
				rec2.Y += rec2.Height / 16
				rec2.Width -= rec2.Width / 8
				rec2.Height -= rec2.Height / 8
				rl.DrawTexturePro(imgs, rollocomp.image, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.15))
				rec2.X += (rollocomp.dirX * 2) * -1
				rec2.Y += (rollocomp.dirY * 2) * -1
				rec2.X += rec2.Width / 16
				rec2.Y += rec2.Height / 16
				rec2.Width -= rec2.Width / 8
				rec2.Height -= rec2.Height / 8
				rl.DrawTexturePro(imgs, rollocomp.image, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.1))
				rec2.X += (rollocomp.dirX * 2) * -1
				rec2.Y += (rollocomp.dirY * 2) * -1
				rec2.X += rec2.Width / 16
				rec2.Y += rec2.Height / 16
				rec2.Width -= rec2.Width / 8
				rec2.Height -= rec2.Height / 8
				rl.DrawTexturePro(imgs, rollocomp.image, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.05))
				rl.DrawTexturePro(imgs, rollocomp.image, rec3, rl.Vector2Zero(), 0, rl.White)
				if frames%2 == 0 {
					if rollocomp.lr {
						rollocomp.image.X -= animation[154].width
						if rollocomp.image.X < animation[154].x-animation[154].frames*animation[154].width {
							rollocomp.image.X = animation[154].x
						}
					} else {
						rollocomp.image.X += animation[153].width
						if rollocomp.image.X > animation[153].x+animation[153].frames*animation[153].width {
							rollocomp.image.X = animation[153].x
						}
					}
				}
			}
		}

		//DRAW PLAYER

		rec2 := player2.rectangle //INCREASE SIZE OF PLAYER DRAW IMAGE
		rec2.X -= b / 8
		rec2.Y -= b / 5
		rec2.Width += b / 4
		rec2.Height += b / 4
		if !exiting {
			rl.DrawTexturePro(imgs, player2.anim[player2.animationNum].rectangle, shrec(rec2, 3), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, player2.anim[player2.animationNum].rectangle, rec2, rl.Vector2Zero(), 0, rl.White)

			if loadedT > 0 {
				txt := "loaded"
				txs := tx5
				txlen := rl.MeasureText(txt, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx := int32(currentPosition.Y) - txs/8
				ytx += player.rectangle.ToInt32().Height
				rl.DrawText(txt, xtx, ytx, txs, rl.Fade(RandColor(), 0.2))
				loadedT--
			}
			if notenoughscrapT > 0 {
				txt := "not enough scrap"
				txs := tx5
				txlen := rl.MeasureText(txt, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx := int32(currentPosition.Y) - txs/8
				ytx += player.rectangle.ToInt32().Height
				rl.DrawText(txt, xtx, ytx, txs, rl.Fade(RandColor(), 0.2))
				notenoughscrapT--
			}
			if weapchangedT > 0 {
				txt := player.weapon.name + " > new weapon"
				txs := tx5
				txlen := rl.MeasureText(txt, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx := int32(currentPosition.Y) - txs/8
				ytx += player.rectangle.ToInt32().Height
				rl.DrawText(txt, xtx, ytx, txs, rl.Fade(RandColor(), 0.2))
				weapchangedT--
			}

			//DRAW BAT COMPANION
			if batty {
				rec3 := batcomp.rectangle
				rec3.X -= 7
				rec3.Y -= 7
				rec3.Width += 14
				rec3.Height += 14
				rl.DrawTexturePro(imgs, batcomp.image, shrec(rec3, 20), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, batcomp.image, rec3, rl.Vector2Zero(), 0, rl.White)
				if frames%2 == 0 {
					if batcomp.lr {
						batcomp.image.X -= animation[142].width
						if batcomp.image.X < animation[142].x-animation[142].frames*animation[142].width {
							batcomp.image.X = animation[142].x
						}
					} else {
						batcomp.image.X += animation[141].width
						if batcomp.image.X > animation[141].x+animation[141].frames*animation[141].width {
							batcomp.image.X = animation[141].x
						}
					}
				}
			}

			//PIGEON
			if base.pigeonT > 0 {
				base.pigeonT--
				if base.pigeonT == 1 {
					base.pigeonoff = !base.pigeonoff
				}
			}
			if !base.pigeonoff {
				rl.DrawTexturePro(imgs, base.pigeon.image, shrec(base.pigeon.rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, base.pigeon.image, base.pigeon.rectangle, rl.Vector2Zero(), 0, rl.White)
				if frames%4 == 0 {
					if base.pigeon.dirX < 0 {
						base.pigeon.image.X -= animation[74].width
						if base.pigeon.image.X < animation[74].x-animation[74].frames*animation[74].width {
							base.pigeon.image.X = animation[74].x
						}
					} else {
						base.pigeon.image.X += animation[73].width
						if base.pigeon.image.X > animation[73].x+animation[73].frames*animation[73].width {
							base.pigeon.image.X = animation[73].x
							base.pigeonT = fps * RandInt32(5, 11)
						}
					}
				}
				base.pigeon.rectangle.X += base.pigeon.dirX
				if base.pigeon.rectangle.X > baseBordRec.X+baseBordRec.Width+base.pigeon.rectangle.Width {
					base.pigeon.dirX = -base.pigeon.dirX
					base.pigeon.rectangle.Y = RandF32(baseBordRec.Y+b/4, baseBordRec.Y+baseBordRec.Height/2)
					base.pigeonoff = true
				}
				if base.pigeon.rectangle.X < baseBordRec.X-base.pigeon.rectangle.Width*2 {
					base.pigeon.dirX = Abs(base.pigeon.dirX)
					base.pigeon.rectangle.Y = RandF32(baseBordRec.Y+b/4, baseBordRec.Y+baseBordRec.Height/2)
					base.pigeonoff = true
					base.pigeonT = fps * RandInt32(5, 11)
				}
			}
		}
		//DEBUG
		if debug {
			rl.DrawRectangleLinesEx(player2.rectangle, 1, rl.Magenta)
			rl.DrawRectangleLinesEx(player2.collisionRectangle, 1, rl.Red)
			rl.DrawCircleV(player2.center, 2, RandColor())
			rl.DrawRectangleLinesEx(baseBordRec, 2, rl.Yellow)
		}
		plWorldScreenV2 := rl.GetWorldToScreen2D(player2.center, camBase)
		if cursorV2.X < plWorldScreenV2.X {
			player2.direction = true
		} else if cursorV2.X > plWorldScreenV2.X {
			player2.direction = false
		}
		player2.animationNum = 0
		if player2.direction {
			player2.animationNum = 1
		}
		if rl.IsKeyDown(rl.KeyW) || rl.IsKeyDown(rl.KeyUp) || rl.GetGamepadAxisMovement(0, 1) < 0 || rl.IsGamepadButtonDown(0, 1) { //UP
			if checkplayermoveBase(1) {
				player2.center.Y -= player2.speed / 2
			}
			player2.animationNum = 4
		}
		if rl.IsKeyDown(rl.KeyS) || rl.IsKeyDown(rl.KeyDown) || rl.GetGamepadAxisMovement(0, 1) > 0 || rl.IsGamepadButtonDown(0, 3) { //DOWN
			if checkplayermoveBase(3) {
				player2.center.Y += player2.speed / 2
			}
			player2.animationNum = 2
			if player2.direction {
				player2.animationNum = 3
			}
		}
		if rl.IsKeyDown(rl.KeyA) || rl.IsKeyDown(rl.KeyLeft) || rl.GetGamepadAxisMovement(0, 0) < 0 || rl.IsGamepadButtonDown(0, 4) { //LEFT
			if checkplayermoveBase(4) {
				player2.center.X -= player2.speed / 2
			}
			player2.animationNum = 3
			player2.direction = true
		}
		if rl.IsKeyDown(rl.KeyD) || rl.IsKeyDown(rl.KeyRight) || rl.GetGamepadAxisMovement(0, 0) > 0 || rl.IsGamepadButtonDown(0, 2) { //RIGHT
			if checkplayermoveBase(2) {
				player2.center.X += player2.speed / 2
			}
			player2.animationNum = 2
			player2.direction = false
		}
		updatePlayerRectangle()
		if frames%7 == 0 { //IDLE ANIM
			player2.anim[0].rectangle.X += player2.anim[0].width
			if player2.anim[0].rectangle.X > player2.anim[0].x+player2.anim[0].frames*player2.anim[0].width {
				player2.anim[0].rectangle.X = player2.anim[0].x
			}
			player2.anim[1].rectangle.X -= player2.anim[1].width
			if player2.anim[1].rectangle.X < player2.anim[1].x-player2.anim[1].frames*player2.anim[1].width {
				player2.anim[1].rectangle.X = player2.anim[1].x
			}
		}
		if frames%3 == 0 { //RUN PUSH ANIM
			player2.anim[4].rectangle.X += player2.anim[4].width
			if player2.anim[4].rectangle.X > player2.anim[4].x+player2.anim[4].frames*player2.anim[4].width {
				player2.anim[4].rectangle.X = player2.anim[4].x
			}
			player2.anim[2].rectangle.X += player2.anim[2].width
			if player2.anim[2].rectangle.X > player2.anim[2].x+player2.anim[2].frames*player2.anim[2].width {
				player2.anim[2].rectangle.X = player2.anim[2].x
			}
			player2.anim[3].rectangle.X -= player2.anim[3].width
			if player2.anim[3].rectangle.X < player2.anim[3].x-player2.anim[3].frames*player2.anim[3].width {
				player2.anim[3].rectangle.X = player2.anim[3].x
			}
		}

		rl.EndMode2D()

		//SCRAP NUM
		siz2 := b + bq
		txs := tx4
		if medium {
			siz2 = bq3
			txs = tx2
		}
		if xxl {
			siz2 = b2
			txs = tx8
		}
		rec2 = rl.NewRectangle(4, 4, siz2, siz2)
		if !exiting {
			rl.DrawRectangleRec(rec2, rl.Black)
			rl.DrawTexturePro(imgs, otherTiles[55], rec2, rl.Vector2Zero(), 0, rl.White)
			xtx := rec2.ToInt32().X + rec2.ToInt32().Width + txs/3
			ytx := rec2.ToInt32().Y + 2
			rl.DrawText(fmt.Sprint(scrapNum), xtx, ytx, txs, rl.Black)

			if rl.CheckCollisionPointRec(gameCursor, rec2) || rl.CheckCollisionPointRec(cursorV2, rec2) {
				toptx = "scrap available to unlock"
				toptxT = fps * 2
			}

			//TOP INFO
			if toptxT > 0 && !options && !charscr {
				siz := tx3
				if medium {
					siz = tx2
				}
				if xxl {
					siz = tx6
				}
				txlen := rl.MeasureText(toptx, siz)
				cntr := rl.NewVector2(screenWidthF32/2, screenHeightF32/2)
				x := int32(cntr.X) - txlen/2
				y := int32(b / 4)
				txrec := rl.NewRectangle(float32(x-8), float32(y-4), float32(txlen+16), float32(siz+8))
				rl.DrawRectangleRec(txrec, rl.Fade(rl.Black, 0.7))
				rl.DrawText(toptx, x-2, y+2, siz, rl.Black)
				rl.DrawText(toptx, x, y, siz, rl.White)
			}
			if toptxT > 0 {
				toptxT--
			}
		}
	}
}

func drawcam() { //MARK:DRAW CAM

	//DRAW GAME LEVEL
	if !pause {
		//LEVEL
		lev := levels[levNum].rectangles
		floor := levels[levNum].floors
		dbg := levels[levNum].dbg
		inf := levels[levNum].inf
		doors := levels[levNum].doors
		walls := levels[levNum].walls
		etc2 := levels[levNum].otherTiles
		chests := levels[levNum].chests
		itm := levels[levNum].items
		enm := levels[levNum].enemies
		bgi := levels[levNum].backgroundInformation
		bgi2 := levels[levNum].backgroundInformation2
		flowers := levels[levNum].flowers
		//FLOORS
		for i := 0; i < len(floor); i++ {
			if rl.CheckCollisionRecs(floor[i].rectangle, drawRec) {
				rl.DrawRectangleRec(floor[i].rectangle, rl.Black)
				if psychedelicsT > 0 {
					rl.DrawTexturePro(imgs, floortile, floor[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(floor[i].color2, floor[i].fade))
				} else {
					rl.DrawTexturePro(imgs, floortile, floor[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(floor[i].color, floor[i].fade))
				}
			}
		}
		//BGI
		for i := 0; i < len(bgi); i++ {
			if rl.CheckCollisionRecs(bgi[i].rectangle, drawRec) {
				rl.DrawTexturePro(imgs, bgi[i].imageRectangle, shrec(bgi[i].rectangle, 12), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, bgi[i].imageRectangle, bgi[i].rectangle, rl.Vector2Zero(), 0, rl.DarkGray)
			}
		}
		//BGI 2
		for i := 0; i < len(bgi2); i++ {
			if rl.CheckCollisionRecs(bgi2[i].rectangle, drawRec) {
				rl.DrawTexturePro(imgs, bgi2[i].imageRectangle, shrec(drec(bgi2[i].rectangle), 12), orgn(bgi2[i].rectangle), bgi2[i].rotation, ShadowColor())
				rl.DrawTexturePro(imgs, bgi2[i].imageRectangle, drec(bgi2[i].rectangle), orgn(bgi2[i].rectangle), bgi2[i].rotation, rl.Fade(rl.DarkGray, 0.7))
			}
		}
		//FLOWERS
		for i := 0; i < len(flowers); i++ {
			if rl.CheckCollisionRecs(flowers[i].rectangle, drawRec) {
				rl.DrawTexturePro(imgs, flowers[i].imageRectangle, shrec(flowers[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, flowers[i].imageRectangle, flowers[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.7))
			}
		}
		//MARK: DRAW FX LAYER BELOW
		if len(effect) > 0 {
			clear := false
			for i := 0; i < len(effect); i++ {
				if !effect[i].isOff && effect[i].isBelow {

					switch effect[i].name {
					case "sludgegeyser":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.5, 0.7)))
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, brec(effect[i].rectangle, 5), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.3, 0.5)))
						if frames%5 == 0 {
							if effect[i].imageRectangle.X < animation[203].x+animation[203].frames*animation[203].width {
								effect[i].imageRectangle.X += animation[203].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, effect[i].rectangle) {
								if !levels[levNum].enemies[j].nodmg {
									if levels[levNum].enemies[j].fly {
										if msgT == 0 {
											admsg("immune > enemy is flying", rl.Yellow)
											msgT = fps
										}
									} else {
										if levels[levNum].enemies[j].poisonT == 0 {
											levels[levNum].enemies[j].poisonT += fps * 3
										}
									}
								}
							}
						}
					case "hotsoup":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(DarkRed(), effect[i].fade))
						rec3 := effect[i].rectangle
						rec3.X += RandF32(-4, 4)
						rec3.Y += RandF32(-4, 4)
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, rec3, rl.Vector2Zero(), 0, rl.Fade(DarkRed(), RandF32(0.05, 0.15)))
						effect[i].fade -= 0.005
						if effect[i].fade <= 0 {
							effect[i].isOff = true
							clear = true
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Yellow)
							rl.DrawRectangleLinesEx(effect[i].collisionRectangle, 2, rl.Magenta)
						}
						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, effect[i].collisionRectangle) {
								if !levels[levNum].enemies[j].nodmg {
									if levels[levNum].enemies[j].fly {
										if msgT == 0 {
											admsg("immune > enemy is flying", rl.Yellow)
											msgT = fps
										}
									} else {
										if levels[levNum].enemies[j].burnT == 0 {
											levels[levNum].enemies[j].burnT += fps * 3
										}
									}
								}
							}
						}
						if rl.CheckCollisionPointRec(cursorV2cam, effect[i].rectangle) {
							toptx = "hot soup"
							toptxT = fps
						}
					case "frenchfries":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.Black, effect[i].fade))
						rec3 := effect[i].rectangle
						rec3.X += RandF32(-4, 4)
						rec3.Y += RandF32(-4, 4)
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, rec3, rl.Vector2Zero(), 0, rl.Fade(RandBlue(), RandF32(0.05, 0.15)))
						effect[i].fade -= 0.005
						if effect[i].fade <= 0 {
							effect[i].isOff = true
							clear = true
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Yellow)
							rl.DrawRectangleLinesEx(effect[i].collisionRectangle, 2, rl.Magenta)
						}
						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, effect[i].collisionRectangle) {
								if !levels[levNum].enemies[j].nodmg {
									if levels[levNum].enemies[j].fly {
										if msgT == 0 {
											admsg("immune > enemy is flying", rl.Yellow)
											msgT = fps
										}
									} else {
										if levels[levNum].enemies[j].oilT == 0 {
											levels[levNum].enemies[j].oilT = fps * 5
										}
									}
								}
							}
						}
						if rl.CheckCollisionPointRec(cursorV2cam, effect[i].rectangle) {
							toptx = "oil slick"
							toptxT = fps
						}
					case "icecream":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandBlue(), RandF32(0.1, 0.3)))
						rec3 := effect[i].rectangle
						rec3.X += RandF32(-4, 4)
						rec3.Y += RandF32(-4, 4)
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, rec3, rl.Vector2Zero(), 0, rl.Fade(RandBlue(), RandF32(0.05, 0.15)))
						effect[i].fade -= 0.005
						if effect[i].fade <= 0 {
							effect[i].isOff = true
							clear = true
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Yellow)
							rl.DrawRectangleLinesEx(effect[i].collisionRectangle, 2, rl.Magenta)
						}
						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, effect[i].collisionRectangle) {
								if !levels[levNum].enemies[j].nodmg {
									if levels[levNum].enemies[j].fly {
										if msgT == 0 {
											admsg("immune > enemy is flying", rl.Yellow)
											msgT = fps
										}
									} else {
										if levels[levNum].enemies[j].freezeT == 0 {
											levels[levNum].enemies[j].freezeT = fps * 3
										}
									}
								}
							}
						}
						if rl.CheckCollisionPointRec(cursorV2cam, effect[i].rectangle) {
							toptx = "ice cream sludge"
							toptxT = fps
						}
					case "birdegg":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 4), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.White, effect[i].fade))
						effect[i].fade -= 0.007
						if effect[i].fade <= 0 {
							effect[i].isOff = true
							clear = true
						}
					case "mrfrisbeenear":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandYellow(), RandF32(0.4, 0.7)))
						if frames%3 == 0 {
							if effect[i].imageRectangle.X < animation[117].x+animation[117].frames*animation[117].width {
								effect[i].imageRectangle.X += animation[117].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
					case "bomb":
						//FUSE
						rec3 := effect[i].rectangle
						rec3.Y -= rec3.Height / 2
						rec3.X -= b / 4
						rec3.Y -= b / 4
						rec3.Width += b / 2
						rec3.Height += b / 2
						rl.DrawTexturePro(imgs, animation[105].rectangle, rec3, rl.Vector2Zero(), 0, rl.White)
						if frames%4 == 0 {
							animation[105].rectangle.X += animation[105].width
							if animation[105].rectangle.X > animation[105].x+animation[105].frames*animation[105].width {
								animation[105].rectangle.X = animation[105].x
							}
						}
						//IMG
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.White)
						effect[i].timer--
						if effect[i].timer == 0 {
							rl.PlaySound(audfx[94])
							zfx := Effect{}
							zfx.name = "bombExplode"
							zfx.rectangle = effect[i].rectangle
							zfx.rectangle.X -= b10
							zfx.rectangle.Y -= b10
							zfx.rectangle.Width += b10 * 2
							zfx.rectangle.Height += b10 * 2
							zfx.imageRectangle = animation[106].rectangle
							effect = append(effect, zfx)
							effect[i].isOff = true
							clear = true
						}
					case "chickenEgg":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.4, 0.7)))
						effect[i].timer--
						if effect[i].timer == 0 {
							zfx := Effect{}
							zfx.name = "chickenExplode"
							zfx.imageRectangle = animation[104].rectangle
							zfx.rectangle = effect[i].rectangle
							zfx.rectangle.X -= b5
							zfx.rectangle.Y -= b8
							zfx.rectangle.Width += b10
							zfx.rectangle.Height += b10
							zfx.collisionRectangle = zfx.rectangle
							zfx.collisionRectangle.X += b2
							zfx.collisionRectangle.Y += b2
							zfx.collisionRectangle.Width -= b4
							zfx.collisionRectangle.Height -= b4
							effect = append(effect, zfx)
							effect[i].isOff = true
							clear = true
						}
					case "flamingoflame":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.White, effect[i].fade))
						rec3 := effect[i].rectangle
						rec3.X += RandF32(-4, 4)
						rec3.Y += RandF32(-4, 4)
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, rec3, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.2))
						if frames%4 == 0 {
							effect[i].imageRectangle.X += animation[98].width
							if effect[i].imageRectangle.X > animation[98].x+animation[98].frames*animation[98].width {
								effect[i].imageRectangle.X = animation[98].x
							}
						}
						effect[i].timer--
						if effect[i].timer < fps {
							effect[i].fade -= 0.05
						}
						if effect[i].timer == 0 {
							effect[i].isOff = true
							clear = true
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Yellow)
							rl.DrawRectangleLinesEx(effect[i].collisionRectangle, 2, rl.Magenta)
						}
						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, effect[i].collisionRectangle) {
								if !levels[levNum].enemies[j].nodmg && levels[levNum].enemies[j].burnT == 0 {
									if levels[levNum].enemies[j].name == "flamehead" || levels[levNum].enemies[j].name == "yellowdino" || levels[levNum].enemies[j].name == "ghost" || levels[levNum].enemies[j].name == "fly" || levels[levNum].enemies[j].name == "reddevil" {
										if msgT == 0 {
											admsg("immune to burn", rl.Yellow)
											msgT = fps
										}
									} else {
										levels[levNum].enemies[j].burnT = fps * 3
									}
								}
							}
						}
					case "toxic":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandGreen(), effect[i].fade))
						rec3 := effect[i].rectangle
						rec3.X += RandF32(-4, 4)
						rec3.Y += RandF32(-4, 4)
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, rec3, rl.Vector2Zero(), 0, rl.Fade(RandGreen(), 0.1))
						effect[i].fade -= 0.005
						if effect[i].fade <= 0 {
							effect[i].isOff = true
							clear = true
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Yellow)
							rl.DrawRectangleLinesEx(effect[i].collisionRectangle, 2, rl.Magenta)
						}
						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, effect[i].collisionRectangle) {
								if !levels[levNum].enemies[j].nodmg {
									if levels[levNum].enemies[j].fly {
										if msgT == 0 {
											admsg("immune > enemy is flying", rl.Yellow)
											msgT = fps
										}
									} else {
										if levels[levNum].enemies[j].poisonT == 0 {
											levels[levNum].enemies[j].poisonT = fps * 3
										}
									}
								}
							}
						}
					}

				}
			}
			if clear {
				Remove(1)
			}
		}
		//MARK: DRAW ETC LAYER BELOW
		for i := 0; i < len(etc2); i++ {
			clear := false
			if rl.CheckCollisionRecs(etc2[i].rectangle, drawRec) {
				if !etc2[i].isOff {
					switch etc2[i].name {
					case "stairs":
						rl.DrawTexturePro(imgs, etc2[i].image, shrec(etc2[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, etc2[i].image, etc2[i].rectangle, rl.Vector2Zero(), 0, rl.White)
						txs := tx2
						txt := "exit"
						txlen := rl.MeasureText(txt, txs)
						xtx := (etc2[i].rectangle.ToInt32().X + etc2[i].rectangle.ToInt32().Width/2) - txlen/2
						xtx += 2
						ytx := etc2[i].rectangle.ToInt32().Y + etc2[i].rectangle.ToInt32().Height - (txs + 1)
						rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
						rl.DrawText(txt, xtx, ytx, txs, RandColor())
						if rl.CheckCollisionRecs(player.collisionRectangle, etc2[i].rectangle) {
							exitPauseT--
							xtx := int32(etc2[i].rectangle.X+etc2[i].rectangle.Width/2) - tx/4
							ytx := int32(etc2[i].rectangle.Y) - tx2
							if exitPauseT > fps {
								rl.DrawText("2", xtx-2, ytx+2, tx2, rl.Black)
								rl.DrawText("2", xtx, ytx, tx2, rl.Yellow)
							} else if exitPauseT > 0 && exitPauseT < fps {
								rl.DrawText("1", xtx-2, ytx+2, tx2, rl.Black)
								rl.DrawText("1", xtx, ytx, tx2, rl.Yellow)
							}
							if exitPauseT == 0 {
								choose := RandInt(1, 6)
								switch choose {
								case 1:
									rl.PlaySound(audfx[124])
								case 2:
									rl.PlaySound(audfx[125])
								case 3:
									rl.PlaySound(audfx[126])
								case 4:
									rl.PlaySound(audfx[127])
								case 5:
									rl.PlaySound(audfx[128])
								}
								if treasureRoom {
									treasureRoom = false
									pause = true
									isBaseOn = true
									rl.StopMusicStream(music[currentMusic])
									currentMusic = 2
									rl.PlayMusicStream(music[currentMusic])
									if vineRing {
										for i := 0; i < len(player.art); i++ {
											if player.art[i].name == "ring of vine" {
												player.art[i].isOff = false
											}
										}
									}
									if batty {
										batcomp.cnt = currentPosition
										batcomp.rectangle = rl.NewRectangle(batcomp.cnt.X-batcomp.rectangle.Width/2, batcomp.rectangle.Height/2, batcomp.rectangle.Width, batcomp.rectangle.Height)
										batcomp.moveChangeT = fps * 3
									}
									if rollo {
										rollocomp.cnt = currentPosition
										rollocomp.rectangle = rl.NewRectangle(rollocomp.cnt.X-rollocomp.rectangle.Width/2, rollocomp.cnt.Y-rollocomp.rectangle.Height/2, rollocomp.rectangle.Width, rollocomp.rectangle.Height)
									}
								}
								player.center = currentPosition
								updatePlayerRectangle()
								makelevel()
							}
						} else {
							exitPauseT = fps * 2
						}
					case "rock":
						rl.DrawTexturePro(imgs, etc2[i].image, shrec(etc2[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, etc2[i].image, etc2[i].rectangle, rl.Vector2Zero(), 0, rl.White)
					case "switch": //SWITCHES
						rl.DrawTexturePro(imgs, etc2[i].image, shrec(etc2[i].rectangle, 3), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, etc2[i].image, etc2[i].rectangle, rl.Vector2Zero(), 0, rl.White)
						if rl.CheckCollisionRecs(player.collisionRectangle, etc2[i].rectangle) && !etc2[i].onoff {
							rl.PlaySound(audfx[4])
							etc2[i].onoff = true
							if etc2[i].image == otherTiles[132] {
								etc2[i].image = otherTiles[133]
							} else if etc2[i].image == otherTiles[134] {
								etc2[i].image = otherTiles[135]
							}
							switch etc2[i].numType {
							case 6: //ORE
								rl.PlaySound(audfx[114])
								zitm := Item{}
								choose2 := RandInt(1, 6)
								switch choose2 {
								case 1:
									zitm = itemList[38]
								case 2:
									zitm = itemList[39]
								case 3:
									zitm = itemList[40]
								case 4:
									zitm = itemList[41]
								case 5:
									zitm = itemList[42]
								}
								zitm.numof = 10
								count := 0
								for {
									zitm.center = player.center
									switch count {
									case 0:
										zitm.center.X -= player.rectangle.Width
									case 1:
										zitm.center.X -= player.rectangle.Width
										zitm.center.Y -= player.rectangle.Width
									case 2:
										zitm.center.Y -= player.rectangle.Width
									case 3:
										zitm.center.X += player.rectangle.Width
										zitm.center.Y -= player.rectangle.Width
									case 4:
										zitm.center.X += player.rectangle.Width
									case 5:
										zitm.center.X += player.rectangle.Width
										zitm.center.Y += player.rectangle.Width
									case 6:
										zitm.center.Y += player.rectangle.Width
									case 7:
										zitm.center.X -= player.rectangle.Width
										zitm.center.Y += player.rectangle.Width
									}
									canadd := checkV2Walls(zitm.center)
									if canadd {
										zitm.rectangle = rl.NewRectangle(zitm.center.X-zitm.rectangle.Width/2, zitm.center.Y-zitm.rectangle.Height/2, zitm.rectangle.Width, zitm.rectangle.Height)
										levels[levNum].items = append(levels[levNum].items, zitm)
										zfx := Effect{}
										zfx.imageRectangle = animation[108].rectangle
										zfx.rectangle = zitm.rectangle
										zfx.rectangle.X -= b
										zfx.rectangle.Y -= b
										zfx.rectangle.Width += b2
										zfx.rectangle.Height += b2
										zfx.name = "summonitem"
										effect = append(effect, zfx)
										break
									}
									count++
									if count > 7 {
										admsg("nothing... sorry", rl.Yellow)
										break
									}
								}
							case 5: //TELEPORT CRYSTAL
								rl.PlaySound(audfx[114])
								zitm := itemList[104]
								count := 0
								for {
									zitm.center = player.center
									switch count {
									case 0:
										zitm.center.X -= player.rectangle.Width
									case 1:
										zitm.center.X -= player.rectangle.Width
										zitm.center.Y -= player.rectangle.Width
									case 2:
										zitm.center.Y -= player.rectangle.Width
									case 3:
										zitm.center.X += player.rectangle.Width
										zitm.center.Y -= player.rectangle.Width
									case 4:
										zitm.center.X += player.rectangle.Width
									case 5:
										zitm.center.X += player.rectangle.Width
										zitm.center.Y += player.rectangle.Width
									case 6:
										zitm.center.Y += player.rectangle.Width
									case 7:
										zitm.center.X -= player.rectangle.Width
										zitm.center.Y += player.rectangle.Width
									}
									canadd := checkV2Walls(zitm.center)
									if canadd {
										zitm.rectangle = rl.NewRectangle(zitm.center.X-zitm.rectangle.Width/2, zitm.center.Y-zitm.rectangle.Height/2, zitm.rectangle.Width, zitm.rectangle.Height)
										levels[levNum].items = append(levels[levNum].items, zitm)
										zfx := Effect{}
										zfx.imageRectangle = animation[108].rectangle
										zfx.rectangle = zitm.rectangle
										zfx.rectangle.X -= b
										zfx.rectangle.Y -= b
										zfx.rectangle.Width += b2
										zfx.rectangle.Height += b2
										zfx.name = "summonitem"
										effect = append(effect, zfx)
										break
									}
									count++
									if count > 7 {
										admsg("nothing... sorry", rl.Yellow)
										break
									}
								}
							case 4: //MULITPLE STATUS EFFECTS
								found := false
								countbreak := 100
								for {
									choose := RandInt(1, 9)
									switch choose {
									case 1:
										if lollipopT == 0 {
											rl.PlaySound(audfx[90])
											admsg("mana regeneration", rl.Yellow)
											lollipopT = fps * 30
											found = true
										}
									case 2:
										if tvT == 0 {
											rl.PlaySound(audfx[89])
											admsg("paused", rl.Yellow)
											tvT = fps * 10
											found = true
										}
									case 3:
										if orangeT == 0 {
											rl.PlaySound(audfx[88])
											admsg("health regeneration", rl.Yellow)
											orangeT = fps * 30
											found = true
										}
									case 4:
										if steroidsT == 0 {
											rl.PlaySound(audfx[75])
											admsg("rambo returns", rl.Yellow)
											steroidsT = fps * 30
											stats.strength2 = stats.strength
											stats.strength = 5
											found = true
										}
									case 5:
										teleportT = fps / 2
										telCntr = true
										found = true
									case 6:
										if gasT == 0 {
											rl.PlaySound(audfx[16])
											admsg("burn baby burn", rl.Yellow)
											gasT = fps * 30
											found = true
										}
									case 7:
										if pistolT == 0 {
											rl.PlaySound(audfx[78])
											admsg("attack, attack, attack!", rl.Yellow)
											pistolT = fps * 30
											found = true
										}
									case 8:
										if slugT == 0 {
											rl.PlaySound(audfx[16])
											admsg("run like the wind", rl.Yellow)
											slugT = fps * 30
											found = true
										}
									}
									if found {
										zfx := Effect{}
										zfx.imageRectangle = animation[180].rectangle
										zfx.rectangle = etc2[i].rectangle
										zfx.rectangle.X -= b2
										zfx.rectangle.Y -= b2
										zfx.rectangle.Width += b4
										zfx.rectangle.Height += b4
										zfx.name = "switchfx"
										effect = append(effect, zfx)
										break
									}
									countbreak--
									if countbreak == 0 {
										break
									}
								}
							case 3: //BLACKDOT
								if blackdotCount < 50 {
									rl.PlaySound(audfx[116])
									for j := 0; j < 3; j++ {
										zenm := enmlist[10] //BLACKDOT
										zenm.numMax = RandInt(4, 11)
										zenm.atkT = fps
										zenm.cnt = findRanCntinRoom(levels[levNum].rectangles[etc2[i].room])
										zenm.rectangle = rl.NewRectangle(zenm.cnt.X-zenm.rectangle.Width/2, zenm.cnt.Y-zenm.rectangle.Height/2, zenm.rectangle.Width, zenm.rectangle.Height)
										zenm.collisionRectangle = zenm.rectangle
										zenm.dirX = RandF32(-zenm.speed, zenm.speed)
										zenm.dirY = RandF32(-zenm.speed, zenm.speed)
										levels[levNum].enemies = append(levels[levNum].enemies, zenm)
										levels[levNum].enemyNum++
									}
								}
							case 2: //GHOSTS
								if len(levels[levNum].enemies) < 70 {
									for j := 0; j < 3; j++ {
										rl.PlaySound(audfx[116])
										zenm := enmlist[3] //GHOST
										zenm.cnt = findRanCntinRoom(levels[levNum].rectangles[etc2[i].room])
										zenm.rectangle = rl.NewRectangle(zenm.cnt.X-zenm.rectangle.Width/2, zenm.cnt.Y-zenm.rectangle.Height/2, zenm.rectangle.Width, zenm.rectangle.Height)
										zenm.dirX = RandF32(-zenm.speed, zenm.speed)
										zenm.dirY = RandF32(-zenm.speed, zenm.speed)
										zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 8
										zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 8
										zenm.collisionRectangle.Width -= zenm.collisionRectangle.Width / 4
										zenm.collisionRectangle.Height -= zenm.collisionRectangle.Height / 4
										//AREA REC
										zenm.carec = zenm.rectangle
										zenm.carec.X -= b3
										zenm.carec.Y -= b3
										zenm.carec.Width += b6
										zenm.carec.Height += b6
										levels[levNum].enemies = append(levels[levNum].enemies, zenm)
										levels[levNum].enemyNum++
									}
								}
							case 1: //DARTS
								rl.PlaySound(audfx[115])
								makedarts(etc2[i])
							}
						}
						if etc2[i].onoff {
							etc2[i].timer--
							if etc2[i].timer == 0 {
								switch etc2[i].numType {
								case 1, 2, 3:
									etc2[i].timer = fps * 3
									if etc2[i].image == otherTiles[133] {
										etc2[i].image = otherTiles[132]
									} else if etc2[i].image == otherTiles[135] {
										etc2[i].image = otherTiles[134]
									}
									etc2[i].onoff = false
								case 4:
									etc2[i].timer = fps * 30
									if etc2[i].image == otherTiles[133] {
										etc2[i].image = otherTiles[132]
									} else if etc2[i].image == otherTiles[135] {
										etc2[i].image = otherTiles[134]
									}
									etc2[i].onoff = false
								}
							}
						}
					case "flametrap": //FLAME TRAP
						rl.DrawTexturePro(imgs, etc2[i].image, etc2[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(etc2[i].color, etc2[i].fade))
						if rl.CheckCollisionRecs(player.collisionRectangle, etc2[i].rectangle2) && !etc2[i].onoff && etc2[i].image.X == animation[2].x && tvT == 0 {
							rl.PlaySound(audfx[13])
							etc2[i].onoff = true
							if bootsT > 0 {
								admsg("boots save trap damage", rl.Green)
							} else {
								if player.burnTimer == 0 && player.dampTimer == 0 && icelollyT == 0 && player.resistFireTimer == 0 {
									if ovenglovenum > 0 {
										if Roll6() <= ovenglovenum {
											admsg("oven glove saves burn", rl.Green)
										} else {
											admsg("burning...", rl.Orange)
											player.burnTimer += fps * 3
										}
									} else {
										admsg("burning...", rl.Orange)
										player.burnTimer += fps * 3
									}
								} else if player.burnTimer == 0 && player.dampTimer != 0 && icelollyT == 0 && player.resistFireTimer == 0 {
									admsg("damp saves burn", rl.Green)
								} else if player.burnTimer == 0 && player.dampTimer == 0 && icelollyT != 0 && player.resistFireTimer == 0 {
									admsg("ice lolly saves burn", rl.Green)
								} else if player.burnTimer == 0 && player.dampTimer == 0 && icelollyT == 0 && player.resistFireTimer != 0 {
									admsg("resist fire saves burn", rl.Green)
								} else {
									if player.hpTimer == 0 {
										hitPL(2)
									}
								}
							}
						}
						if frames%3 == 0 {
							if etc2[i].onoff && etc2[i].image.X < animation[2].x+animation[2].frames*animation[2].width {
								etc2[i].image.X += animation[2].width
								if etc2[i].image.X >= animation[2].x+animation[2].frames*animation[2].width {
									etc2[i].onoff = false
								}
							}
							if !etc2[i].onoff && etc2[i].image.X > animation[2].x {
								etc2[i].image.X -= animation[2].width
							}
						}
					case "spiketrap": //SPIKE TRAP
						rl.DrawTexturePro(imgs, etc2[i].image, etc2[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(etc2[i].color, etc2[i].fade))
						if rl.CheckCollisionRecs(player.collisionRectangle, etc2[i].rectangle) && !etc2[i].onoff && etc2[i].image.X == animation[1].x && player.enemyCollisionTimer == 0 && tvT == 0 {
							rl.PlaySound(audfx[12])
							etc2[i].onoff = true
							if feather {
								if msgT == 0 {
									admsg("immune spikes > feather cushions", rl.White)
									msgT = fps
								}
							} else if bootsT > 0 {
								admsg("boots save trap damage", rl.Blue)
							} else {
								player.enemyCollisionTimer = fps
								if stats.dexterity > 1 {
									if Roll12() <= stats.dexterity {
										if msgT == 0 {
											admsg("dodged > dexterity", rl.Magenta)
											msgT = fps
										}
									} else {
										if player.hpTimer == 0 {
											hitPL(1)
										}
									}
								} else {
									if player.hpTimer == 0 {
										hitPL(1)
									}
								}
							}
						}
						if frames%3 == 0 {
							if etc2[i].onoff && etc2[i].image.X < animation[1].x+animation[1].frames*animation[1].width {
								etc2[i].image.X += animation[1].width
								if etc2[i].image.X >= animation[1].x+animation[1].frames*animation[1].width {
									etc2[i].onoff = false
								}
							}
							if !etc2[i].onoff && etc2[i].image.X > animation[1].x {
								etc2[i].image.X -= animation[1].width
							}
						}
					case "water": //WATER
						rl.DrawTexturePro(imgs, etc2[i].image2, etc2[i].rectangle2, rl.Vector2Zero(), 0, rl.Fade(etc2[i].color, etc2[i].fade)) //BLUE SPLAT IMG
						rec2 := etc2[i].rectangle                                                                                              //SMALLER REC FOR WATER ANIM
						rec2.X += b / 8
						rec2.Y += b / 8
						rec2.Width -= b / 4
						rec2.Height -= b / 4
						rl.DrawTexturePro(imgs, etc2[i].image, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.SkyBlue, RandF32(0.2, 0.7)))
						if frames%3 == 0 {
							etc2[i].image.X += animation[0].width
							if etc2[i].image.X > animation[0].x+animation[0].width*animation[0].frames {
								etc2[i].image.X = animation[0].x
							}
						}
						if rl.CheckCollisionRecs(player.collisionRectangle, etc2[i].rectangle) && player.dampTimer == 0 && !umbrella {
							player.dampTimer = fps * 2
							admsg("damp...", rl.Blue)
							rl.PlaySound(audfx[6])
							if toaster {
								zfx := Effect{}
								zfx.name = "shockwave"
								zfx.imageRectangle = animation[99].rectangle
								zfx.rectangle = player.rectangle
								zfx.rectangle.X -= b5
								zfx.rectangle.Y -= b5
								zfx.rectangle.Width += b10
								zfx.rectangle.Height += b10
								effect = append(effect, zfx)
							}
						} else if rl.CheckCollisionRecs(player.collisionRectangle, etc2[i].rectangle) && player.dampTimer == 0 && umbrella {
							if msgT == 0 {
								msgT = fps * 2
								admsg("umbrella saves damp", rl.Green)
								if toaster {
									zfx := Effect{}
									zfx.name = "shockwave"
									zfx.imageRectangle = animation[99].rectangle
									zfx.rectangle = player.rectangle
									zfx.rectangle.X -= b5
									zfx.rectangle.Y -= b5
									zfx.rectangle.Width += b10
									zfx.rectangle.Height += b10
									effect = append(effect, zfx)
								}
							}
						}
						//TXT
						if rl.CheckCollisionPointRec(cursorV2cam, etc2[i].rectangle2) {
							toptx = "a puddle"
							toptxT = fps
						}
					}
					//DEBUG ETC
					if debug {
						rl.DrawRectangleLinesEx(etc2[i].rectangle, 2, rl.Orange)
						rl.DrawRectangleLinesEx(etc2[i].cRectangle, 2, rl.Magenta)
						txtx := etc2[i].rectangle.ToInt32().X + 2
						txty := etc2[i].rectangle.ToInt32().Y + 2
						rl.DrawText(fmt.Sprint(etc2[i].name), txtx-1, txty+1, tx, rl.Black)
						rl.DrawText(fmt.Sprint(etc2[i].name), txtx, txty, tx, rl.White)
						rl.DrawCircleV(etc2[i].center, 4, rl.Red)
						if etc2[i].rectangle2.Width > 0 {
							rl.DrawRectangleLinesEx(etc2[i].rectangle2, 2, rl.White)
						}
					}
				} else {
					clear = true
				}
				if clear {
					Remove(2)
				}
			}
		}
		//WALLS
		for i := 0; i < len(walls); i++ {
			if rl.CheckCollisionRecs(walls[i].rectangle, drawRec) {
				if walls[i].dirX == 0 && walls[i].dirY == 0 {
					//BG REC
					rl.DrawRectangleRec(walls[i].rectangle, rl.Black)
					if psychedelicsT > 0 {
						//IMG REC
						rl.DrawTexturePro(imgs, walltile, walls[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(walls[i].color2, walls[i].fade))
						//BLUR REC
						rl.DrawTexturePro(imgs, walltile, blrec(walls[i].rectangle, 0.2), rl.Vector2Zero(), 0, rl.Fade(walls[i].color2, 0.3))
					} else {
						//IMG REC
						rl.DrawTexturePro(imgs, walltile, walls[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(walls[i].color, walls[i].fade))
						//BLUR REC
						rl.DrawTexturePro(imgs, walltile, blrec(walls[i].rectangle, 0.2), rl.Vector2Zero(), 0, rl.Fade(walls[i].color, 0.3))
					}
					if debug {
						rl.DrawRectangleLinesEx(walls[i].rectangle, 2, rl.Green)
					}
				}
			}
		}

		//MARK: DRAW PROJ ENEMY BELOW
		if len(enemyProjectiles) > 0 {
			for i := 0; i < len(enemyProjectiles); i++ {
				if !enemyProjectiles[i].isOff && enemyProjectiles[i].isBelow {
					switch enemyProjectiles[i].name {
					case "reddevilFlame":
						rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 3), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
						col := RandOrange()
						rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(col, enemyProjectiles[i].fade))
						//BLUR
						rl.DrawTexturePro(imgs, enemyProjectiles[i].image, brec(drec(enemyProjectiles[i].rec), 3), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(col, RandF32(0.5, 0.25)))
						enemyProjectiles[i].fade -= 0.005
						if enemyProjectiles[i].fade <= 0 {
							enemyProjectiles[i].isOff = true
						}
						if frames%4 == 0 {
							enemyProjectiles[i].image.X += animation[169].width
							if enemyProjectiles[i].image.X > animation[169].x+animation[169].frames*animation[169].width {
								enemyProjectiles[i].image.X = animation[169].x
							}
						}
					case "mushLand":
						rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 5), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
						rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.White)
						if frames%10 == 0 {
							enemyProjectiles[i].isOn = !enemyProjectiles[i].isOn
						}
						if enemyProjectiles[i].isOn {
							cntr := enemyProjectiles[i].center
							cntr.Y -= 2
							rl.DrawCircleV(cntr, 1, rl.Red)
							rl.DrawCircleGradient(int32(cntr.X), int32(cntr.Y), 8, DarkRed(), rl.Blank)
						}
						if rl.CheckCollisionRecs(player.collisionRectangle, enemyProjectiles[i].crec) {
							zfx := Effect{}
							zfx.imageRectangle = animation[57].rectangle
							zfx.center = player.center
							siz := b5
							zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
							zfx.collisionRectangle = zfx.rectangle
							zfx.collisionRectangle.X += zfx.collisionRectangle.Width / 8
							zfx.collisionRectangle.Y += zfx.collisionRectangle.Width / 8
							zfx.collisionRectangle.Height -= zfx.collisionRectangle.Height / 4
							zfx.collisionRectangle.Width -= zfx.collisionRectangle.Width / 4
							zfx.name = "landmineExplod"
							effect = append(effect, zfx)
							hitPL(1)
							if player.burnTimer == 0 {
								player.burnTimer = fps * 3
								if msgT == 0 {
									admsg("burning...", rl.Orange)
								}
							}
							enemyProjectiles[i].isOff = true
						}
					case "zomboSlime":
						rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 3), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
						rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(RandGreen(), enemyProjectiles[i].fade))
						enemyProjectiles[i].fade -= 0.003
						if enemyProjectiles[i].fade <= 0 {
							enemyProjectiles[i].isOff = true
						}
						if rl.CheckCollisionRecs(player.rectangle, enemyProjectiles[i].rec) && player.poisonTimer == 0 {
							player.poisonTimer += fps * 3
						}
					case "yellowdinobull":
						rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 4), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
						rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(enemyProjectiles[i].col, enemyProjectiles[i].fade))
						if frames%4 == 0 {
							enemyProjectiles[i].image.X += animation[62].width
							if enemyProjectiles[i].image.X > animation[62].x+animation[62].frames*animation[62].width {
								enemyProjectiles[i].image.X = animation[62].x
							}
						}
						enemyProjectiles[i].fade -= 0.01
						if enemyProjectiles[i].fade <= 0 {
							enemyProjectiles[i].isOff = true
						}
					}
					if debug {
						rl.DrawRectangleLinesEx(enemyProjectiles[i].rec, 1, rl.Yellow)
						rl.DrawRectangleLinesEx(enemyProjectiles[i].crec, 1, rl.Magenta)
					}
				}
			}
		}
		//MARK: DRAW PLAYER LIGHT CIRCLE
		if lightbulbnum > 0 && !player.gameover {
			rad := float32(b2)
			rad += float32(lightbulbnum) * b / 3
			rl.DrawCircleGradient(int32(player.center.X), int32(player.center.Y), rad, rl.Fade(rl.SkyBlue, RandF32(0.3, 0.5)), rl.Blank)
			for j := 0; j < len(levels[levNum].enemies); j++ {
				if rl.CheckCollisionPointCircle(levels[levNum].enemies[j].cnt, player.center, rad-rad/4) && levels[levNum].enemies[j].stunT == 0 {
					levels[levNum].enemies[j].stunT = fps * 2
					levels[levNum].enemies[j].stunF = 0.9
					levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
					levels[levNum].enemies[j].stunSiz = b / 4
				}
			}
		}
		//MARK: DRAW ETC LAYER ABOVE 1
		for i := 0; i < len(etc2); i++ {
			if rl.CheckCollisionRecs(etc2[i].rectangle, drawRec) {
				if !etc2[i].isOff {
					switch etc2[i].name {
					case "teleporter": //TELEPORTER
						rl.DrawTexturePro(imgs, etc2[i].image, shrec(etc2[i].rectangle, 12), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, etc2[i].image, etc2[i].rectangle, rl.Vector2Zero(), 0, rl.White)
						if frames%4 == 0 {
							etc2[i].image.X += animation[88].width
							if etc2[i].image.X > animation[88].x+animation[88].width*animation[88].frames {
								etc2[i].image.X = animation[88].x
							}
						}
						//TXT
						if rl.CheckCollisionPointRec(cursorV2cam, etc2[i].cRectangle) {
							toptx = "teleporter"
							toptxT = fps
						}
						//PLAYER COLLIS
						if rl.CheckCollisionRecs(player.collisionRectangle, etc2[i].cRectangle) {
							found := false
							for j := 0; j < len(player.inventory); j++ {
								if player.inventory[j].name == "teleporter crystal" {
									found = true
									teleporting = true
									xtx := int32(etc2[i].cRectangle.X+etc2[i].cRectangle.Width/2) - tx/4
									ytx := int32(etc2[i].cRectangle.Y)
									if teleportPauseT > fps {
										rl.DrawText("2", xtx-2, ytx+2, tx2, rl.Black)
										rl.DrawText("2", xtx, ytx, tx2, rl.Yellow)
									} else if teleportPauseT > 0 && teleportPauseT < fps {
										rl.DrawText("1", xtx-2, ytx+2, tx2, rl.Black)
										rl.DrawText("1", xtx, ytx, tx2, rl.Yellow)
									}
									teleportPauseT--
									if teleportPauseT == 0 {
										rl.PlaySound(audfx[45])
										if teleportT == 0 {
											teleportT = fps / 2
											telBase = true
											admsg("bye bye", rl.Magenta)
											if player.inventory[j].numof > 1 {
												player.inventory[j].numof--
											} else {
												player.inventory[j] = Item{}
											}
										}
									}
								}
							}
							if !found && !teleporting && msgT == 0 {
								admsg("no teleporter crystal", rl.Red)
								msgT = fps
							}
						} else {
							teleportPauseT = fps * 2
							teleporting = false
						}
					case "beartrap": //BEAR TRAP
						rl.DrawTexturePro(imgs, etc2[i].image, shrec(etc2[i].rectangle, 3), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, etc2[i].image, etc2[i].rectangle, rl.Vector2Zero(), 0, rl.White)
						if etc2[i].onoff && etc2[i].image.X < animation[86].x+animation[86].frames*animation[86].width {
							if frames%4 == 0 {
								etc2[i].image.X += animation[86].width
							}
						} else if etc2[i].onoff && etc2[i].image.X >= animation[86].x+animation[86].frames*animation[86].width {
							levels[levNum].otherTiles[i].isOff = true
						}
						//TXT
						if rl.CheckCollisionPointRec(cursorV2cam, etc2[i].cRectangle) {
							toptx = "bear trap"
							toptxT = fps
						}
					case "landmine": //PLAYER LANDMINE
						rl.DrawTexturePro(imgs, etc2[i].image, shrec(etc2[i].rectangle, 3), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, etc2[i].image, etc2[i].rectangle, rl.Vector2Zero(), 0, rl.White)
						//TXT
						if rl.CheckCollisionPointRec(cursorV2cam, etc2[i].cRectangle) {
							toptx = "landmine"
							toptxT = fps
						}
						if frames%10 == 0 {
							etc2[i].onoff = !etc2[i].onoff
						}
						if etc2[i].onoff {
							cntr := etc2[i].center
							cntr.Y -= 2
							rl.DrawCircleV(cntr, 1, rl.Red)
							rl.DrawCircleGradient(int32(cntr.X), int32(cntr.Y), 8, DarkRed(), rl.Blank)
						}
					}
					//DEBUG ETC
					if debug {
						rl.DrawRectangleLinesEx(etc2[i].rectangle, 2, rl.Orange)
						rl.DrawRectangleLinesEx(etc2[i].cRectangle, 2, rl.Magenta)
						txtx := etc2[i].rectangle.ToInt32().X + 2
						txty := etc2[i].rectangle.ToInt32().Y + 2
						rl.DrawText(fmt.Sprint(etc2[i].name), txtx-1, txty+1, tx, rl.Black)
						rl.DrawText(fmt.Sprint(etc2[i].name), txtx, txty, tx, rl.White)
						rl.DrawCircleV(etc2[i].center, 4, rl.Red)
						if etc2[i].rectangle2.Width > 0 {
							rl.DrawRectangleLinesEx(etc2[i].rectangle2, 2, rl.White)
						}
					}
				}
			}
		}
		//DRAW ETC CRATE SHADOWS
		for i := 0; i < len(etc2); i++ {
			if rl.CheckCollisionRecs(etc2[i].rectangle, drawRec) {
				if !etc2[i].isOff && etc2[i].name == "crate" {
					rl.DrawTexturePro(imgs, etc2[i].image, shrec(etc2[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
				}
			}
		}
		//MARK: DRAW ETC ABOVE LAYER 2 CRATES
		for i := 0; i < len(etc2); i++ {
			clear := false
			if rl.CheckCollisionRecs(etc2[i].rectangle, drawRec) {
				if !etc2[i].isOff {
					switch etc2[i].name {
					case "crate":
						rl.DrawTexturePro(imgs, etc2[i].image, shrec(etc2[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
						if etc2[i].hpTimer > 0 {
							if etc2[i].image == otherTiles[2] { //HIT IMG OLD CRATE
								rl.DrawTexturePro(imgs, otherTiles[6], etc2[i].rectangle, rl.Vector2Zero(), 0, RandColor())
							} else { //HIT IMG NEW CRATE
								rl.DrawTexturePro(imgs, otherTiles[5], etc2[i].rectangle, rl.Vector2Zero(), 0, RandColor())
							}
						} else { //CRATE IMG
							rl.DrawTexturePro(imgs, etc2[i].image, etc2[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(etc2[i].color, etc2[i].fade))
						}
						//TXT
						if rl.CheckCollisionPointRec(cursorV2cam, etc2[i].rectangle) {
							if etc2[i].image == otherTiles[2] || etc2[i].image == otherTiles[4] {
								toptx = "scrap crate"
								toptxT = fps
							} else {
								toptx = "loot crate"
								toptxT = fps
							}
						}
						//HIT TIMER
						if etc2[i].hpTimer > 0 {
							etc2[i].hpTimer--
						}
						if etc2[i].hp <= 0 {
							destroycrate(i)
							etc2[i].isOff = true
						}
						//MOVE CRATE TIMER
						if etc2[i].moveTimer > 0 {
							etc2[i].moveTimer--
							if checkRecWallsChestsEtcSolid(etc2[i].rectangle, i, 1) {
								etc2[i].rectangle.X += etc2[i].dirX
								etc2[i].rectangle.Y += etc2[i].dirY
								etc2[i].center = makecnt(etc2[i].rectangle)
							}
						} else {
							etc2[i].dirX = 0
							etc2[i].dirY = 0
						}
						//MARK: CHECK CRATE VS TRAP COLLIS
						for j := 0; j < len(etc2); j++ {
							if etc2[j].name == "flametrap" || etc2[j].name == "spiketrap" {
								if rl.CheckCollisionRecs(etc2[i].rectangle, etc2[j].rectangle) {
									if etc2[j].name == "flametrap" && rl.CheckCollisionRecs(etc2[i].rectangle, etc2[j].rectangle2) && !etc2[j].onoff && etc2[j].image.X == animation[2].x {
										etc2[j].onoff = true
									}
									if rl.CheckCollisionRecs(etc2[i].rectangle, etc2[j].rectangle) && !etc2[j].onoff && etc2[j].image.X == animation[1].x {
										etc2[j].onoff = true
									}
									if etc2[i].image == otherTiles[2] || etc2[i].image == otherTiles[4] {
										if etc2[i].hpTimer == 0 {
											etc2[i].hpTimer = fps / 10
											etc2[i].hp--
										}
									}
								}
							}
						}
						//MARK:CHECK CRATE VS FIRE COLLIS
						if fireson {
							for j := 0; j < len(levels[levNum].enemies); j++ {
								if levels[levNum].enemies[j].name == "fire" {
									if rl.CheckCollisionRecs(etc2[i].rectangle, levels[levNum].enemies[j].collisionRectangle) {
										if etc2[i].image == otherTiles[2] || etc2[i].image == otherTiles[4] {
											if etc2[i].hpTimer == 0 {
												etc2[i].hpTimer = fps / 10
												etc2[i].hp--
											}
										}
									}
								}
							}
						}
						//DEBUG ETC
						if debug {
							rl.DrawRectangleLinesEx(etc2[i].rectangle, 2, rl.Orange)
							txtx := etc2[i].rectangle.ToInt32().X + 2
							txty := etc2[i].rectangle.ToInt32().Y + 2
							rl.DrawText(fmt.Sprint(etc2[i].name), txtx-1, txty+1, tx, rl.Black)
							rl.DrawText(fmt.Sprint(etc2[i].name), txtx, txty, tx, rl.White)
							rl.DrawCircleV(etc2[i].center, 4, rl.Red)
							if etc2[i].rectangle2.Width > 0 {
								rl.DrawRectangleLinesEx(etc2[i].rectangle2, 2, rl.White)
							}
						}
					}
				} else {
					clear = true
				}
				if clear {
					Remove(2)
				}
			}
		}

		//MARK:DRAW ROLLO COMPANION
		if rollo {
			rl.DrawTexturePro(imgs, rollocomp.image, shrec(rollocomp.rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
			rec2 := rollocomp.rectangle
			rec2.X += (rollocomp.dirX * 2) * -1
			rec2.Y += (rollocomp.dirY * 2) * -1
			rec2.X += rec2.Width / 16
			rec2.Y += rec2.Height / 16
			rec2.Width -= rec2.Width / 8
			rec2.Height -= rec2.Height / 8
			rl.DrawTexturePro(imgs, rollocomp.image, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.2))
			rec2.X += (rollocomp.dirX * 2) * -1
			rec2.Y += (rollocomp.dirY * 2) * -1
			rec2.X += rec2.Width / 16
			rec2.Y += rec2.Height / 16
			rec2.Width -= rec2.Width / 8
			rec2.Height -= rec2.Height / 8
			rl.DrawTexturePro(imgs, rollocomp.image, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.15))
			rec2.X += (rollocomp.dirX * 2) * -1
			rec2.Y += (rollocomp.dirY * 2) * -1
			rec2.X += rec2.Width / 16
			rec2.Y += rec2.Height / 16
			rec2.Width -= rec2.Width / 8
			rec2.Height -= rec2.Height / 8
			rl.DrawTexturePro(imgs, rollocomp.image, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.1))
			rec2.X += (rollocomp.dirX * 2) * -1
			rec2.Y += (rollocomp.dirY * 2) * -1
			rec2.X += rec2.Width / 16
			rec2.Y += rec2.Height / 16
			rec2.Width -= rec2.Width / 8
			rec2.Height -= rec2.Height / 8
			rl.DrawTexturePro(imgs, rollocomp.image, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.05))
			rl.DrawTexturePro(imgs, rollocomp.image, rollocomp.rectangle, rl.Vector2Zero(), 0, rl.White)
			if frames%2 == 0 {
				if rollocomp.lr {
					rollocomp.image.X -= animation[154].width
					if rollocomp.image.X < animation[154].x-animation[154].frames*animation[154].width {
						rollocomp.image.X = animation[154].x
					}
				} else {
					rollocomp.image.X += animation[153].width
					if rollocomp.image.X > animation[153].x+animation[153].frames*animation[153].width {
						rollocomp.image.X = animation[153].x
					}
				}
			}
		}

		//MARK: DRAW ITEMS
		if len(itm) > 0 {
			for i := 0; i < len(itm); i++ {
				if !itm[i].isOff {
					if rl.CheckCollisionRecs(itm[i].rectangle, drawRec) {
						///INVISIBLE
						if itm[i].isInvisible {
							if stats.perception > 1 {
								if rl.CheckCollisionRecs(player.perceptionRectangle, itm[i].rectangle) {
									if frames%int(fps*3) == 0 {
										if Roll6() <= stats.perception {
											itm[i].isInvisible = false
											zfx := Effect{}
											zfx.imageRectangle = animation[108].rectangle
											zfx.rectangle = itm[i].rectangle
											zfx.rectangle.X -= b
											zfx.rectangle.Y -= b
											zfx.rectangle.Width += b2
											zfx.rectangle.Height += b2
											zfx.name = "summonitem"
											effect = append(effect, zfx)
											admsg("invisible loot revealed > perception", rl.Magenta)
											//LUK
											if stats.luck > 1 {
												if Roll6() <= stats.luck {
													zitm := Item{}
													zitm = crateitm[RandInt(0, len(crateitm))]
													zitm.rectangle = rl.NewRectangle(itm[i].center.X-zitm.rectangle.Width/2, itm[i].center.Y-zitm.rectangle.Height/2, zitm.rectangle.Width, zitm.rectangle.Height)
													zitm.rectangle = finddropside(zitm.rectangle, 1)
													if zitm.rectangle != blankRec {
														levels[levNum].items = append(levels[levNum].items, zitm)
													}
												}
											}
										}
									}
								}
							}
							if debug {
								rl.DrawCircleV(itm[i].center, 20, rl.Fade(RandColor(), 0.4))
								rl.DrawTexturePro(imgs, itm[i].image, itm[i].rectangle, rl.Vector2Zero(), 0, rl.White)
							}
						} else { //VISIBLE ITEMS
							rl.DrawTexturePro(imgs, itm[i].image, shrec(itm[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, itm[i].image, itm[i].rectangle, rl.Vector2Zero(), 0, rl.White)
							if debug {
								rl.DrawRectangleLinesEx(itm[i].rectangle, 1, rl.Yellow)
							}
							//TXT
							if rl.CheckCollisionPointRec(cursorV2cam, itm[i].rectangle) {
								toptx = itm[i].name
								toptxT = fps
							}
							//TIMERS
							if itm[i].dropTimer > 0 {
								itm[i].dropTimer--
							}
							//MAP PIN ANIMATE
							if itm[i].name == "map exit pin" {
								if frames%2 == 0 {
									itm[i].image.X += animation[175].width
									if itm[i].image.X > animation[175].x+animation[175].frames*animation[175].width {
										itm[i].image.X = animation[175].x
									}
								}
							}
							//CHEST PIN ANIMATE
							if itm[i].name == "map chest pin" {
								if frames%2 == 0 {
									itm[i].image.X += animation[176].width
									if itm[i].image.X > animation[176].x+animation[176].frames*animation[176].width {
										itm[i].image.X = animation[176].x
									}
								}
							}
							//NOODLES
							if noodles {
								spd := b / 12
								cntr := makecnt(itm[i].rectangle)
								dirX := float32(0)
								dirY := float32(0)
								xdiff := AbsDiff(cntr.X, player.center.X)
								ydiff := AbsDiff(cntr.Y, player.center.Y)
								if xdiff > ydiff {
									dirX = spd
									dirY = ydiff / (xdiff / dirX)
								} else {
									dirY = spd
									dirX = xdiff / (ydiff / dirY)
								}
								if cntr.X > player.center.X {
									dirX = -dirX
								}
								if cntr.Y > player.center.Y {
									dirY = -dirY
								}
								checkrec := itm[i].rectangle
								checkrec.X += dirX
								canmove := checkRecWalls(checkrec)
								if canmove {
									canmove = checkRecSolid(checkrec)
								}
								if canmove {
									itm[i].rectangle = checkrec
								}
								checkrec = itm[i].rectangle
								checkrec.Y += dirY
								canmove = checkRecWalls(checkrec)
								if canmove {
									canmove = checkRecSolid(checkrec)
								}
								if canmove {
									itm[i].rectangle = checkrec
								}
							}
						}
					}
				}
			}

			//MARK:COLLECT ITEMS
			for i := 0; i < len(levels[levNum].items); i++ {
				if !levels[levNum].items[i].isOff && !levels[levNum].items[i].isInvisible {
					if rl.CheckCollisionRecs(player.collisionRectangle, levels[levNum].items[i].rectangle) {
						if levels[levNum].items[i].art {
							collectart(i)
						} else if levels[levNum].items[i].dropTimer == 0 {
							collectinvn(i)
						}
					}
				}
			}
			//MARK:REMOVE ITEMS
			for i := 0; i < len(levels[levNum].items); i++ {
				if levels[levNum].items[i].isOff {
					levels[levNum].items = RemoveItem(levels[levNum].items, i)
				}
			}
		}
		//MARK: DRAW CHESTS
		if len(chests) > 0 {
			for i := 0; i < len(chests); i++ {
				if rl.CheckCollisionRecs(chests[i].rectangle, drawRec) {
					rl.DrawTexturePro(imgs, chests[i].image, shrec(chests[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
					rl.DrawTexturePro(imgs, chests[i].image, chests[i].rectangle, rl.Vector2Zero(), 0, rl.White)
					//PLAYER CHEST COLLIS
					if rl.CheckCollisionRecs(player.caRectangle, chests[i].collisionRectangle) {
						if !chests[i].isOpen {
							chests[i].isOpen = true
							if msgT == 0 {
								admsg("@end level items goto base", rl.Magenta)
								msgT = fps
							}
						}
						inchest = true
					} else {
						if chests[i].isOpen {
							chests[i].isOpen = false
						}
						inchest = false
					}
					//TXT
					if rl.CheckCollisionPointRec(cursorV2cam, chests[i].rectangle) {
						toptx = "chest"
						toptxT = fps
					}
					//DEBUG
					if debug {
						rl.DrawRectangleLinesEx(chests[i].collisionRectangle, 1, rl.Yellow)
					}
				}
			}
		}

		//MARK: DRAW WEAPONS
		if len(levels[levNum].weapons) > 0 {
			for i := 0; i < len(levels[levNum].weapons); i++ {
				if !levels[levNum].weapons[i].isOff {
					if levels[levNum].weapons[i].dropTimer > 0 {
						levels[levNum].weapons[i].dropTimer--
					}
					rl.DrawTexturePro(imgs, levels[levNum].weapons[i].image, shrec(levels[levNum].weapons[i].rec, 4), rl.Vector2Zero(), 0, ShadowColor())
					rl.DrawTexturePro(imgs, levels[levNum].weapons[i].image, levels[levNum].weapons[i].rec, rl.Vector2Zero(), 0, rl.White)
					//TXT
					if rl.CheckCollisionPointRec(cursorV2cam, levels[levNum].weapons[i].rec) {
						toptx = levels[levNum].weapons[i].name
						toptxT = fps
					}
					//MARK: COLLECT  WEAPONS
					if rl.CheckCollisionRecs(player.collisionRectangle, levels[levNum].weapons[i].rec) && !levels[levNum].weapons[i].isOff && levels[levNum].weapons[i].dropTimer == 0 {
						found := false
						if player.weapon2.name == "" {
							rl.PlaySound(audfx[119])
							player.weapon2 = weapons[levels[levNum].weapons[i].weapListNum]
							levels[levNum].weapons[i].isOff = true
							found = true
						} else if player.weapon.name == "" {
							rl.PlaySound(audfx[119])
							player.weapon = weapons[levels[levNum].weapons[i].weapListNum]
							levels[levNum].weapons[i].isOff = true
							found = true
						} else {
							for j := 0; j < len(player.weapons); j++ {
								if player.weapons[j].name == "" {
									rl.PlaySound(audfx[119])
									player.weapons[j] = weapons[levels[levNum].weapons[i].weapListNum]
									levels[levNum].weapons[i].isOff = true
									found = true
									break
								}
							}
							if found {
								if msgT == 0 {
									admsg("collected "+weapons[levels[levNum].weapons[i].weapListNum].name, rl.Green)
									msgT = fps
								}
							} else {
								dropweap(0, 1)
							}
						}

					}
					if debug {
						rl.DrawRectangleLinesEx(levels[levNum].weapons[i].rec, 2, rl.Magenta)
					}
				}
			}
		}

		//MARK: DRAW WEAPON CRATE
		if levels[levNum].weaponCrate.isOn {
			rl.DrawTexturePro(imgs, levels[levNum].weaponCrate.tile.image, shrec(levels[levNum].weaponCrate.tile.rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, levels[levNum].weaponCrate.tile.image, levels[levNum].weaponCrate.tile.rectangle, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionRecs(player.collisionRectangle, levels[levNum].weaponCrate.tile.cRectangle) && levels[levNum].weaponCrate.isOn {
				zfx := Effect{}
				zfx.imageRectangle = animation[181].rectangle
				zfx.rectangle = levels[levNum].weaponCrate.tile.rectangle
				zfx.rectangle.X -= b2
				zfx.rectangle.Y -= b2
				zfx.rectangle.Width += b4
				zfx.rectangle.Height += b4
				zfx.rectangle.Y -= b2
				zfx.name = "weaponcrate"
				effect = append(effect, zfx)
				zweap := weapons[levels[levNum].weaponCrate.weaponNum]
				zweap.weapListNum = levels[levNum].weaponCrate.weaponNum
				zweap.dropTimer = fps
				cntr := makecnt(levels[levNum].weaponCrate.tile.rectangle)
				zweap.rec = rl.NewRectangle(cntr.X-zweap.rec.Width/2, cntr.Y-zweap.rec.Height/2, zweap.rec.Width, zweap.rec.Height)
				rl.PlaySound(audfx[118])
				if zweap.name == "raspberry" {
					zweap.rec.X -= be
					zweap.rec.Y -= be
					zweap.rec.Width += bq
					zweap.rec.Height += bq
				}
				levels[levNum].weapons = append(levels[levNum].weapons, zweap)
				levels[levNum].weaponCrate.isOn = false
			}
			if debug {
				rl.DrawRectangleLinesEx(levels[levNum].weaponCrate.tile.rectangle, 2, rl.White)
				rl.DrawRectangleLinesEx(levels[levNum].weaponCrate.tile.cRectangle, 2, rl.Magenta)
			}
		}

		//MARK: DRAW ENEMIES
		if len(enm) > 0 {

			upenm()

			clear := false
			for i := 0; i < len(enm); i++ {
				if rl.CheckCollisionRecs(enm[i].rectangle, drawRec) {
					if !enm[i].off {
						if rl.CheckCollisionPointRec(cursorV2cam, enm[i].collisionRectangle) {
							toptx = enm[i].name2
							toptxT = fps * 2
						}

						//JERSEY SPELL
						if enm[i].name == "jersey" && enm[i].onoff {
							siz := b8
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].cnt.Y-siz/2, siz, siz)
							rec.Y += 7
							rec.X -= 2
							rl.DrawTexturePro(imgs, animation[172].rectangle, shrec(drec(rec), 5), orgn(rec), enm[i].rotation2, ShadowColor())
							rl.DrawTexturePro(imgs, animation[172].rectangle, drec(rec), orgn(rec), enm[i].rotation2, rl.Fade(RandGreen(), 0.15))
							enm[i].rotation2 += 5
							if frames%3 == 0 {
								animation[172].rectangle.X += animation[172].width
								if animation[172].rectangle.X > animation[172].x+animation[172].frames*animation[172].width {
									enm[i].onoff = false
									enm[i].atkT = int32(RandInt(int(fps), int(fps*3)))
									animation[172].rectangle.X = animation[172].x
								}
							}
							rec2 := rec
							rec2.X += rec.Width / 8
							rec2.Y += rec.Width / 8
							rec2.Width -= rec.Width / 4
							rec2.Height -= rec.Width / 4
							if rl.CheckCollisionRecs(player.collisionRectangle, rec2) && player.poisonTimer == 0 {
								player.poisonTimer += fps * 3
								admsg("posioned...", rl.Green)
							}
							if debug {
								rl.DrawRectangleLinesEx(rec2, 2, rl.Magenta)
								rl.DrawRectangleLinesEx(rec, 2, rl.Yellow)
							}
						}
						//ROBOT SHOCK
						if enm[i].name == "robot" && enm[i].onoff {
							siz := b7
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].cnt.Y-siz/2, siz, siz)
							rec.Y += 7
							rec.X -= 2
							rl.DrawTexturePro(imgs, animation[168].rectangle, shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, animation[168].rectangle, rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.15))
							if frames%6 == 0 {
								animation[168].rectangle.X += animation[168].width
								if animation[168].rectangle.X > animation[168].x+animation[168].frames*animation[168].width {
									enm[i].onoff = false
									enm[i].atkT = int32(RandInt(int(fps), int(fps*3)))
									animation[168].rectangle.X = animation[168].x
								}
							}
							rec2 := rec
							rec2.X += rec.Width / 8
							rec2.Y += rec.Width / 8
							rec2.Width -= rec.Width / 4
							rec2.Height -= rec.Width / 4
							if rl.CheckCollisionRecs(player.collisionRectangle, rec2) && player.freezeTimer == 0 && saltT == 0 {
								player.freezeTimer = fps * 2
								admsg("frozen...", rl.Blue)
							} else if saltT > 0 {
								if msgT == 0 {
									admsg("salt saves freeze", rl.Green)
									msgT = fps
								}
							}
							if debug {
								rl.DrawRectangleLinesEx(rec2, 2, rl.Magenta)
								rl.DrawRectangleLinesEx(rec, 2, rl.Yellow)
							}
						}
						//HP HEART
						if enm[i].hpT > 0 && enm[i].hpY > enm[i].hpY2 {
							siz := be3
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].collisionRectangle.Y-enm[i].hpY2, siz, siz)
							rl.DrawTexturePro(imgs, otherTiles[29], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, otherTiles[29], rec, rl.Vector2Zero(), 0, rl.White)
							enm[i].hpY2++
						}
						//BURN POISON BLEED ICONS
						if enm[i].burnT > 0 && enm[i].bleedT == 0 && enm[i].poisonT == 0 {
							siz := be3
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].collisionRectangle.Y+enm[i].collisionRectangle.Height+4, siz, siz)
							rl.DrawTexturePro(imgs, otherTiles[79], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, otherTiles[79], rec, rl.Vector2Zero(), 0, RandOrange())
						} else if enm[i].burnT > 0 && enm[i].bleedT > 0 && enm[i].poisonT == 0 {
							siz := be3
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].collisionRectangle.Y+enm[i].collisionRectangle.Height+4, siz, siz)
							rec.X -= siz
							rl.DrawTexturePro(imgs, otherTiles[79], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, otherTiles[79], rec, rl.Vector2Zero(), 0, RandOrange())
							rec.X += siz
							rl.DrawTexturePro(imgs, otherTiles[80], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, otherTiles[80], rec, rl.Vector2Zero(), 0, rl.White)
						} else if enm[i].burnT == 0 && enm[i].bleedT > 0 && enm[i].poisonT == 0 {
							siz := be3
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].collisionRectangle.Y+enm[i].collisionRectangle.Height+4, siz, siz)
							rl.DrawTexturePro(imgs, otherTiles[80], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, otherTiles[80], rec, rl.Vector2Zero(), 0, rl.White)
						} else if enm[i].burnT == 0 && enm[i].bleedT == 0 && enm[i].poisonT > 0 {
							siz := be3
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].collisionRectangle.Y+enm[i].collisionRectangle.Height+4, siz, siz)
							rl.DrawTexturePro(imgs, otherTiles[81], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, otherTiles[81], rec, rl.Vector2Zero(), 0, rl.White)
						} else if enm[i].burnT > 0 && enm[i].bleedT > 0 && enm[i].poisonT > 0 {
							siz := be3
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].collisionRectangle.Y+enm[i].collisionRectangle.Height+4, siz, siz)
							rec.X -= siz + siz/2
							rl.DrawTexturePro(imgs, otherTiles[79], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, otherTiles[79], rec, rl.Vector2Zero(), 0, RandOrange())
							rec.X += siz
							rl.DrawTexturePro(imgs, otherTiles[80], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, otherTiles[80], rec, rl.Vector2Zero(), 0, rl.White)
							rec.X += siz
							rl.DrawTexturePro(imgs, otherTiles[81], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, otherTiles[81], rec, rl.Vector2Zero(), 0, rl.White)
						} else if enm[i].burnT > 0 && enm[i].bleedT == 0 && enm[i].poisonT > 0 {
							siz := be3
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].collisionRectangle.Y+enm[i].collisionRectangle.Height+4, siz, siz)
							rec.X -= siz
							rl.DrawTexturePro(imgs, otherTiles[79], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, otherTiles[79], rec, rl.Vector2Zero(), 0, RandOrange())
							rec.X += siz
							rl.DrawTexturePro(imgs, otherTiles[81], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, otherTiles[81], rec, rl.Vector2Zero(), 0, rl.White)
						} else if enm[i].burnT == 0 && enm[i].bleedT > 0 && enm[i].poisonT > 0 {
							siz := be3
							rec := rl.NewRectangle(enm[i].cnt.X-siz/2, enm[i].collisionRectangle.Y+enm[i].collisionRectangle.Height+4, siz, siz)
							rec.X -= siz
							rl.DrawTexturePro(imgs, otherTiles[80], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, otherTiles[80], rec, rl.Vector2Zero(), 0, RandOrange())
							rec.X += siz
							rl.DrawTexturePro(imgs, otherTiles[81], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, otherTiles[81], rec, rl.Vector2Zero(), 0, rl.White)
						}
						//IMG
						if !isBossOn {
							switch enm[i].name {
							default:
								rl.DrawTexturePro(imgs, enm[i].image, shrec(drec(enm[i].rectangle), 5), orgn(enm[i].rectangle), enm[i].rotation, ShadowColor())
								if icecreamT > 0 || enm[i].freezeT > 0 || enm[i].oilT > 0 {
									rl.DrawTexturePro(imgs, enm[i].image, drec(enm[i].rectangle), orgn(enm[i].rectangle), enm[i].rotation, RandCyan())
								} else {
									if enm[i].hpT > 0 {
										rl.DrawTexturePro(imgs, enm[i].image, drec(enm[i].rectangle), orgn(enm[i].rectangle), enm[i].rotation, RandPink())
									} else {
										rl.DrawTexturePro(imgs, enm[i].image, drec(enm[i].rectangle), orgn(enm[i].rectangle), enm[i].rotation, rl.White)
									}
								}
							case "blackdot":
								rl.DrawTexturePro(imgs, enm[i].image, shrec(drec(enm[i].rectangle), 4), orgn(enm[i].rectangle), enm[i].rotation, ShadowColor())
								if icecreamT > 0 || enm[i].freezeT > 0 || enm[i].oilT > 0 {
									rl.DrawTexturePro(imgs, enm[i].image, drec(enm[i].rectangle), orgn(enm[i].rectangle), enm[i].rotation, RandCyan())
								} else {
									if enm[i].hpT > 0 {
										rl.DrawTexturePro(imgs, enm[i].image, drec(enm[i].rectangle), orgn(enm[i].rectangle), enm[i].rotation, RandColor())
									} else {
										rl.DrawTexturePro(imgs, enm[i].image, drec(enm[i].rectangle), orgn(enm[i].rectangle), enm[i].rotation, rl.White)
									}
								}
							case "balloon", "fly", "flamehead", "greenpig":
								rl.DrawTexturePro(imgs, enm[i].image, shrec(drec(enm[i].rectangle), 12), orgn(enm[i].rectangle), enm[i].rotation, ShadowColor())
								if icecreamT > 0 || enm[i].freezeT > 0 {
									rl.DrawTexturePro(imgs, enm[i].image, drec(enm[i].rectangle), orgn(enm[i].rectangle), enm[i].rotation, RandCyan())
								} else {
									if enm[i].hpT > 0 {
										rl.DrawTexturePro(imgs, enm[i].image, drec(enm[i].rectangle), orgn(enm[i].rectangle), enm[i].rotation, RandColor())
									} else {
										rl.DrawTexturePro(imgs, enm[i].image, drec(enm[i].rectangle), orgn(enm[i].rectangle), enm[i].rotation, rl.White)
									}
								}
							case "ghost":
								rl.DrawTexturePro(imgs, enm[i].image, shrec(drec(enm[i].rectangle), 12), orgn(enm[i].rectangle), enm[i].rotation, ShadowColor())
								if icecreamT > 0 || enm[i].freezeT > 0 {
									rl.DrawTexturePro(imgs, enm[i].image, drec(enm[i].rectangle), orgn(enm[i].rectangle), enm[i].rotation, rl.Fade(RandCyan(), RandF32(0.2, 0.5)))
								} else {
									if enm[i].hpT > 0 {
										rl.DrawTexturePro(imgs, enm[i].image, drec(enm[i].rectangle), orgn(enm[i].rectangle), enm[i].rotation, rl.Fade(RandColor(), RandF32(0.2, 0.5)))
									} else {
										rl.DrawTexturePro(imgs, enm[i].image, drec(enm[i].rectangle), orgn(enm[i].rectangle), enm[i].rotation, rl.Fade(rl.White, RandF32(0.2, 0.5)))
									}
								}
							}

							if debug {
								xtx := enm[i].collisionRectangle.ToInt32().X
								ytx := enm[i].collisionRectangle.ToInt32().Y - tx2
								rl.DrawText(fmt.Sprint(enm[i].hp), xtx, ytx, tx2, rl.Red)
							}
						}
						//MARK: ENEMY ANIM STUN
						//STUN IMG
						if enm[i].stunT > 0 {
							if enm[i].stunF > 0 {
								cntr := rl.NewVector2(enm[i].cnt.X, enm[i].stunY)
								rec3 := rl.NewRectangle(cntr.X-enm[i].stunSiz/2, cntr.Y-enm[i].stunSiz/2, enm[i].stunSiz, enm[i].stunSiz)
								rl.DrawTexturePro(imgs, otherTiles[82], shrec(rec3, 12), rl.Vector2Zero(), 0, ShadowColor())
								rl.DrawTexturePro(imgs, otherTiles[82], rec3, rl.Vector2Zero(), 0, rl.Fade(rl.White, enm[i].stunF))
								enm[i].stunF -= 0.03
								enm[i].stunSiz += 0.5
								enm[i].stunY -= 2
							}
							//STUN STARS ANIM
							siz2 := b2
							rec4 := rl.NewRectangle(enm[i].cnt.X-siz2/2, enm[i].cnt.Y-siz2/2, siz2, siz2)
							rl.DrawTexturePro(imgs, animation[107].rectangle, shrec(rec4, 12), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, animation[107].rectangle, rec4, rl.Vector2Zero(), 0, rl.Fade(rl.Yellow, 0.7))
						}
						//MARK:UP ENEMY IMAGE ANIMS
						if !isBossOn {
							if icecreamT == 0 {
								switch enm[i].name {
								case "spike":
									if frames%2 == 0 {
										enm[i].image.X += animation[184].width
										if enm[i].image.X > animation[184].x+animation[184].frames*animation[184].width {
											enm[i].image.X = animation[184].x
										}
									}
								case "jersey":
									if frames%4 == 0 {
										if enm[i].lr {
											enm[i].image.X -= animation[167].width
											if enm[i].image.X < animation[167].x-animation[167].frames*animation[167].width {
												enm[i].image.X = animation[167].x
											}
										} else {
											enm[i].image.X += animation[166].width
											if enm[i].image.X > animation[166].x+animation[166].frames*animation[166].width {
												enm[i].image.X = animation[166].x
											}
										}
									}
								case "bird":
									if frames%5 == 0 {
										if enm[i].lr {
											enm[i].image.X -= animation[165].width
											if enm[i].image.X < animation[165].x-animation[165].frames*animation[165].width {
												enm[i].image.X = animation[165].x
											}
										} else {
											enm[i].image.X += animation[164].width
											if enm[i].image.X > animation[164].x+animation[164].frames*animation[164].width {
												enm[i].image.X = animation[164].x
											}
										}
									}
								case "bush":
									if enm[i].idl {
										enm[i].image = otherTiles[151]
									} else {
										if frames%5 == 0 {
											if enm[i].lr {
												enm[i].image.X -= animation[171].width
												if enm[i].image.X < animation[171].x-animation[171].frames*animation[171].width {
													enm[i].image.X = animation[171].x
												}
											} else {
												enm[i].image.X += animation[170].width
												if enm[i].image.X > animation[170].x+animation[170].frames*animation[170].width {
													enm[i].image.X = animation[170].x
												}
											}
										}
									}
								case "reddevil":
									if frames%5 == 0 {
										if enm[i].lr {
											enm[i].image.X -= animation[163].width
											if enm[i].image.X < animation[163].x-animation[163].frames*animation[163].width {
												enm[i].image.X = animation[163].x
											}
										} else {
											enm[i].image.X += animation[162].width
											if enm[i].image.X > animation[162].x+animation[162].frames*animation[162].width {
												enm[i].image.X = animation[162].x
											}
										}
									}
								case "greenpig":
									if frames%5 == 0 {
										if enm[i].lr {
											enm[i].image.X -= animation[159].width
											if enm[i].image.X < animation[159].x-animation[159].frames*animation[159].width {
												enm[i].image.X = animation[159].x
											}
										} else {
											enm[i].image.X += animation[158].width
											if enm[i].image.X > animation[158].x+animation[158].frames*animation[158].width {
												enm[i].image.X = animation[158].x
											}
										}
									}
								case "robot":
									if frames%3 == 0 {
										if enm[i].lr {
											enm[i].image.X -= animation[161].width
											if enm[i].image.X < animation[161].x-animation[161].frames*animation[161].width {
												enm[i].image.X = animation[161].x
											}
										} else {
											enm[i].image.X += animation[160].width
											if enm[i].image.X > animation[160].x+animation[160].frames*animation[160].width {
												enm[i].image.X = animation[160].x
											}
										}
									}
								case "carrot":
									if frames%6 == 0 {
										if enm[i].lr {
											enm[i].image.X -= animation[157].width
											if enm[i].image.X < animation[157].x-animation[157].frames*animation[157].width {
												enm[i].image.X = animation[157].x
											}
										} else {
											enm[i].image.X += animation[156].width
											if enm[i].image.X > animation[156].x+animation[156].frames*animation[156].width {
												enm[i].image.X = animation[156].x
											}
										}
									}
								case "redblob":
									if frames%4 == 0 {
										if enm[i].lr {
											enm[i].image.X -= animation[70].width
											if enm[i].image.X < animation[70].x-animation[70].frames*animation[70].width {
												enm[i].image.X = animation[70].x
											}
										} else {
											enm[i].image.X += animation[69].width
											if enm[i].image.X > animation[69].x+animation[69].frames*animation[69].width {
												enm[i].image.X = animation[69].x
											}
										}
									}
								case "skeleton":
									if frames%4 == 0 {
										if enm[i].lr {
											enm[i].image.X -= animation[68].width
											if enm[i].image.X < animation[68].x-animation[68].frames*animation[68].width {
												enm[i].image.X = animation[68].x
											}
										} else {
											enm[i].image.X += animation[67].width
											if enm[i].image.X > animation[67].x+animation[67].frames*animation[67].width {
												enm[i].image.X = animation[67].x
											}
										}
									}
								case "orange":
									if frames%3 == 0 {
										if enm[i].lr {
											enm[i].image.X -= animation[66].width
											if enm[i].image.X < animation[66].x-animation[66].frames*animation[66].width {
												enm[i].image.X = animation[66].x
											}
										} else {
											enm[i].image.X += animation[65].width
											if enm[i].image.X > animation[65].x+animation[65].frames*animation[65].width {
												enm[i].image.X = animation[65].x
											}
										}
									}
								case "flamehead":
									if frames%3 == 0 {
										if enm[i].lr {
											enm[i].image.X -= animation[64].width
											if enm[i].image.X < animation[64].x-animation[64].frames*animation[64].width {
												enm[i].image.X = animation[64].x
											}
										} else {
											enm[i].image.X += animation[63].width
											if enm[i].image.X > animation[63].x+animation[63].frames*animation[63].width {
												enm[i].image.X = animation[63].x
											}
										}
									}
								case "fire":
									if frames%3 == 0 {
										enm[i].image.X += animation[55].width
										if enm[i].image.X > animation[55].x+animation[55].frames*animation[55].width {
											enm[i].image.X = animation[55].x
										}
									}
								case "fly":
									if frames%4 == 0 {
										if enm[i].lr {
											enm[i].image.X -= animation[54].width
											if enm[i].image.X < animation[54].x-animation[54].frames*animation[54].width {
												enm[i].image.X = animation[54].x
											}
										} else {
											enm[i].image.X += animation[53].width
											if enm[i].image.X > animation[53].x+animation[53].frames*animation[53].width {
												enm[i].image.X = animation[53].x
											}
										}
									}
								case "worm":
									if frames%12 == 0 {
										if enm[i].lr {
											enm[i].image.X -= animation[52].width
											if enm[i].image.X < animation[52].x-animation[52].frames*animation[52].width {
												enm[i].image.X = animation[52].x
											}
										} else {
											enm[i].image.X += animation[51].width
											if enm[i].image.X > animation[51].x+animation[51].frames*animation[51].width {
												enm[i].image.X = animation[51].x
											}
										}
									}
								case "blackdot":
									if frames%5 == 0 {
										if enm[i].lr {
											enm[i].image.X -= animation[50].width
											if enm[i].image.X < animation[50].x-animation[50].frames*animation[50].width {
												enm[i].image.X = animation[50].x
											}
										} else {
											enm[i].image.X += animation[49].width
											if enm[i].image.X > animation[49].x+animation[49].frames*animation[49].width {
												enm[i].image.X = animation[49].x
											}
										}
									}
								case "yellowdino":
									if frames%4 == 0 {
										if enm[i].lr {
											enm[i].image.X -= animation[47].width
											if enm[i].image.X < animation[47].x-animation[47].frames*animation[47].width {
												enm[i].image.X = animation[47].x
											}
										} else {
											enm[i].image.X += animation[46].width
											if enm[i].image.X > animation[46].x+animation[46].frames*animation[46].width {
												enm[i].image.X = animation[46].x
											}
										}
									}
								case "greenplant":
									if enm[i].idlon {
										if frames%12 == 0 {
											enm[i].image.X += animation[45].width
											if enm[i].image.X > animation[45].x+animation[45].frames*animation[45].width {
												enm[i].image.X = animation[45].x
											}
										}
									} else {
										if frames%4 == 0 {
											if enm[i].lr {
												enm[i].image.X -= animation[44].width
												if enm[i].image.X < animation[44].x-animation[44].frames*animation[44].width {
													enm[i].image.X = animation[44].x
												}
											} else {
												enm[i].image.X += animation[43].width
												if enm[i].image.X > animation[43].x+animation[43].frames*animation[43].width {
													enm[i].image.X = animation[43].x
												}
											}
										}
									}
								case "pinkcart":
									if enm[i].idlon {
										if enm[i].image.X < animation[42].x {
											enm[i].image.X = animation[42].x
										}
										if frames%12 == 0 {
											enm[i].image.X += animation[42].width
											if enm[i].image.X > animation[42].x+animation[42].frames*animation[42].width {
												enm[i].image.X = animation[42].x
											}
										}
									} else {
										if frames%4 == 0 {
											if enm[i].lr {
												enm[i].image.X -= animation[41].width
												if enm[i].image.X < animation[41].x-animation[41].frames*animation[41].width {
													enm[i].image.X = animation[41].x
												}
											} else {
												enm[i].image.X += animation[40].width
												if enm[i].image.X > animation[40].x+animation[40].frames*animation[40].width {
													enm[i].image.X = animation[40].x
												}
											}
										}
									}
								case "crocodile":
									if enm[i].hpT > 0 {
										if enm[i].lr {
											enm[i].image = enm[i].hitImgL
										} else {
											enm[i].image = enm[i].hitImgR
										}
									} else {
										if enm[i].fast {
											if frames%2 == 0 {
												if enm[i].lr {
													enm[i].image.X -= animation[59].width
													if enm[i].image.X < animation[59].x-animation[59].frames*animation[59].width {
														enm[i].image.X = animation[59].x
													}
												} else {
													enm[i].image.X += animation[58].width
													if enm[i].image.X > animation[58].x+animation[58].frames*animation[58].width {
														enm[i].image.X = animation[58].x
													}
												}
											}
										} else {
											if frames%6 == 0 {
												if enm[i].lr {
													enm[i].image.Y = animation[39].rectangle.Y
													enm[i].image.X -= animation[39].width
													if enm[i].image.X < animation[39].x-animation[39].frames*animation[39].width {
														enm[i].image.X = animation[39].x
													}
												} else {
													enm[i].image.Y = animation[38].rectangle.Y
													enm[i].image.X += animation[38].width
													if enm[i].image.X > animation[38].x+animation[38].frames*animation[38].width {
														enm[i].image.X = animation[38].x
													}
												}
											}
										}
									}
								case "balloon":
									if frames%int(enm[i].animFrameT) == 0 {
										if enm[i].lr {
											enm[i].image.X -= animation[37].width
											if enm[i].image.X < animation[37].x-animation[37].frames*animation[37].width {
												enm[i].image.X = animation[37].x
											}
										} else {
											enm[i].image.X += animation[36].width
											if enm[i].image.X > animation[36].x+animation[36].frames*animation[36].width {
												enm[i].image.X = animation[36].x
											}
										}
										enm[i].animFrameT = RandInt32(12, 25)
									}
								case "redantenna":
									if enm[i].hpT > 0 {
										if enm[i].lr {
											enm[i].image = enm[i].hitImgL
										} else {
											enm[i].image = enm[i].hitImgR
										}
									} else {
										if frames%6 == 0 {
											if enm[i].lr {
												enm[i].image.X -= animation[35].width
												if enm[i].image.X < animation[35].x-animation[35].frames*animation[35].width {
													enm[i].image.X = animation[35].x
												}
											} else {
												enm[i].image.X += animation[34].width
												if enm[i].image.X > animation[34].x+animation[34].frames*animation[34].width {
													enm[i].image.X = animation[34].x
												}
											}
										}
									}
								case "ghost":
									if frames%6 == 0 {
										if enm[i].lr {
											enm[i].image.X -= animation[33].width
											if enm[i].image.X < animation[33].x-animation[33].frames*animation[33].width {
												enm[i].image.X = animation[33].x
											}
										} else {
											enm[i].image.X += animation[32].width
											if enm[i].image.X > animation[32].x+animation[32].frames*animation[32].width {
												enm[i].image.X = animation[32].x
											}
										}
									}
								case "redbomb":
									if enm[i].idlon {
										if frames%12 == 0 {
											enm[i].image.X += animation[31].width
											if enm[i].image.X > animation[31].x+animation[31].frames*animation[31].width {
												enm[i].image.X = animation[31].x
											}
										}
									} else {
										if frames%6 == 0 {
											if enm[i].lr {
												enm[i].image.X -= animation[30].width
												if enm[i].image.X < animation[30].x-animation[30].frames*animation[30].width {
													enm[i].image.X = animation[30].x
												}
											} else {
												enm[i].image.X += animation[29].width
												if enm[i].image.X > animation[29].x+animation[29].frames*animation[29].width {
													enm[i].image.X = animation[29].x
												}
											}
										}
									}
								case "redeye":
									if enm[i].idlon {
										if frames%12 == 0 {
											enm[i].image.X += animation[28].width
											if enm[i].image.X > animation[28].x+animation[28].frames*animation[28].width {
												enm[i].image.X = animation[28].x
											}
										}
									} else {
										if frames%6 == 0 {
											if enm[i].lr {
												enm[i].image.X -= animation[27].width
												if enm[i].image.X < animation[27].x-animation[27].frames*animation[27].width {
													enm[i].image.X = animation[27].x
												}
											} else {
												enm[i].image.X += animation[26].width
												if enm[i].image.X > animation[26].x+animation[26].frames*animation[26].width {
													enm[i].image.X = animation[26].x
												}
											}
										}
									}
								case "bluespike":
									if enm[i].idlon {
										if frames%12 == 0 {
											enm[i].image.X += animation[25].width
											if enm[i].image.X > animation[25].x+animation[25].frames*animation[25].width {
												enm[i].image.X = animation[25].x
											}
										}
									} else {
										if frames%6 == 0 {
											if enm[i].lr {
												enm[i].image.X -= animation[24].width
												if enm[i].image.X < animation[24].x-animation[24].frames*animation[24].width {
													enm[i].image.X = animation[24].x
												}
											} else {
												enm[i].image.X += animation[23].width
												if enm[i].image.X > animation[23].x+animation[23].frames*animation[23].width {
													enm[i].image.X = animation[23].x
												}
											}
										}
									}
								}
							}
							//DEBUG
							if debug {
								rl.DrawRectangleLinesEx(enm[i].rectangle, 1, rl.Red)
								rl.DrawRectangleLinesEx(enm[i].collisionRectangle, 1, rl.Magenta)
								rl.DrawRectangleLinesEx(enm[i].carec, 1, rl.Green)
							}
						}
					} else {
						clear = true
					}
				}
				if clear {
					Remove(4)
				}
			}
		}

		//MARK: DRAW LIGHTNING
		if len(lightningEnm) > 1 && !isBossOn {
			if lightningCount > 0 {
				for i := 0; i < len(lightningEnm)-1; i++ {
					cnt1 := makecnt(levels[levNum].enemies[lightningEnm[i]].collisionRectangle)
					cnt2 := makecnt(levels[levNum].enemies[lightningEnm[i+1]].collisionRectangle)
					//rl.DrawLineV(cnt1,cnt2,rl.Blue)
					rl.DrawLineEx(cnt1, cnt2, RandF32(2, 5), rl.Fade(RandBlue(), RandF32(0.1, 0.4)))
					cnt1.X += RandF32(-5, 5)
					cnt1.Y += RandF32(-5, 5)
					cnt2.X += RandF32(-5, 5)
					cnt2.Y += RandF32(-5, 5)
					rl.DrawLineEx(cnt1, cnt2, RandF32(3, 7), rl.Fade(RandBlue(), RandF32(0.1, 0.4)))
					cnt1.X += RandF32(-5, 5)
					cnt1.Y += RandF32(-5, 5)
					cnt2.X += RandF32(-5, 5)
					cnt2.Y += RandF32(-5, 5)
					rl.DrawLineEx(cnt1, cnt2, RandF32(1, 3), rl.Fade(RandBlue(), RandF32(0.3, 0.7)))
					cnt1.X += RandF32(-5, 5)
					cnt1.Y += RandF32(-5, 5)
					cnt2.X += RandF32(-5, 5)
					cnt2.Y += RandF32(-5, 5)
					rl.DrawLineEx(cnt1, cnt2, RandF32(1, 3), rl.Fade(RandBlue(), RandF32(0.2, 0.5)))

				}
				lightningCount--
			} else {
				for i := 0; i < len(lightningEnm); i++ {
					if levels[levNum].enemies[lightningEnm[i]].hpT == 0 {
						levels[levNum].enemies[lightningEnm[i]].hp--
					}
					if levels[levNum].enemies[lightningEnm[i]].hp <= 0 && !levels[levNum].enemies[lightningEnm[i]].off {
						player.xp += levels[levNum].enemies[lightningEnm[i]].xp
						makeEnDeathFx(lightningEnm[i])
						levels[levNum].enemies[lightningEnm[i]].off = true
					} else {
						rl.PlaySound(audfx[8])
						if !levels[levNum].enemies[lightningEnm[i]].nodmg {
							levels[levNum].enemies[lightningEnm[i]].hpT = fps
							levels[levNum].enemies[lightningEnm[i]].hpY = bq3
							levels[levNum].enemies[lightningEnm[i]].hpY2 = 0
							if isBossOn {
								levels[levNum].enemies[i].hpY = b
								levels[levNum].enemies[i].hpY2 = b / 2
							}
						}
					}
				}
				lightningEnm = nil
			}
		}

		//MARK: DRAW PROJ ENEMY ABOVE
		if len(enemyProjectiles) > 0 {
			upprojEn()
			for i := 0; i < len(enemyProjectiles); i++ {
				if rl.CheckCollisionRecs(enemyProjectiles[i].rec, drawRec) {
					if !enemyProjectiles[i].isOff && !enemyProjectiles[i].isBelow {
						switch enemyProjectiles[i].name {
						case "bushProj":
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 12), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.White)
							enemyProjectiles[i].rotation += enemyProjectiles[i].rotationSpeed
							if frames%3 == 0 {
								enemyProjectiles[i].image.X += animation[173].width
								if enemyProjectiles[i].image.X > animation[173].x+animation[173].frames*animation[173].width {
									enemyProjectiles[i].image.X = animation[173].x
								}
							}
						case "birdProj":
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 12), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.White)
							enemyProjectiles[i].rotation += enemyProjectiles[i].rotationSpeed
						case "greenpigProj":
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 12), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.White)
							if frames%3 == 0 {
								enemyProjectiles[i].image.X += animation[132].width
								if enemyProjectiles[i].image.X > animation[132].x+animation[132].frames*animation[132].width {
									enemyProjectiles[i].image.X = animation[132].x
								}
							}
							if rl.CheckCollisionRecs(player.collisionRectangle, enemyProjectiles[i].crec) && player.poisonTimer == 0 {
								admsg("poisoned...", rl.Green)
								player.poisonTimer += fps * 3
							}
						case "rolloProj":
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 12), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(rl.White, RandF32(0.2, 0.5)))
							//BLUR
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, brec(drec(enemyProjectiles[i].rec), 7), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(rl.White, RandF32(0.05, 0.2)))
							if frames%2 == 0 {
								enemyProjectiles[i].image.X += animation[155].width
								if enemyProjectiles[i].image.X > animation[155].x+animation[155].frames*animation[155].width {
									enemyProjectiles[i].image.X = animation[155].x
								}
							}
							enemyProjectiles[i].rotation += 4
						case "mushbossProj":
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 12), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(rl.White, RandF32(0.4, 0.7)))
							if frames%2 == 0 {
								enemyProjectiles[i].image.X += animation[152].width
								if enemyProjectiles[i].image.X > animation[152].x+animation[152].frames*animation[152].width {
									enemyProjectiles[i].image.X = animation[152].x
								}
							}
						case "battyProj":
							col := RandColor()
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 3), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, col)
							//BLUR
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, brec(drec(enemyProjectiles[i].rec), 12), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(col, RandF32(0.05, 0.2)))
							if frames%2 == 0 {
								enemyProjectiles[i].image.X += animation[147].width
								if enemyProjectiles[i].image.X > animation[147].x+animation[147].frames*animation[147].width {
									enemyProjectiles[i].image.X = animation[147].x
								}
							}
						case "zomboProj":
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 12), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(rl.White, RandF32(0.2, 0.5)))
							//BLUR
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, brec(drec(enemyProjectiles[i].rec), 4), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(rl.White, RandF32(0.05, 0.2)))
							if frames%3 == 0 {
								enemyProjectiles[i].image.X += animation[140].width
								if enemyProjectiles[i].image.X > animation[140].x+animation[140].frames*animation[140].width {
									enemyProjectiles[i].image.X = animation[140].x
								}
								enemyProjectiles[i].rec.X -= 4
								enemyProjectiles[i].rec.Y -= 4
								enemyProjectiles[i].rec.Width += 8
								enemyProjectiles[i].rec.Height += 8
								enemyProjectiles[i].crec = enemyProjectiles[i].rec
								enemyProjectiles[i].crec.X += enemyProjectiles[i].crec.Width / 4
								enemyProjectiles[i].crec.Y += enemyProjectiles[i].crec.Height / 4
								enemyProjectiles[i].crec.Width = enemyProjectiles[i].crec.Width / 2
								enemyProjectiles[i].crec.Height = enemyProjectiles[i].crec.Height / 2
							}
							enemyProjectiles[i].rotation += 4
						case "pigProj":
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 12), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(rl.White, RandF32(0.4, 0.7)))
							if frames%3 == 0 {
								enemyProjectiles[i].image.X += animation[135].width
								if enemyProjectiles[i].image.X > animation[135].x+animation[135].frames*animation[135].width {
									enemyProjectiles[i].image.X = animation[135].x
								}
							}
						case "spacemanProj":
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 12), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(rl.White, RandF32(0.4, 0.7)))
							//BLUR
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, brec(drec(enemyProjectiles[i].rec), 4), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(rl.White, RandF32(0.1, 0.3)))
							if frames%3 == 0 {
								enemyProjectiles[i].image.X += animation[131].width
								if enemyProjectiles[i].image.X > animation[131].x+animation[131].frames*animation[131].width {
									enemyProjectiles[i].image.X = animation[131].x
								}
							}
							enemyProjectiles[i].rotation += 4
						case "spinnaProj":
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(enemyProjectiles[i].rec, 12), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, enemyProjectiles[i].rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.4, 0.7)))
							//BLUR
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, brec(enemyProjectiles[i].rec, 12), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.1, 0.3)))
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, brec(enemyProjectiles[i].rec, 24), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.1, 0.3)))
							enemyProjectiles[i].image.X += animation[123].width
							if enemyProjectiles[i].image.X > animation[123].x+animation[123].frames*animation[123].width {
								enemyProjectiles[i].image.X = animation[123].x
							}
						case "mrfrisbeeProj":
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 12), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, RandYellow())
							if frames%2 == 0 {
								enemyProjectiles[i].image.X += animation[116].width
								if enemyProjectiles[i].image.X > animation[116].x+animation[116].frames*animation[116].width {
									enemyProjectiles[i].image.X = animation[116].x
								}
							}
							enemyProjectiles[i].rotation += 4
						case "icemanProj":
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 12), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(rl.White, 0.5))
						case "redblobbull":
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 12), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(enemyProjectiles[i].col, enemyProjectiles[i].fade))
							if frames%5 == 0 {
								enemyProjectiles[i].image.X += animation[71].width
								if enemyProjectiles[i].image.X > animation[71].x+animation[71].frames*animation[71].width {
									enemyProjectiles[i].image.X = animation[71].x
								}
							}
						case "greenplantbull":
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 12), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(enemyProjectiles[i].col, enemyProjectiles[i].fade))
							if frames%2 == 0 {
								enemyProjectiles[i].image.X += animation[61].width
								if enemyProjectiles[i].image.X > animation[61].x+animation[61].frames*animation[61].width {
									enemyProjectiles[i].image.X = animation[61].x
								}
							}
						case "pinkcartbull":
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 12), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(enemyProjectiles[i].col, RandF32(0.4, 0.7)))
							if frames%3 == 0 {
								enemyProjectiles[i].image.X += animation[60].width
								if enemyProjectiles[i].image.X > animation[60].x+animation[60].frames*animation[60].width {
									enemyProjectiles[i].image.X = animation[60].x
								}
							}
						case "redantbull":
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 12), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(enemyProjectiles[i].col, enemyProjectiles[i].fade))
							if frames%3 == 0 {
								enemyProjectiles[i].image.X += animation[56].width
								if enemyProjectiles[i].image.X > animation[56].x+animation[56].frames*animation[56].width {
									enemyProjectiles[i].image.X = animation[56].x
								}
							}
						default: //NO ANIM IMG BULLET
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, shrec(drec(enemyProjectiles[i].rec), 12), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, enemyProjectiles[i].image, drec(enemyProjectiles[i].rec), orgn(enemyProjectiles[i].rec), enemyProjectiles[i].rotation, rl.Fade(enemyProjectiles[i].col, enemyProjectiles[i].fade))
						}
						if debug {
							rl.DrawRectangleLinesEx(enemyProjectiles[i].rec, 1, rl.Yellow)
							rl.DrawRectangleLinesEx(enemyProjectiles[i].crec, 1, rl.Magenta)
						}
					}
				}
			}
		}
		//MARK: DRAW PROJ PLAYER
		if len(playerProjectiles) > 0 {
			updatePlayerProjectiles()
			for i := 0; i < len(playerProjectiles); i++ {
				if rl.CheckCollisionRecs(playerProjectiles[i].rec, drawRec) {
					if !playerProjectiles[i].isOff {
						switch playerProjectiles[i].name {
						case "rolloProj":
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, shrec(drec(playerProjectiles[i].rec), 12), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, drec(playerProjectiles[i].rec), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, rl.Fade(rl.White, RandF32(0.2, 0.5)))
							//BLUR
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, brec(drec(playerProjectiles[i].rec), 7), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, rl.Fade(rl.White, RandF32(0.05, 0.2)))
							if frames%2 == 0 {
								playerProjectiles[i].image.X += animation[155].width
								if playerProjectiles[i].image.X > animation[155].x+animation[155].frames*animation[155].width {
									playerProjectiles[i].image.X = animation[155].x
								}
							}
							playerProjectiles[i].rotation += 4
						case "battyProj":
							col := RandColor()
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, shrec(drec(playerProjectiles[i].rec), 3), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, drec(playerProjectiles[i].rec), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, col)
							//BLUR
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, brec(drec(playerProjectiles[i].rec), 12), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, rl.Fade(col, RandF32(0.05, 0.2)))
							if frames%2 == 0 {
								playerProjectiles[i].image.X += animation[147].width
								if playerProjectiles[i].image.X > animation[147].x+animation[147].frames*animation[147].width {
									playerProjectiles[i].image.X = animation[147].x
								}
							}
						case "pigProj":
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, shrec(drec(playerProjectiles[i].rec), 12), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, drec(playerProjectiles[i].rec), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, rl.Fade(rl.White, RandF32(0.4, 0.7)))
							if frames%3 == 0 {
								playerProjectiles[i].image.X += animation[135].width
								if playerProjectiles[i].image.X > animation[135].x+animation[135].frames*animation[135].width {
									playerProjectiles[i].image.X = animation[135].x
								}
							}
						case "mrfrisbeeProj":
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, shrec(drec(playerProjectiles[i].rec), 12), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, drec(playerProjectiles[i].rec), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, RandYellow())
							if frames%2 == 0 {
								playerProjectiles[i].image.X += animation[116].width
								if playerProjectiles[i].image.X > animation[116].x+animation[116].frames*animation[116].width {
									playerProjectiles[i].image.X = animation[116].x
								}
							}
							playerProjectiles[i].rotation += 4
						case "fartfire":
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, shrec(drec(playerProjectiles[i].rec), 12), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, drec(playerProjectiles[i].rec), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, rl.Fade(rl.White, RandF32(0.5, 0.7)))
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, brec(drec(playerProjectiles[i].rec), 5), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, rl.Fade(rl.White, RandF32(0.1, 0.3)))
						case "mustard":
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, shrec(drec(playerProjectiles[i].rec), 12), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, drec(playerProjectiles[i].rec), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, rl.Fade(rl.Orange, RandF32(0.4, 0.7)))
						case "popcornProj":
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, drec(playerProjectiles[i].rec), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, drec(playerProjectiles[i].rec), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, rl.White)
							playerProjectiles[i].rotation += playerProjectiles[i].rotationSpeed
						case "chickenProj":
							if playerProjectiles[i].direction {
								rl.DrawTexturePro(imgs, animation[103].rectangle, shrec(playerProjectiles[i].rec, 5), rl.Vector2Zero(), 0, ShadowColor())
								rl.DrawTexturePro(imgs, animation[103].rectangle, playerProjectiles[i].rec, rl.Vector2Zero(), 0, rl.White)
							} else {
								rl.DrawTexturePro(imgs, animation[102].rectangle, shrec(playerProjectiles[i].rec, 5), rl.Vector2Zero(), 0, ShadowColor())
								rl.DrawTexturePro(imgs, animation[102].rectangle, playerProjectiles[i].rec, rl.Vector2Zero(), 0, rl.White)
							}
							if eggsT == 0 {
								playerProjectiles[i].isOff = true
							}
							if debug {
								rl.DrawRectangleLinesEx(playerProjectiles[i].rec, 1, rl.Yellow)
								rl.DrawRectangleLinesEx(playerProjectiles[i].crec, 1, rl.Magenta)
							}
						case "beeProj":
							if playerProjectiles[i].direction {
								rl.DrawTexturePro(imgs, animation[101].rectangle, shrec(playerProjectiles[i].rec, 12), rl.Vector2Zero(), 0, ShadowColor())
								rl.DrawTexturePro(imgs, animation[101].rectangle, playerProjectiles[i].rec, rl.Vector2Zero(), 0, rl.White)
							} else {
								rl.DrawTexturePro(imgs, animation[100].rectangle, shrec(playerProjectiles[i].rec, 12), rl.Vector2Zero(), 0, ShadowColor())
								rl.DrawTexturePro(imgs, animation[100].rectangle, playerProjectiles[i].rec, rl.Vector2Zero(), 0, rl.White)
							}
							if honeycombT == 0 {
								playerProjectiles[i].isOff = true
							}
							if debug {
								rl.DrawRectangleLinesEx(playerProjectiles[i].rec, 1, rl.Yellow)
								rl.DrawRectangleLinesEx(playerProjectiles[i].crec, 1, rl.Magenta)
							}
						case "ladybugproj":
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, shrec(drec(playerProjectiles[i].rec), 12), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, drec(playerProjectiles[i].rec), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, rl.Fade(playerProjectiles[i].col, playerProjectiles[i].fade))
							if frames%3 == 0 {
								playerProjectiles[i].image.X += animation[97].width
								if playerProjectiles[i].image.X > animation[97].x+animation[97].frames*animation[97].width {
									playerProjectiles[i].image.X = animation[97].x
								}
							}
							playerProjectiles[i].rotation += 4
							if debug {
								rl.DrawRectangleLinesEx(playerProjectiles[i].rec, 1, rl.Red)
								rl.DrawRectangleLinesEx(playerProjectiles[i].crec, 1, rl.White)
								if playerProjectiles[i].carec.Width > 0 {
									rl.DrawRectangleLinesEx(playerProjectiles[i].carec, 1, rl.Magenta)
								}
							}
						case "frogProj":
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, shrec(drec(playerProjectiles[i].rec), 5), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, drec(playerProjectiles[i].rec), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, rl.Fade(playerProjectiles[i].col, playerProjectiles[i].fade))
							if debug {
								rl.DrawRectangleLinesEx(playerProjectiles[i].rec, 1, rl.Red)
								rl.DrawRectangleLinesEx(playerProjectiles[i].crec, 1, rl.White)
								if playerProjectiles[i].carec.Width > 0 {
									rl.DrawRectangleLinesEx(playerProjectiles[i].carec, 1, rl.Magenta)
								}
							}
						default:
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, shrec(drec(playerProjectiles[i].rec), 12), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, ShadowColor())
							rl.DrawTexturePro(imgs, playerProjectiles[i].image, drec(playerProjectiles[i].rec), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, rl.Fade(playerProjectiles[i].col, playerProjectiles[i].fade))
							//WINDOW CLEANER
							if playerProjectiles[i].name == "window cleaner" {
								rl.DrawTexturePro(imgs, playerProjectiles[i].image, brec(drec(playerProjectiles[i].rec), 10), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, rl.Fade(playerProjectiles[i].col, RandF32(0.5, 0.7)))
								rl.DrawTexturePro(imgs, playerProjectiles[i].image, brec(drec(playerProjectiles[i].rec), 20), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, rl.Fade(playerProjectiles[i].col, RandF32(0.2, 0.5)))
							}
							//FIREWORK
							if playerProjectiles[i].name == "firework" {
								playerProjectiles[i].rec3 = playerProjectiles[i].rec
								switch playerProjectiles[i].rotation {
								case 45:
									playerProjectiles[i].rec3.X -= playerProjectiles[i].rec3.Width
								case -135:
									playerProjectiles[i].rec3.X += playerProjectiles[i].rec3.Width
								case -45:
									playerProjectiles[i].rec3.Y += playerProjectiles[i].rec3.Width
								case 135:
									playerProjectiles[i].rec3.Y -= playerProjectiles[i].rec3.Width
								case 90:
									playerProjectiles[i].rec3.X -= playerProjectiles[i].rec3.Width
									playerProjectiles[i].rec3.Y -= playerProjectiles[i].rec3.Width
								case 270:
									playerProjectiles[i].rec3.X += playerProjectiles[i].rec3.Width
									playerProjectiles[i].rec3.Y += playerProjectiles[i].rec3.Width
								case 180:
									playerProjectiles[i].rec3.X += playerProjectiles[i].rec3.Width
									playerProjectiles[i].rec3.Y += playerProjectiles[i].rec3.Width
								case 0:
									playerProjectiles[i].rec3.X -= playerProjectiles[i].rec3.Width
									playerProjectiles[i].rec3.Y -= playerProjectiles[i].rec3.Width

								}
								rl.DrawTexturePro(imgs, playerProjectiles[i].rec2, drec(playerProjectiles[i].rec3), orgn(playerProjectiles[i].rec3), playerProjectiles[i].rotation-225, rl.White)
								playerProjectiles[i].rec2.X += animation[201].width
								if playerProjectiles[i].rec2.X > animation[201].x+animation[201].frames*animation[201].width {
									playerProjectiles[i].rec2.X = animation[201].x
								}
							}
							//ROCKET
							if playerProjectiles[i].name == "rocket" {
								rl.DrawTexturePro(imgs, playerProjectiles[i].rec2, drec(playerProjectiles[i].rec3), orgn(playerProjectiles[i].rec3), playerProjectiles[i].rotation-270, rl.White)
								playerProjectiles[i].rec2.X += animation[201].width
								if playerProjectiles[i].rec2.X > animation[201].x+animation[201].frames*animation[201].width {
									playerProjectiles[i].rec2.X = animation[201].x
								}
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(playerProjectiles[i].rec, 1, rl.Red)
							rl.DrawRectangleLinesEx(playerProjectiles[i].crec, 1, rl.White)
							if playerProjectiles[i].carec.Width > 0 {
								rl.DrawRectangleLinesEx(playerProjectiles[i].carec, 1, rl.Magenta)
							}
						}
					}
				}
			}
		}
		for i := 0; i < len(etc2); i++ {
			switch etc2[i].name {
			case "popcornturret":
				rl.DrawTexturePro(imgs, etc2[i].image, drec(shrec(etc2[i].rectangle, 5)), orgn(etc2[i].rectangle), etc2[i].rotation, ShadowColor())
				rl.DrawTexturePro(imgs, etc2[i].image, drec(etc2[i].rectangle), orgn(etc2[i].rectangle), etc2[i].rotation, rl.White)
				etc2[i].moveTimer--
				if etc2[i].moveTimer == 0 {
					etc2[i].moveTimer = fps
					siz := be3
					zproj := Weapon{}
					zproj.col = rl.White
					zproj.speed = 4
					zproj.damage = 1
					zproj.fade = 1
					zproj.rotationSpeed = RandF32(5, 11)
					if FlipCoin() {
						zproj.rotationSpeed = -zproj.rotationSpeed
					}
					zproj.rec = rl.NewRectangle(etc2[i].center.X-siz/2, etc2[i].center.Y-siz/2, siz, siz)
					zproj.crec = zproj.rec
					zproj.image = otherTiles[131]
					zproj.dirX = RandF32(-zproj.speed/2, zproj.speed/2)
					zproj.dirY = -zproj.speed
					zproj.bounce = 2
					if FlipCoin() {
						zproj.bounce = 3
					}
					zproj.name = "popcornProj"
					playerProjectiles = append(playerProjectiles, zproj)
					zproj.dirX = RandF32(-zproj.speed/2, zproj.speed/2)
					playerProjectiles = append(playerProjectiles, zproj)
					zproj.dirX = RandF32(-zproj.speed/2, zproj.speed/2)
					playerProjectiles = append(playerProjectiles, zproj)
					if rl.CheckCollisionRecs(etc2[i].rectangle, drawRec) {
						rl.PlaySound(audfx[86])
					}
					if FlipCoin() {
						zproj.dirX = RandF32(-zproj.speed/2, zproj.speed/2)
						playerProjectiles = append(playerProjectiles, zproj)
						if rl.CheckCollisionRecs(etc2[i].rectangle, drawRec) {
							rl.PlaySound(audfx[86])
						}
					}
					if FlipCoin() {
						zproj.dirX = RandF32(-zproj.speed/2, zproj.speed/2)
						playerProjectiles = append(playerProjectiles, zproj)
						if rl.CheckCollisionRecs(etc2[i].rectangle, drawRec) {
							rl.PlaySound(audfx[86])
						}
					}
				}
				//TXT
				if rl.CheckCollisionPointRec(cursorV2cam, etc2[i].rectangle) {
					toptx = "popcorn turret"
					toptxT = fps
				}
			case "ladybugturret":
				rl.DrawTexturePro(imgs, etc2[i].image, drec(shrec(etc2[i].rectangle, 5)), orgn(etc2[i].rectangle), etc2[i].rotation, ShadowColor())
				rl.DrawTexturePro(imgs, etc2[i].image, drec(etc2[i].rectangle), orgn(etc2[i].rectangle), etc2[i].rotation, rl.White)
				etc2[i].rotation += 1.015
				etc2[i].moveTimer--
				if etc2[i].moveTimer == 0 {
					if rl.CheckCollisionRecs(etc2[i].rectangle, drawRec) {
						rl.PlaySound(audfx[85])
					}
					etc2[i].moveTimer = fps
					siz := b / 2
					zproj := Weapon{}
					zproj.col = rl.White
					zproj.speed = 4
					zproj.damage = 1
					zproj.fade = 1
					zproj.rec = rl.NewRectangle(etc2[i].center.X-siz/2, etc2[i].center.Y-siz/2, siz, siz)
					xdiff := AbsDiff(etc2[i].center.X, etc2[i].vector.X)
					ydiff := AbsDiff(etc2[i].center.Y, etc2[i].vector.Y)
					if xdiff > ydiff {
						zproj.dirX = zproj.speed
						zproj.dirY = ydiff / (xdiff / zproj.dirX)
					} else {
						zproj.dirY = zproj.speed
						zproj.dirX = xdiff / (ydiff / zproj.dirY)
					}
					if etc2[i].center.X > etc2[i].vector.X {
						zproj.dirX = -zproj.dirX
					}
					if etc2[i].center.Y > etc2[i].vector.Y {
						zproj.dirY = -zproj.dirY
					}
					zproj.crec = zproj.rec
					zproj.image = animation[97].rectangle
					zproj.bounce = 2
					if FlipCoin() {
						zproj.bounce = 3
					}
					zproj.name = "ladybugproj"
					playerProjectiles = append(playerProjectiles, zproj)
				}
				etc2[i].angle = etc2[i].angle * (math.Pi / 180)
				newx := float32(math.Cos(float64(etc2[i].angle)))*(etc2[i].vector.X-etc2[i].center.X) - float32(math.Sin(float64(etc2[i].angle)))*(etc2[i].vector.Y-etc2[i].center.Y) + etc2[i].center.X
				newy := float32(math.Sin(float64(etc2[i].angle)))*(etc2[i].vector.X-etc2[i].center.X) + float32(math.Cos(float64(etc2[i].angle)))*(etc2[i].vector.Y-etc2[i].center.Y) + etc2[i].center.Y
				etc2[i].vector = rl.NewVector2(newx, newy)
				etc2[i].angle++
				if etc2[i].angle >= 360 {
					etc2[i].angle = 0
				}
				//TXT
				if rl.CheckCollisionPointRec(cursorV2cam, etc2[i].rectangle) {
					toptx = "ladybug turret"
					toptxT = fps
				}
			}
		}
		//MARK: DRAW PLAYER PROJ LAYER ABOVE
		if len(playerProjectiles) > 0 {
			for i := 0; i < len(playerProjectiles); i++ {
				if rl.CheckCollisionRecs(playerProjectiles[i].rec, drawRec) {
					if playerProjectiles[i].name == "poisongas" {
						rl.DrawTexturePro(imgs, playerProjectiles[i].image, shrec(drec(playerProjectiles[i].rec), 12), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, ShadowColor())
						rl.DrawTexturePro(imgs, playerProjectiles[i].image, drec(playerProjectiles[i].rec), orgn(playerProjectiles[i].rec), playerProjectiles[i].rotation, rl.Fade(RandGreen(), RandF32(0.7, 1.1)))
						if debug {
							rl.DrawRectangleLinesEx(playerProjectiles[i].rec, 1, rl.Red)
							rl.DrawRectangleLinesEx(playerProjectiles[i].crec, 1, rl.White)
						}
						playerProjectiles[i].rotation += playerProjectiles[i].rotationSpeed
						if frames%4 == 0 {
							if playerProjectiles[i].name == "poisongas" {
								playerProjectiles[i].image.X += animation[76].width
								if playerProjectiles[i].image.X > animation[76].x+animation[76].frames*animation[76].width {
									playerProjectiles[i].image.X = animation[76].x
								}
							}
						}
					}
				}
			}
		}
		//WALLS
		for i := 0; i < len(walls); i++ {
			//MOVE BLOCK SHADOW REC
			if walls[i].dirX != 0 || walls[i].dirY != 0 {
				rl.DrawTexturePro(imgs, walltile, shrec(walls[i].rectangle, 4), rl.Vector2Zero(), 0, ShadowColor())
				//SPIKES
				if walls[i].spikes {
					//MARK:MOVE BLOK SPIKES
					if walls[i].onoff {
						walls[i].spikeRectangles[0].Y++ //TOP SPIKE
						walls[i].spikeRectangles[1].X-- //RIGHT SPIKE
						walls[i].spikeRectangles[2].Y-- //DOWN SPIKE
						walls[i].spikeRectangles[3].X++ //LEFT SPIKE
						if walls[i].spikeRectangles[0].Y >= walls[i].rectangle.Y {
							walls[i].spikeRectangles[0].Y = walls[i].rectangle.Y
							walls[i].onoff = false
						}
						if walls[i].spikeRectangles[1].X < walls[i].rectangle.X+walls[i].rectangle.Width-walls[i].spikeRectangles[1].Width {
							walls[i].spikeRectangles[1].X = walls[i].rectangle.X + walls[i].rectangle.Width - walls[i].spikeRectangles[1].Width
						}
						if walls[i].spikeRectangles[2].Y < walls[i].rectangle.Y+walls[i].rectangle.Height-walls[i].spikeRectangles[1].Height {
							walls[i].spikeRectangles[2].Y = walls[i].rectangle.Y + walls[i].rectangle.Height - walls[i].spikeRectangles[1].Height
						}
						if walls[i].spikeRectangles[3].X > walls[i].rectangle.X {
							walls[i].spikeRectangles[3].X = walls[i].rectangle.X
						}
					} else {
						walls[i].spikeRectangles[0].Y-- //TOP SPIKE
						walls[i].spikeRectangles[1].X++ //RIGHT SPIKE
						walls[i].spikeRectangles[2].Y++ //DOWN SPIKE
						walls[i].spikeRectangles[3].X-- //LEFT SPIKE
						if walls[i].spikeRectangles[0].Y <= walls[i].rectangle.Y-walls[i].spikeRectangles[0].Height {
							walls[i].spikeRectangles[0].Y = walls[i].rectangle.Y - walls[i].spikeRectangles[0].Height
							walls[i].onoff = true
						}
						if walls[i].spikeRectangles[1].X > walls[i].rectangle.X+walls[i].rectangle.Width {
							walls[i].spikeRectangles[1].X = walls[i].rectangle.X + walls[i].rectangle.Width
						}
						if walls[i].spikeRectangles[2].Y > walls[i].rectangle.Y+walls[i].rectangle.Height {
							walls[i].spikeRectangles[2].Y = walls[i].rectangle.Y + walls[i].rectangle.Height
						}
						if walls[i].spikeRectangles[3].X < walls[i].rectangle.X-walls[i].spikeRectangles[3].Width {
							walls[i].spikeRectangles[3].X = walls[i].rectangle.X - walls[i].spikeRectangles[3].Width
						}
					}

					for j := 0; j < len(walls[i].spikeRectangles); j++ {
						if walls[i].onoff {
							if walls[i].spikeRectangles[0].Y > walls[i].rectangle.Y {
								walls[i].spikeRectangles[0].Y--
							}
							if walls[i].spikeRectangles[1].X < walls[i].rectangle.X+walls[i].rectangle.Width-walls[i].spikeRectangles[1].Width {
								walls[i].spikeRectangles[1].X++
							}
							if walls[i].spikeRectangles[2].Y < walls[i].rectangle.Y-walls[i].spikeRectangles[2].Height {
								walls[i].spikeRectangles[2].Y++
							}
							if walls[i].spikeRectangles[3].X > walls[i].rectangle.X {
								walls[i].spikeRectangles[3].X--
							}
						} else {
							if walls[i].spikeRectangles[0].Y < walls[i].rectangle.Y-walls[i].spikeRectangles[0].Height {
								walls[i].spikeRectangles[0].Y++
							}
							if walls[i].spikeRectangles[1].X > walls[i].rectangle.X+walls[i].rectangle.Width {
								walls[i].spikeRectangles[1].X--
							}
							if walls[i].spikeRectangles[2].Y > walls[i].rectangle.Y+walls[i].rectangle.Height {
								walls[i].spikeRectangles[2].Y--
							}
							if walls[i].spikeRectangles[3].X < walls[i].rectangle.X-walls[i].spikeRectangles[3].Width {
								walls[i].spikeRectangles[3].X++
							}
						}

					}

					for j := 0; j < len(walls[i].spikeRectangles); j++ {
						rl.DrawTexturePro(imgs, otherTiles[0], shrec(drec(walls[i].spikeRectangles[j]), 7), orgn(walls[i].spikeRectangles[j]), float32(j)*90, ShadowColor())
						if psychedelicsT > 0 {
							rl.DrawTexturePro(imgs, otherTiles[0], drec(walls[i].spikeRectangles[j]), orgn(walls[i].spikeRectangles[j]), float32(j)*90, walls[i].color2)
						} else {
							rl.DrawTexturePro(imgs, otherTiles[0], drec(walls[i].spikeRectangles[j]), orgn(walls[i].spikeRectangles[j]), float32(j)*90, rl.White)
						}

						//CHECK PL SPIKE COLLIS
						if rl.CheckCollisionRecs(player.collisionRectangle, walls[i].spikeRectangles[j]) && player.enemyCollisionTimer == 0 {
							if feather {
								if msgT == 0 {
									admsg("immune spikes > feather cushions", rl.White)
									msgT = fps
								}
							} else {
								player.enemyCollisionTimer = fps
								if stats.dexterity > 1 {
									if Roll12() <= stats.dexterity {
										if msgT == 0 {
											admsg("dodged > dexterity", rl.Magenta)
											msgT = fps
										}
									} else {
										if player.hpTimer == 0 {
											hitPL(1)
										}
									}
								} else {
									if player.hpTimer == 0 {
										hitPL(1)
									}
								}
							}
						}
					}
				}
				//BG REC
				rl.DrawRectangleRec(walls[i].rectangle, rl.Black)
				//IMG REC
				if psychedelicsT > 0 {
					rl.DrawTexturePro(imgs, walltile, walls[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(walls[i].color2, walls[i].fade))
				} else {
					rl.DrawTexturePro(imgs, walltile, walls[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(walls[i].color, walls[i].fade))
				}

				//BLUR REC
				rl.DrawTexturePro(imgs, walltile, blrec(walls[i].rectangle, 0.2), rl.Vector2Zero(), 0, rl.Fade(walls[i].color, 0.3))
				if debug {
					rl.DrawRectangleLinesEx(walls[i].rectangle, 2, rl.Green)
				}
				//MARK:MOVE BLOKS
				if tvT == 0 {
					if walls[i].dirX != 0 {
						if checkmoveblok(walls[i], i) {
							walls[i].rectangle.X += walls[i].dirX + delta
							for j := 0; j < len(walls[i].spikeRectangles); j++ {
								walls[i].spikeRectangles[j].X += walls[i].dirX + delta
							}
						} else {
							walls[i].dirX = walls[i].dirX * -1
						}
					}
					if walls[i].dirY != 0 {
						if checkmoveblok(walls[i], i) {
							walls[i].rectangle.Y += walls[i].dirY + delta
							for j := 0; j < len(walls[i].spikeRectangles); j++ {
								walls[i].spikeRectangles[j].Y += walls[i].dirY + delta
							}
						} else {
							walls[i].dirY = walls[i].dirY * -1
						}
					}
				}
			}
		}
		//MARK: DRAW FX LAYER ABOVE
		if len(effect) > 0 {
			clear := false
			for i := 0; i < len(effect); i++ {
				if !effect[i].isOff && !effect[i].isBelow {
					switch effect[i].name {
					case "redWeapEnd":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandRed(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if effect[i].imageRectangle.X < animation[179].x+animation[179].frames*animation[179].width {
								effect[i].imageRectangle.X += animation[179].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "greenWeapEnd":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandGreen(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if effect[i].imageRectangle.X < animation[179].x+animation[179].frames*animation[179].width {
								effect[i].imageRectangle.X += animation[179].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "brownWeapEnd":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandBrown(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if effect[i].imageRectangle.X < animation[179].x+animation[179].frames*animation[179].width {
								effect[i].imageRectangle.X += animation[179].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "blueWeapEnd":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandBlue(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if effect[i].imageRectangle.X < animation[179].x+animation[179].frames*animation[179].width {
								effect[i].imageRectangle.X += animation[179].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "orangeWeapEnd":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandOrange(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if effect[i].imageRectangle.X < animation[179].x+animation[179].frames*animation[179].width {
								effect[i].imageRectangle.X += animation[179].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "greyWeapEnd":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandGrey(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if effect[i].imageRectangle.X < animation[179].x+animation[179].frames*animation[179].width {
								effect[i].imageRectangle.X += animation[179].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "pinkWeapEnd":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandPink(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if effect[i].imageRectangle.X < animation[179].x+animation[179].frames*animation[179].width {
								effect[i].imageRectangle.X += animation[179].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "yellowWeapEnd":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandYellow(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if effect[i].imageRectangle.X < animation[179].x+animation[179].frames*animation[179].width {
								effect[i].imageRectangle.X += animation[179].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "ringoffire":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(drec(effect[i].rectangle), 20), orgn(effect[i].rectangle), effect[i].rotation, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, drec(effect[i].rectangle), orgn(effect[i].rectangle), effect[i].rotation, rl.Fade(rl.White, RandF32(0.5, 0.7)))
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, brec(drec(effect[i].rectangle), 5), orgn(effect[i].rectangle), effect[i].rotation, rl.Fade(rl.White, RandF32(0.3, 0.5)))
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, brec(drec(effect[i].rectangle), 12), orgn(effect[i].rectangle), effect[i].rotation, rl.Fade(rl.White, RandF32(0.1, 0.3)))
						if frames%2 == 0 {
							if effect[i].imageRectangle.X < animation[202].x+animation[202].frames*animation[202].width {
								effect[i].imageRectangle.X += animation[202].width
							} else {
								effect[i].imageRectangle.X = animation[202].x
							}

							if effect[i].rectangle.Width < b10*2 {
								effect[i].rectangle.X -= 5
								effect[i].rectangle.Y -= 5
								effect[i].rectangle.Width += 10
								effect[i].rectangle.Height += 10
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, effect[i].rectangle) {
								if !levels[levNum].enemies[j].nodmg {
									if levels[levNum].enemies[j].name == "flamehead" || levels[levNum].enemies[j].name == "ghost" || levels[levNum].enemies[j].name == "yellowdino" || levels[levNum].enemies[j].name == "reddevil" {
										if msgT == 0 {
											admsg("immune to burn", rl.Yellow)
											msgT = fps
										}
									} else {
										if levels[levNum].enemies[j].burnT <= 0 {
											levels[levNum].enemies[j].burnT = fps * 3
										}
									}
								}
							}
						}

						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "icecrystal":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(drec(effect[i].rectangle), 20), orgn(effect[i].rectangle), effect[i].rotation, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, drec(effect[i].rectangle), orgn(effect[i].rectangle), effect[i].rotation, rl.Fade(RandBlue(), RandF32(0.1, 0.2)))
						effect[i].rotation += 12
						if frames%3 == 0 {
							if effect[i].rectangle.Width < b10 {
								effect[i].rectangle.X -= 4
								effect[i].rectangle.Y -= 4
								effect[i].rectangle.Width += 8
								effect[i].rectangle.Height += 8
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, effect[i].rectangle) {
								if !levels[levNum].enemies[j].nodmg {
									if levels[levNum].enemies[j].freezeT == 0 {
										levels[levNum].enemies[j].freezeT = fps * 3
									}
								}
							}
						}

						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "rollodthfx":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						col := RandYellow()
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.2, 0.5)))
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, brec(effect[i].rectangle, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))

						if frames%2 == 0 {
							if effect[i].imageRectangle.X < animation[197].x+animation[197].frames*animation[197].width {
								effect[i].imageRectangle.X += animation[197].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "musheedthfx":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						col := RandRed()
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.5, 0.7)))
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, brec(effect[i].rectangle, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))

						if frames%2 == 0 {
							if effect[i].imageRectangle.X < animation[196].x+animation[196].frames*animation[196].width {
								effect[i].imageRectangle.X += animation[196].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "battydthfx":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						col := RandRed()
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.5, 0.7)))
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, brec(effect[i].rectangle, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))

						if frames%2 == 0 {
							if effect[i].imageRectangle.X < animation[195].x+animation[195].frames*animation[195].width {
								effect[i].imageRectangle.X += animation[195].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "zombodthfx":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						col := RandGreen()
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.5, 0.7)))
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, brec(effect[i].rectangle, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))
						if frames%2 == 0 {
							if effect[i].imageRectangle.X < animation[194].x+animation[194].frames*animation[194].width {
								effect[i].imageRectangle.X += animation[194].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "pyrodthfx":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						col := RandOrange()
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.5, 0.7)))
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, brec(effect[i].rectangle, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))
						if frames%2 == 0 {
							if effect[i].imageRectangle.X < animation[193].x+animation[193].frames*animation[193].width {
								effect[i].imageRectangle.X += animation[193].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "spzmandthfx":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						col := RandColor()
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.5, 0.7)))
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, brec(effect[i].rectangle, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))
						if frames%2 == 0 {
							if effect[i].imageRectangle.X < animation[192].x+animation[192].frames*animation[192].width {
								effect[i].imageRectangle.X += animation[192].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "spinnadthfx":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						col := RandColor()
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.5, 0.7)))
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, brec(effect[i].rectangle, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))
						if frames%2 == 0 {
							if effect[i].imageRectangle.X < animation[191].x+animation[191].frames*animation[191].width {
								effect[i].imageRectangle.X += animation[191].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "frisbeedthfx":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						col := RandYellow()
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.2, 0.5)))
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, brec(effect[i].rectangle, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))
						if frames%2 == 0 {
							if effect[i].imageRectangle.X < animation[190].x+animation[190].frames*animation[190].width {
								effect[i].imageRectangle.X += animation[190].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "icedthfx":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						col := RandBlue()
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.2, 0.5)))
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, brec(effect[i].rectangle, 7), rl.Vector2Zero(), 0, rl.Fade(col, RandF32(0.1, 0.25)))
						if frames%2 == 0 {
							if effect[i].imageRectangle.X < animation[189].x+animation[189].frames*animation[189].width {
								effect[i].imageRectangle.X += animation[189].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "potionfx":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
						if frames%3 == 0 {
							if effect[i].imageRectangle.X < animation[188].x+animation[188].frames*animation[188].width {
								effect[i].imageRectangle.X += animation[188].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "scrollfx":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
						if frames%3 == 0 {
							if effect[i].imageRectangle.X < animation[186].x+animation[186].frames*animation[186].width {
								effect[i].imageRectangle.X += animation[186].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}
					case "weaponcrate":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandOrange(), RandF32(0.4, 0.7)))
						if frames%5 == 0 {
							if effect[i].imageRectangle.X < animation[181].x+animation[181].frames*animation[181].width {
								effect[i].imageRectangle.X += animation[181].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
					case "switchfx":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.3, 0.5)))
						if frames%3 == 0 {
							if effect[i].imageRectangle.X < animation[180].x+animation[180].frames*animation[180].width {
								effect[i].imageRectangle.X += animation[180].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}

					case "fryingShock":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.2, 0.4)))
						if frames%3 == 0 {
							if effect[i].imageRectangle.X < animation[178].x+animation[178].frames*animation[178].width {
								effect[i].imageRectangle.X += animation[178].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Magenta)
						}

						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, effect[i].rectangle) {
								if !levels[levNum].enemies[j].nodmg {
									if levels[levNum].enemies[j].stunT == 0 {
										if levels[levNum].enemies[j].stunT == 0 {
											levels[levNum].enemies[j].stunT = fps * 2
											levels[levNum].enemies[j].stunF = 0.9
											levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
											levels[levNum].enemies[j].stunSiz = b / 4
										}
									}
								}
							}
						}
					case "landmineExplod":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.4, 0.7)))
						if frames%3 == 0 {
							if effect[i].imageRectangle.X < animation[57].x+animation[57].frames*animation[57].width {
								effect[i].imageRectangle.X += animation[57].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
					case "icemanchange":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 20), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.2, 0.5)))
						if frames%3 == 0 {
							if effect[i].imageRectangle.X < animation[109].x+animation[109].frames*animation[109].width {
								effect[i].imageRectangle.X += animation[109].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						if rl.CheckCollisionRecs(player.rectangle, effect[i].rectangle) && player.freezeTimer == 0 && saltT == 0 {
							player.freezeTimer = fps * 2
						} else if saltT > 0 {
							if msgT == 0 {
								admsg("salt saves freeze", rl.Green)
								msgT = fps
							}
						}
					case "summonitem":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.4, 0.7)))
						if frames%4 == 0 {
							if effect[i].imageRectangle.X < animation[108].x+animation[108].frames*animation[108].width {
								effect[i].imageRectangle.X += animation[108].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
					case "bombExplode":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 12), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandOrange(), RandF32(0.4, 0.7)))
						if frames%2 == 0 {
							if effect[i].imageRectangle.X < animation[106].x+animation[106].frames*animation[106].width {
								effect[i].imageRectangle.X += animation[106].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, effect[i].rectangle) {
								if !levels[levNum].enemies[j].nodmg {
									if levels[levNum].enemies[j].hpT == 0 {
										levels[levNum].enemies[j].hp -= 3
										if levels[levNum].enemies[j].hp <= 0 && !levels[levNum].enemies[j].off {
											player.xp += levels[levNum].enemies[j].xp
											makeEnDeathFx(j)
											levels[levNum].enemies[j].off = true
										} else {
											levels[levNum].enemies[j].hpT = fps
											levels[levNum].enemies[j].hpY = bq3
											levels[levNum].enemies[j].hpY2 = 0
											if isBossOn {
												levels[levNum].enemies[j].hpY = b
												levels[levNum].enemies[j].hpY2 = b / 2
											}
											if levels[levNum].enemies[j].name == "crocodile" || levels[levNum].enemies[j].name == "redantenna" {
												levels[levNum].enemies[j].stunT = fps * 2
												levels[levNum].enemies[j].stunF = 0.9
												levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
												levels[levNum].enemies[j].stunSiz = b / 4
											}
											if levels[levNum].enemies[j].name == "flamehead" || levels[levNum].enemies[j].name == "ghost" || levels[levNum].enemies[j].name == "yellowdino" || levels[levNum].enemies[j].name == "reddevil" {
												if msgT == 0 {
													admsg("immune to burn", rl.Yellow)
													msgT = fps
												}
											} else {
												if levels[levNum].enemies[j].burnT <= 0 {
													levels[levNum].enemies[j].burnT = fps * 3
												}
											}
										}
									}

								}
							}
						}
					case "chickenExplode":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 12), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.2, 0.5)))
						if frames%4 == 0 {
							if effect[i].imageRectangle.X < animation[104].x+animation[104].frames*animation[104].width {
								effect[i].imageRectangle.X += animation[104].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, effect[i].collisionRectangle) {
								if !levels[levNum].enemies[j].nodmg {
									if levels[levNum].enemies[j].hpT == 0 {
										levels[levNum].enemies[j].hp -= 1
										if levels[levNum].enemies[j].hp <= 0 && !levels[levNum].enemies[j].off {
											player.xp += levels[levNum].enemies[j].xp
											makeEnDeathFx(j)
											levels[levNum].enemies[j].off = true
										} else {
											levels[levNum].enemies[j].hpT = fps
											levels[levNum].enemies[j].hpY = bq3
											levels[levNum].enemies[j].hpY2 = 0
											if isBossOn {
												levels[levNum].enemies[j].hpY = b
												levels[levNum].enemies[j].hpY2 = b / 2
											}
										}
										if levels[levNum].enemies[j].name == "crocodile" || levels[levNum].enemies[j].name == "redantenna" {
											levels[levNum].enemies[j].stunT = fps * 2
											levels[levNum].enemies[j].stunF = 0.9
											levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
											levels[levNum].enemies[j].stunSiz = b / 4
										}
									}
									if levels[levNum].enemies[j].name == "flamehead" || levels[levNum].enemies[j].name == "ghost" || levels[levNum].enemies[j].name == "yellowdino" || levels[levNum].enemies[j].name == "reddevil" {
										if msgT == 0 {
											admsg("immune to burn", rl.Yellow)
											msgT = fps
										}
									} else {
										if levels[levNum].enemies[j].burnT <= 0 {
											levels[levNum].enemies[j].burnT = fps * 3
										}
									}
								}
							}
						}
						if debug {
							rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Yellow)
							rl.DrawRectangleLinesEx(effect[i].collisionRectangle, 2, rl.Magenta)
						}
					case "shockwave":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 12), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.2, 0.5)))
						if frames%4 == 0 {
							if effect[i].imageRectangle.X < animation[99].x+animation[99].frames*animation[99].width {
								effect[i].imageRectangle.X += animation[99].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, effect[i].rectangle) {
								if !levels[levNum].enemies[j].nodmg {
									if levels[levNum].enemies[j].stunT == 0 {
										levels[levNum].enemies[j].stunT = fps * 2
										levels[levNum].enemies[j].stunF = 0.9
										levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
										levels[levNum].enemies[j].stunSiz = b / 4
									}
									if levels[levNum].enemies[j].hpT == 0 {
										levels[levNum].enemies[j].hp -= 1
										if levels[levNum].enemies[j].hp <= 0 && !levels[levNum].enemies[j].off {
											player.xp += levels[levNum].enemies[j].xp
											makeEnDeathFx(j)
											levels[levNum].enemies[j].off = true
										} else {
											levels[levNum].enemies[j].hpT = fps
											levels[levNum].enemies[j].hpY = bq3
											levels[levNum].enemies[j].hpY2 = 0
											if isBossOn {
												levels[levNum].enemies[j].hpY = b
												levels[levNum].enemies[j].hpY2 = b / 2
											}
										}
										if levels[levNum].enemies[j].name == "crocodile" || levels[levNum].enemies[j].name == "redantenna" {
											levels[levNum].enemies[j].stunT = fps * 2
											levels[levNum].enemies[j].stunF = 0.9
											levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
											levels[levNum].enemies[j].stunSiz = b / 4
										}
									}
								}
							}
						}
					case "cloaksparks":
						for j := 0; j < len(effect[i].rectangles2); j++ {
							rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangles2[j], rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangles2[j], rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.2, 0.4)))
							if debug {
								rl.DrawRectangleLinesEx(effect[i].rectangles2[j], 2, rl.Yellow)
								rl.DrawRectangleLinesEx(effect[i].collisionRectangles[j], 2, rl.Magenta)
							}
							for k := 0; k < len(levels[levNum].enemies); k++ {
								if rl.CheckCollisionRecs(levels[levNum].enemies[k].collisionRectangle, effect[i].collisionRectangles[j]) {
									if !levels[levNum].enemies[k].nodmg {
										if levels[levNum].enemies[k].hpT == 0 {
											levels[levNum].enemies[k].hp--
											if levels[levNum].enemies[k].hp <= 0 && !levels[levNum].enemies[k].off {
												player.xp += levels[levNum].enemies[k].xp
												makeEnDeathFx(k)
												levels[levNum].enemies[k].off = true
											} else {
												levels[levNum].enemies[k].hpT = fps
												levels[levNum].enemies[k].hpY = bq3
												levels[levNum].enemies[k].hpY2 = 0
												if isBossOn {
													levels[levNum].enemies[k].hpY = b
													levels[levNum].enemies[k].hpY2 = b / 2
												}
											}
											if levels[levNum].enemies[k].name == "crocodile" || levels[levNum].enemies[k].name == "redantenna" {
												levels[levNum].enemies[k].stunT = fps
												levels[levNum].enemies[k].stunF = 0.9
												levels[levNum].enemies[k].stunY = levels[levNum].enemies[k].cnt.Y
												levels[levNum].enemies[k].stunSiz = b / 4
											}
										}
									}
								}
							}
						}
						if frames%4 == 0 {
							effect[i].imageRectangle.X += animation[96].width
							if effect[i].imageRectangle.X > animation[96].x+animation[96].frames*animation[96].width {
								effect[i].imageRectangle.X = animation[96].x
							}
						}
						if cloakT == 0 {
							effect[i].isOff = true
							clear = true
						}
					case "beetrootExplode":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 12), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandRed(), RandF32(0.4, 0.7)))
						if frames%4 == 0 {
							if effect[i].imageRectangle.X < animation[95].x+animation[95].frames*animation[95].width {
								effect[i].imageRectangle.X += animation[95].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, effect[i].rectangle) {
								if !levels[levNum].enemies[j].nodmg {
									if levels[levNum].enemies[j].stunT == 0 {
										levels[levNum].enemies[j].stunT = fps * 2
										levels[levNum].enemies[j].stunF = 0.9
										levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
										levels[levNum].enemies[j].stunSiz = b / 4
									}
									if levels[levNum].enemies[j].hpT == 0 {
										levels[levNum].enemies[j].hp -= 3
										if levels[levNum].enemies[j].hp <= 0 && !levels[levNum].enemies[j].off {
											player.xp += levels[levNum].enemies[j].xp
											makeEnDeathFx(j)
											levels[levNum].enemies[j].off = true
										} else {
											levels[levNum].enemies[j].hpT = fps
											levels[levNum].enemies[j].hpY = bq3
											levels[levNum].enemies[j].hpY2 = 0
											if isBossOn {
												levels[levNum].enemies[j].hpY = b
												levels[levNum].enemies[j].hpY2 = b / 2
											}
										}
										if levels[levNum].enemies[j].name == "crocodile" || levels[levNum].enemies[j].name == "redantenna" {
											levels[levNum].enemies[j].stunT = fps * 2
											levels[levNum].enemies[j].stunF = 0.9
											levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
											levels[levNum].enemies[j].stunSiz = b / 4
										}
									}
								}
							}
						}
						if beetrootT == 0 {
							effect[i].isOff = true
							clear = true
						}
					case "beetroot":
						siz := bq3
						for j := 0; j < len(effect[i].v1); j++ {
							rec := rl.NewRectangle(effect[i].v2[j].X-siz/2, effect[i].v2[j].Y-siz/2, siz, siz)
							if effect[i].v2[j].Y < effect[i].v1[j].Y {
								rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(rec, 12), rl.Vector2Zero(), 0, ShadowColor())
								rl.DrawTexturePro(imgs, effect[i].imageRectangle, rec, rl.Vector2Zero(), 0, rl.White)
								effect[i].v2[j].Y += b / 2
							} else {
								if !effect[i].isOn[j] {
									effect[i].isOn[j] = true
									zfx := Effect{}
									zfx.imageRectangle = animation[95].rectangle
									zfx.rectangle = effect[i].rectangles2[j]
									zfx.name = "beetrootExplode"
									effect = append(effect, zfx)
								}
							}
						}
						if beetrootT == 0 {
							effect[i].isOff = true
							clear = true
						}
					case "belt":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.White)
						if frames%4 == 0 {
							if effect[i].imageRectangle.X < animation[94].x+animation[94].frames*animation[94].width {
								effect[i].imageRectangle.X += animation[94].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, effect[i].rectangle) {
								if !levels[levNum].enemies[j].nodmg {
									if levels[levNum].enemies[j].hpT == 0 {
										levels[levNum].enemies[j].hp -= 1
										if levels[levNum].enemies[j].hp <= 0 && !levels[levNum].enemies[j].off {
											player.xp += levels[levNum].enemies[j].xp
											makeEnDeathFx(j)
											levels[levNum].enemies[j].off = true
										} else {
											levels[levNum].enemies[j].hpT = fps
											levels[levNum].enemies[j].hpY = bq3
											levels[levNum].enemies[j].hpY2 = 0
											if isBossOn {
												levels[levNum].enemies[j].hpY = b
												levels[levNum].enemies[j].hpY2 = b / 2
											}
										}
										if levels[levNum].enemies[j].name == "crocodile" || levels[levNum].enemies[j].name == "redantenna" {
											levels[levNum].enemies[j].stunT = fps * 2
											levels[levNum].enemies[j].stunF = 0.9
											levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
											levels[levNum].enemies[j].stunSiz = b / 4
										}
										if levels[levNum].enemies[j].name == "flamehead" || levels[levNum].enemies[j].name == "skeleton" || levels[levNum].enemies[j].name == "ghost" || levels[levNum].enemies[j].name == "robot" {
											if msgT == 0 {
												admsg("immune to bleed", rl.Yellow)
												msgT = fps
											}
										} else {
											levels[levNum].enemies[j].bleed++
											levels[levNum].enemies[j].bleedT = fps * 2
										}
									}
								}
							}
						}
					case "frisbee":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, drec(shrec(effect[i].rectangle, 18)), orgn(effect[i].rectangle), effect[i].rotation, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, drec(effect[i].rectangle), orgn(effect[i].rectangle), effect[i].rotation, rl.Fade(RandColor(), RandF32(0.7, 0.9)))
						if frames%4 == 0 {
							effect[i].imageRectangle.X += animation[93].width
							if effect[i].imageRectangle.X > animation[93].x+animation[93].frames*animation[93].width {
								effect[i].imageRectangle.X = animation[93].x
							}
						}
						effect[i].rotation += 8
						if frisbeeT == 0 {
							effect[i].isOff = true
							clear = true
						}
						checkV2 := effect[i].center
						checkV2.X += effect[i].dirX
						checkV2.Y += effect[i].dirY
						if checkV2Walls(checkV2) {
							effect[i].center = checkV2
							effect[i].rectangle = rl.NewRectangle(effect[i].center.X-effect[i].rectangle.Width/2, effect[i].center.Y-effect[i].rectangle.Height/2, effect[i].rectangle.Width, effect[i].rectangle.Height)
							effect[i].collisionRectangle = effect[i].rectangle
							effect[i].collisionRectangle.X += effect[i].collisionRectangle.Width / 8
							effect[i].collisionRectangle.Y += effect[i].collisionRectangle.Width / 8
							effect[i].collisionRectangle.Width -= effect[i].collisionRectangle.Width / 4
							effect[i].collisionRectangle.Height -= effect[i].collisionRectangle.Width / 4
						} else {
							countbreak := 100
							for {
								effect[i].dirX = RandF32(-effect[i].speed, effect[i].speed)
								effect[i].dirY = RandF32(-effect[i].speed, effect[i].speed)
								if Abs(effect[i].dirX) > 2 || Abs(effect[i].dirY) > 2 {
									break
								}
								countbreak--
								if countbreak == 0 {
									break
								}
							}
						}
						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, effect[i].collisionRectangle) {
								if !levels[levNum].enemies[j].nodmg {
									if levels[levNum].enemies[j].hpT == 0 {
										levels[levNum].enemies[j].hp -= 1
										if levels[levNum].enemies[j].hp <= 0 && !levels[levNum].enemies[j].off {
											player.xp += levels[levNum].enemies[j].xp
											makeEnDeathFx(j)
											levels[levNum].enemies[j].off = true
										} else {
											levels[levNum].enemies[j].hpT = fps
											levels[levNum].enemies[j].hpY = bq3
											levels[levNum].enemies[j].hpY2 = 0
											if isBossOn {
												levels[levNum].enemies[j].hpY = b
												levels[levNum].enemies[j].hpY2 = b / 2
											}
										}
										if levels[levNum].enemies[j].name == "crocodile" || levels[levNum].enemies[j].name == "redantenna" {
											levels[levNum].enemies[j].stunT = fps * 2
											levels[levNum].enemies[j].stunF = 0.9
											levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
											levels[levNum].enemies[j].stunSiz = b / 4
										}
									}
									if levels[levNum].enemies[j].stunT == 0 {
										levels[levNum].enemies[j].stunT = fps * 2
										levels[levNum].enemies[j].stunF = 0.9
										levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
										levels[levNum].enemies[j].stunSiz = b / 4
									}
								}
							}
						}
					case "purplerain":
						for j := 0; j < len(effect[i].rectangles2); j++ {
							rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangles2[j], 5), rl.Vector2Zero(), 0, ShadowColor())
							rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangles2[j], rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.5, 0.7)))
							if debug {
								rl.DrawRectangleLinesEx(effect[i].rectangles2[j], 2, rl.Magenta)
							}
							for k := 0; k < len(levels[levNum].enemies); k++ {
								if rl.CheckCollisionRecs(levels[levNum].enemies[k].collisionRectangle, effect[i].rectangles2[j]) {
									if !levels[levNum].enemies[k].nodmg {
										if levels[levNum].enemies[k].hpT == 0 {
											levels[levNum].enemies[k].hp -= 1
											if levels[levNum].enemies[k].hp <= 0 && !levels[levNum].enemies[k].off {
												player.xp += levels[levNum].enemies[k].xp
												makeEnDeathFx(j)
												levels[levNum].enemies[k].off = true
											} else {
												levels[levNum].enemies[k].hpT = fps
												levels[levNum].enemies[k].hpY = bq3
												levels[levNum].enemies[k].hpY2 = 0
												if isBossOn {
													levels[levNum].enemies[k].hpY = b
													levels[levNum].enemies[k].hpY2 = b / 2
												}
											}
											if levels[levNum].enemies[k].name == "crocodile" || levels[levNum].enemies[k].name == "redantenna" {
												levels[levNum].enemies[k].stunT = fps
												levels[levNum].enemies[k].stunF = 0.9
												levels[levNum].enemies[k].stunY = levels[levNum].enemies[k].cnt.Y
												levels[levNum].enemies[k].stunSiz = b / 4
											}
										}
									}
								}
							}
						}
						if frames%3 == 0 {
							effect[i].imageRectangle.X += animation[92].width
							if effect[i].imageRectangle.X > animation[92].x+animation[92].frames*animation[92].width {
								effect[i].imageRectangle.X = animation[92].x
							}
						}
						if purplerainT == 0 {
							effect[i].isOff = true
							clear = true
						}
					case "tesla":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 18), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.1, 0.3)))
						if frames%4 == 0 {
							effect[i].imageRectangle.X += animation[91].width
							if effect[i].imageRectangle.X > animation[91].x+animation[91].frames*animation[91].width {
								effect[i].imageRectangle.X = animation[91].x
							}
						}
						if teslaT == 0 {
							effect[i].isOff = true
							clear = true
						}
						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, effect[i].rectangle) {
								if !levels[levNum].enemies[j].nodmg {
									if levels[levNum].enemies[j].stunT == 0 {
										levels[levNum].enemies[j].stunT = fps * 2
										levels[levNum].enemies[j].stunF = 0.9
										levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
										levels[levNum].enemies[j].stunSiz = b / 4
									}
									if levels[levNum].enemies[j].hpT == 0 {
										levels[levNum].enemies[j].hp -= 1
										if levels[levNum].enemies[j].hp <= 0 && !levels[levNum].enemies[j].off {
											player.xp += levels[levNum].enemies[j].xp
											makeEnDeathFx(j)
											levels[levNum].enemies[j].off = true
										} else {
											levels[levNum].enemies[j].hpT = fps
											levels[levNum].enemies[j].hpY = bq3
											levels[levNum].enemies[j].hpY2 = 0
											if isBossOn {
												levels[levNum].enemies[j].hpY = b
												levels[levNum].enemies[j].hpY2 = b / 2
											}
										}
										if levels[levNum].enemies[j].name == "crocodile" || levels[levNum].enemies[j].name == "redantenna" {
											levels[levNum].enemies[j].stunT = fps * 2
											levels[levNum].enemies[j].stunF = 0.9
											levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
											levels[levNum].enemies[j].stunSiz = b / 4
										}
									}
								}
							}
						}
					case "tornado":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 18), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.2, 0.4)))
						if frames%4 == 0 {
							effect[i].imageRectangle.X += animation[90].width
							if effect[i].imageRectangle.X > animation[90].x+animation[90].frames*animation[90].width {
								effect[i].imageRectangle.X = animation[90].x
							}
						}
						if quailT == 0 {
							effect[i].isOff = true
							clear = true
						}
						checkV2 := effect[i].center
						checkV2.X += effect[i].dirX
						checkV2.Y += effect[i].dirY
						if checkV2Walls(checkV2) {
							effect[i].center = checkV2
							effect[i].rectangle = rl.NewRectangle(effect[i].center.X-effect[i].rectangle.Width/2, effect[i].center.Y-effect[i].rectangle.Height/2, effect[i].rectangle.Width, effect[i].rectangle.Height)
							effect[i].collisionRectangle = effect[i].rectangle
							effect[i].collisionRectangle.X += effect[i].collisionRectangle.Width / 4
							effect[i].collisionRectangle.Width = effect[i].collisionRectangle.Width - effect[i].collisionRectangle.Width/2
						} else {
							countbreak := 100
							for {
								effect[i].dirX = RandF32(-effect[i].speed, effect[i].speed)
								effect[i].dirY = RandF32(-effect[i].speed, effect[i].speed)
								if Abs(effect[i].dirX) > 1 || Abs(effect[i].dirY) > 1 {
									break
								}
								countbreak--
								if countbreak == 0 {
									break
								}
							}
						}
						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, effect[i].collisionRectangle) {
								if !levels[levNum].enemies[j].nodmg {
									if levels[levNum].enemies[j].stunT == 0 {
										levels[levNum].enemies[j].stunT = fps * 2
										levels[levNum].enemies[j].stunF = 0.9
										levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
										levels[levNum].enemies[j].stunSiz = b / 4
									}
								}
							}
						}
					case "thorns":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 12), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(RandRed(), 0.4))
						if frames%4 == 0 {
							if effect[i].imageRectangle.X < animation[89].x+animation[89].frames*animation[89].width {
								effect[i].imageRectangle.X += animation[89].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
					case "beartrap":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 12), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.4))
						if frames%6 == 0 {
							if effect[i].imageRectangle.X < animation[87].x+animation[87].frames*animation[87].width {
								effect[i].imageRectangle.X += animation[87].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
					case "gascanExplode":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.7))
						if frames%4 == 0 {
							if effect[i].imageRectangle.X < animation[57].x+animation[57].frames*animation[57].width {
								effect[i].imageRectangle.X += animation[57].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
						for j := 0; j < len(levels[levNum].enemies); j++ {
							if rl.CheckCollisionRecs(effect[i].rectangle, levels[levNum].enemies[j].collisionRectangle) {
								if levels[levNum].enemies[j].name == "flamehead" || levels[levNum].enemies[j].name == "ghost" || levels[levNum].enemies[j].name == "yellowdino" || levels[levNum].enemies[j].name == "reddevil" {
									if msgT == 0 {
										admsg("immune to burn", rl.Yellow)
										msgT = fps
									}
								} else {
									if levels[levNum].enemies[j].burnT <= 0 {
										levels[levNum].enemies[j].burnT = fps * 3
									}
								}
							}
						}
					case "frogexit":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.7))
						if frames%4 == 0 {
							if effect[i].imageRectangle.X < animation[82].x+animation[82].frames*animation[82].width {
								effect[i].imageRectangle.X += animation[82].width
							} else {
								effect[i].isOff = true
								clear = true
							}
						}
					case "balloonexplode":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, shrec(effect[i].rectangle, 5), rl.Vector2Zero(), 0, ShadowColor())
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.5))
						if frames%4 == 0 {
							effect[i].imageRectangle.X += animation[57].width
							if effect[i].imageRectangle.X > animation[57].x+animation[57].frames*animation[57].width {
								effect[i].imageRectangle.X = animation[57].x
							}
						}
						if effect[i].timer > 0 {
							effect[i].timer--
						} else {
							effect[i].isOff = true
							clear = true
						}
						if rl.CheckCollisionRecs(player.collisionRectangle, effect[i].rectangle) && player.hpTimer == 0 {
							player.hpTimer = fps
							hitPL(2)
							if player.burnTimer == 0 && player.dampTimer == 0 && icelollyT == 0 && player.resistFireTimer == 0 {
								if ovenglovenum > 0 {
									if Roll6() <= ovenglovenum {
										admsg("oven glove saves burn", rl.Green)
									} else {
										admsg("burning...", rl.Orange)
										player.burnTimer += fps * 3
									}
								} else {
									admsg("burning...", rl.Orange)
									player.burnTimer += fps * 3
								}
							} else if player.burnTimer == 0 && player.dampTimer != 0 && icelollyT == 0 && player.resistFireTimer == 0 {
								admsg("damp saves burn", rl.Green)
							} else if player.burnTimer == 0 && player.dampTimer == 0 && icelollyT != 0 && player.resistFireTimer == 0 {
								admsg("ice lolly saves burn", rl.Green)
							} else if player.burnTimer == 0 && player.dampTimer == 0 && icelollyT == 0 && player.resistFireTimer != 0 {
								admsg("resist fire saves burn", rl.Green)
							}
						}
					case "enm":
						for j := 0; j < len(effect[i].circles); j++ {
							rl.DrawCircleV(effect[i].circles[j].center, effect[i].circles[j].radius, rl.Fade(effect[i].circles[j].color, effect[i].circles[j].fade))
							effect[i].circles[j].fade -= 0.03
							effect[i].circles[j].center.X += effect[i].circles[j].dirX
							effect[i].circles[j].center.Y += effect[i].circles[j].dirY
						}
						if effect[i].timer > 0 {
							effect[i].timer--
						} else {
							effect[i].isOff = true
							clear = true
						}
					case "desCrate":
						for j := 0; j < len(effect[i].rectangles); j++ {
							rl.DrawRectangleRec(effect[i].rectangles[j].rectangle, rl.Fade(effect[i].rectangles[j].color, effect[i].rectangles[j].fade))
							effect[i].rectangles[j].fade -= 0.03
							effect[i].rectangles[j].rectangle.X += effect[i].rectangles[j].dirX
							effect[i].rectangles[j].rectangle.Y += effect[i].rectangles[j].dirY
						}
						if effect[i].timer > 0 {
							effect[i].timer--
						} else {
							effect[i].isOff = true
							clear = true
						}
					case "plblood":
						rl.DrawTexturePro(imgs, effect[i].imageRectangle, effect[i].rectangle, rl.Vector2Zero(), 0, rl.Fade(effect[i].color, effect[i].fade))
						if effect[i].fade > 0 {
							effect[i].fade -= 0.02
						} else {
							effect[i].isOff = true
							clear = true
						}
					}
					if debug {
						rl.DrawRectangleLinesEx(effect[i].rectangle, 2, rl.Yellow)
						rl.DrawRectangleLinesEx(effect[i].collisionRectangle, 2, rl.Magenta)
						txtx := effect[i].rectangle.ToInt32().X + 2
						txty := effect[i].rectangle.ToInt32().Y + 2
						rl.DrawText(fmt.Sprint(effect[i].name), txtx, txty, tx, rl.White)
					}
				}
			}
			if clear {
				Remove(1)
			}
		}
		if debug && !isBossOn {
			//DEBUG ROOM RECS
			for i := 0; i < len(lev); i++ {
				rl.DrawRectangleRec(lev[i], rl.Fade(rl.Green, 0.1))
				rl.DrawRectangleLinesEx(lev[i], 4, rl.Fade(rl.Green, 0.5))
				x := int32(lev[i].X) + 8
				y := int32(lev[i].Y) + 8
				rl.DrawText("num "+fmt.Sprint(inf[i].num), x, y, tx2, rl.Black)
				y += tx2
				rl.DrawText("conec "+fmt.Sprint(dbg[i].conecRoom), x, y, tx2, rl.Black)
				y += tx2
				rl.DrawText("side "+fmt.Sprint(dbg[i].side), x, y, tx2, rl.Black)
				rl.DrawCircleV(inf[i].center, 4, rl.Red)
			}
			//DEBUG DOOR RECS
			for i := 0; i < len(doors); i++ {
				rl.DrawRectangleLinesEx(doors[i], 4, rl.Fade(rl.Red, 0.5))
				x := int32(doors[i].X) + 8
				y := int32(doors[i].Y) + 8
				rl.DrawText(fmt.Sprint(levels[levNum].doorNums[i]), x-2, y+2, tx2, rl.Black)
				rl.DrawText(fmt.Sprint(levels[levNum].doorNums[i]), x, y, tx2, rl.White)
			}
			//MARK: DEBUG INNER REC DRAW REC
			rl.DrawRectangleLinesEx(screenBordRec, 2, rl.Orange)
			rl.DrawRectangleLinesEx(inRec, 2, rl.White)
			rl.DrawRectangleLinesEx(drawRec, 2, rl.Magenta)
		}

		//MARK: DRAW BOSS
		if isBossOn && len(levels[levNum].enemies) > 0 {
			if !levels[levNum].enemies[0].off {
				switch bossNum {
				case 9: //ROLLO
					rec2 := boss.rectangle
					rec2.X += (boss.dirX * 2) * -1
					rec2.Y += (boss.dirY * 2) * -1
					rec2.X += rec2.Width / 16
					rec2.Y += rec2.Height / 16
					rec2.Width -= rec2.Width / 8
					rec2.Height -= rec2.Height / 8
					rl.DrawTexturePro(imgs, boss.image, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.2))
					rec2.X += (boss.dirX * 2) * -1
					rec2.Y += (boss.dirY * 2) * -1
					rec2.X += rec2.Width / 16
					rec2.Y += rec2.Height / 16
					rec2.Width -= rec2.Width / 8
					rec2.Height -= rec2.Height / 8
					rl.DrawTexturePro(imgs, boss.image, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.15))
					rec2.X += (boss.dirX * 2) * -1
					rec2.Y += (boss.dirY * 2) * -1
					rec2.X += rec2.Width / 16
					rec2.Y += rec2.Height / 16
					rec2.Width -= rec2.Width / 8
					rec2.Height -= rec2.Height / 8
					rl.DrawTexturePro(imgs, boss.image, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.1))
					rec2.X += (boss.dirX * 2) * -1
					rec2.Y += (boss.dirY * 2) * -1
					rec2.X += rec2.Width / 16
					rec2.Y += rec2.Height / 16
					rec2.Width -= rec2.Width / 8
					rec2.Height -= rec2.Height / 8
					rl.DrawTexturePro(imgs, boss.image, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.05))
					if boss.hpT == 0 {
						rl.DrawTexturePro(imgs, boss.image, boss.rectangle, rl.Vector2Zero(), 0, rl.White)
					} else {
						rl.DrawTexturePro(imgs, boss.image, boss.rectangle, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
					}
				case 5, 7: //PYRO PIG BATTY
					rl.DrawTexturePro(imgs, boss.image, shrec(boss.rectangle, 17), rl.Vector2Zero(), 0, ShadowColor())
					if boss.hpT == 0 {
						rl.DrawTexturePro(imgs, boss.image, boss.rectangle, rl.Vector2Zero(), 0, rl.White)
					} else {
						rl.DrawTexturePro(imgs, boss.image, boss.rectangle, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
					}
				case 2, 3, 4, 6, 8: //MR FRISBEE SPINNA SPACEMAN ZOMBO MUSHEE
					rl.DrawTexturePro(imgs, boss.image, shrec(boss.rectangle, 7), rl.Vector2Zero(), 0, ShadowColor())
					if boss.hpT == 0 {
						rl.DrawTexturePro(imgs, boss.image, boss.rectangle, rl.Vector2Zero(), 0, rl.White)
					} else {
						rl.DrawTexturePro(imgs, boss.image, boss.rectangle, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
					}
				case 1: //ICEMAN
					switch boss.state {
					case 3: //WALK L
						rl.DrawTexturePro(bossWALKL, boss.image, shrec(boss.rectangle, 7), rl.Vector2Zero(), 0, ShadowColor())
						if boss.hpT == 0 {
							rl.DrawTexturePro(bossWALKL, boss.image, boss.rectangle, rl.Vector2Zero(), 0, rl.White)
						} else {
							rl.DrawTexturePro(bossWALKL, boss.image, boss.rectangle, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
						}
					case 2: //WALK R
						rl.DrawTexturePro(bossWALKR, boss.image, shrec(boss.rectangle, 7), rl.Vector2Zero(), 0, ShadowColor())
						if boss.hpT == 0 {
							rl.DrawTexturePro(bossWALKR, boss.image, boss.rectangle, rl.Vector2Zero(), 0, rl.White)
						} else {
							rl.DrawTexturePro(bossWALKR, boss.image, boss.rectangle, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
						}
					case 1: //ATK
						rl.DrawTexturePro(bossATK, boss.image, shrec(boss.rectangle, 7), rl.Vector2Zero(), 0, ShadowColor())
						if boss.hpT == 0 {
							rl.DrawTexturePro(bossATK, boss.image, boss.rectangle, rl.Vector2Zero(), 0, rl.White)
						} else {
							rl.DrawTexturePro(bossATK, boss.image, boss.rectangle, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
						}
					case 0: //IDLE
						rl.DrawTexturePro(bossIDL, boss.image, shrec(boss.rectangle, 7), rl.Vector2Zero(), 0, ShadowColor())
						if boss.hpT == 0 {
							rl.DrawTexturePro(bossIDL, boss.image, boss.rectangle, rl.Vector2Zero(), 0, rl.White)
						} else {
							rl.DrawTexturePro(bossIDL, boss.image, boss.rectangle, rl.Vector2Zero(), 0, rl.Fade(RandColor(), RandF32(0.5, 0.7)))
						}
					}
				}
				if debug {
					rl.DrawRectangleLinesEx(boss.rectangle, 2, rl.Yellow)
					rl.DrawRectangleLinesEx(boss.collisionRectangle, 2, rl.Magenta)
					rl.DrawRectangleLinesEx(boss.carec, 2, rl.Red)
					rl.DrawCircleV(boss.cnt, 4, rl.Red)
				}
			}
		}

		//MARK:DRAW PLAYER
		if !player.gameover {
			//SPINNA
			if spinnaT2 > 0 {
				spinnaT2--
				siz := b5
				rec := rl.NewRectangle(player.center.X-siz/2, player.center.Y-siz/2, siz, siz)
				rl.DrawTexturePro(imgs, player.bossEffectRectangle, shrec(rec, 12), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, player.bossEffectRectangle, rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.2, 0.4)))
				rl.DrawTexturePro(imgs, player.bossEffectRectangle, brec(rec, 12), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.05, 0.1)))
				rl.DrawTexturePro(imgs, player.bossEffectRectangle, brec(rec, 24), rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.05, 0.1)))
				if frames%3 == 0 {
					player.bossEffectRectangle.X += animation[123].width
					if player.bossEffectRectangle.X > animation[123].x+animation[123].frames*animation[123].width {
						player.bossEffectRectangle.X = animation[123].x
					}
				}
				if spinnaT2 == 1 {
					spinnaT = fps * 7
				}

				rec2 := rec
				rec2.Y += rec2.Height / 4
				rec2.Height = rec2.Height / 2
				if debug {
					rl.DrawRectangleLinesEx(rec2, 2, rl.Yellow)
				}

				for j := 0; j < len(levels[levNum].enemies); j++ {
					if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, rec2) {
						if !levels[levNum].enemies[j].nodmg {
							if levels[levNum].enemies[j].hpT == 0 {
								levels[levNum].enemies[j].hp -= 2
								if levels[levNum].enemies[j].hp <= 0 && !levels[levNum].enemies[j].off {
									player.xp += levels[levNum].enemies[j].xp
									makeEnDeathFx(j)
									levels[levNum].enemies[j].off = true
								} else {
									levels[levNum].enemies[j].hpT = fps
									levels[levNum].enemies[j].hpY = bq3
									levels[levNum].enemies[j].hpY2 = 0
									if isBossOn {
										levels[levNum].enemies[j].hpY = b
										levels[levNum].enemies[j].hpY2 = b / 2
									}
									if levels[levNum].enemies[j].name == "crocodile" || levels[levNum].enemies[j].name == "redantenna" {
										levels[levNum].enemies[j].stunT = fps * 2
										levels[levNum].enemies[j].stunF = 0.9
										levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
										levels[levNum].enemies[j].stunSiz = b / 4
									}
								}
							}

						}
					}
				}
			}

			//NINJA STAR
			if ninjanum > 0 {
				radians := player.angle3 * math.Pi / 180.0
				newX := player.center.X + b3*float32(math.Cos(float64(radians)))
				newY := player.center.Y + b3*float32(math.Sin(float64(radians)))
				player.angle3 += 4
				player.v3 = rl.NewVector2(newX, newY)
				siz := b / 2
				rec2 := rl.NewRectangle(player.v3.X-siz/2, player.v3.Y-siz/2, siz, siz)
				rl.DrawTexturePro(imgs, otherTiles[115], shrec(rec2, 12), orgn(rec2), player.rotation, ShadowColor())
				rl.DrawTexturePro(imgs, otherTiles[115], drec(rec2), orgn(rec2), player.rotation, rl.White)
				player.rotation += 20
				rec3 := rl.Rectangle{}
				if ninjanum == 2 {
					radians := player.angle4 * math.Pi / 180.0
					newX := player.center.X + b3*float32(math.Cos(float64(radians)))
					newY := player.center.Y + b3*float32(math.Sin(float64(radians)))
					player.angle4 -= 4
					player.v4 = rl.NewVector2(newX, newY)
					siz := b / 2
					rec3 = rl.NewRectangle(player.v4.X-siz/2, player.v4.Y-siz/2, siz, siz)
					rl.DrawTexturePro(imgs, otherTiles[115], shrec(rec3, 12), orgn(rec2), player.rotation, ShadowColor())
					rl.DrawTexturePro(imgs, otherTiles[115], drec(rec3), orgn(rec2), player.rotation, rl.White)
				}
				for j := 0; j < len(levels[levNum].enemies); j++ {
					if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, rec2) && !levels[levNum].enemies[j].nodmg && levels[levNum].enemies[j].hpT == 0 {
						if levels[levNum].enemies[j].hpT == 0 {
							levels[levNum].enemies[j].hp -= 1
							if levels[levNum].enemies[j].hp <= 0 && !levels[levNum].enemies[j].off {
								player.xp += levels[levNum].enemies[j].xp
								makeEnDeathFx(j)
								levels[levNum].enemies[j].off = true
							} else {
								levels[levNum].enemies[j].hpT = fps
								levels[levNum].enemies[j].hpY = bq3
								levels[levNum].enemies[j].hpY2 = 0
								if isBossOn {
									levels[levNum].enemies[j].hpY = b
									levels[levNum].enemies[j].hpY2 = b / 2
								}
							}
							if levels[levNum].enemies[j].name == "crocodile" || levels[levNum].enemies[j].name == "redantenna" {
								levels[levNum].enemies[j].stunT = fps * 2
								levels[levNum].enemies[j].stunF = 0.9
								levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
								levels[levNum].enemies[j].stunSiz = b / 4
							}
						}
					}
					if ninjanum == 2 {
						if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, rec3) && !levels[levNum].enemies[j].nodmg && levels[levNum].enemies[j].hpT == 0 {
							levels[levNum].enemies[j].hp -= 1
							if levels[levNum].enemies[j].hp <= 0 && !levels[levNum].enemies[j].off {
								player.xp += levels[levNum].enemies[j].xp
								makeEnDeathFx(j)
								levels[levNum].enemies[j].off = true
							} else {
								levels[levNum].enemies[j].hpT = fps
								levels[levNum].enemies[j].hpY = bq3
								levels[levNum].enemies[j].hpY2 = 0
								if isBossOn {
									levels[levNum].enemies[j].hpY = b
									levels[levNum].enemies[j].hpY2 = b / 2
								}
							}
							if levels[levNum].enemies[j].name == "crocodile" || levels[levNum].enemies[j].name == "redantenna" {
								levels[levNum].enemies[j].stunT = fps * 2
								levels[levNum].enemies[j].stunF = 0.9
								levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
								levels[levNum].enemies[j].stunSiz = b / 4
							}
						}
					}
				}
			}
			//TEA
			if teanum > 0 {
				radians := player.angle * math.Pi / 180.0
				newX := player.center.X + b2*float32(math.Cos(float64(radians)))
				newY := player.center.Y + b2*float32(math.Sin(float64(radians)))
				player.angle += 5
				player.v1 = rl.NewVector2(newX, newY)
				siz := b / 2
				rec2 := rl.NewRectangle(player.v1.X-siz/2, player.v1.Y-siz/2, siz, siz)
				rl.DrawTexturePro(imgs, otherTiles[129], shrec(rec2, 12), orgn(rec2), player.rotation, ShadowColor())
				rl.DrawTexturePro(imgs, otherTiles[129], drec(rec2), orgn(rec2), player.rotation, rl.White)
				player.rotation += 10
				rec3 := rl.Rectangle{}
				if teanum == 2 {
					radians := player.angle2 * math.Pi / 180.0
					newX := player.center.X + b4*float32(math.Cos(float64(radians)))
					newY := player.center.Y + b4*float32(math.Sin(float64(radians)))
					player.angle2 -= 5
					player.v2 = rl.NewVector2(newX, newY)
					siz := b / 2
					rec3 = rl.NewRectangle(player.v2.X-siz/2, player.v2.Y-siz/2, siz, siz)
					rl.DrawTexturePro(imgs, otherTiles[129], shrec(rec3, 12), orgn(rec3), player.rotation, ShadowColor())
					rl.DrawTexturePro(imgs, otherTiles[129], drec(rec3), orgn(rec3), player.rotation, rl.White)
				}
				for j := 0; j < len(levels[levNum].enemies); j++ {
					if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, rec2) {
						if !levels[levNum].enemies[j].nodmg {
							if levels[levNum].enemies[j].stunT == 0 {
								levels[levNum].enemies[j].stunT = fps * 2
								levels[levNum].enemies[j].stunF = 0.9
								levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
								levels[levNum].enemies[j].stunSiz = b / 4
							}
						}
					}
					if teanum == 2 {
						if rl.CheckCollisionRecs(levels[levNum].enemies[j].collisionRectangle, rec3) {
							if !levels[levNum].enemies[j].nodmg {
								if levels[levNum].enemies[j].stunT == 0 {
									levels[levNum].enemies[j].stunT = fps * 2
									levels[levNum].enemies[j].stunF = 0.9
									levels[levNum].enemies[j].stunY = levels[levNum].enemies[j].cnt.Y
									levels[levNum].enemies[j].stunSiz = b / 4
								}
							}
						}
					}
				}
			}
			if reviveT > 0 {
				rec2 := player.rectangle
				rec2.X -= b2
				rec2.Y -= b2
				rec2.Width += b4
				rec2.Height += b4
				rl.DrawTexturePro(imgs, animation[85].rectangle, rec2, rl.Vector2Zero(), 0, rl.Fade(RandColor(), 0.7))
				if frames%6 == 0 {
					animation[85].rectangle.X += animation[85].width
					if animation[85].rectangle.X > animation[85].x+animation[85].frames*animation[85].width {
						animation[85].rectangle.X = animation[85].x
					}
				}
			} else if teleportT > 0 {
				rec2 := player.rectangle
				rec2.X -= b
				rec2.Y -= b
				rec2.Width += b2
				rec2.Height += b2
				rl.DrawTexturePro(imgs, animation[83].rectangle, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.7))
				if frames%6 == 0 {
					animation[83].rectangle.X += animation[83].width
					if animation[83].rectangle.X > animation[83].x+animation[83].frames*animation[83].width {
						animation[83].rectangle.X = animation[83].x
					}
				}
			} else {
				//VINE
				if vineon {
					siz := b / 2
					x := player.center.X - (siz/8)*5
					y := player.collisionRectangle.Y - siz
					for y > 0 {
						rec := rl.NewRectangle(x, y, siz, siz)
						rl.DrawTexturePro(imgs, otherTiles[128], rec, rl.Vector2Zero(), 0, rl.White)
						y -= siz
					}
				}
				rec2 := player.rectangle //INCREASE SIZE OF PLAYER DRAW IMAGE
				rec2.X -= b / 8
				rec2.Y -= b / 5
				rec2.Width += b / 4
				rec2.Height += b / 4
				//INFLICT
				if inflictT > 0 {
					rec3 := rec2
					rec3.X -= b
					rec3.Y -= b + be5
					rec3.Width += b2
					rec3.Height += b2
					rl.DrawTexturePro(imgs, animation[84].rectangle, shrec(rec3, 5), rl.Vector2Zero(), 0, ShadowColor())
					rl.DrawTexturePro(imgs, animation[84].rectangle, rec3, rl.Vector2Zero(), 0, rl.Fade(RandRed(), 0.7))
					if frames%6 == 0 {
						animation[84].rectangle.X += animation[84].width
						if animation[84].rectangle.X > animation[84].x+animation[84].frames*animation[84].width {
							animation[84].rectangle.X = animation[84].x
						}
					}
				}
				//TURTLE
				if turtleT > 0 {
					rec3 := rec2
					rec3.X -= b / 2
					rec3.Y -= b / 2
					rec3.Width += b
					rec3.Height += b
					rl.DrawTexturePro(imgs, animation[75].rectangle, shrec(rec3, 5), rl.Vector2Zero(), 0, ShadowColor())
					rl.DrawTexturePro(imgs, animation[75].rectangle, rec3, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.4))
					if frames%6 == 0 {
						animation[75].rectangle.X += animation[75].width
						if animation[75].rectangle.X > animation[75].x+animation[75].frames*animation[75].width {
							animation[75].rectangle.X = animation[75].x
						}
					}
				}
				//ARMOR SHIELD
				if player.armorTimer > 0 {
					rec3 := rec2
					rec3.X -= b / 2
					rec3.Y -= b / 2
					rec3.Width += b
					rec3.Height += b
					rl.DrawTexturePro(imgs, animation[77].rectangle, shrec(rec3, 5), rl.Vector2Zero(), 0, ShadowColor())
					rl.DrawTexturePro(imgs, animation[77].rectangle, rec3, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.4))
					if frames%6 == 0 {
						animation[77].rectangle.X += animation[77].width
						if animation[77].rectangle.X > animation[77].x+animation[77].frames*animation[77].width {
							animation[77].rectangle.X = animation[77].x
						}
					}
				}
				//SHADOW
				rl.DrawTexturePro(imgs, player.anim[player.animationNum].rectangle, shrec(rec2, 3), rl.Vector2Zero(), 0, ShadowColor())
				//BURN SMOKE
				if player.burnTimer > 0 {
					rec3 := rec2
					rec3.Width = rec3.Width / 2
					rec3.Height = rec3.Height / 2
					rec3.Y = rec2.Y - rec3.Height
					rec3.Y += 7
					rec3.X = player.center.X - rec3.Width/2
					if player.direction {
						rec3.X += 1
					} else {
						rec3.X -= 1
					}
					rl.DrawTexturePro(imgs, animation[3].rectangle, rec3, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.2))
					if frames%5 == 0 {
						animation[3].rectangle.X += animation[3].width
						if animation[3].rectangle.X > animation[3].x+animation[3].frames*animation[3].width {
							animation[3].rectangle.X = animation[3].x
						}
					}
				}
				//POISON BUBBLES
				if player.poisonTimer > 0 {
					rec3 := rec2
					rec3.Width = rec3.Width / 2
					rec3.Height = rec3.Height / 2
					rec3.Y = rec2.Y - rec3.Height
					rec3.Y += 2
					rec3.X = player.center.X - rec3.Width/2
					if player.direction {
						rec3.X += 1
					} else {
						rec3.X -= 1
					}
					rl.DrawTexturePro(imgs, animation[174].rectangle, rec3, rl.Vector2Zero(), 0, rl.Fade(RandGreen(), 0.5))
					if frames%3 == 0 {
						animation[174].rectangle.X += animation[174].width
						if animation[174].rectangle.X > animation[174].x+animation[174].frames*animation[173].width {
							animation[174].rectangle.X = animation[174].x
						}
					}
				}
				//IMG
				//MIRROR
				if mirror {
					planimnum2 := player.animationNum
					switch planimnum2 {
					case 0:
						planimnum2 = 1
					case 2:
						planimnum2 = 3
					case 7:
						planimnum2 = 8
					case 1:
						planimnum2 = 0
					case 3:
						planimnum2 = 2
					case 8:
						planimnum2 = 7
					case 5:
						planimnum2 = 6
					case 6:
						planimnum2 = 5
					}
					rec4 := rec2
					if player.direction {
						rec4.X += rec4.Width / 2
					} else {
						rec4.X -= rec4.Width / 2
					}
					rl.DrawTexturePro(imgs, player.anim[planimnum2].rectangle, rec4, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.2))
				}
				if player.burnTimer > 0 {
					rl.DrawTexturePro(imgs, player.anim[player.animationNum].rectangle, rec2, rl.Vector2Zero(), 0, RandOrange())
				} else if player.poisonTimer > 0 {
					rl.DrawTexturePro(imgs, player.anim[player.animationNum].rectangle, rec2, rl.Vector2Zero(), 0, rl.Lime)
				} else if player.hpTimer > 0 {
					rl.DrawTexturePro(imgs, player.anim[player.animationNum].rectangle, rec2, rl.Vector2Zero(), 0, RandColor())
				} else if player.dampTimer > 0 {
					rl.DrawTexturePro(imgs, player.anim[player.animationNum].rectangle, rec2, rl.Vector2Zero(), 0, RandCyan())
				} else if player.invisibleTimer > 0 {
					rl.DrawTexturePro(imgs, player.anim[player.animationNum].rectangle, rec2, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.2, 0.4)))
				} else {
					rl.DrawTexturePro(imgs, player.anim[player.animationNum].rectangle, rec2, rl.Vector2Zero(), 0, rl.White)
				}
				//ICE CUBE
				if player.freezeTimer > 0 {
					rec3 := rec2
					rec3.X -= b / 2
					rec3.Y -= b / 2
					rec3.Width += b
					rec3.Height += b
					rl.DrawTexturePro(imgs, otherTiles[149], rec3, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.1, 0.2)))
					blurrec := rec3
					blurrec.X += RandF32(-4, 4)
					blurrec.Y += RandF32(-4, 4)
					rl.DrawTexturePro(imgs, otherTiles[149], blurrec, rl.Vector2Zero(), 0, rl.Fade(rl.White, RandF32(0.05, 0.1)))
				}
				//DEBUG
				if debug {
					rl.DrawRectangleLinesEx(player.rectangle, 1, rl.Yellow)
					rl.DrawRectangleLinesEx(player.collisionRectangle, 1, rl.Magenta)
					rl.DrawRectangleLinesEx(player.caRectangle, 1, rl.Green)
					rl.DrawRectangleLinesEx(player.perceptionRectangle, 1, rl.Blue)
					rl.DrawCircleV(player.center, 2, RandColor())
				}
				if frames%7 == 0 { //IDLE ANIM
					player.anim[0].rectangle.X += player.anim[0].width
					if player.anim[0].rectangle.X > player.anim[0].x+player.anim[0].frames*player.anim[0].width {
						player.anim[0].rectangle.X = player.anim[0].x
					}
					player.anim[1].rectangle.X -= player.anim[1].width
					if player.anim[1].rectangle.X < player.anim[1].x-player.anim[1].frames*player.anim[1].width {
						player.anim[1].rectangle.X = player.anim[1].x
					}
				}
				if frames%3 == 0 { //RUN PUSH ANIM
					player.anim[4].rectangle.X += player.anim[4].width
					if player.anim[4].rectangle.X > player.anim[4].x+player.anim[4].frames*player.anim[4].width {
						player.anim[4].rectangle.X = player.anim[4].x
					}
					player.anim[2].rectangle.X += player.anim[2].width
					if player.anim[2].rectangle.X > player.anim[2].x+player.anim[2].frames*player.anim[2].width {
						player.anim[2].rectangle.X = player.anim[2].x
					}
					player.anim[3].rectangle.X -= player.anim[3].width
					if player.anim[3].rectangle.X < player.anim[3].x-player.anim[3].frames*player.anim[3].width {
						player.anim[3].rectangle.X = player.anim[3].x
					}
					player.anim[7].rectangle.X += player.anim[7].width
					if player.anim[7].rectangle.X > player.anim[7].x+player.anim[7].frames*player.anim[7].width {
						player.anim[7].rectangle.X = player.anim[7].x
					}
					player.anim[8].rectangle.X -= player.anim[8].width
					if player.anim[8].rectangle.X < player.anim[8].x-player.anim[8].frames*player.anim[8].width {
						player.anim[8].rectangle.X = player.anim[8].x
					}
					if frames%3 == 0 { //ATK ANIM
						player.anim[5].rectangle.X += player.anim[5].width
						if player.anim[5].rectangle.X > player.anim[5].x+player.anim[5].frames*player.anim[5].width {
							player.anim[5].rectangle.X = player.anim[5].x
						}
						player.anim[6].rectangle.X -= player.anim[6].width
						if player.anim[6].rectangle.X < player.anim[6].x-player.anim[6].frames*player.anim[6].width {
							player.anim[6].rectangle.X = player.anim[6].x
						}
					}
				}
			}
		}
		//MARK:DRAW BAT COMPANION
		if batty {
			rl.DrawTexturePro(imgs, batcomp.image, shrec(batcomp.rectangle, 12), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, batcomp.image, batcomp.rectangle, rl.Vector2Zero(), 0, rl.White)
			if frames%2 == 0 {
				if batcomp.lr {
					batcomp.image.X -= animation[142].width
					if batcomp.image.X < animation[142].x-animation[142].frames*animation[142].width {
						batcomp.image.X = animation[142].x
					}
				} else {
					batcomp.image.X += animation[141].width
					if batcomp.image.X > animation[141].x+animation[141].frames*animation[141].width {
						batcomp.image.X = animation[141].x
					}
				}
			}
		}

		//MARK: CHEST LAYER ABOVE SLOTS ANIM MOUSE INP
		if len(chests) > 0 {
			for i := 0; i < len(chests); i++ {
				if chests[i].isOpen {
					if !chests[i].audioPlayed {
						rl.PlaySound(audfx[3])
						chests[i].audioPlayed = true
					}
					//OPEN ANIM
					if chests[i].image.X < animation[4].x+animation[4].width*animation[4].frames {
						if frames%6 == 0 {
							chests[i].image.X += animation[4].width
						}
					} else {
						x := chests[i].center.X
						y := chests[i].collisionRectangle.Y + chests[i].collisionRectangle.Height
						y += 4
						siz := be5
						if xxl {
							siz = bq3
						}
						wid := float32(chests[i].slots) * (siz + 2)
						x -= wid / 2
						//CHECK IN SLOTS REC
						checkslotsrec := rl.NewRectangle(x, y, wid, siz)
						if rl.CheckCollisionPointRec(cursorV2cam, checkslotsrec) {
							inchestslot = true
						} else {
							inchestslot = false
						}
						for j := 0; j < chests[i].slots; j++ {
							rec := rl.NewRectangle(x, y, siz, siz)
							//MOUSE INP
							if rl.CheckCollisionPointRec(cursorV2cam, rec) {
								rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.7))
								if chests[i].item[j].name != "" {
									toptx = chests[i].item[j].name
									toptxT = fps
									if inpL && !chests[i].item[j].isOff && clickT == 0 {
										clickT = fps / 8
										collectfromchest(i, j)
									}
								}
							} else {
								rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
							}
							//IMG SLOT
							rl.DrawRectangleLinesEx(rec, 1, rl.White)
							if chests[i].item[j].name != "" {
								rl.DrawTexturePro(imgs, chests[i].item[j].image, rec, rl.Vector2Zero(), 0, rl.White)
							}
							x += siz + 2
						}
					}
				} else {
					inchestslot = false
					if chests[i].audioPlayed {
						rl.PlaySound(audfx[5])
						chests[i].audioPlayed = false
					}
					//CLOSE ANIM
					if chests[i].image.X > animation[4].x {
						if frames%6 == 0 {
							chests[i].image.X -= animation[4].width
						}
					}
				}
			}
		}
	}

}

func drawquickslots() { //MARK:DRAW QUICK SLOTS
	siz := b + bq3
	if medium {
		siz = b
	}
	spc := float32(4)
	if xxl {
		siz = b4
		spc = 8
	}
	x := siz / 4
	y := screenHeightF32 - (siz + siz/4)
	//CHECK IN QUICK SLOTS REC
	W := x + float32(len(player.quik))*(siz+spc)
	H := siz
	checkInQuick := rl.NewRectangle(x, y, W, H)
	if rl.CheckCollisionPointRec(cursorV2, checkInQuick) {
		inquick = true
	} else {
		inquick = false
	}
	//DRAW QUICK
	xorig := x
	txs := tx2
	if medium {
		txs = tx
	}
	if xxl {
		txs = tx4
	}
	for i := 0; i < len(player.quik); i++ {
		//BG REC
		rec := rl.NewRectangle(x, y, siz, siz)
		if rl.CheckCollisionPointRec(cursorV2, rec) {
			rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.3))
			if player.quik[i].name != "" {
				//TXT
				if charscr {
					xtx := int32(xorig)
					ytx := int32(rec.Y) - (txs + 8)
					if mouseoff {
						rl.DrawText("a move to inventory / x use", xtx, ytx, txs, rl.White)
					} else {
						rl.DrawText("left click move to inventory / right click use", xtx, ytx, txs, rl.White)
					}
					ytx -= txs + tx/4
					rl.DrawText(player.quik[i].name, xtx, ytx, txs, rl.White)
				} else {
					toptx = player.quik[i].name
					if player.quik[i].cooldownTimer > 0 && player.quik[i].cooldownTimer > fps/2 {
						toptx = toptx + " > cooldown " + fmt.Sprint(player.quik[i].cooldownTimer/fps)
					}
					toptxT = fps
				}
				if inpL {
					if inchest && !charscr { //MOVE ITEM TO CHEST
						canmove, num := checkChestSlots()
						if canmove {
							levels[levNum].chests[0].item[num] = player.quik[i]
							player.quik[i] = Item{}
							rl.PlaySound(audfx[7])
						} else {
							admsg("no free chest slots", rl.Red)
						}
					} else if !charscr {
						if player.quik[i].cooldownTimer > 0 {
							rl.PlaySound(audfx[43])
							admsg("currently active", rl.Yellow)
						} else {
							useitm(i, 1)
						}
					}
				}
				if inpR && !inchest && !charscr { //DROP ITEM
					dropitm(i, 1)
				} else if inpR && charscr && !isBaseOn { //USE ITEM
					useitm(i, 1)
				}
				if inpL && charscr { //MOVE TO INVN
					if nxInvnNum != blankint {
						movequik2invn(i)
						rl.PlaySound(audfx[18])
					} else {
						admsg("inventory full > drop, stack or use", rl.Red)
					}
				}
			}
		} else {
			rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
		}
		//BORDER REC
		rl.DrawRectangleLinesEx(rec, 2, rl.Fade(rl.White, 0.7))
		//DRAW ITEM
		if player.quik[i].name != "" {
			rl.DrawTexturePro(imgs, player.quik[i].image, rec, rl.Vector2Zero(), 0, rl.White)
			if player.quik[i].cooldownTimer > 0 {
				rl.DrawRectangleRec(rec, rl.Fade(RandRed(), 0.3))
			}
			if player.quik[i].numof > 1 {
				txlen := rl.MeasureText(fmt.Sprint(player.quik[i].numof), txs)
				xtx := int32(rec.X+rec.Width) - txlen
				ytx := int32(rec.Y+rec.Height) - txs
				rl.DrawText(fmt.Sprint(player.quik[i].numof), xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(fmt.Sprint(player.quik[i].numof), xtx-1, ytx+1, txs, rl.Black)
				rl.DrawText(fmt.Sprint(player.quik[i].numof), xtx, ytx, txs, rl.Yellow)
			}
		}
		x += siz + spc
	}
}
func drawweapslots() { //MARK:DRAW WEAPON SLOTS XP
	siz := b + bq3
	if medium {
		siz = b
	}
	spc := float32(4)
	if xxl {
		siz = b4
		spc = 8
	}

	x := screenWidthF32 - ((siz + spc) * 2)
	x -= siz / 4
	y := screenHeightF32 - (siz + siz/4)

	//CHECK IN INVEN REC
	W := x + (siz+spc)*2
	H := siz
	checkinquickRec := rl.NewRectangle(x, y, W, H)
	if rl.CheckCollisionPointRec(cursorV2, checkinquickRec) {
		inweapslots = true
	} else {
		inweapslots = false
	}
	//SWAP WEAPONS
	txs := tx2
	if xxl {
		txs = tx4
	}
	if medium {
		txs = tx
	}
	if charscr {
		rec2 := rl.NewRectangle(x, y, siz, siz)
		rec2.X -= siz + spc
		rl.DrawTexturePro(imgs, otherTiles[198], rec2, rl.Vector2Zero(), 0, rl.White)
		if rl.CheckCollisionPointRec(cursorV2, rec2) || rl.CheckCollisionPointRec(gameCursor, rec2) {
			txt := "swap weapons"
			xtx := rec2.ToInt32().X
			ytx := int32(rec2.Y) - (txs + 8)
			rl.DrawText(txt, xtx, ytx, txs, rl.White)
			if inpL && clickT == 0 {
				clickT = fps / 4
				weapHold := player.weapon
				player.weapon = player.weapon2
				player.weapon2 = weapHold
			}
		}
	}
	//DRAW WEAP SLOTS
	for i := 0; i < 2; i++ {
		//BG REC
		rec := rl.NewRectangle(x, y, siz, siz)

		if rl.CheckCollisionPointRec(cursorV2, rec) {
			rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.3))
			if i == 0 {
				if player.weapon.name != "" {
					toptx = player.weapon.name
					toptxT = fps
					if charscr {
						txt := player.weapon.name + " > level " + fmt.Sprint(player.weapon.level)
						txtlen := rl.MeasureText(txt, txs)
						xtx := screenWidth32 - (txtlen + txs)
						ytx := int32(rec.Y) - (txs + 8)
						rl.DrawText(txt, xtx, ytx, txs, rl.White)
						if inpL {
							if len(player.weapons) > 0 {
								if player.weapon2.name == "" {
									disTxt1 = "you must have one"
									disTxt2 = "weapon equipped"
									invDisTxtT = fps * 2
								} else {
									found := false
									for j := 0; j < len(player.weapons); j++ {
										if player.weapons[j].name == "" {
											player.weapons[j] = player.weapon
											player.weapon = Weapon{}
											found = true
											break
										}
									}
									if !found {
										lastWeap := player.weapons[len(player.weapons)-1]
										var newWeaps []Weapon
										newWeaps = append(newWeaps, Weapon{})
										for j := 0; j < len(player.weapons)-1; j++ {
											newWeaps = append(newWeaps, player.weapons[j])
										}
										newWeaps[0] = player.weapon
										player.weapons = newWeaps
										player.weapon = lastWeap
									}
								}
							} else {
								if msgT == 0 {
									admsg("no weapon storage", rl.Red)
									msgT = fps
								}
							}
						}
					}
				}
			} else {
				if player.weapon2.name != "" {
					toptx = player.weapon2.name
					toptxT = fps
					if charscr {
						txt := player.weapon2.name + " > level " + fmt.Sprint(player.weapon2.level)
						txtlen := rl.MeasureText(txt, txs)
						xtx := screenWidth32 - (txtlen + txs)
						ytx := int32(rec.Y) - txs
						rl.DrawText(txt, xtx, ytx, txs, rl.White)
						if inpL {
							if len(player.weapons) > 0 {
								if player.weapon.name == "" {
									disTxt1 = "you must have one"
									disTxt2 = "weapon equipped"
									invDisTxtT = fps * 2
								} else {
									found := false
									for j := 0; j < len(player.weapons); j++ {
										if player.weapons[j].name == "" {
											player.weapons[j] = player.weapon2
											player.weapon2 = Weapon{}
											found = true
											break
										}
									}
									if !found {
										lastWeap := player.weapons[len(player.weapons)-1]
										var newWeaps []Weapon
										newWeaps = append(newWeaps, Weapon{})
										for j := 0; j < len(player.weapons)-1; j++ {
											newWeaps = append(newWeaps, player.weapons[j])
										}
										newWeaps[0] = player.weapon2
										player.weapons = newWeaps
										player.weapon2 = lastWeap
									}
								}
							} else {
								if msgT == 0 {
									admsg("no weapon storage", rl.Red)
									msgT = fps
								}
							}
						}
					}
				}
			}
		} else {
			rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
		}
		//BORDER REC
		rl.DrawRectangleLinesEx(rec, 2, rl.Fade(rl.White, 0.7))
		//DRAW ITEM
		if i == 0 {
			if player.weapon.name != "" {
				//WEAP IMG
				rl.DrawTexturePro(imgs, player.weapon.image, rec, rl.Vector2Zero(), 0, rl.White)
				//BONUS STARS
				if player.weapon.special != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
				if player.weapon.special2 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					if player.weapon.special != 0 {
						rec3.X -= (siz / 12) * 9
					}
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
			}
		} else {
			if player.weapon2.name != "" {
				rl.DrawTexturePro(imgs, player.weapon2.image, rec, rl.Vector2Zero(), 0, rl.White)
				//BONUS STARS
				if player.weapon2.special != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
				if player.weapon2.special2 != 0 {
					siz := be7
					rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
					if player.weapon2.special != 0 {
						rec3.X -= (siz / 12) * 9
					}
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
					rec3.X += 4
					rec3.Y += 4
					rec3.Width -= 8
					rec3.Height -= 8
					rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
				}
			}
		}
		x += siz + spc
	}
}
func drawartifacts() { //MARK:DRAW ARTIFACTS

	siz := b
	if xl {
		siz = b + b/2
	}
	if medium {
		siz = b
	}
	if xxl {
		siz = b3
	}
	x, y := siz/4, siz/4
	xorig := x
	spc := float32(7)
	if medium {
		spc = 4
	}
	txs := tx2
	if xxl {
		txs = tx4
	}
	if medium {
		txs = tx
	}

	y2 := y
	count := 0
	for i := 0; i < len(player.art); i++ {
		y2 += siz + spc
		count++
		if y2 >= screenHeightF32-siz*4 {
			break
		}
	}
	countdiff := 0
	checkcount := false
	if count < len(player.art) {
		checkcount = true
		countdiff = len(player.art) - count
	}

	for i := 0; i < len(player.art); i++ {
		if player.art[i].name == "ring of vine" {
			vineRingArtNum = i
		}
		rec := rl.NewRectangle(x, y, siz, siz)
		rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
		if player.art[i].isOff {
			rl.DrawTexturePro(imgs, player.art[i].image, rec, rl.Vector2Zero(), 0, rl.DarkGray)
		} else {
			rl.DrawTexturePro(imgs, player.art[i].image, rec, rl.Vector2Zero(), 0, rl.White)
		}
		if rl.CheckCollisionPointRec(cursorV2, rec) {
			xtx := int32(rec.X+rec.Width) + txs
			if x == xorig && checkcount && i < countdiff {
				xtx += int32(siz + spc)

			}
			ytx := int32(rec.Y+rec.Height/2) - txs/2
			txt := fmt.Sprint(player.art[i].name) + " > " + fmt.Sprint(player.art[i].des)
			if player.art[i].isOff {
				txt = txt + " > depleted"
			}
			rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
			rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
		}
		if player.art[i].numof > 1 {
			txs2 := tx3
			if medium || large {
				txs2 = tx2
			}
			xtx := int32(rec.X+rec.Width) - txs2/3
			ytx := int32(rec.Y+rec.Height) - txs2
			rl.DrawText(fmt.Sprint(player.art[i].numof), xtx-3, ytx+3, txs2, rl.Black)
			rl.DrawText(fmt.Sprint(player.art[i].numof), xtx-1, ytx+1, txs2, rl.White)
			rl.DrawText(fmt.Sprint(player.art[i].numof), xtx, ytx, txs2, rl.Yellow)
		}
		y += siz + spc

		if y >= screenHeightF32-siz*4 {
			y = siz / 4
			x += siz + spc
		}
	}
}
func drawinvhints() { //MARK:DRAW INVEN HINTS
	xtx := tx
	ytx := tx
	spc := tx / 2
	txs := tx2
	if xxl {
		txs = tx4
	}
	if mouseoff {
		rl.DrawText("X inventory item menu", xtx, ytx, txs, rl.White)
		ytx += txs + spc
		rl.DrawText("A move quick slot items", xtx, ytx, txs, rl.White)
	} else {
		rl.DrawText("right click inventory item menu", xtx, ytx, txs, rl.White)
		ytx += txs + spc
		rl.DrawText("left click move quick slot items", xtx, ytx, txs, rl.White)
	}
}

func drawnocam() { //MARK:DRAW NO CAM

	//GAMEPAD DEBUG
	if debug {
		rl.DrawText("0,0 "+fmt.Sprint(rl.GetGamepadAxisMovement(0, 0)), 400, 10, 20, rl.White)
		rl.DrawText("0,1 "+fmt.Sprint(rl.GetGamepadAxisMovement(0, 1)), 400, 30, 20, rl.White)
		rl.DrawText("0,2 "+fmt.Sprint(rl.GetGamepadAxisMovement(0, 2)), 400, 50, 20, rl.White)
		rl.DrawText("0,3 "+fmt.Sprint(rl.GetGamepadAxisMovement(0, 3)), 400, 70, 20, rl.White)
		rl.DrawText("0,4 "+fmt.Sprint(rl.GetGamepadAxisMovement(0, 4)), 400, 90, 20, rl.White)
		rl.DrawText("0,5 "+fmt.Sprint(rl.GetGamepadAxisMovement(0, 5)), 400, 110, 20, rl.White)
		rl.DrawText("pressed "+fmt.Sprint(rl.GetGamepadButtonPressed()), 400, 130, 20, rl.White)
	}

	//INTRO
	if intro {
		drawIntro()
	} else if startScreen {
		drawStartScreen()
	} else if gameOver {
		drawgameover()
	} else if endgame {
		drawendgame()
	}
	//BORDER RECS TO HIDE SHADER EDGES
	rec := rl.NewRectangle(0, 0, screenWidthF32, 3)
	rl.DrawRectangleRec(rec, rl.Black)
	rec.Y += screenHeightF32 - 3
	rl.DrawRectangleRec(rec, rl.Black)
	rec = rl.NewRectangle(0, 0, 3, screenHeightF32)
	rl.DrawRectangleRec(rec, rl.Black)
	rec.X += screenWidthF32 - 3
	rl.DrawRectangleRec(rec, rl.Black)
	//OTHER SCREENS
	if charscr {
		drawcharscr()
	} else if helpon {
		drawhelp()
	} else if options {
		drawOptions()
	} else if isBaseOn {
		drawBase()
	}
	//MARK: DRAW BOSS NAME TXT BOSS HP
	if isBossOn && !gameOver && !endgame && !credits {
		//NAME
		txs := tx7
		if xxl {
			txs = tx8
		}
		if large {
			txs = tx5
		}
		if medium {
			txs = tx4
		}
		txtlen := rl.MeasureText(boss.name, txs)
		y := int32(bq)
		x := screenWidth32 - (txtlen + int32(b/2))
		rl.DrawText(boss.name, x-4, y+4, txs, rl.Yellow)
		rl.DrawText(boss.name, x-3, y+3, txs, rl.Black)
		rl.DrawText(boss.name, x-2, y+2, txs, rl.Magenta)
		rl.DrawText(boss.name, x-1, y+1, txs, rl.Black)
		rl.DrawText(boss.name, x, y, txs, rl.White)
		//HP BARS
		siz := float32(4)
		spc := float32(1)
		heig := b
		wid := (siz + spc) * float32(boss.hpMax)
		y2 := float32(txs + tx2)
		x2 := screenWidthF32 - bq - wid
		rec := rl.NewRectangle(x2, y2, siz, heig)
		if len(levels[levNum].enemies) > 0 {
			for i := 0; i < levels[levNum].enemies[0].hpMax; i++ {
				rl.DrawRectangleRec(rec, rl.Fade(rl.DarkGray, 0.2))
				rec.X += siz + spc
			}
			rec = rl.NewRectangle(x2, y2, siz, heig)
			for i := 0; i < levels[levNum].enemies[0].hp; i++ {
				rl.DrawRectangleRec(rec, rl.Fade(DarkRed(), 0.7))
				rec.X += siz + spc
			}
		}
	}
	//GAME SCREEN
	//QUICKSLOTS
	if !pause || charscr {
		if !gameOver {
			drawquickslots()
			drawweapslots()
		}
	}
	if !pause && !gameOver {
		//MARK: DRAW STATUS EFFECTS
		y2 := sideY
		siz := b2
		txs := tx3
		if xxl {
			y2 += b2
			txs = tx4
			siz = b3
		}
		if medium {
			siz = b
			y2 -= b
			txs = tx2
		}
		rec := rl.NewRectangle(screenWidthF32-(siz+siz/4), y2, siz, siz)
		if saltT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[186], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[186], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "immune to freeze > " + fmt.Sprint(saltT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(saltT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if fartT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[184], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[184], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "fart fireballs > " + fmt.Sprint(fartT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(fartT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if psychedelicsT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[182], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[182], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "rainbows > " + fmt.Sprint(psychedelicsT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(psychedelicsT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if bootsT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[183], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[183], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "no floor trap damage > " + fmt.Sprint(bootsT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(bootsT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if gasT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[79], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[79], rec, rl.Vector2Zero(), 0, RandOrange())
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "inflict burn > " + fmt.Sprint(gasT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(gasT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if bloodT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[80], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[80], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "inflict bleed > " + fmt.Sprint(bloodT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(bloodT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if icecreamT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[65], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[65], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "frozen > " + fmt.Sprint(icecreamT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(icecreamT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if pistolT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[59], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[59], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := " faster attack speed > " + fmt.Sprint(pistolT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(pistolT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if icelollyT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[73], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[73], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "chilly > " + fmt.Sprint(icelollyT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(icelollyT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if watchT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[56], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[56], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "slower enemy move time > " + fmt.Sprint(watchT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(watchT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if slugT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[58], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[58], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "slug pee > " + fmt.Sprint(slugT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(slugT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if player.resistFireTimer > 0 {
			rl.DrawTexturePro(imgs, otherTiles[84], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[84], rec, rl.Vector2Zero(), 0, RandOrange())
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "resist fire > " + fmt.Sprint(player.resistFireTimer/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(player.resistFireTimer/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if player.resistPoisonTimer > 0 {
			rl.DrawTexturePro(imgs, otherTiles[85], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[85], rec, rl.Vector2Zero(), 0, RandGreen())
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "resist poison > " + fmt.Sprint(player.resistPoisonTimer/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(player.resistPoisonTimer/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if player.invisibleTimer > 0 {
			rl.DrawTexturePro(imgs, otherTiles[86], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[86], rec, rl.Vector2Zero(), 0, RandCyan())
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "invisible > " + fmt.Sprint(player.invisibleTimer/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(player.invisibleTimer/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if player.armorTimer > 0 {
			rl.DrawTexturePro(imgs, otherTiles[87], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[87], rec, rl.Vector2Zero(), 0, RandCyan())
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "armor > " + fmt.Sprint(player.armorTimer/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(player.armorTimer/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if intangibleT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[88], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[88], rec, rl.Vector2Zero(), 0, RandColor())
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "intangible > " + fmt.Sprint(intangibleT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(intangibleT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if powerT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[89], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[89], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "max stats > " + fmt.Sprint(powerT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(powerT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if orangeT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[116], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[116], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "health regeneration > " + fmt.Sprint(orangeT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(orangeT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if tvT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[117], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[117], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "paused > " + fmt.Sprint(tvT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(tvT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if lollipopT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[119], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[119], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "mana regeneration > " + fmt.Sprint(lollipopT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(lollipopT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if steroidsT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[24], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[24], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "max strength > " + fmt.Sprint(steroidsT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(steroidsT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if turtleT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[60], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[60], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "turtle shield > " + fmt.Sprint(turtleT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(turtleT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		if sodaT > 0 {
			rl.DrawTexturePro(imgs, otherTiles[62], shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[62], rec, rl.Vector2Zero(), 0, rl.White)
			if rl.CheckCollisionPointRec(cursorV2, rec) {
				txt := "faster movement > " + fmt.Sprint(sodaT/fps) + "s remaining"
				txlen := rl.MeasureText(txt, txs)
				xtx := rec.ToInt32().X - txlen - txs
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs, rl.Gold)
			} else {
				txt := fmt.Sprint(sodaT/fps) + "s"
				txlen := rl.MeasureText(txt, txs+tx)
				xtx := rec.ToInt32().X - txlen - txs/2
				ytx := rec.ToInt32().Y + rec.ToInt32().Width/2 - txs/2
				rl.DrawText(txt, xtx-2, ytx+2, txs+tx, rl.Black)
				rl.DrawText(txt, xtx, ytx, txs+tx, rl.Gold)
			}
			rec.Y += siz + b/4
		}
		//MARK: DRAW HP MANA
		siz = b + be3
		if medium {
			siz = b
		}
		if xl {
			siz = b2
		}
		if xxl {
			siz = b4
		}
		spc := float32(4)
		x2 := screenWidthF32 / 2
		y2 = screenHeightF32 - (siz + siz/4)
		wid := (siz + spc) * float32(player.hpMax+player.manaMax)
		x2 -= wid / 2
		xorig := x2
		x3 := x2
		//HP MAX
		for i := 0; i < player.hpMax; i++ {
			rec := rl.NewRectangle(x2, y2, siz, siz)
			if medium {
				rl.DrawTexturePro(imgs, otherTiles[32], shrec(rec, 3), rl.Vector2Zero(), 0, rl.Fade(rl.Magenta, 0.7))
			} else if xxl {
				rl.DrawTexturePro(imgs, otherTiles[32], shrec(rec, 12), rl.Vector2Zero(), 0, rl.Fade(rl.Magenta, 0.7))
			} else if xl {
				rl.DrawTexturePro(imgs, otherTiles[32], shrec(rec, 7), rl.Vector2Zero(), 0, rl.Fade(rl.Magenta, 0.7))
			} else {
				rl.DrawTexturePro(imgs, otherTiles[32], shrec(rec, 5), rl.Vector2Zero(), 0, rl.Fade(rl.Magenta, 0.7))
			}
			rl.DrawTexturePro(imgs, otherTiles[32], rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.7))
			x2 += siz + spc
		}
		//SHRIMP
		if shrimpnum > 0 {
			for i := 0; i < shrimpnum; i++ {
				rec := rl.NewRectangle(x2, y2, siz, siz)
				rl.DrawTexturePro(imgs, otherTiles[57], shrec(rec, 7), rl.Vector2Zero(), 0, ShadowColor())
				rl.DrawTexturePro(imgs, otherTiles[57], rec, rl.Vector2Zero(), 0, rl.White)
				x2 += siz + spc
			}
		}
		x3 = x2 + spc*2
		//HP
		x2 = xorig
		for i := 0; i < player.hp; i++ {
			rec := rl.NewRectangle(x2, y2, siz, siz)
			rl.DrawTexturePro(imgs, otherTiles[32], rec, rl.Vector2Zero(), 0, rl.Fade(BrightYellow(), RandF32(0.8, 1.1)))
			x2 += siz + spc
		}
		//MANA
		xorig = x3
		for i := 0; i < player.manaMax; i++ {
			rec := rl.NewRectangle(x3, y2, siz, siz)
			if medium {
				rl.DrawTexturePro(imgs, otherTiles[83], shrec(rec, 3), rl.Vector2Zero(), 0, rl.Fade(rl.Magenta, 0.7))
			} else {
				rl.DrawTexturePro(imgs, otherTiles[83], shrec(rec, 5), rl.Vector2Zero(), 0, rl.Fade(rl.Magenta, 0.7))
			}
			rl.DrawTexturePro(imgs, otherTiles[83], rec, rl.Vector2Zero(), 0, rl.Fade(rl.White, 0.7))
			x3 += siz + spc
		}
		x3 = xorig
		for i := 0; i < player.mana; i++ {
			rec := rl.NewRectangle(x3, y2, siz, siz)
			if medium {
				rl.DrawTexturePro(imgs, otherTiles[83], shrec(rec, 3), rl.Vector2Zero(), 0, rl.Fade(rl.DarkBlue, 0.7))
			} else {
				rl.DrawTexturePro(imgs, otherTiles[83], shrec(rec, 5), rl.Vector2Zero(), 0, rl.Fade(rl.DarkBlue, 0.7))
			}
			rl.DrawTexturePro(imgs, otherTiles[83], rec, rl.Vector2Zero(), 0, rl.Fade(RandCyan(), RandF32(0.8, 1.1)))
			x3 += siz + spc
		}
		//ARTIFACTS
		if len(player.art) > 0 {
			drawartifacts()
		}

		//SAVE ANIMATION
		if saveT > 0 {
			siz2 := b3
			if medium {
				siz2 = b2
			}
			cntr := rl.NewVector2(screenWidthF32/2, screenHeightF32)
			rec3 := rl.NewRectangle(cntr.X-siz2/2, b, siz2, siz2)
			rl.DrawTexturePro(imgs, animation[198].rectangle, shrec(rec3, 12), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, animation[198].rectangle, rec3, rl.Vector2Zero(), 0, rl.White)
			if frames%5 == 0 {
				animation[198].rectangle.X += animation[198].width
				if animation[198].rectangle.X > animation[198].x+animation[198].frames*animation[198].width {
					animation[198].rectangle.X = animation[198].x
				}
			}
			saveT--
		} else {
			//TOP INFO

			if toptxT > 0 && !options && !charscr {
				siz := tx3
				if medium {
					siz = tx2
				}
				if xxl {
					siz = tx6
				}
				txlen := rl.MeasureText(toptx, siz)
				cntr := rl.NewVector2(screenWidthF32/2, screenHeightF32/2)
				x := int32(cntr.X) - txlen/2
				y := int32(b / 4)
				txrec := rl.NewRectangle(float32(x-8), float32(y-4), float32(txlen+16), float32(siz+8))
				rl.DrawRectangleRec(txrec, rl.Fade(rl.Black, 0.7))
				rl.DrawText(toptx, x-2, y+2, siz, rl.Black)
				rl.DrawText(toptx, x, y, siz, rl.White)
			}
		}
		//TV PAUSE TEXT
		if tvT > 0 {
			txt := "paused"
			siz := tx10 * 2
			txlen := rl.MeasureText(txt, siz)
			xtx := int32(currentPosition.X) - txlen/2
			ytx := int32(currentPosition.Y)
			ytx += player.rectangle.ToInt32().Height
			rl.DrawText(txt, xtx, ytx, siz, rl.Fade(RandColor(), 0.2))
		}
	}
	//CURSOR
	if debug {
		rl.ShowCursor()
	} else {
		rl.HideCursor()
	}
	if !intro {
		siz := b + b/2
		if medium {
			siz = b
		}
		cursorRec := rl.NewRectangle(cursorV2.X-siz/2, cursorV2.Y-siz/2, siz, siz)
		rl.DrawTexturePro(imgs, otherTiles[7], shrec(drec(cursorRec), 17), orgn(cursorRec), curRo, ShadowColor())
		rl.DrawTexturePro(imgs, otherTiles[7], drec(cursorRec), orgn(cursorRec), curRo, RandColor())
		curRo++
	}
	//PIXELS
	if pixels && !isBaseOn {
		num := 150
		max := float32(3)
		if medium {
			max = 2
		} else if xxl {
			max = 7
		}
		min := float32(1)
		if xxl {
			min = 3
		}
		for num > 0 {
			siz := RandF32(min, max)
			rec := rl.NewRectangle(RandF32(0, screenWidthF32), RandF32(0, screenHeightF32), siz, siz)
			rl.DrawRectangleRec(rec, rl.Black)
			num--
		}
	}
	//SCAN
	if scanlines {
		for i := 0; i < len(scan); i++ {
			v2 := scan[i]
			v2.X += screenWidthF32
			if xxl {
				rl.DrawLineV(scan[i], v2, rl.Fade(rl.Black, 0.45))
			} else if large {
				rl.DrawLineV(scan[i], v2, rl.Fade(rl.Black, 0.15))
			} else if medium {
				rl.DrawLineV(scan[i], v2, rl.Fade(rl.Black, 0.15))
			} else {
				rl.DrawLineV(scan[i], v2, rl.Fade(rl.Black, 0.55))
			}

			if frames%3 == 0 {
				scan[i].Y++
				if scan[i].Y > screenHeightF32+scanlineSpc*2 {
					scan[i].Y = -scanlineSpc + 1
				}
			}
		}
	}
}
func drawminimap() { //MARK:DRAW MINIMAP
	camMap.Offset.X = screenWidthF32 - screenWidthF32/8
	camMap.Offset.Y = 12

	if medium {
		camMap.Offset.X = screenWidthF32 - screenWidthF32/7.5
		camMap.Offset.Y = 24
	}
	if xl {
		camMap.Offset.X = screenWidthF32 - screenWidthF32/7.5
		camMap.Offset.Y = -b / 2
	}
	if xxl {
		camMap.Offset.X = screenWidthF32 - screenWidthF32/6.5
		camMap.Offset.Y = -b3
	}
	rl.BeginMode2D(camMap)
	for i := 0; i < len(levels[levNum].rectangles); i++ {
		if playerRoom == i {
			rl.DrawRectangleRec(levels[levNum].rectangles[i], rl.Fade(rl.Yellow, 0.4))
			rl.DrawRectangleLinesEx(levels[levNum].rectangles[i], 8, rl.Yellow)
		} else {
			if mappin && i == exitRoomNum {
				rl.DrawRectangleRec(levels[levNum].rectangles[i], rl.Fade(rl.Magenta, 0.4))
				rl.DrawRectangleLinesEx(levels[levNum].rectangles[i], 8, rl.Magenta)
			} else if chestpin && i == chestRoomNum {
				rl.DrawRectangleRec(levels[levNum].rectangles[i], rl.Fade(rl.Blue, 0.4))
				rl.DrawRectangleLinesEx(levels[levNum].rectangles[i], 8, rl.Blue)
			} else {
				if levels[levNum].inf[i].isVisible {
					rl.DrawRectangleRec(levels[levNum].rectangles[i], rl.Fade(rl.Green, 0.4))
					rl.DrawRectangleLinesEx(levels[levNum].rectangles[i], 8, rl.Green)
				} else {
					rl.DrawRectangleRec(levels[levNum].rectangles[i], rl.Fade(rl.Red, 0.4))
					rl.DrawRectangleLinesEx(levels[levNum].rectangles[i], 8, rl.Red)
				}
			}
		}
	}
	rl.EndMode2D()
}
func drawnoRender() { //MARK:DRAW NO RENDER
	//SIDEBAR
	if !isBaseOn && !options && !intro && !startScreen && !gameOver && !endgame && !helpon {
		drawsidebar()
	}
	//MINI MAP
	if !isBossOn && !isBaseOn && !options && !intro && !startScreen && !treasureRoom && !gameOver && !endgame && !helpon {
		drawminimap()
	}
	//INVEN HINTS
	if charscr {
		drawinvhints()
	}

	if debug {
		drawDebug()
	}
}
func drawsidebar() { //MARK:DRAW SIDE BAR MESSAGES DRAW TIMER
	//MSG
	y := int32(120)

	if xxl {
		y = int32(250)
	}
	if xl {
		y = int32(200)
	}
	if treasureRoom {
		y = 16
	} else if isBossOn {
		y = 150
	}
	txs := tx2
	if medium {
		txs = tx
	}
	if xxl {
		txs = tx4
	}
	if len(msg) > 0 {
		count := 0
		for i := len(msg) - 1; i > 0; i-- {
			txlen := rl.MeasureText(msg[i].txt, txs)
			x := screenWidth32 - (txlen + txs)
			rl.DrawText(msg[i].txt, x-1, y+1, txs, rl.Black)
			rl.DrawText(msg[i].txt, x, y, txs, msg[i].col)
			y += txs
			count++
			if count == 10 {
				break
			}
		}
	}
	y += txs
	//TIMER
	secs := fmt.Sprint(levSecs)
	mins := fmt.Sprint(levMins)
	if levSecs == 0 {
		secs = "00"
	} else if levSecs < 10 {
		secs = "0" + secs
	}
	if levMins == 0 {
		mins = "00"
	} else if levMins < 10 {
		mins = "0" + mins
	}
	txt := mins + ":" + secs
	if !isBossOn && !treasureRoom {
		txt = "level " + fmt.Sprint(levNumDis) + " >> " + txt
	}
	txlen := rl.MeasureText(txt, txs)
	x := screenWidth32 - (txlen + txs)
	rl.DrawText(txt, x-2, y+2, txs, rl.Black)
	rl.DrawText(txt, x, y, txs, RandColor())
	y += txs + tx
	sideY = float32(y) + b2 + b/2
	//ENEMIES REMAIN
	if !isBossOn {
		if levels[levNum].enemyNum > 0 {
			if levels[levNum].enemyNum == 1 {
				txt = "1 enemy remains"
			} else {
				txt = fmt.Sprint(levels[levNum].enemyNum) + " enemies remain"
			}
		} else {
			txt = "cleared > +100xp @ end level"
		}
		txlen = rl.MeasureText(txt, txs)
		x = screenWidth32 - (txlen + txs)
		rl.DrawText(txt, x-2, y+2, txs, rl.Black)
		rl.DrawText(txt, x, y, txs, RandColor())
	}
	//XP
	ytx := y + (txs + tx/2) + 2
	if isBossOn {
		ytx -= txs
	}
	xtx := screenWidth32
	txt = fmt.Sprint(player.xp) + " xp"
	if player.xp == 0 {
		txt = "zero xp"
	}
	txtlen := rl.MeasureText(txt, txs*2)
	xtx -= txtlen + txs
	rl.DrawText(txt, xtx-2, ytx+2, txs*2, rl.Black)
	rl.DrawText(txt, xtx, ytx, txs*2, RandColor())

}

func drawcharscr() { //MARK:DRAW INVENTORY CHARACTER SCREEN

	for i := 0; i < len(bgpix); i++ {
		rec := rl.NewRectangle(bgpix[i].vector2.X, bgpix[i].vector2.Y, bgpix[i].siz, bgpix[i].siz)
		rl.DrawRectangleRec(rec, rl.Fade(bgpix[i].color, bgpix[i].fd))
		bgpix[i].vector2.X += bgpix[i].dirX
		bgpix[i].vector2.Y += bgpix[i].dirY

		if bgpix[i].vector2.X < 0 {
			bgpix[i].vector2.X = screenWidthF32
		}
		if bgpix[i].vector2.X > screenWidthF32 {
			bgpix[i].vector2.X = 0
		}
		if bgpix[i].vector2.Y < 0 {
			bgpix[i].vector2.Y = screenHeightF32
		}
		if bgpix[i].vector2.Y > screenHeightF32 {
			bgpix[i].vector2.Y = 0
		}

		if bgpix[i].fd > 0 {
			bgpix[i].fd -= 0.005
		} else {
			bgpix[i].fd = RandF32(0.5, 1)
		}
	}
	if cantmoveT > 0 {
		cantmoveT--
	}
	if invDisTxtT > 0 {
		invDisTxtT--
	}
	if invInfoT > 0 {
		invInfoT--
	}

	rl.BeginMode2D(camInventory) //CHANGE ZOOM FOR SCREEN RES
	rl.DrawRectangleRec(optionsRec, rl.Fade(rl.Magenta, 0.9))
	cursorV2camInven = rl.GetScreenToWorld2D(cursorV2, camInventory)
	//DRAW INVEN
	bgtxrec := rl.NewRectangle(optionsRec.X, optionsRec.Y+b/2, optionsRec.Width, b2+b/4)
	rl.DrawRectangleRec(bgtxrec, rl.Orange)
	rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
	rl.DrawText(">> inventory", optionsRec.ToInt32().X+tx3-1, bgtxrec.ToInt32().Y+9, tx5, rl.Black)
	rl.DrawText(">> inventory", optionsRec.ToInt32().X+tx3, bgtxrec.ToInt32().Y+8, tx5, rl.Black)
	//CLOSE REC
	siz2 := bgtxrec.Height
	closerec := rl.NewRectangle(optionsRec.X+optionsRec.Width-siz2, bgtxrec.Y, siz2, siz2)
	closerec.X += 16
	closerec.Y += 16
	closerec.Width -= 32
	closerec.Height -= 32
	v1 := rl.NewVector2(closerec.X, closerec.Y)
	v1.X += 8
	v1.Y += 8
	v2 := v1
	v2.X += closerec.Width - 16
	v3 := v2
	v3.Y += closerec.Width - 16
	v4 := v3
	v4.X -= closerec.Width - 16
	if rl.CheckCollisionPointRec(cursorV2camInven, closerec) {
		rl.DrawRectangleRec(closerec, DarkRed())
		rl.DrawLineEx(v1, v3, 4, rl.Black)
		rl.DrawLineEx(v2, v4, 4, rl.Black)
		if invInfoT == 0 {
			if clickT == 0 {
				if inpL {
					rl.PlaySound(audfx[41])
					if !isBaseOn {
						pause = false
					}
					inMenuOn = false
					charscr = false
				}
			}
		}
	} else {
		rl.DrawRectangleRec(closerec, rl.Black)
		rl.DrawLineEx(v1, v3, 4, rl.Orange)
		rl.DrawLineEx(v2, v4, 4, rl.Orange)
	}

	if rl.IsGamepadButtonPressed(0, 6) {
		rl.PlaySound(audfx[41])
		if !isBaseOn {
			pause = false
		}
		inMenuOn = false
		charscr = false
	}
	x := optionsRec.X
	x += 14
	xorig := x
	y := b3 + bq
	siz := b2
	spc := float32(4)
	diff := inventoryMax - len(player.inventory)
	for i := 0; i < len(player.inventory); i++ {

		if player.inventory[i].name == "map" && player.inventory[i].notquick && isBaseOn {
			player.inventory[i].notquick = false
		} else if player.inventory[i].name == "map" && !player.inventory[i].notquick && !isBaseOn {
			player.inventory[i].notquick = true
		}

		rec := rl.NewRectangle(x, y, siz, siz)
		if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
			rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.7))
		} else {
			rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
		}
		rl.DrawRectangleLinesEx(rec, 4, rl.Fade(rl.Purple, 0.7))
		if player.inventory[i].name != "" {
			rl.DrawTexturePro(imgs, player.inventory[i].image, shrec(rec, 5), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, player.inventory[i].image, rec, rl.Vector2Zero(), 0, rl.White)
			//NUMOF TXT
			if player.inventory[i].numof > 1 {
				txlen := rl.MeasureText(fmt.Sprint(player.inventory[i].numof), tx2)
				xtx := int32(rec.X+rec.Width) - txlen
				ytx := int32(rec.Y+rec.Height) - tx2
				rl.DrawText(fmt.Sprint(player.inventory[i].numof), xtx-2, ytx+2, tx2, rl.Black)
				rl.DrawText(fmt.Sprint(player.inventory[i].numof), xtx-1, ytx+1, tx2, rl.Black)
				rl.DrawText(fmt.Sprint(player.inventory[i].numof), xtx, ytx, tx2, rl.Yellow)
			}
			if rl.CheckCollisionPointRec(cursorV2camInven, rec) && !inMenuOn && clickT == 0 {
				disTxt1 = player.inventory[i].name
				disTxt2 = player.inventory[i].des
				if cantmoveT > 0 {
					disTxt1 = "cannot be used"
					disTxt2 = "in quick slots"
				}
				invDisTxtT = fps * 2
				//MOVE TO QUIK
				if inpL && nxQuikNum != blankint && !player.inventory[i].notquick && player.inventory[i].name != "map" && !player.inventory[i].art && clickT == 0 {
					clickT = fps / 4
					found, numSame := checkQuikSameItm(player.inventory[i])
					if found {
						player.quik[numSame].numof++
					} else {
						player.quik[nxQuikNum] = player.inventory[i]
						player.inventory[i] = Item{}
					}
					rl.PlaySound(audfx[18])
				} else if inpL && nxQuikNum != blankint && player.inventory[i].notquick && !player.inventory[i].art && clickT == 0 && cantmoveT == 0 {
					cantmoveT = fps * 2
				} else if inpL && nxQuikNum != blankint && !player.inventory[i].notquick && player.inventory[i].art && clickT == 0 && cantmoveT == 0 {
					cantmoveT = fps * 2
				}
				//MENU
				if clickT == 0 {
					if inpR && !inMenuOn {
						rl.PlaySound(audfx[44])
						clickT = fps / 4
						inMenuOn = true
						siz2 := (siz + spc) * 2
						siz2 -= spc
						inMenuRec = rl.NewRectangle(rec.X+rec.Width+spc, rec.Y, siz2, siz2+siz+spc)
						if inchest {
							inMenuRec.Height += siz / 2
						}
						if cursorV2.X > currentPosition.X+siz2 {
							inMenuRec.X -= siz2 + siz + spc
						}
						inMenuItm = i
					}
				}
			}
		}
		x += siz + spc
		if x+siz+spc >= optionsRec.X+optionsRec.Width {
			x = xorig
			y += siz + spc
		}
	}
	//DRAW LOCKED INVEN
	if diff > 0 {
		for i := 0; i < diff; i++ {
			rec := rl.NewRectangle(x, y, siz, siz)
			rl.DrawRectangleRec(rec, rl.DarkPurple)
			rl.DrawRectangleLinesEx(rec, 4, rl.Fade(rl.Purple, 0.7))
			rec.X += 4
			rec.Y += 4
			rec.Width -= 8
			rec.Height -= 8
			rl.DrawTexturePro(imgs, otherTiles[46], shrec(rec, 4), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[46], rec, rl.Vector2Zero(), 0, rl.White)
			x += siz + spc
			if x+siz+spc >= optionsRec.X+optionsRec.Width {
				x = xorig
				y += siz + spc
			}
		}
	}
	//WEAPON SLOTS
	y += b / 2
	diff = player.weaponMax - len(player.weapons)
	for i := 0; i < len(player.weapons); i++ {
		rec := rl.NewRectangle(x, y, siz, siz)
		if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
			rl.DrawRectangleRec(rec, rl.Fade(RandColor(), 0.7))
			if player.weapons[i].name != "" {
				disTxt1 = player.weapons[i].name + " > level " + fmt.Sprint(player.weapons[i].level)
				disTxt2 = "right click for menu"
				invDisTxtT = fps * 2
			}
			//MENU
			if clickT == 0 {
				if inpR && !inWeapMenuOn {
					clickT = fps / 4
					inWeapMenuOn = true
					siz2 := (siz + spc) * 2
					siz2 -= spc
					inMenuRec = rl.NewRectangle(rec.X+rec.Width+spc, rec.Y, siz2, siz2+siz/2)
					if cursorV2.X > currentPosition.X+siz2 {
						inMenuRec.X -= siz2 + siz + spc
					}
					inMenuItm = i
				}
			}
		} else {
			rl.DrawRectangleRec(rec, rl.Fade(rl.Black, 0.7))
		}
		rl.DrawRectangleLinesEx(rec, 4, rl.Fade(rl.Gold, 0.7))
		if player.weapons[i].name != "" {
			rl.DrawTexturePro(imgs, player.weapons[i].image, shrec(rec, 7), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, player.weapons[i].image, rec, rl.Vector2Zero(), 0, rl.White)
			//BONUS STARS
			if player.weapons[i].special != 0 {
				siz := be7
				rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
				rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
				rec3.X += 4
				rec3.Y += 4
				rec3.Width -= 8
				rec3.Height -= 8
				rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
			}
			if player.weapons[i].special2 != 0 {
				siz := be7
				rec3 := rl.NewRectangle(rec.X+rec.Width-(siz-4), rec.Y+rec.Height-(siz/8)*5, siz, siz)
				if player.weapons[i].special != 0 {
					rec3.X -= (siz / 12) * 9
				}
				rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.Black)
				rec3.X += 4
				rec3.Y += 4
				rec3.Width -= 8
				rec3.Height -= 8
				rl.DrawTexturePro(imgs, otherTiles[181], rec3, rl.Vector2Zero(), 0, rl.White)
			}
		}
		x += siz + spc
	}
	if diff > 0 {
		for i := 0; i < diff; i++ {
			rec := rl.NewRectangle(x, y, siz, siz)
			rl.DrawRectangleRec(rec, rl.DarkPurple)
			rl.DrawRectangleLinesEx(rec, 4, rl.Fade(rl.Gold, 0.7))
			rec.X += 4
			rec.Y += 4
			rec.Width -= 8
			rec.Height -= 8
			rl.DrawTexturePro(imgs, otherTiles[46], shrec(rec, 4), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, otherTiles[46], rec, rl.Vector2Zero(), 0, rl.White)
			x += siz + spc
		}
	}
	ytx := int32(y) + tx/2
	xtx := int32(x) + tx
	rl.DrawText("<< weapons", xtx-1, ytx+1, tx5, rl.Black)
	rl.DrawText("<< weapons", xtx, ytx, tx5, rl.Black)

	//STACK
	y += siz + be5
	rec2 := rl.NewRectangle(currentPosition.X-(b4+b/8), y, b4, b+b/2)
	if rl.CheckCollisionPointRec(cursorV2camInven, rec2) {
		rl.DrawRectangleRec(rec2, DarkRed())
		rl.DrawRectangleLinesEx(rec2, 4, rl.Black)
		txt := "stack"
		txs := tx3
		txlen := rl.MeasureText(txt, txs)
		ytx := rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
		xtx := rec2.ToInt32().X + rec2.ToInt32().Width/2 - txlen/2
		rl.DrawText(txt, xtx, ytx, txs, rl.White)
		if clickT == 0 {
			if inpL {
				rl.PlaySound(audfx[44])
				clickT = fps / 4
				stack()
			}
		}
	} else {
		rl.DrawRectangleRec(rec2, rl.Orange)
		rl.DrawRectangleLinesEx(rec2, 4, rl.Black)
		txt := "stack"
		txs := tx3
		txlen := rl.MeasureText(txt, txs)
		ytx := rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
		xtx := rec2.ToInt32().X + rec2.ToInt32().Width/2 - txlen/2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)
	}
	//PACK
	rec2.X += rec2.Width + b/4
	if rl.CheckCollisionPointRec(cursorV2camInven, rec2) {
		rl.DrawRectangleRec(rec2, DarkRed())
		rl.DrawRectangleLinesEx(rec2, 4, rl.Black)
		txt := "pack"
		txs := tx3
		txlen := rl.MeasureText(txt, txs)
		ytx := rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
		xtx := rec2.ToInt32().X + rec2.ToInt32().Width/2 - txlen/2
		rl.DrawText(txt, xtx, ytx, txs, rl.White)
		if clickT == 0 {
			if inpL {
				rl.PlaySound(audfx[44])
				clickT = fps / 4
				pack()
			}
		}
	} else {
		rl.DrawRectangleRec(rec2, rl.Orange)
		rl.DrawRectangleLinesEx(rec2, 4, rl.Black)
		txt := "pack"
		txs := tx3
		txlen := rl.MeasureText(txt, txs)
		ytx := rec2.ToInt32().Y + rec2.ToInt32().Height/2 - txs/2
		xtx := rec2.ToInt32().X + rec2.ToInt32().Width/2 - txlen/2
		rl.DrawText(txt, xtx-1, ytx+1, txs, rl.Black)
		rl.DrawText(txt, xtx, ytx, txs, rl.Black)
	}
	//INVEN MOUSE OVER DISPLAY TXT
	if invDisTxtT > 0 {
		y = rec2.Y + rec2.Height
		ytx := int32(y + be)
		txs := tx4
		spc2 := tx
		txlen := rl.MeasureText(disTxt1, txs)
		xtx := int32(currentPosition.X) - txlen/2
		rl.DrawText(disTxt1, xtx-3, ytx+3, txs, rl.DarkPurple)
		rl.DrawText(disTxt1, xtx-3, ytx+3, txs, rl.Black)
		rl.DrawText(disTxt1, xtx, ytx, txs, rl.White)
		ytx += txs + spc2
		txlen = rl.MeasureText(disTxt2, txs)
		xtx = int32(currentPosition.X) - txlen/2
		rl.DrawText(disTxt2, xtx-3, ytx+3, txs, rl.DarkPurple)
		rl.DrawText(disTxt2, xtx-3, ytx+3, txs, rl.Black)
		rl.DrawText(disTxt2, xtx, ytx, txs, rl.White)
	}
	y = rec2.Y + rec2.Height + b3 + bq
	//MARK: DRAW STATS
	bgtxrec = rl.NewRectangle(optionsRec.X, y, optionsRec.Width, b10)
	rl.DrawRectangleRec(bgtxrec, rl.Black)
	rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Orange)
	rl.DrawText(">> stats", optionsRec.ToInt32().X+tx3, bgtxrec.ToInt32().Y+tx, tx5, rl.Orange)
	x = optionsRec.X
	x += b / 4
	xtx = int32(x + b)
	ytx = int32(y + b2 + bq)
	txs := tx3
	spc2 := tx
	txt := "perception > " + fmt.Sprint(stats.perception) + " > discover secrets+"
	txlen := rl.MeasureText(txt, txs)
	xtx = int32(currentPosition.X) - txlen/2
	rl.DrawText(txt, xtx, ytx, txs, rl.Orange)
	ytx += txs + spc2
	txt = "critical > " + fmt.Sprint(stats.critical) + " > x2 damage chance+"
	txlen = rl.MeasureText(txt, txs)
	xtx = int32(currentPosition.X) - txlen/2
	rl.DrawText(txt, xtx, ytx, txs, rl.Orange)
	ytx += txs + spc2
	txt = "dexterity > " + fmt.Sprint(stats.dexterity) + " > dodge chance+"
	txlen = rl.MeasureText(txt, txs)
	xtx = int32(currentPosition.X) - txlen/2
	rl.DrawText(txt, xtx, ytx, txs, rl.Orange)
	ytx += txs + spc2
	txt = "intelligence > " + fmt.Sprint(stats.intelligence) + " > magic power+"
	txlen = rl.MeasureText(txt, txs)
	xtx = int32(currentPosition.X) - txlen/2
	rl.DrawText(txt, xtx, ytx, txs, rl.Orange)
	ytx += txs + spc2
	txt = "luck > " + fmt.Sprint(stats.luck) + " > find more loot+"
	txlen = rl.MeasureText(txt, txs)
	xtx = int32(currentPosition.X) - txlen/2
	rl.DrawText(txt, xtx, ytx, txs, rl.Orange)
	ytx += txs + spc2
	txt = "strength > " + fmt.Sprint(stats.strength) + " > damage+"
	txlen = rl.MeasureText(txt, txs)
	xtx = int32(currentPosition.X) - txlen/2
	rl.DrawText(txt, xtx, ytx, txs, rl.Orange)
	//MARK: DRAW WEAPON MENU
	if inWeapMenuOn {
		rl.DrawRectangleRec(inMenuRec, rl.Magenta)
		rl.DrawRectangleRec(inMenuRec, rl.Fade(rl.Black, 0.7))
		rl.DrawRectangleLinesEx(inMenuRec, 4, rl.Fade(rl.Purple, 0.7))
		if !rl.CheckCollisionPointRec(cursorV2camInven, inMenuRec) {
			inMenuExitT++
			if inMenuExitT >= (fps/3)*2 {
				inMenuExitT = 0
				inWeapMenuOn = false
			}
		} else {
			inMenuExitT = 0
		}
		xtx := int32(inMenuRec.X) + 12
		ytx := int32(inMenuRec.Y) + 12
		txs := tx3
		txrecy := float32(ytx) - 2
		for i := 0; i < 4; i++ {
			txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
			if rl.CheckCollisionPointRec(cursorV2camInven, txrec) {
				rl.DrawRectangleRec(txrec, RandColor())
				if inpL {
					switch i {
					case 0: //MOVE TO SLOT 1
						if player.weapon.name == "" {
							player.weapon = player.weapons[inMenuItm]
							player.weapons[inMenuItm] = Weapon{}
							inWeapMenuOn = false
						} else {
							changeWeap := player.weapon
							player.weapon = player.weapons[inMenuItm]
							player.weapons[inMenuItm] = changeWeap
							inWeapMenuOn = false
						}
					case 1: //MOVE TO SLOT 2
						if player.weapon2.name == "" {
							player.weapon2 = player.weapons[inMenuItm]
							player.weapons[inMenuItm] = Weapon{}
							inWeapMenuOn = false
						} else {
							changeWeap := player.weapon2
							player.weapon2 = player.weapons[inMenuItm]
							player.weapons[inMenuItm] = changeWeap
							inWeapMenuOn = false
						}
					case 2: //INFO
						invInfoT = fps
						invenInfo = true
						weapInfon = true
						inWeapMenuOn = false
					case 3: //DROP
						if !isBaseOn {
							dropweap(inMenuItm, 0)
							inWeapMenuOn = false
						} else {
							disTxt1 = "cannot drop"
							disTxt2 = "items at camp"
							invDisTxtT = fps * 2
						}
					}
				}
			}
			txrecy += txrec.Height
		}
		rl.DrawText("slot 1", xtx, ytx, txs, rl.Black)
		ytx += txs + 4
		rl.DrawText("slot 2", xtx, ytx, txs, rl.Black)
		ytx += txs + 4
		rl.DrawText("info", xtx, ytx, txs, rl.Black)
		ytx += txs + 4
		rl.DrawText("drop", xtx, ytx, txs, rl.Black)
	}

	if clickT == 0 {
		if inpR {
			clickT = fps / 3
			inWeapMenuOn = false
		}
	}

	//MARK: DRAW INVEN MENU
	if inMenuOn {
		rl.DrawRectangleRec(inMenuRec, rl.Magenta)
		rl.DrawRectangleRec(inMenuRec, rl.Fade(rl.Black, 0.7))
		rl.DrawRectangleLinesEx(inMenuRec, 4, rl.Fade(rl.Purple, 0.7))
		if !rl.CheckCollisionPointRec(cursorV2camInven, inMenuRec) {
			inMenuExitT++
			if inMenuExitT >= (fps/3)*2 {
				inMenuExitT = 0
				inMenuOn = false
			}
		} else {
			inMenuExitT = 0
		}
		xtx := int32(inMenuRec.X) + 12
		ytx := int32(inMenuRec.Y) + 12
		txs := tx3
		txrecy := float32(ytx) - 2
		if player.inventory[inMenuItm].notquick { //COMPONENTS MENU
			if player.inventory[inMenuItm].numof > 1 {
				checkNum := 4
				if inchest {
					checkNum = 5
				}
				for i := 0; i < checkNum; i++ {
					txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
					if rl.CheckCollisionPointRec(cursorV2camInven, txrec) {
						rl.DrawRectangleRec(txrec, RandColor())
						if inpL {
							switch i {
							case 0: //DROP
								if !isBaseOn {
									rl.PlaySound(audfx[40])
									dropitm(inMenuItm, 0)
									inMenuOn = false
								} else {
									rl.PlaySound(audfx[43])
									disTxt1 = "cannot drop"
									disTxt2 = "items at camp"
									invDisTxtT = fps * 2
									inMenuOn = false
								}
							case 1: //INFO
								rl.PlaySound(audfx[40])
								invInfoT = fps
								invenInfo = true
								inMenuOn = false
							case 2: //SCRAP
								rl.PlaySound(audfx[40])
								num := player.inventory[inMenuItm].numof
								player.inventory[inMenuItm] = Item{}
								player.inventory[inMenuItm].name = ""
								found := false
								for j := 0; j < len(player.inventory); j++ {
									if j != inMenuItm {
										if player.inventory[j].name == "scrap" {
											player.inventory[j].numof += num
											found = true
											break
										}
									}
								}
								if !found {
									player.inventory[inMenuItm] = itemList[43]
									player.inventory[inMenuItm].numof = num
								}
								inMenuOn = false
							case 3: //SPLIT
								rl.PlaySound(audfx[40])
								if nxInvnNum != blankint {
									num1, num2 := 0, 0
									if player.inventory[inMenuItm].numof%2 == 0 {
										num1 = player.inventory[inMenuItm].numof / 2
										num2 = num1
									} else {
										num2 = player.inventory[inMenuItm].numof / 2
										num1 = num2 + 1
									}
									newItm := player.inventory[inMenuItm]
									newItm.numof = num1
									player.inventory[inMenuItm].numof = num2
									player.inventory[nxInvnNum] = newItm
									findnxinvnum()
								} else {
									rl.PlaySound(audfx[43])
									admsg("no free inventory slots", rl.Red)
								}
								inMenuOn = false
							case 4: //MOVE TO CHEST
								found := false
								for j := 0; j < len(levels[levNum].chests[0].item); j++ {
									if levels[levNum].chests[0].item[j].name == player.inventory[inMenuItm].name {
										levels[levNum].chests[0].item[j].numof += player.inventory[inMenuItm].numof
										player.inventory[inMenuItm] = Item{}
										found = true
										inMenuOn = false
										break
									}
								}
								if !found {
									canmove, num := checkChestSlots()
									if canmove {
										rl.PlaySound(audfx[40])
										levels[levNum].chests[0].item[num] = player.inventory[inMenuItm]
										player.inventory[inMenuItm] = Item{}
										inMenuOn = false
									} else {
										rl.PlaySound(audfx[43])
										admsg("no free chest slots", rl.Red)
										inMenuOn = false
									}
								}
							}
						}
					}
					txrecy += txrec.Height
				}
				rl.DrawText("drop", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("info", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("scrap", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("split", xtx, ytx, txs, rl.Black)
				if inchest {
					ytx += txs + 4
					rl.DrawText("> chest", xtx, ytx, txs, rl.Black)
				}
			} else {
				checkNum := 3
				if inchest {
					checkNum = 4
				}
				for i := 0; i < checkNum; i++ {
					txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
					if rl.CheckCollisionPointRec(cursorV2camInven, txrec) {
						rl.DrawRectangleRec(txrec, RandColor())
						if inpL {
							switch i {
							case 0: //DROP
								if !isBaseOn {
									rl.PlaySound(audfx[40])
									dropitm(inMenuItm, 0)
									inMenuOn = false
								} else {
									rl.PlaySound(audfx[43])
									disTxt1 = "cannot drop"
									disTxt2 = "items at camp"
									invDisTxtT = fps * 2
									inMenuOn = false
								}
							case 1: //INFO
								rl.PlaySound(audfx[40])
								invInfoT = fps
								invenInfo = true
								inMenuOn = false
							case 2: //SCRAP
								rl.PlaySound(audfx[40])
								num := player.inventory[inMenuItm].numof
								player.inventory[inMenuItm] = Item{}
								player.inventory[inMenuItm].name = ""
								found := false
								for j := 0; j < len(player.inventory); j++ {
									if j != inMenuItm {
										if player.inventory[j].name == "scrap" {
											player.inventory[j].numof += num
											found = true
											break
										}
									}
								}
								if !found {
									player.inventory[inMenuItm] = itemList[43]
									player.inventory[inMenuItm].numof = num
								}
								inMenuOn = false
							case 3: //MOVE TO CHEST
								found := false
								for j := 0; j < len(levels[levNum].chests[0].item); j++ {
									if levels[levNum].chests[0].item[j].name == player.inventory[inMenuItm].name {
										levels[levNum].chests[0].item[j].numof += player.inventory[inMenuItm].numof
										player.inventory[inMenuItm] = Item{}
										found = true
										inMenuOn = false
										break
									}
								}
								if !found {
									canmove, num := checkChestSlots()
									if canmove {
										rl.PlaySound(audfx[40])
										levels[levNum].chests[0].item[num] = player.inventory[inMenuItm]
										player.inventory[inMenuItm] = Item{}
										inMenuOn = false
									} else {
										rl.PlaySound(audfx[43])
										admsg("no free chest slots", rl.Red)
										inMenuOn = false
									}
								}
							}
						}
					}
					txrecy += txrec.Height
				}
				rl.DrawText("drop", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("info", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("scrap", xtx, ytx, txs, rl.Black)
				if inchest {
					ytx += txs + 4
					rl.DrawText("> chest", xtx, ytx, txs, rl.Black)
				}
			}
		} else { //OTHER ITEMS MENU
			if player.inventory[inMenuItm].numof > 1 {
				checkNum := 5
				if inchest {
					checkNum = 6
				}
				for i := 0; i < checkNum; i++ {
					txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
					if rl.CheckCollisionPointRec(cursorV2camInven, txrec) {
						rl.DrawRectangleRec(txrec, RandColor())
						if inpL {
							switch i {
							case 0: //USE
								if player.inventory[inMenuItm].name == "map" && !treasureRoom {
									rl.PlaySound(audfx[40])
									treasureRoom = true
									if player.inventory[inMenuItm].numof > 1 {
										player.inventory[inMenuItm].numof--
									} else {
										player.inventory[inMenuItm] = Item{}
									}
									inMenuOn = false
								} else if player.inventory[inMenuItm].name == "map" && treasureRoom {
									rl.PlaySound(audfx[43])
									disTxt1 = "treasure map is"
									disTxt2 = "already active"
									invDisTxtT = fps * 2
									inMenuOn = false
								} else {
									if !isBaseOn {
										rl.PlaySound(audfx[40])
										useitm(inMenuItm, 0)
										inMenuOn = false
									} else {
										rl.PlaySound(audfx[43])
										disTxt1 = "cannot use"
										disTxt2 = "items at camp"
										invDisTxtT = fps * 2
										inMenuOn = false
									}
								}
							case 1: //DROP
								if !isBaseOn {
									rl.PlaySound(audfx[40])
									dropitm(inMenuItm, 0)
								} else {
									rl.PlaySound(audfx[43])
									disTxt1 = "cannot drop"
									disTxt2 = "items at camp"
									invDisTxtT = fps * 2
								}
								inMenuOn = false
							case 2: //INFO
								rl.PlaySound(audfx[40])
								invInfoT = fps
								invenInfo = true
								inMenuOn = false
							case 3: //SCRAP
								rl.PlaySound(audfx[40])
								num := player.inventory[inMenuItm].numof
								player.inventory[inMenuItm] = Item{}
								player.inventory[inMenuItm].name = ""
								found := false
								for j := 0; j < len(player.inventory); j++ {
									if j != inMenuItm {
										if player.inventory[j].name == "scrap" {
											player.inventory[j].numof += num
											found = true
											break
										}
									}
								}
								if !found {
									player.inventory[inMenuItm] = itemList[43]
									player.inventory[inMenuItm].numof = num
								}
								inMenuOn = false
							case 4: //SPLIT
								if nxInvnNum != blankint {
									rl.PlaySound(audfx[40])
									num1, num2 := 0, 0
									if player.inventory[inMenuItm].numof%2 == 0 {
										num1 = player.inventory[inMenuItm].numof / 2
										num2 = num1
									} else {
										num2 = player.inventory[inMenuItm].numof / 2
										num1 = num2 + 1
									}
									newItm := player.inventory[inMenuItm]
									newItm.numof = num1
									player.inventory[inMenuItm].numof = num2
									player.inventory[nxInvnNum] = newItm
									findnxinvnum()
									inMenuOn = false
								} else {
									inMenuOn = false
									rl.PlaySound(audfx[43])
									admsg("no free inventory slots", rl.Red)
								}
							case 5: //MOVE TO CHEST
								found := false
								for j := 0; j < len(levels[levNum].chests[0].item); j++ {
									if levels[levNum].chests[0].item[j].name == player.inventory[inMenuItm].name {
										levels[levNum].chests[0].item[j].numof += player.inventory[inMenuItm].numof
										player.inventory[inMenuItm] = Item{}
										found = true
										inMenuOn = false
										break
									}
								}
								if !found {
									canmove, num := checkChestSlots()
									if canmove {
										rl.PlaySound(audfx[40])
										levels[levNum].chests[0].item[num] = player.inventory[inMenuItm]
										player.inventory[inMenuItm] = Item{}
										inMenuOn = false
									} else {
										rl.PlaySound(audfx[43])
										admsg("no free chest slots", rl.Red)
										inMenuOn = false
									}
								}
							}
						}
					}
					txrecy += txrec.Height
				}
				rl.DrawText("use", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("drop", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("info", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("scrap", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("split", xtx, ytx, txs, rl.Black)
				if inchest {
					ytx += txs + 4
					rl.DrawText("> chest", xtx, ytx, txs, rl.Black)
				}
			} else {
				checkNum := 4
				if inchest {
					checkNum = 5
				}
				for i := 0; i < checkNum; i++ {
					txrec := rl.NewRectangle(inMenuRec.X, txrecy, inMenuRec.Width, float32(txs)+4)
					if rl.CheckCollisionPointRec(cursorV2camInven, txrec) {
						rl.DrawRectangleRec(txrec, RandColor())
						if inpL {
							switch i {
							case 0: //USE
								if player.inventory[inMenuItm].name == "map" && !treasureRoom {
									rl.PlaySound(audfx[40])
									treasureRoom = true
									if player.inventory[inMenuItm].numof > 1 {
										player.inventory[inMenuItm].numof--
									} else {
										player.inventory[inMenuItm] = Item{}
									}
									inMenuOn = false
								} else if player.inventory[inMenuItm].name == "map" && treasureRoom {
									rl.PlaySound(audfx[43])
									disTxt1 = "treasure map is"
									disTxt2 = "already active"
									invDisTxtT = fps * 2
									inMenuOn = false
								} else {
									if !isBaseOn {
										rl.PlaySound(audfx[40])
										useitm(inMenuItm, 0)
										inMenuOn = false
									} else {
										rl.PlaySound(audfx[43])
										disTxt1 = "cannot use"
										disTxt2 = "items at camp"
										invDisTxtT = fps * 2
										inMenuOn = false
									}
								}
							case 1: //DROP
								if !isBaseOn {
									rl.PlaySound(audfx[40])
									dropitm(inMenuItm, 0)
									inMenuOn = false
								} else {
									rl.PlaySound(audfx[43])
									disTxt1 = "cannot drop"
									disTxt2 = "items at camp"
									invDisTxtT = fps * 2
									inMenuOn = false
								}
							case 2: //INFO
								rl.PlaySound(audfx[40])
								invInfoT = fps
								invenInfo = true
								inMenuOn = false
							case 3: //SCRAP
								rl.PlaySound(audfx[40])
								num := player.inventory[inMenuItm].numof
								player.inventory[inMenuItm] = Item{}
								player.inventory[inMenuItm].name = ""
								found := false
								for j := 0; j < len(player.inventory); j++ {
									if j != inMenuItm {
										if player.inventory[j].name == "scrap" {
											player.inventory[j].numof += num
											found = true
											break
										}
									}
								}
								if !found {
									player.inventory[inMenuItm] = itemList[43]
									player.inventory[inMenuItm].numof = num
								}
								inMenuOn = false
							case 4: //MOVE TO CHEST
								found := false
								for j := 0; j < len(levels[levNum].chests[0].item); j++ {
									if levels[levNum].chests[0].item[j].name == player.inventory[inMenuItm].name {
										levels[levNum].chests[0].item[j].numof += player.inventory[inMenuItm].numof
										player.inventory[inMenuItm] = Item{}
										found = true
										inMenuOn = false
										break
									}
								}
								if !found {
									canmove, num := checkChestSlots()
									if canmove {
										rl.PlaySound(audfx[40])
										levels[levNum].chests[0].item[num] = player.inventory[inMenuItm]
										player.inventory[inMenuItm] = Item{}
										inMenuOn = false
									} else {
										rl.PlaySound(audfx[43])
										admsg("no free chest slots", rl.Red)
										inMenuOn = false
									}
								}
							}
						}
					}
					txrecy += txrec.Height
				}
				rl.DrawText("use", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("drop", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("info", xtx, ytx, txs, rl.Black)
				ytx += txs + 4
				rl.DrawText("scrap", xtx, ytx, txs, rl.Black)
				if inchest {
					ytx += txs + 4
					rl.DrawText("> chest", xtx, ytx, txs, rl.Black)
				}
			}
		}
		if clickT == 0 {
			if inpR {
				clickT = fps / 3
				inMenuOn = false
			}
		}
	}
	//MARK: DRAW INVEN INFO
	if invenInfo {

		invInfoT++
		if invInfoT > fps*2 {
			invInfoT = fps
		}
		//BG REC
		rl.DrawRectangleRec(optionsRec, rl.Magenta)
		bgtxrec := rl.NewRectangle(optionsRec.X, optionsRec.Y+b/2, optionsRec.Width, b2+b/4)
		rl.DrawRectangleRec(bgtxrec, rl.Orange)
		rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
		closeY := bgtxrec.Y
		closeH := bgtxrec.Height
		//IMG
		irec := rl.NewRectangle(optionsRec.X+optionsRec.Width/4, b3+b/2, optionsRec.Width/2, optionsRec.Width/2)
		rl.DrawRectangleRec(irec, rl.Fade(rl.Black, 0.8))
		rl.DrawRectangleLinesEx(irec, 8, rl.Black)
		irec.X += b
		irec.Y += b
		irec.Width -= b2
		irec.Height -= b2
		if weapInfon {
			rl.DrawTexturePro(imgs, player.weapons[inMenuItm].image, shrec(irec, 8), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, player.weapons[inMenuItm].image, irec, rl.Vector2Zero(), 0, rl.White)
		} else {
			rl.DrawTexturePro(imgs, player.inventory[inMenuItm].image, shrec(irec, 8), rl.Vector2Zero(), 0, ShadowColor())
			rl.DrawTexturePro(imgs, player.inventory[inMenuItm].image, irec, rl.Vector2Zero(), 0, rl.White)
		}
		//TITLE TX
		txs := tx4
		if weapInfon {
			txlen := rl.MeasureText(player.weapons[inMenuItm].name, txs)
			xtx := int32(currentPosition.X) - txlen/2
			ytx := bgtxrec.ToInt32().Y + bgtxrec.ToInt32().Height/2 - txs/2
			rl.DrawText(player.weapons[inMenuItm].name, xtx, ytx, txs, rl.Black)
		} else {
			txlen := rl.MeasureText(player.inventory[inMenuItm].name, txs)
			xtx := int32(currentPosition.X) - txlen/2
			ytx := bgtxrec.ToInt32().Y + bgtxrec.ToInt32().Height/2 - txs/2
			rl.DrawText(player.inventory[inMenuItm].name, xtx, ytx, txs, rl.Black)
		}

		//DESC
		txs = tx4
		if weapInfon {
			txlen = rl.MeasureText(player.weapons[inMenuItm].description, txs)
			xtx = int32(currentPosition.X) - txlen/2
			ytx = irec.ToInt32().Y + irec.ToInt32().Height + tx6
			bgtxrec.Y = float32(ytx) - 4
			bgtxrec.Height = float32(txs) + 12
			rl.DrawRectangleRec(bgtxrec, rl.Orange)
			rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
			rl.DrawText(player.weapons[inMenuItm].description, xtx, ytx, txs, rl.Black)
		} else {
			txlen = rl.MeasureText(player.inventory[inMenuItm].des, txs)
			xtx = int32(currentPosition.X) - txlen/2
			ytx = irec.ToInt32().Y + irec.ToInt32().Height + tx6
			bgtxrec.Y = float32(ytx) - 4
			bgtxrec.Height = float32(txs) + 12
			rl.DrawRectangleRec(bgtxrec, rl.Orange)
			rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Black)
			rl.DrawText(player.inventory[inMenuItm].des, xtx, ytx, txs, rl.Black)
		}

		bgtxrec = rl.NewRectangle(optionsRec.X, bgtxrec.Y+bgtxrec.Height+b/2, optionsRec.Width, b10+b/2)
		rl.DrawRectangleRec(bgtxrec, rl.Black)
		rl.DrawRectangleLinesEx(bgtxrec, 4, rl.Orange)
		rl.DrawText(">> more info...", optionsRec.ToInt32().X+tx3, bgtxrec.ToInt32().Y+tx, tx5, rl.Orange)

		//SEE DRAW NO RENDER FOR OTHER TXT

		txs = tx2
		ytx = int32(bgtxrec.Y) + tx5

		//DESC
		if weapInfon {
			if player.weapons[inMenuItm].description2 != "" {
				txlen := rl.MeasureText(player.weapons[inMenuItm].description2, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += tx5
				rl.DrawText(player.weapons[inMenuItm].description2, xtx, ytx, txs, rl.Yellow)
			}
			if player.weapons[inMenuItm].description3 != "" {
				txlen := rl.MeasureText(player.weapons[inMenuItm].description3, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(player.weapons[inMenuItm].description3, xtx, ytx, txs, rl.Yellow)
			}
			if player.weapons[inMenuItm].description4 != "" {
				txlen := rl.MeasureText(player.weapons[inMenuItm].description4, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(player.weapons[inMenuItm].description4, xtx, ytx, txs, rl.Yellow)
			}
			if player.weapons[inMenuItm].description5 != "" {
				txlen := rl.MeasureText(player.weapons[inMenuItm].description5, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(player.weapons[inMenuItm].description5, xtx, ytx, txs, rl.Yellow)
			}
			if player.weapons[inMenuItm].descrition6 != "" {
				txlen := rl.MeasureText(player.weapons[inMenuItm].descrition6, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(player.weapons[inMenuItm].descrition6, xtx, ytx, txs, rl.Yellow)
			}
			if player.weapons[inMenuItm].description7 != "" {
				txt2 := "dmg > " + fmt.Sprint(player.weapons[inMenuItm].damage)
				if player.weapons[inMenuItm].special != 0 {
					switch player.weapons[inMenuItm].special {
					case 1:
						txt2 = txt2 + " +lightning"
					case 2:
						txt2 = txt2 + " +arrows"
					case 3:
						txt2 = txt2 + " +fireworks"
					case 4:
						txt2 = txt2 + " +turret"
					case 5:
						txt2 = txt2 + " +bomb"
					case 6:
						txt2 = txt2 + " +rocket"
					case 7:
						txt2 = txt2 + " +attack speed"
					case 8:
						txt2 = txt2 + " +potion"
					case 9:
						txt2 = txt2 + " +double xp"
					case 10:
						txt2 = txt2 + " +ring of fire"
					case 11:
						txt2 = txt2 + " +sludge geyser"
					}
				}
				if player.weapons[inMenuItm].special2 != 0 {
					switch player.weapons[inMenuItm].special2 {
					case 1:
						txt2 = txt2 + " +lightning"
					case 2:
						txt2 = txt2 + " +arrows"
					case 3:
						txt2 = txt2 + " +fireworks"
					case 4:
						txt2 = txt2 + " +turret"
					case 5:
						txt2 = txt2 + " +bomb"
					case 6:
						txt2 = txt2 + " +rocket"
					case 7:
						txt2 = txt2 + " +attack speed"
					case 8:
						txt2 = txt2 + " +potion"
					case 9:
						txt2 = txt2 + " +double xp"
					case 10:
						txt2 = txt2 + " +ring of fire"
					case 11:
						txt2 = txt2 + " +sludge geyser"
					}
				}
				txlen := rl.MeasureText(txt2, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(txt2, xtx, ytx, txs, rl.Yellow)
			}
		} else {
			if player.inventory[inMenuItm].des2 != "" {
				txlen := rl.MeasureText(player.inventory[inMenuItm].des2, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(player.inventory[inMenuItm].des2, xtx, ytx, txs, rl.Yellow)
			}
			if player.inventory[inMenuItm].des3 != "" {
				txlen := rl.MeasureText(player.inventory[inMenuItm].des3, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(player.inventory[inMenuItm].des3, xtx, ytx, txs, rl.Yellow)
			}
			if player.inventory[inMenuItm].des4 != "" {
				txlen := rl.MeasureText(player.inventory[inMenuItm].des4, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(player.inventory[inMenuItm].des4, xtx, ytx, txs, rl.Yellow)
			}
			if player.inventory[inMenuItm].des5 != "" {
				txlen := rl.MeasureText(player.inventory[inMenuItm].des5, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(player.inventory[inMenuItm].des5, xtx, ytx, txs, rl.Yellow)
			}
			if player.inventory[inMenuItm].des6 != "" {
				txlen := rl.MeasureText(player.inventory[inMenuItm].des6, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(player.inventory[inMenuItm].des6, xtx, ytx, txs, rl.Yellow)
			}
			if player.inventory[inMenuItm].des7 != "" {
				txlen := rl.MeasureText(player.inventory[inMenuItm].des7, txs)
				xtx := int32(currentPosition.X) - txlen/2
				ytx += txs + txs/2
				rl.DrawText(player.inventory[inMenuItm].des7, xtx, ytx, txs, rl.Yellow)
			}
		}

		//EXIT
		if inpR {
			invenInfo = false
			weapInfon = false
			inMenuOn = false
			inWeapMenuOn = false
		}
		//CLOSE REC
		siz2 := closeH
		closerec := rl.NewRectangle(optionsRec.X+optionsRec.Width-siz2, closeY, siz2, siz2)
		closerec.X += 16
		closerec.Y += 16
		closerec.Width -= 32
		closerec.Height -= 32
		v1 := rl.NewVector2(closerec.X, closerec.Y)
		v1.X += 8
		v1.Y += 8
		v2 := v1
		v2.X += closerec.Width - 16
		v3 := v2
		v3.Y += closerec.Width - 16
		v4 := v3
		v4.X -= closerec.Width - 16
		if rl.CheckCollisionPointRec(cursorV2camInven, closerec) {
			rl.DrawRectangleRec(closerec, DarkRed())
			rl.DrawLineEx(v1, v3, 4, rl.Black)
			rl.DrawLineEx(v2, v4, 4, rl.Black)
			if clickT == 0 {
				if inpL {
					rl.PlaySound(audfx[41])
					clickT = fps / 4
					invInfoT = fps / 2
					weapInfon = false
					invenInfo = false
					inMenuOn = false
					inWeapMenuOn = false
				}
			}
		} else {
			rl.DrawRectangleRec(closerec, rl.Black)
			rl.DrawLineEx(v1, v3, 4, rl.Orange)
			rl.DrawLineEx(v2, v4, 4, rl.Orange)
		}
	}
	if rl.IsGamepadButtonPressed(0, 6) {
		rl.PlaySound(audfx[41])
		clickT = fps / 4
		invInfoT = fps / 2
		weapInfon = false
		invenInfo = false
		inMenuOn = false
		inWeapMenuOn = false
	}
	rl.EndMode2D()
}
func drawDebug() { //MARK:DRAW DEBUG
	siderec := rl.NewRectangle(0, 0, 300, screenHeightF32)
	rl.DrawRectangleRec(siderec, rl.Fade(DarkRed(), 0.3))
	txtX, txtY := tx, tx
	rl.DrawText("levels[levNum].enm[0].dirX"+" "+fmt.Sprint(levels[levNum].enemies[0].dirX), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("levels[levNum].enm[0].dirY"+" "+fmt.Sprint(levels[levNum].enemies[0].dirY), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("tvT"+" "+fmt.Sprint(tvT), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("bosson"+" "+fmt.Sprint(isBossOn), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("xxl"+" "+fmt.Sprint(xxl), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("xl"+" "+fmt.Sprint(xl), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("lrg"+" "+fmt.Sprint(large), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("med"+" "+fmt.Sprint(medium), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("camBoss.Zoom"+" "+fmt.Sprint(camBoss.Zoom), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("camBase.Zoom"+" "+fmt.Sprint(camBase.Zoom), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("cam2.Zoom"+" "+fmt.Sprint(cam2.Zoom), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("camInven.Zoom"+" "+fmt.Sprint(camInventory.Zoom), txtX, txtY, tx, rl.White)
	txtY += tx
	txt2 := fmt.Sprintf("%.2f", stickMov)
	txt2 = strings.TrimLeft(txt2, "0.")
	rl.DrawText("stickMov"+" "+txt2, txtX, txtY, tx, rl.White)
	txtY += tx
	if len(levels[levNum].enemies) > 0 {
		rl.DrawText("len(levels[levNum].enm)"+" "+fmt.Sprint(len(levels[levNum].enemies)), txtX, txtY, tx, rl.White)
		txtY += tx
	}
	rl.DrawText("scrWF32"+" "+fmt.Sprint(screenWidthF32), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("scrHF32"+" "+fmt.Sprint(screenHeightF32), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("poisongasCount"+" "+fmt.Sprint(poisongasCount), txtX, txtY, tx, rl.White)
	txtY += tx
	rl.DrawText("maxWeapDmg"+" "+fmt.Sprint(maxWeapDmg), txtX, txtY, tx, rl.White)
	txtY += tx

	rl.DrawFPS(int32(b/4), screenHeight32-int32(b))

	rl.DrawCircleV(currentPosition, 8, RandColor())
}

// MARK: CHECK CHECK CHECK CHECK CHECK CHECK CHECK CHECK CHECK CHECK CHECK CHECK CHECK CHECK
func checkV2chest(v2 rl.Vector2) bool { //MARK: CHECK V2 IN CHEST
	canadd := true
	if rl.CheckCollisionPointRec(v2, levels[levNum].chests[0].rectangle) {
		canadd = false
	}
	return canadd
}
func checkmovemouse() bool { //MARK: CHECK MOVE MOUSE
	canmove := true
	checkrec := base.mouse.rectangle
	checkrec.X += base.mouse.dirX
	checkrec.Y += base.mouse.dirY
	for i := 0; i < len(base.collisionRectangle); i++ {
		if rl.CheckCollisionRecs(checkrec, base.collisionRectangle[i]) {
			canmove = false
		}
	}
	v1 := rl.NewVector2(checkrec.X, checkrec.Y)
	v2 := v1
	v2.X += checkrec.Width
	v3 := v2
	v3.Y += checkrec.Height
	v4 := v3
	v4.X -= checkrec.Width
	if !rl.CheckCollisionPointRec(v1, baseBordRec) || !rl.CheckCollisionPointRec(v2, baseBordRec) || !rl.CheckCollisionPointRec(v3, baseBordRec) || !rl.CheckCollisionPointRec(v4, baseBordRec) {
		canmove = false
	}
	return canmove
}
func checkWeapWeap(rec rl.Rectangle) bool { //MARK: CHECK WEAP VS WEAP
	canadd := true
	for i := 0; i < len(levels[levNum].weapons); i++ {
		if rl.CheckCollisionRecs(rec, levels[levNum].weapons[i].rec) {
			canadd = false
		}
	}
	return canadd
}
func checkRecEtc(rec rl.Rectangle) bool { //MARK: CHECK ETC VS ETC
	canadd := true
	for i := 0; i < len(levels[levNum].otherTiles); i++ {
		if rl.CheckCollisionRecs(rec, levels[levNum].otherTiles[i].rectangle) {
			canadd = false
		}
	}
	return canadd
}
func checkRecDoors(rec rl.Rectangle) bool { //MARK: CHECK REC DOORS
	canadd := true
	for i := 0; i < len(levels[levNum].doors); i++ {
		if rl.CheckCollisionRecs(rec, levels[levNum].doors[i]) {
			canadd = false
		}
	}
	return canadd
}
func checkRecSolid(rec rl.Rectangle) bool { //MARK: CHECK REC VS ETC SOLID
	canadd := true
	for i := 0; i < len(levels[levNum].otherTiles); i++ {
		if levels[levNum].otherTiles[i].solid {
			if rl.CheckCollisionRecs(rec, levels[levNum].otherTiles[i].rectangle) {
				canadd = false
				break
			}
		}
	}
	return canadd
}
func checkV2water(v2 rl.Vector2) bool { //MARK: CHECK V2 WATER
	canadd := true
	for i := 0; i < len(levels[levNum].otherTiles); i++ {
		if levels[levNum].otherTiles[i].name == "water" {
			if rl.CheckCollisionPointRec(v2, levels[levNum].otherTiles[i].rectangle2) {
				canadd = false
				break
			}
		}
	}
	return canadd
}
func checkV2inRooms(v2 rl.Vector2) bool { //MARK: CHECK V2 IS IN ROOM RECS
	canadd := false
	for i := 0; i < len(levels[levNum].rectangles); i++ {
		if rl.CheckCollisionPointRec(v2, levels[levNum].rectangles[i]) {
			canadd = true
			break
		}
	}
	return canadd
}
func checkV2Walls(v2 rl.Vector2) bool { //MARK: CHECK V2 WALLS
	canadd := true
	for i := 0; i < len(levels[levNum].walls); i++ {
		if rl.CheckCollisionPointRec(v2, levels[levNum].walls[i].rectangle) {
			canadd = false
			break
		}
	}
	return canadd
}
func checkV2WallsLev(v2 rl.Vector2, lev x1scr) bool { //MARK: CHECK V2 WALLS X1SCR LEV
	canadd := true
	for i := 0; i < len(lev.walls); i++ {
		if rl.CheckCollisionPointRec(v2, lev.walls[i].rectangle) {
			canadd = false
			break
		}
	}
	return canadd
}
func checkMoveEnm(num int) bool { //MARK: CHECK MOVE ENEMY
	canmove := true
	if levels[levNum].enemies[num].name == "bird" || levels[levNum].enemies[num].name == "fly" || levels[levNum].enemies[num].name == "balloon" {
		v2 := levels[levNum].enemies[num].cnt
		v2.X += levels[levNum].enemies[num].dirX + delta
		v2.Y += levels[levNum].enemies[num].dirY + delta
		canmove2 := false
		for i := 0; i < len(levels[levNum].rectangles); i++ {
			if rl.CheckCollisionPointRec(v2, levels[levNum].rectangles[i]) {
				canmove2 = true
			}
		}
		canmove = canmove2
	} else {
		rec := levels[levNum].enemies[num].collisionRectangle
		rec.X += levels[levNum].enemies[num].dirX + delta
		rec.Y += levels[levNum].enemies[num].dirY + delta
		if canmove && !levels[levNum].enemies[num].fly {
			canmove, _ = checkRecEtcSolid(rec)
		}
		if canmove {
			canmove = checkRecWalls(rec)
		}
	}
	return canmove
}
func checkArtSameItm(itm Item) (found bool, numSame int) { //MARK:CHECK ART SAME ITM
	numSame = 0
	found = false
	for i := 0; i < len(player.art); i++ {
		if player.art[i].name == itm.name {
			found = true
			numSame = i
			break
		}
	}
	return found, numSame
}
func checkInvnSameItm(itm Item) (found bool, numSame int) { //MARK:CHECK INVN SAME ITM
	numSame = 0
	found = false
	for i := 0; i < len(player.inventory); i++ {
		if player.inventory[i].name == itm.name {
			found = true
			numSame = i
			break
		}
	}
	return found, numSame
}
func checkQuikSameItm(itm Item) (found bool, numSame int) { //MARK:CHECK QUIK SAME ITM
	numSame = 0
	found = false
	for i := 0; i < len(player.quik); i++ {
		if player.quik[i].name == itm.name {
			found = true
			numSame = i
			break
		}
	}
	return found, numSame
}
func checkRecWalls(rec rl.Rectangle) bool { //MARK:CHECK REC VS WALLS
	canadd := true
	for i := 0; i < len(levels[levNum].walls); i++ {
		if rl.CheckCollisionRecs(rec, levels[levNum].walls[i].rectangle) {
			canadd = false
			break
		}
	}
	return canadd
}
func checkItemItem(rec rl.Rectangle) bool { //MARK:CHECK REC VS ITEM
	canadd := true
	for i := 0; i < len(levels[levNum].items); i++ {
		if rl.CheckCollisionRecs(rec, levels[levNum].items[i].rectangle) {
			canadd = false
			break
		}
	}
	return canadd
}
func checkChestSlots() (bool, int) { //MARK:CHECK CHEST SLOTS
	found := false
	num := 0
	for i := 0; i < len(levels[levNum].chests[0].item); i++ {
		if levels[levNum].chests[0].item[i].name == "" {
			found = true
			num = i
			break
		}
	}
	return found, num
}
func checkRecWallsChestsEtcSolid(rec rl.Rectangle, num int, numType int) bool {
	//NUMTYPE 1 = ETC
	canmove := true
	//WALLS
	for i := 0; i < len(levels[levNum].walls); i++ {
		if rl.CheckCollisionRecs(rec, levels[levNum].walls[i].rectangle) {
			canmove = false
		}
	}
	//ETC
	if canmove {
		for i := 0; i < len(levels[levNum].otherTiles); i++ {
			if numType == 1 { //CHECK VS SELF ETC
				if i != num {
					if levels[levNum].otherTiles[i].solid {
						if rl.CheckCollisionRecs(rec, levels[levNum].otherTiles[i].rectangle) {
							canmove = false
						}
					}
				}
			} else {
				if levels[levNum].otherTiles[i].solid {
					if rl.CheckCollisionRecs(rec, levels[levNum].otherTiles[i].rectangle) {
						canmove = false
					}
				}
			}
			if !canmove {
				break
			}
		}
	}
	//CHESTS
	if canmove {
		for i := 0; i < len(levels[levNum].chests); i++ {
			if rl.CheckCollisionRecs(rec, levels[levNum].chests[i].collisionRectangle) {
				canmove = false
			}
			if !canmove {
				break
			}
		}
	}
	return canmove
}
func checkRecChests(rec rl.Rectangle) bool { //MARK:CHECK REC VS CHESTS
	canmove := true
	for i := 0; i < len(levels[levNum].chests); i++ {
		if rl.CheckCollisionRecs(rec, levels[levNum].chests[i].collisionRectangle) {
			canmove = false
		}
		if !canmove {
			break
		}
	}
	return canmove
}
func checkRecEtcSolid(rec rl.Rectangle) (canmove bool, num int) { //MARK:CHECK NON-ETC REC VS ETC SOLID RECS
	canmove = true
	for i := 0; i < len(levels[levNum].otherTiles); i++ {
		if levels[levNum].otherTiles[i].solid {
			if rl.CheckCollisionRecs(rec, levels[levNum].otherTiles[i].rectangle) {
				canmove = false
				num = i
			}
		}
		if !canmove {
			break
		}
	}
	return canmove, num
}
func checkRecPlayer(rec rl.Rectangle) bool { //MARK:CHECK PLAYER VS REC
	canadd := true
	if rl.CheckCollisionRecs(rec, player.rectangle) {
		canadd = false
	}
	return canadd
}
func checkmoveblok(blok Tile, num int) bool { //MARK:CHECK MOVE BLOK
	canmove := true
	checkrec := blok.rectangle
	checkrec.X += blok.dirX
	checkrec.Y += blok.dirY
	for i := 0; i < len(levels[levNum].walls); i++ {
		if i != num {
			if rl.CheckCollisionRecs(checkrec, levels[levNum].walls[i].rectangle) {
				canmove = false
			}
		}
	}
	//CHECK VS CHESTS
	if canmove {
		canmove = checkRecChests(checkrec)
	}
	//CHECK VS ETC SOLID
	if canmove {
		canmove, _ = checkRecEtcSolid(checkrec)
	}
	if canmove {
		if rl.CheckCollisionRecs(checkrec, player.collisionRectangle) {
			canmove = false
		}
	}
	return canmove
}
func checkRecMoveWalls(rec rl.Rectangle, dirX, dirY float32) bool { //MARK:CHECK REC MOVE WALL COLLIS
	canmove := true
	rec.X += dirX
	rec.Y += dirY
	for i := 0; i < len(levels[levNum].walls); i++ {
		if rl.CheckCollisionRecs(rec, levels[levNum].walls[i].rectangle) {
			canmove = false
		}
	}
	return canmove
}
func checkplayermoveBase(direc int) bool { //MARK:CHECK PLAYER MOVE BASE
	canmove := true
	checkrec := player2.collisionRectangle
	switch direc {
	case 1: //UP
		checkrec.Y -= player2.speed
	case 2: //RIGHT
		checkrec.X += player2.speed
	case 3: //DOWN
		checkrec.Y += player2.speed
	case 4: //LEFT
		checkrec.X -= player2.speed
	}
	for i := 0; i < len(base.collisionRectangle); i++ {
		if rl.CheckCollisionRecs(checkrec, base.collisionRectangle[i]) {
			canmove = false
		}
	}
	if canmove {
		v1 := rl.NewVector2(checkrec.X, checkrec.Y)
		v2 := v1
		v2.X += checkrec.Width
		v3 := v2
		v3.Y += checkrec.Height
		v4 := v3
		v4.X -= checkrec.Width
		if !rl.CheckCollisionPointRec(v1, baseBordRec) || !rl.CheckCollisionPointRec(v2, baseBordRec) || !rl.CheckCollisionPointRec(v3, baseBordRec) || !rl.CheckCollisionPointRec(v4, baseBordRec) {
			canmove = false
		}
	}
	return canmove
}
func checkplayermove(direc int) bool { //MARK:CHECK PLAYER MOVE
	canmove := true
	if intangibleT == 0 {
		checkrec := player.collisionRectangle
		switch direc {
		case 1: //UP
			checkrec.Y -= player.speed + delta
		case 2: //RIGHT
			checkrec.X += player.speed + delta
		case 3: //DOWN
			checkrec.Y += player.speed + delta
		case 4: //LEFT
			checkrec.X -= player.speed + delta
		}
		for i := 0; i < len(levels[levNum].walls); i++ {
			if rl.CheckCollisionRecs(checkrec, levels[levNum].walls[i].rectangle) {
				canmove = false
			}
		}
		if canmove {
			numEtc := 0
			canmove, numEtc = checkRecEtcSolid(checkrec)
			if !canmove {
				if levels[levNum].otherTiles[numEtc].name == "crate" {
					pushcrate(numEtc, direc)
				}
			}
		}
		if isBossOn {
			if rl.CheckCollisionRecs(checkrec, boss.collisionRectangle) {
				canmove = false
			}
		}
	} else {
		checkV2 := player.center
		switch direc {
		case 1: //UP
			checkV2.Y -= player.speed + delta
		case 2: //RIGHT
			checkV2.X += player.speed + delta
		case 3: //DOWN
			checkV2.Y += player.speed + delta
		case 4: //LEFT
			checkV2.X -= player.speed + delta
		}
		canmove = false
		for i := 0; i < len(levels[levNum].rectangles); i++ {
			if rl.CheckCollisionPointRec(checkV2, levels[levNum].rectangles[i]) {
				canmove = true
			}
		}
	}
	return canmove
}
func checkaddtilerec(rec rl.Rectangle, lev x1scr) bool { //MARK:CHECK TILE REC WALL RECS
	canadd := true
	for i := 0; i < len(lev.walls); i++ {
		if rl.CheckCollisionRecs(rec, lev.walls[i].rectangle) {
			canadd = false
		}
	}
	if canadd {
		for i := 0; i < len(lev.rectangles); i++ {
			if rl.CheckCollisionRecs(rec, lev.rectangles[i]) && lev.inf[i].wallsAdded {
				canadd = false
			}
		}
	}
	return canadd
}
func checkaddetc(rec rl.Rectangle, lev x1scr) bool {
	canadd := true
	for i := 0; i < len(lev.otherTiles); i++ {
		if rl.CheckCollisionRecs(rec, lev.otherTiles[i].rectangle) {
			canadd = false
		}
	}
	return canadd
}
func checkaddtilerecInner(rec rl.Rectangle, lev x1scr) bool { //MARK:CHECK ADD INNER TILE
	canadd := true
	for i := 0; i < len(lev.walls); i++ {
		if rl.CheckCollisionRecs(rec, lev.walls[i].rectangle) {
			canadd = false
		}
	}
	if canadd {
		if rl.CheckCollisionRecs(rec, player.rectangle) {
			canadd = false
		}
	}
	return canadd
}
func checkrecaddto1scr(rec rl.Rectangle, recs []rl.Rectangle) bool { //MARK:CHECK REC ADD TO 1SCR
	canadd := true
	for i := 0; i < len(recs); i++ {
		if rl.CheckCollisionRecs(rec, recs[i]) {
			canadd = false
		}
	}
	if canadd {
		v1 := rl.NewVector2(rec.X, rec.Y)
		v2 := v1
		v2.X += rec.Width
		v3 := v2
		v3.Y += rec.Height
		v4 := v1
		v4.Y += rec.Height
		if !rl.CheckCollisionPointRec(v1, inRec) || !rl.CheckCollisionPointRec(v2, inRec) || !rl.CheckCollisionPointRec(v3, inRec) || !rl.CheckCollisionPointRec(v4, inRec) {
			canadd = false
		}
	}
	return canadd
}

// MARK: FIND FIND FIND FIND FIND FIND FIND FIND FIND FIND FIND FIND FIND FIND FIND FIND FIND
func findranrecpos(rec rl.Rectangle) (rl.Rectangle, bool) { //MARK: FIND RANDOM REC POSITION
	found := false
	countbreak := 100
	for {
		choose := levels[levNum].rectangles[RandInt(0, len(levels[levNum].rectangles))]
		x := choose.X + b/2
		y := choose.Y + b/2
		x2 := (x + choose.Width) - (b + rec.Width)
		y2 := (y + choose.Height) - (b + rec.Height)

		x = RandF32(x, x2)
		y = RandF32(y, y2)

		rec.X = x
		rec.Y = y

		if checkRecSolid(rec) && checkRecWalls(rec) {
			found = true
		}

		countbreak--
		if countbreak == 0 || found {
			break
		}
	}

	return rec, found
}
func findnextstoreslotnum() { //MARK: FIND NEXT STORE ITEM SLOT
	nxStoreNum = blankint
	for i := 0; i < len(storeItm); i++ {
		if storeItm[i].name == "" {
			nxStoreNum = i
			break
		}
	}
}
func finddropside(rec rl.Rectangle, msgonoff int) rl.Rectangle { //MARK: FIND EMPTY DROP POSITION NEXT TO RECTANGLE
	count := 0
	for {
		checkrec := rec
		switch count {
		case 0:
			checkrec.X -= checkrec.Width
		case 1:
			checkrec.X -= checkrec.Width
			checkrec.Y -= checkrec.Width
		case 2:
			checkrec.Y -= checkrec.Width
		case 3:
			checkrec.X += checkrec.Width
			checkrec.Y -= checkrec.Width
		case 4:
			checkrec.X += checkrec.Width
		case 5:
			checkrec.X += checkrec.Width
			checkrec.Y += checkrec.Width
		case 6:
			checkrec.Y += checkrec.Width
		case 7:
			checkrec.X -= checkrec.Width
			checkrec.Y += checkrec.Width
		}
		canadd := checkRecWalls(checkrec)
		if canadd {
			rec = checkrec
			zfx := Effect{}
			zfx.imageRectangle = animation[108].rectangle
			zfx.rectangle = checkrec
			zfx.rectangle.X -= b
			zfx.rectangle.Y -= b
			zfx.rectangle.Width += b2
			zfx.rectangle.Height += b2
			zfx.name = "summonitem"
			effect = append(effect, zfx)
			if msgonoff == 1 {
				admsg("extra loot drop > luck", rl.Magenta)
			}
			break
		}
		count++
		if count > 7 {
			rec = rl.Rectangle{}
			break
		}
	}
	return rec
}
func findnxinvnum() { //MARK: FIND NEXT INVEN NUM
	nxInvnNum = blankint
	for i := 0; i < len(player.inventory); i++ {
		if player.inventory[i].name == "" {
			nxInvnNum = i
		}
	}
}
func findRanCntinRoom(rec rl.Rectangle) rl.Vector2 { //MARK: FIND RANDOM CENTER IN ROOM
	cntr := rl.Vector2{}
	countbreak := 1000
	for {
		x := rec.X + b/2
		y := rec.Y + b/2
		x += RandF32(0, rec.Width-b)
		y += RandF32(0, rec.Height-b)
		cntr = rl.NewVector2(x, y)
		if checkV2Walls(cntr) {
			break
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	return cntr
}
func findRanCnt() rl.Vector2 { //MARK: FIND RANDOM CENTER
	cntr := rl.Vector2{}
	choose := RandInt(0, len(levels[levNum].rectangles))
	countbreak := 1000
	for {
		x := levels[levNum].rectangles[choose].X + b
		y := levels[levNum].rectangles[choose].Y + b
		x += RandF32(0, levels[levNum].rectangles[choose].Width-b2)
		y += RandF32(0, levels[levNum].rectangles[choose].Height-b2)
		cntr = rl.NewVector2(x, y)
		if checkV2Walls(cntr) {
			break
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	return cntr
}
func findRanCntLev(lev x1scr) rl.Vector2 { //MARK: FIND RANDOM CENTER X1SCR LEV
	cntr := rl.Vector2{}
	choose := RandInt(0, len(lev.rectangles))
	countbreak := 1000
	for {
		x := lev.rectangles[choose].X + b
		y := lev.rectangles[choose].Y + b
		x += RandF32(0, lev.rectangles[choose].Width-b2)
		y += RandF32(0, lev.rectangles[choose].Height-b2)
		cntr = rl.NewVector2(x, y)
		if checkV2WallsLev(cntr, lev) {
			break
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	return cntr
}
func findRanCntLevTreasureRoom(lev x1scr) rl.Vector2 { //MARK: FIND RANDOM CENTER TREASURE ROOM
	cntr := rl.Vector2{}
	choose := RandInt(0, len(lev.rectangles))
	if Roll6() > 3 {
		choose = 0
	}
	countbreak := 1000
	for {
		x := lev.rectangles[choose].X + b
		y := lev.rectangles[choose].Y + b
		x += RandF32(0, lev.rectangles[choose].Width-b2)
		y += RandF32(0, lev.rectangles[choose].Height-b2)
		cntr = rl.NewVector2(x, y)
		if checkV2WallsLev(cntr, lev) {
			break
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	return cntr
}
func findSpdXY(startV2, destV2 rl.Vector2, spd float32) (x, y float32) { //MARK: FIND DIRX DIRY FOR 2X V2
	xdiff := AbsDiff(destV2.X, startV2.X)
	ydiff := AbsDiff(destV2.Y, startV2.Y)
	if xdiff > ydiff {
		x = spd
		y = ydiff / (xdiff / x)
	} else {
		y = spd
		x = xdiff / (ydiff / y)
	}
	if startV2.X > destV2.X {
		x = -x
	}
	if startV2.Y > destV2.Y {
		y = -y
	}
	return x, y
}

// MARK: ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC ETC
func foundsameart(nm string) (int, bool) { //MARK: FOUND SAME ARTIFACT
	found := false
	num := 0
	if len(player.art) > 0 {
		for i := 0; i > len(player.art); i++ {
			if player.art[i].name == nm {
				found = true
				num = i
				break
			}
		}
	}

	return num, found
}
func pushcrate(num, direc int) { //MARK: PUSH CRATE
	checkrec := levels[levNum].otherTiles[num].rectangle
	switch direc {
	case 1:
		checkrec.Y -= player.speed * 2
	case 2:
		checkrec.X += player.speed * 2
	case 3:
		checkrec.Y += player.speed * 2
	case 4:
		checkrec.X -= player.speed * 2
	}
	if checkRecWallsChestsEtcSolid(checkrec, num, 1) {
		levels[levNum].otherTiles[num].moveTimer = 2
		player.push = true
		player.pushTimer = fps / 4
		switch direc {
		case 1:
			levels[levNum].otherTiles[num].dirY = -player.speed
		case 2:
			levels[levNum].otherTiles[num].dirX = player.speed
		case 3:
			levels[levNum].otherTiles[num].dirY = player.speed
		case 4:
			levels[levNum].otherTiles[num].dirX = -player.speed
		}
	}
}
func Reset() { //MARK: NEW GAME RESET

	levNumDis = 0

	bossSkillList = nil

	base = Base{}
	player = Player{}

	weaponStandOn = true
	scopeon = false
	drillon = false
	telBase = false
	telCntr = false
	medikiton = false
	vineon = false
	vineon2 = false
	vineRing = false
	thornson = false
	twin = false
	tesla = false
	purplerain = false
	frisbee = false
	mirror = false
	toxic = false
	feather = false
	cloak = false
	toaster = false
	noodles = false
	mappin = false
	chestpin = false
	umbrella = false
	treasureRoom = false
	icecrystal = false
	mrfrisbee = false
	spinna = false
	pyroball = false
	zombiehead = false
	batty = false
	landmine = false
	rollo = false
	shrimpnum = 0
	basketballnum = 0
	broccolinum = 0
	garlicnum = 0
	tenderisernum = 0
	cleavernum = 0
	deathbottlenum = 0
	gascannum = 0
	beartrapnum = 0
	toiletpapernum = 0
	teslacount = 0
	purpleraincount = 0
	frisbeecount = 0
	beltnum = 0
	beltAtk = 0
	throwingknifenum = 0
	magicianshatnum = 0
	pearlnum = 0
	lightbulbnum = 0
	mugnum = 0
	teanum = 0
	ninjanum = 0
	ovenglovenum = 0
	poisongasCount = 0
	medikitnum = 0
	sneakersnum = 0
	weaponcasenum = 0
	spacehelmetnum = 0
	zombienum = 0
	candycanenum = 0
	flamingonum = 0
	gasmasknum = 0
	watchT = 0
	scopeT = 0
	slugT = 0
	pistolT = 0
	turtleT = 0
	sodaT = 0
	icecreamT = 0
	gasT = 0
	bloodT = 0
	icelollyT = 0
	intangibleT = 0
	teleportT = 0
	inflictT = 0
	powerT = 0
	steroidsT = 0
	reviveT = 0
	beartrapT = 0
	quailT = 0
	teslaT = 0
	purplerainT = 0
	frisbeeT = 0
	beetrootT = 0
	cloakT = 0
	flamingoT = 0
	orangeT = 0
	tvT = 0
	lollipopT = 0
	honeycombT = 0
	eggsT = 0
	gasmaskT = 0
	psychedelicsT = 0
	bootsT = 0
	fartT = 0
	teleportPauseT = 0
	exitPauseT = 0
	saltT = 0
	icecrystalT = 0
	mrfrisbeeT = 0
	spinnaT = 0
	spinnaT2 = 0
	pyroballT = 0
	landmineT = 0

	for i := 0; i < len(itemList); i++ {
		itemList[i].isUnlocked = false
	}

	itemList[2].isUnlocked = true
	itemList[5].isUnlocked = true
	itemList[8].isUnlocked = true
	itemList[11].isUnlocked = true
	itemList[43].isUnlocked = true

	upunlocks()

	makeplayer()
	makebase()
	if isStoreUnlocked {
		for i := 0; i < len(base.name); i++ {
			if base.name[i] == "store room" {
				base.isUnlocked[i] = true
			}
		}
	}
	makelevel()

	rl.StopMusicStream(music[currentMusic])
	currentMusic = 2
	rl.PlayMusicStream(music[currentMusic])

}
func clearsave(num int) { //MARK: CLEAR SAVE FILE

	switch num {
	case 1:
		f, err := os.Create("save/1s.ave")
		if err != nil {
			fmt.Println(err)
			return
		}
		savelist := "777777777"
		f.WriteString(savelist)
		save1 = false
	case 2:
		f, err := os.Create("save/2s.ave")
		if err != nil {
			fmt.Println(err)
			return
		}
		savelist := "777777777"
		f.WriteString(savelist)
		save2 = false
	case 3:
		f, err := os.Create("save/3s.ave")
		if err != nil {
			fmt.Println(err)
			return
		}
		savelist := "777777777"
		f.WriteString(savelist)
		save3 = false
	}

}
func savestore() { //MARK: SAVE STORE ROOM

	switch currentSave {
	case 1:
		f, err := os.Create("save/1s.ave")
		if err != nil {
			fmt.Println(err)
			return
		}
		savelist := ""
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].name != "" {
				savelist += fmt.Sprint(storeItm[i].listNum) + ","
				savelist += fmt.Sprint(storeItm[i].numof) + ","
			}
		}
		f.WriteString(savelist)
	case 2:
		f, err := os.Create("save/2s.ave")
		if err != nil {
			fmt.Println(err)
			return
		}
		savelist := ""
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].name != "" {
				savelist += fmt.Sprint(storeItm[i].listNum) + ","
				savelist += fmt.Sprint(storeItm[i].numof) + ","
			}
		}
		f.WriteString(savelist)
	case 3:
		f, err := os.Create("save/3s.ave")
		if err != nil {
			fmt.Println(err)
			return
		}
		savelist := ""
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].name != "" {
				savelist += fmt.Sprint(storeItm[i].listNum) + ","
				savelist += fmt.Sprint(storeItm[i].numof) + ","
			}
		}
		f.WriteString(savelist)
	}

}
func ReadSaves() { //MARK: READ SAVES

	contents, err := os.ReadFile("save/1s.ave")
	if err != nil {
		fmt.Println("File reading error", err)
		return
	}
	saveitms := strings.Split(string(contents), ",")

	num, _ := strconv.Atoi(saveitms[0])
	if num == blankint {
		save1 = false
	} else {
		save1 = true
	}

	if save1 {
		savestore1 = nil
		for i := 0; i < len(saveitms)-1; i++ {
			num2, _ := strconv.Atoi(saveitms[i])
			num3, _ := strconv.Atoi(saveitms[i+1])
			zitm := itemList[num2]
			zitm.numof = num3
			savestore1 = append(savestore1, zitm)
			i++
		}
	}

	contents, err = os.ReadFile("save/2s.ave")
	if err != nil {
		fmt.Println("File reading error", err)
		return
	}
	saveitms = strings.Split(string(contents), ",")

	num, _ = strconv.Atoi(saveitms[0])
	if num == blankint {
		save2 = false
	} else {
		save2 = true
	}

	if save2 {
		savestore2 = nil
		for i := 0; i < len(saveitms)-1; i++ {
			num2, _ := strconv.Atoi(saveitms[i])
			num3, _ := strconv.Atoi(saveitms[i+1])
			zitm := itemList[num2]
			zitm.numof = num3
			savestore2 = append(savestore2, zitm)
			i++
		}
	}

	contents, err = os.ReadFile("save/3s.ave")
	if err != nil {
		fmt.Println("File reading error", err)
		return
	}
	saveitms = strings.Split(string(contents), ",")

	num, _ = strconv.Atoi(saveitms[0])
	if num == blankint {
		save3 = false
	} else {
		save3 = true
	}

	if save3 {
		savestore3 = nil
		for i := 0; i < len(saveitms)-1; i++ {
			num2, _ := strconv.Atoi(saveitms[i])
			num3, _ := strconv.Atoi(saveitms[i+1])
			zitm := itemList[num2]
			zitm.numof = num3
			savestore3 = append(savestore3, zitm)
			i++
		}
	}

}
func projEnmCollis(num, enNum int) { //MARK: PLAYER PROJ ENEMY COLLIS

	if !levels[levNum].enemies[enNum].nodmg {
		nohpT := false
		switch playerProjectiles[num].name {
		case "frogProj":
			if !levels[levNum].enemies[enNum].fly {
				levels[levNum].enemies[enNum].hp -= playerProjectiles[num].damage
				if levels[levNum].enemies[enNum].name == "crocodile" || levels[levNum].enemies[enNum].name == "redantenna" {
					levels[levNum].enemies[enNum].stunT = fps
					levels[levNum].enemies[enNum].stunF = 0.9
					levels[levNum].enemies[enNum].stunY = levels[levNum].enemies[enNum].cnt.Y
					levels[levNum].enemies[enNum].stunSiz = b / 4
				}
			} else {
				nohpT = true
			}
		case "poisongas":
			if levels[levNum].enemies[enNum].name == "flamehead" || levels[levNum].enemies[enNum].name == "skeleton" || levels[levNum].enemies[enNum].name == "ghost" {
				if msgT == 0 {
					admsg("immune to poison", rl.Yellow)
					msgT = fps
				}
			} else {
				if levels[levNum].enemies[enNum].poisonT == 0 {
					levels[levNum].enemies[enNum].poisonT = fps * 3
				}
			}
		default:
			if levels[levNum].enemies[enNum].name == "bush" && levels[levNum].enemies[enNum].idl {
				if msgT == 0 {
					admsg("immune - disguised as rock", rl.Yellow)
					msgT = fps
				}
			} else {
				levels[levNum].enemies[enNum].hp -= playerProjectiles[num].damage + (stats.strength - 1)
				if cleavernum > 0 && playerProjectiles[num].name != "splinter" {
					if Roll6() <= cleavernum {
						zproj := playerProjectiles[num]
						countbreak := 20
						for {
							zproj.dirX = RandF32(-zproj.speed, zproj.speed)
							zproj.dirY = RandF32(-zproj.speed, zproj.speed)
							if Abs(zproj.dirX) > zproj.speed/2 || Abs(zproj.dirY) > zproj.speed/2 {
								//CHANGE RO
								if playerProjectiles[num].name == "bunch of carrots" || playerProjectiles[num].name == "drawing pin" || playerProjectiles[num].name == "fork" || playerProjectiles[num].name == "french fries" {
									cntr := makecnt(playerProjectiles[num].rec)
									cntr2 := cntr
									cntr2.X += zproj.dirX * 5
									cntr2.Y += zproj.dirY * 5
									if playerProjectiles[num].name == "bunch of carrots" || playerProjectiles[num].name == "french fries" {
										zproj.rotation = AngleBetweenTwoPoints(cntr, cntr2) - 90
									} else {
										zproj.rotation = AngleBetweenTwoPoints(cntr, cntr2) + 45
									}
								}
								break
							}
							countbreak--
							if countbreak == 0 {
								break
							}
						}
						zproj.crec = zproj.rec
						zproj.bounce += basketballnum
						playerProjectiles = append(playerProjectiles, zproj)
						zproj = playerProjectiles[num]
						countbreak = 20
						for {
							zproj.dirX = RandF32(-zproj.speed, zproj.speed)
							zproj.dirY = RandF32(-zproj.speed, zproj.speed)
							if Abs(zproj.dirX) > zproj.speed/2 || Abs(zproj.dirY) > zproj.speed/2 {
								//CHANGE RO
								if playerProjectiles[num].name == "bunch of carrots" || playerProjectiles[num].name == "drawing pin" || playerProjectiles[num].name == "fork" || playerProjectiles[num].name == "french fries" {
									cntr := makecnt(playerProjectiles[num].rec)
									cntr2 := cntr
									cntr2.X += zproj.dirX * 5
									cntr2.Y += zproj.dirY * 5
									if playerProjectiles[num].name == "bunch of carrots" || playerProjectiles[num].name == "french fries" {
										zproj.rotation = AngleBetweenTwoPoints(cntr, cntr2) - 90
									} else {
										zproj.rotation = AngleBetweenTwoPoints(cntr, cntr2) + 45
									}
								}
								break
							}
							countbreak--
							if countbreak == 0 {
								break
							}
						}
						zproj.crec = zproj.rec
						zproj.bounce += basketballnum
						playerProjectiles = append(playerProjectiles, zproj)
					}
				}
				//DRAWING PIN
				if playerProjectiles[num].name == "drawing pin" {
					levels[levNum].enemies[enNum].freezeT += fps * 2
				}
				//FART FIRE
				if playerProjectiles[num].name == "fartfire" || playerProjectiles[num].name == "pigProj" {
					if levels[levNum].enemies[enNum].name == "flamehead" || levels[levNum].enemies[enNum].name == "yellowdino" || levels[levNum].enemies[enNum].name == "ghost" || levels[levNum].enemies[enNum].name == "reddevil" {
						if msgT == 0 {
							admsg("immune to burn", rl.Yellow)
							msgT = fps
						}
					} else {
						levels[levNum].enemies[enNum].burnT = fps * 3
					}
				}
				//MAGNIFYING GLASS
				if playerProjectiles[num].name == "magnifying glass" && !levels[levNum].enemies[enNum].xl {
					levels[levNum].enemies[enNum].xl = true
					W := levels[levNum].enemies[enNum].rectangle.Width * 1.5
					H := levels[levNum].enemies[enNum].rectangle.Height * 1.5
					levels[levNum].enemies[enNum].rectangle = rl.NewRectangle(levels[levNum].enemies[enNum].cnt.X-W/2, levels[levNum].enemies[enNum].cnt.Y-H/2, W, H)

				}
				//CHILLI FLAME
				if playerProjectiles[num].name == "chilli" {
					num2 := RandInt(3, 7)
					countbreak := 100
					for num2 > 0 {
						cntr := makecnt(playerProjectiles[num].rec)
						cntr.X += RandF32(-b2, b2)
						cntr.Y += RandF32(-b2, b2)
						if checkV2Walls(cntr) && checkV2inRooms(cntr) {
							rl.PlaySound(audfx[120])
							zfx := Effect{}
							zfx.name = "flamingoflame"
							zfx.fade = 0.8
							siz := b + b/2
							zfx.imageRectangle = animation[98].rectangle
							zfx.rectangle = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
							zfx.collisionRectangle = zfx.rectangle
							zfx.collisionRectangle.X += zfx.collisionRectangle.Width / 8
							zfx.collisionRectangle.Y += zfx.collisionRectangle.Height / 8
							zfx.collisionRectangle.Width -= zfx.collisionRectangle.Width / 4
							zfx.collisionRectangle.Height -= zfx.collisionRectangle.Height / 4
							zfx.timer = fps * 3
							zfx.isBelow = true
							effect = append(effect, zfx)
							num2--
						}
						countbreak--
						if countbreak == 0 {
							break
						}
					}
				}
				//MINT ICE CREAM
				if playerProjectiles[num].name == "mint ice cream" {
					siz := b5
					zfx := Effect{}
					zfx.imageRectangle = splat[RandInt(0, len(splat))]
					zfx.name = "icecream"
					zfx.center = levels[levNum].enemies[enNum].cnt
					zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
					zfx.collisionRectangle = zfx.rectangle
					zfx.collisionRectangle.X += zfx.collisionRectangle.Width / 8
					zfx.collisionRectangle.Y += zfx.collisionRectangle.Height / 8
					zfx.collisionRectangle.Width -= zfx.collisionRectangle.Width / 4
					zfx.collisionRectangle.Height -= zfx.collisionRectangle.Height / 4
					zfx.fade = 0.7
					zfx.isBelow = true
					effect = append(effect, zfx)
				}
				//STUN
				if tenderisernum > 0 && levels[levNum].enemies[enNum].stunT == 0 {
					if Roll6() <= tenderisernum {
						levels[levNum].enemies[enNum].stunT = fps
						levels[levNum].enemies[enNum].stunF = 0.9
						levels[levNum].enemies[enNum].stunY = levels[levNum].enemies[enNum].cnt.Y
						levels[levNum].enemies[enNum].stunSiz = b / 4
					}
				}
				//POISON GAS
				if broccolinum > 0 {
					if Roll6() <= broccolinum {
						zproj := Weapon{}
						zproj.T = fps * 5
						siz := b4
						zproj.rec = rl.NewRectangle(levels[levNum].enemies[enNum].cnt.X-siz/2, levels[levNum].enemies[enNum].cnt.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.crec.X += zproj.crec.Width / 4
						zproj.crec.Y += zproj.crec.Height / 4
						zproj.crec.Width = zproj.crec.Width / 2
						zproj.crec.Height = zproj.crec.Height / 2
						zproj.image = animation[76].rectangle
						zproj.center = makecnt(zproj.rec)
						zproj.fade = 1
						zproj.col = rl.White
						zproj.rotationSpeed = RandF32(2, 4)
						if FlipCoin() {
							zproj.rotationSpeed = -zproj.rotationSpeed
						}
						zproj.damage = 1
						zproj.speed = 4
						zproj.dirX = RandF32(-zproj.speed, zproj.speed)
						zproj.dirY = RandF32(-zproj.speed, zproj.speed)
						zproj.name = "poisongas"
						playerProjectiles = append(playerProjectiles, zproj)
					}
				}
				//BLEED
				if bloodT > 0 {
					if levels[levNum].enemies[enNum].name == "flamehead" || levels[levNum].enemies[enNum].name == "skeleton" || levels[levNum].enemies[enNum].name == "ghost" || levels[levNum].enemies[enNum].name == "robot" {
						if msgT == 0 {
							admsg("immune to bleed", rl.Yellow)
							msgT = fps
						}
					} else {
						levels[levNum].enemies[enNum].bleed++
						levels[levNum].enemies[enNum].bleedT = fps * 2
					}
				}
				//GAS
				if gasT > 0 {
					if levels[levNum].enemies[enNum].name == "flamehead" || levels[levNum].enemies[enNum].name == "yellowdino" || levels[levNum].enemies[enNum].name == "ghost" || levels[levNum].enemies[enNum].name == "reddevil" {
						if msgT == 0 {
							admsg("immune to burn", rl.Yellow)
							msgT = fps
						}
					} else {
						levels[levNum].enemies[enNum].burnT = fps * 3
					}
				}
				//CRIT
				if stats.critical > 0 {
					if Roll6() <= stats.critical {
						levels[levNum].enemies[enNum].hp -= playerProjectiles[num].damage + (stats.strength - 1)
						if msgT == 0 {
							admsg("critical hit x2 damage", rl.Magenta)
							msgT = fps
						}
					}
				}

				if levels[levNum].enemies[enNum].name == "crocodile" || levels[levNum].enemies[enNum].name == "redantenna" {
					levels[levNum].enemies[enNum].stunT = fps
					levels[levNum].enemies[enNum].stunF = 0.9
					levels[levNum].enemies[enNum].stunY = levels[levNum].enemies[enNum].cnt.Y
					levels[levNum].enemies[enNum].stunSiz = b / 4
				}
				if levels[levNum].enemies[enNum].name == "spzman" {
					levels[levNum].enemies[enNum].moveChangeT = 0
					levels[levNum].enemies[enNum].state = 2
					if boss.lr {
						boss.image = animation[129].rectangle
					} else {
						boss.image = animation[128].rectangle
					}
				}
			}
		}

		if !nohpT {
			if playerProjectiles[num].name != "frogProj" && playerProjectiles[num].name != "chickenProj" && playerProjectiles[num].name != "poisongas" {
				//SPLINTERS
				if playerProjectiles[num].name == "rolling pin" {
					siz := be3
					spd := float32(7)
					zproj := Weapon{}
					zproj.image = otherTiles[162]
					zproj.damage = 1
					zproj.center = levels[levNum].enemies[enNum].cnt
					zproj.rec = rl.NewRectangle(zproj.center.X-siz/2, zproj.center.Y-siz/2, siz, siz)
					zproj.crec = zproj.rec
					zproj.center = makecnt(zproj.rec)
					zproj.fade = 1
					zproj.col = rl.White
					zproj.name = "splinter"
					zproj.dirY = -spd
					zproj.rotation -= 90
					playerProjectiles = append(playerProjectiles, zproj)
					zproj.rotation += 180
					zproj.dirY = spd
					playerProjectiles = append(playerProjectiles, zproj)
					zproj.rotation = 0
					zproj.dirY = 0
					zproj.dirX = spd
					playerProjectiles = append(playerProjectiles, zproj)
					zproj.rotation = 180
					zproj.dirX = -spd
					playerProjectiles = append(playerProjectiles, zproj)
					zproj.rotation = -45
					zproj.dirX = spd
					zproj.dirY = -spd
					playerProjectiles = append(playerProjectiles, zproj)
					zproj.rotation = 45
					zproj.dirX = spd
					zproj.dirY = spd
					playerProjectiles = append(playerProjectiles, zproj)
					zproj.rotation = -135
					zproj.dirX = -spd
					zproj.dirY = -spd
					playerProjectiles = append(playerProjectiles, zproj)
					zproj.rotation = 135
					zproj.dirX = -spd
					zproj.dirY = spd
					playerProjectiles = append(playerProjectiles, zproj)

					levels[levNum].enemies[enNum].stunT = fps
					levels[levNum].enemies[enNum].stunF = 0.9
					levels[levNum].enemies[enNum].stunY = levels[levNum].enemies[enNum].cnt.Y
					levels[levNum].enemies[enNum].stunSiz = b / 4
				}
				//FRYING PAN SHOCK
				if playerProjectiles[num].name == "frying pan" {
					rl.PlaySound(audfx[105])
					zfx := Effect{}
					zfx.name = "fryingShock"
					zfx.rectangle = playerProjectiles[num].rec
					zfx.rectangle.X -= b4
					zfx.rectangle.Y -= b4
					zfx.rectangle.Width += b8
					zfx.rectangle.Height += b8
					zfx.imageRectangle = animation[178].rectangle
					effect = append(effect, zfx)
				}
				//RUBBER DUCK BOUNCE
				if playerProjectiles[num].name == "rubber duck" {
					playerProjectiles[num].collisionTimer = fps / 8
					countbreak := 100
					for {
						playerProjectiles[num].dirX = RandF32(-playerProjectiles[num].speed, playerProjectiles[num].speed)
						playerProjectiles[num].dirY = RandF32(-playerProjectiles[num].speed, playerProjectiles[num].speed)
						if Abs(playerProjectiles[num].dirX) > playerProjectiles[num].speed/2 && Abs(playerProjectiles[num].dirY) > playerProjectiles[num].dirY/2 {
							break
						}
						countbreak--
						if countbreak == 0 {
							break
						}
					}
				} else {
					if playerProjectiles[num].name == "pineapple" {
						zfx := Effect{}
						zfx.imageRectangle = animation[179].rectangle
						zfx.rectangle = playerProjectiles[num].rec
						zfx.name = "pineapple"
						effect = append(effect, zfx)
					}
				}
				playerProjectiles[num].isOff = true
			}
		}
		if levels[levNum].enemies[enNum].hp <= 0 && !levels[levNum].enemies[enNum].off && !isBossOn {
			player.xp += levels[levNum].enemies[enNum].xp
			if playerProjectiles[num].isXp {
				player.xp += levels[levNum].enemies[enNum].xp
			}
			makeEnDeathFx(enNum)
			levels[levNum].enemies[enNum].off = true
			//HOT SOUP
			if playerProjectiles[num].name == "hot soup" {
				siz := b8
				zfx := Effect{}
				zfx.imageRectangle = splat[RandInt(0, len(splat))]
				zfx.name = "hotsoup"
				zfx.center = levels[levNum].enemies[enNum].cnt
				zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
				zfx.collisionRectangle = zfx.rectangle
				zfx.collisionRectangle.X += zfx.collisionRectangle.Width / 8
				zfx.collisionRectangle.Y += zfx.collisionRectangle.Height / 8
				zfx.collisionRectangle.Width -= zfx.collisionRectangle.Width / 4
				zfx.collisionRectangle.Height -= zfx.collisionRectangle.Height / 4
				zfx.fade = 1
				zfx.isBelow = true
				effect = append(effect, zfx)
			}
			//FRENCH FRIES
			if playerProjectiles[num].name == "french fries" {
				siz := b7
				zfx := Effect{}
				zfx.imageRectangle = splat[RandInt(0, len(splat))]
				zfx.name = "frenchfries"
				zfx.center = levels[levNum].enemies[enNum].cnt
				zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
				zfx.collisionRectangle = zfx.rectangle
				zfx.collisionRectangle.X += zfx.collisionRectangle.Width / 8
				zfx.collisionRectangle.Y += zfx.collisionRectangle.Height / 8
				zfx.collisionRectangle.Width -= zfx.collisionRectangle.Width / 4
				zfx.collisionRectangle.Height -= zfx.collisionRectangle.Height / 4
				zfx.fade = 1
				zfx.isBelow = true
				effect = append(effect, zfx)
			}

			//SLUDGE GEYSER
			if playerProjectiles[num].isSludgeGeyser {
				if Roll12() > 9 {
					rl.PlaySound(audfx[113])
					siz := b3
					zfx := Effect{}
					zfx.isBelow = true
					zfx.name = "sludgegeyser"
					zfx.imageRectangle = animation[203].rectangle
					num := RandInt(15, 21)
					for num > 0 {
						cntr := findRanCnt()
						zfx.rectangle = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
						effect = append(effect, zfx)
						num--
					}
				}
			}
			//RING OF FIRE
			if playerProjectiles[num].isRingOfFire {
				if Roll12() > 9 {
					rl.PlaySound(audfx[112])
					siz := b2
					zfx := Effect{}
					zfx.name = "ringoffire"
					zfx.rectangle = rl.NewRectangle(levels[levNum].enemies[enNum].cnt.X-siz/2, levels[levNum].enemies[enNum].cnt.Y-siz/2, siz, siz)
					zfx.imageRectangle = animation[202].rectangle
					effect = append(effect, zfx)
				}
			}
			//POTION
			if playerProjectiles[num].isPotion {
				if Roll12() > 9 {
					rl.PlaySound(audfx[110])
					zitm := itemList[RandInt(0, 18)]
					siz := zitm.rectangle.Width
					zitm.rectangle = rl.NewRectangle(levels[levNum].enemies[enNum].cnt.X-siz/2, levels[levNum].enemies[enNum].cnt.Y-siz/2, siz, siz)
					levels[levNum].items = append(levels[levNum].items, zitm)
				}
			}
			//BOMB
			if playerProjectiles[num].isBomb {
				if Roll12() > 9 {
					rl.PlaySound(audfx[110])
					siz := bq3
					zfx := Effect{}
					zfx.imageRectangle = otherTiles[123]
					zfx.rectangle = rl.NewRectangle(levels[levNum].enemies[enNum].cnt.X-siz/2, levels[levNum].enemies[enNum].cnt.Y-siz/2, siz, siz)
					zfx.name = "bomb"
					zfx.timer = fps * 3
					zfx.isBelow = true
					effect = append(effect, zfx)
				}
			}
			//TURRET
			if playerProjectiles[num].isTurret {
				if Roll12() > 9 {
					rl.PlaySound(audfx[110])
					if FlipCoin() {
						siz := bq3
						ztile := Tile{}
						ztile.image = otherTiles[112]
						ztile.rectangle = rl.NewRectangle(levels[levNum].enemies[enNum].cnt.X-siz/2, levels[levNum].enemies[enNum].cnt.Y-siz/2, siz, siz)
						ztile.name = "ladybugturret"
						ztile.center = makecnt(ztile.rectangle)
						ztile.vector = ztile.center
						ztile.vector.X += b
						ztile.vector.Y -= b
						ztile.angle = 0
						ztile.moveTimer = fps
						ztile.rotation = 0
						levels[levNum].otherTiles = append(levels[levNum].otherTiles, ztile)
					} else {
						siz := bq3
						ztile := Tile{}
						ztile.image = otherTiles[122]
						ztile.rectangle = rl.NewRectangle(levels[levNum].enemies[enNum].cnt.X-siz/2, levels[levNum].enemies[enNum].cnt.Y-siz/2, siz, siz)
						ztile.name = "popcornturret"
						ztile.center = makecnt(ztile.rectangle)
						ztile.vector = ztile.center
						ztile.vector.X += b
						ztile.vector.Y -= b
						ztile.moveTimer = fps
						levels[levNum].otherTiles = append(levels[levNum].otherTiles, ztile)
					}
				}
			}

		} else {
			rl.PlaySound(audfx[8])
			if !levels[levNum].enemies[enNum].nodmg && !nohpT {
				levels[levNum].enemies[enNum].hpT = fps
				levels[levNum].enemies[enNum].hpY = bq3
				levels[levNum].enemies[enNum].hpY2 = 0
				if isBossOn {
					levels[levNum].enemies[enNum].hpY = b
					levels[levNum].enemies[enNum].hpY2 = b / 2
				}
			}
			//LIGHTNING
			if playerProjectiles[num].isLightning && !isBossOn {
				rl.PlaySound(audfx[107])
				lightningEnm = nil
				checkrec := rl.NewRectangle(player.center.X-b10, player.center.Y-b10, b10*2, b10*2)
				for i := 0; i < len(levels[levNum].enemies); i++ {
					if rl.CheckCollisionPointRec(levels[levNum].enemies[i].cnt, checkrec) {
						lightningEnm = append(lightningEnm, i)
					}
				}
				lightningCount = fps / 3
			}
		}
	}

}

func oplr(num, nummax int, x, y float32) int { //MARK: OPTIONS LEFT RIGHT

	siz := b + be
	rec := rl.NewRectangle(x, y, siz, siz)
	rec.X -= siz
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		rl.DrawRectangleRec(rec, RandColor())
	} else {
		rl.DrawRectangleRec(rec, rl.Blue)
	}
	rl.DrawRectangleLinesEx(rec, 3, rl.Black)
	txs := tx3
	txt := "<<"
	txlen := rl.MeasureText(txt, txs)
	xtx := rec.ToInt32().X + rec.ToInt32().Width/2 - txlen/2
	cntr := makecnt(rec)
	ytx := int32(cntr.Y) - txs/2
	ytx += 1
	rl.DrawText(txt, xtx, ytx, txs, rl.Black)
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		if inpL {
			if num > 0 {
				num--
			} else if num == 0 {
				num = nummax
			}
		}
	}
	rec.X += siz
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		rl.DrawRectangleRec(rec, RandColor())
	} else {
		rl.DrawRectangleRec(rec, rl.Blue)
	}
	rl.DrawRectangleLinesEx(rec, 3, rl.Black)
	txt = ">>"
	txlen = rl.MeasureText(txt, txs)
	xtx = rec.ToInt32().X + rec.ToInt32().Width/2 - txlen/2
	cntr = makecnt(rec)
	ytx = int32(cntr.Y) - txs/2
	ytx += 1
	rl.DrawText(txt, xtx, ytx, txs, rl.Black)
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		if inpL {
			if num < nummax {
				num++
			} else if num == nummax {
				num = 0
			}
		}
	}

	return num
}
func opadj(num, nummax int, x, y float32, xl bool, numtype int) int { //MARK: OPTIONS ADJUST

	siz := b + be
	rec := rl.NewRectangle(x, y, siz, siz)
	rec.X -= siz * 2
	if xl {
		rec.X -= siz / 4
	}
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		rl.DrawRectangleRec(rec, RandColor())
	} else {
		rl.DrawRectangleRec(rec, rl.Blue)
	}
	rl.DrawRectangleLinesEx(rec, 3, rl.Black)
	txs := tx3
	txt := "<<"
	txlen := rl.MeasureText(txt, txs)
	xtx := rec.ToInt32().X + rec.ToInt32().Width/2 - txlen/2
	cntr := makecnt(rec)
	ytx := int32(cntr.Y) - txs/2
	ytx += 1
	rl.DrawText(txt, xtx, ytx, txs, rl.Black)
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		if inpL {
			rl.PlaySound(audfx[44])
			if num > 0 {
				num--
			}
			if numtype == 1 {
				if stickMov > 0 {
					stickMov -= 0.01
				}
			} else if numtype == 2 {
				if deadZ > 0 {
					deadZ -= 0.01
				}
			}
		}
	}

	rec.X += siz
	if xl {
		rec.Width += siz / 2
	}
	rl.DrawRectangleRec(rec, rl.Pink)
	rl.DrawRectangleLinesEx(rec, 3, rl.Black)
	txt = fmt.Sprint(num)
	txlen = rl.MeasureText(txt, txs)
	xtx = rec.ToInt32().X + rec.ToInt32().Width/2 - txlen/2
	cntr = makecnt(rec)
	ytx = int32(cntr.Y) - txs/2
	ytx += 1
	rl.DrawText(txt, xtx, ytx, txs, rl.Black)

	rec.X += rec.Width
	if xl {
		rec.Width -= siz / 2
	}
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		rl.DrawRectangleRec(rec, RandColor())
	} else {
		rl.DrawRectangleRec(rec, rl.Blue)
	}
	rl.DrawRectangleLinesEx(rec, 3, rl.Black)
	txt = ">>"
	txlen = rl.MeasureText(txt, txs)
	xtx = rec.ToInt32().X + rec.ToInt32().Width/2 - txlen/2
	cntr = makecnt(rec)
	ytx = int32(cntr.Y) - txs/2
	ytx += 1
	rl.DrawText(txt, xtx, ytx, txs, rl.Black)
	if rl.CheckCollisionPointRec(cursorV2camInven, rec) {
		if inpL {
			rl.PlaySound(audfx[44])
			if num < nummax {
				num++
			}
			if numtype == 1 {
				if stickMov < 0.99 {
					stickMov += 0.01
				}
			} else if numtype == 2 {
				if deadZ < 0.99 {
					deadZ += 0.01
				}
			}
		}
	}

	return num
}
func opswch(x, y float32, opt bool) { //MARK: OPTIONS SWITCH

	siz := b + be
	rec := rl.NewRectangle(x, y, siz, siz)
	rl.DrawRectangleRec(rec, rl.Blue)
	rl.DrawRectangleLinesEx(rec, 3, rl.Black)

	rec.X += 7
	rec.Y += 7
	rec.Width -= 14
	rec.Height -= 14
	if opt {
		rl.DrawRectangleRec(rec, DarkRed())
	} else {
		rl.DrawRectangleRec(rec, rl.Black)
	}
	rl.DrawRectangleLinesEx(rec, 2, rl.White)

}
func movestoreitm(num int) bool { //MARK: MOVE STORE ITEM

	found := false

	if storeItm[num].numof > 1 && storeItm[num].art {

		max := false
		num3 := storeItm[num].numof

		switch storeItm[num].name {
		//NON BOSS ARTIFACTS MUST ALSO BE ADDED TO COLLECT FROM CHEST

		case "rollo":
			if !rollo {
				rollo = true
				num3--
				max = true
				player.hpMax += 1
				player.hp += 1
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "landmine":
			if !landmine {
				landmine = true
				num3--
				max = true
				landmineT = fps * 7
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "batty":
			if !batty {
				batty = true
				num3--
				max = true
				player.hpMax += 1
				player.hp += 1
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "zombie head":
			if !zombiehead {
				zombiehead = true
				zombienum = 2
				if player.hp == player.hpMax {
					player.hp--
				}
				player.hpMax -= 1
				num3--
				max = true
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "pyroball":
			if !pyroball {
				pyroball = true
				num3--
				max = true
				pyroballT = fps * 7
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "space helmet":
			if spacehelmetnum == spacehelmetmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+spacehelmetnum <= spacehelmetmax {
					spacehelmetnum += num3
					for j := 0; j < num3; j++ {
						for i := 0; i < len(itemList); i++ {
							if !itemList[i].isNoCrate {
								if itemList[i].price >= 35 {
									itemList[i].price -= 25
								}
							}
						}
					}
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}

				} else if num3+spacehelmetnum > spacehelmetmax {
					max = true
					diff := spacehelmetmax - spacehelmetnum
					for j := 0; j < diff; j++ {
						for i := 0; i < len(itemList); i++ {
							if !itemList[i].isNoCrate {
								if itemList[i].price >= 35 {
									itemList[i].price -= 25
								}
							}
						}
					}
					num3 = (num3 + spacehelmetnum) - spacehelmetmax
					spacehelmetnum = spacehelmetmax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
			if spacehelmetnum < spacehelmetmax {
				spacehelmetnum++
				for i := 0; i < len(itemList); i++ {
					if !itemList[i].isNoCrate {
						if itemList[i].price >= 35 {
							itemList[i].price -= 25
						}
					}
				}
			} else {
				max = true
			}
		case "spinna":
			if !spinna {
				spinna = true
				num3--
				max = true
				spinnaT = fps * 7
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "mr frisbee's frisbee":
			if !mrfrisbee {
				mrfrisbee = true
				num3--
				max = true
				mrfrisbeeT = fps * 7
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "ice crystal":
			if !icecrystal {
				icecrystal = true
				num3--
				max = true
				icecrystalT = fps * 7
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}

		case "weapon case":
			if weaponcasenum == weaponcasemax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+weaponcasenum <= weaponcasemax {
					for i := 0; i < num3; i++ {
						player.weapons = append(player.weapons, Weapon{})
						weaponcasenum++
					}
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+weaponcasenum > weaponcasemax {
					max = true
					diff := int(weaponcasemax - weaponcasenum)
					num3 = (num3 + weaponcasenum) - weaponcasemax
					weaponcasenum = weaponcasemax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "umbrella":
			if !umbrella {
				umbrella = true
				num3--
				max = true
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "map chest pin":
			if !chestpin {
				chestpin = true
				num3--
				max = true
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "map exit pin":
			if !mappin {
				mappin = true
				num3--
				max = true
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "gas mask":
			if gasmasknum == gasmaskmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+int(gasmasknum) <= int(gasmaskmax) {
					gasmasknum += int32(num3)
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+int(gasmasknum) > int(gasmaskmax) {
					max = true
					diff := int(gasmaskmax - gasmasknum)
					num3 = (num3 + int(gasmasknum)) - int(gasmaskmax)
					gasmasknum = gasmaskmax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
				if gasmaskT == 0 {
					gasmaskT = fps*8 - (gasmasknum * fps)
				}
			}
		case "noodles":
			if !noodles {
				noodles = true
				num3--
				max = true
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "oven glove":
			if ovenglovenum == ovenglovemax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+ovenglovenum <= ovenglovemax {
					ovenglovenum += num3
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+ovenglovenum > ovenglovemax {
					max = true
					diff := int(ovenglovemax - ovenglovenum)
					num3 = (num3 + ovenglovenum) - ovenglovemax
					ovenglovenum = ovenglovemax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "toaster":
			if !toaster {
				toaster = true
				num3--
				max = true
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "ninja star":
			if ninjanum == ninjamax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+ninjanum <= ninjamax {
					ninjanum += num3
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+ninjanum > ninjamax {
					max = true
					diff := int(ninjamax - ninjanum)
					num3 = (num3 + ninjanum) - ninjamax
					ninjanum = ninjamax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "flamingo":
			if flamingonum == flamingomax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+int(flamingonum) <= int(flamingomax) {
					flamingonum += int32(num3)
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+int(flamingonum) > int(flamingomax) {
					max = true
					diff := int(flamingomax - flamingonum)
					num3 = (num3 + int(flamingonum)) - int(flamingomax)
					flamingonum = flamingomax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
				if flamingoT == 0 {
					flamingoT = (fps + fps/2) / flamingonum
				}
			}
		case "mug of tea":
			if teanum == teamax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+teanum <= teamax {
					teanum += num3
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+teanum > teamax {
					max = true
					diff := int(teamax - teanum)
					num3 = (num3 + teanum) - teamax
					teanum = teamax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "cloak of sparks":
			if !cloak {
				cloak = true
				num3--
				max = true
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "feather":
			if !feather {
				feather = true
				num3--
				max = true
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "mugging":
			if mugnum == mugmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+mugnum <= mugmax {
					mugnum += num3
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+mugnum > mugmax {
					max = true
					diff := int(mugmax - mugnum)
					num3 = (num3 + mugnum) - mugmax
					mugnum = mugmax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "lightbulb":
			if lightbulbnum == lightbulbmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+lightbulbnum <= lightbulbmax {
					lightbulbnum += num3
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+lightbulbnum > lightbulbmax {
					max = true
					diff := int(lightbulbmax - lightbulbnum)
					num3 = (num3 + mugnum) - lightbulbmax
					lightbulbnum = lightbulbmax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "candy cane":
			if candycanenum == candycanemax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+int(candycanenum) <= int(candycanemax) {
					candycanenum += int32(num3)
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+int(candycanenum) > int(candycanemax) {
					max = true
					diff := int(candycanemax - candycanenum)
					num3 = (num3 + int(candycanenum)) - int(candycanemax)
					candycanenum = candycanemax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "pearl":
			if pearlnum == pearlmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+pearlnum <= pearlmax {
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
					pearlnum += num3
					player.hpMax += num3
					player.hp += num3
				} else if num3+pearlnum > pearlmax {
					max = true
					diff := pearlmax - pearlnum
					num3 = (num3 + pearlnum) - pearlmax
					pearlnum = pearlmax
					player.hpMax += diff
					player.hp += diff
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "magicians hat":
			if magicianshatnum == magicianshatmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+magicianshatnum <= magicianshatmax {
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
					magicianshatnum += num3
					player.manaMax += num3
					player.mana += num3
				} else if num3+magicianshatnum > magicianshatmax {
					max = true
					diff := magicianshatmax - magicianshatnum
					num3 = (num3 + magicianshatnum) - magicianshatmax
					magicianshatnum = magicianshatmax
					player.manaMax += diff
					player.mana += diff
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "throwing knife":
			if throwingknifenum == throwingknifemax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+throwingknifenum <= throwingknifemax {
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
					throwingknifenum += num3
				} else if num3+throwingknifenum > throwingknifemax {
					max = true
					diff := throwingknifemax - throwingknifenum
					num3 = (num3 + throwingknifenum) - throwingknifemax
					throwingknifenum = throwingknifemax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "toxic sludge":
			if !toxic {
				toxic = true
				num3--
				max = true
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "mirror":
			if !mirror {
				mirror = true
				num3--
				max = true
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "belt of whipping":
			if beltnum == beltmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+beltnum <= beltmax {
					beltnum += num3
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+beltnum > beltmax {
					max = true
					diff := beltmax - beltnum
					num3 = (num3 + beltnum) - beltmax
					beltnum = beltmax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "amulet of disc":
			if !frisbee {
				frisbee = true
				num3--
				max = true
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "amulet of purple rain":
			if !purplerain {
				purplerain = true
				num3--
				max = true
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "tesla coil":
			if !tesla {
				tesla = true
				num3--
				max = true
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "ring of twin":
			if !twin {
				twin = true
				num3--
				max = true
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "ring of thorns":
			if !thornson {
				thornson = true
				num3--
				max = true
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "ring of vine":
			if !vineRing {
				vineRing = true
				if player.hp == 1 {
					player.hp = 2
				}
				num3--
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
				max = true
			} else {
				max = true
			}
		case "toilet paper":
			if toiletpapernum == toiletpapermax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+toiletpapernum <= toiletpapermax {
					toiletpapernum += num3
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+toiletpapernum > toiletpapermax {
					max = true
					diff := toiletpapermax - toiletpapernum
					num3 = (num3 + toiletpapernum) - toiletpapermax
					toiletpapernum = toiletpapermax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "bear trap":
			if beartrapnum == beartrapmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+beartrapnum <= beartrapmax {
					beartrapnum += num3
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+beartrapnum > beartrapmax {
					max = true
					diff := beartrapmax - beartrapnum
					num3 = (num3 + beartrapnum) - beartrapmax
					beartrapnum = beartrapmax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
				beartrapT = (fps * 12) - (int32(beartrapnum*2) * fps)
			}
		case "basketball sneakers":
			if stats.dexterity == 5 {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+stats.dexterity <= 5 {
					stats.dexterity += num3
					stats.dexterity2 = stats.dexterity
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+stats.dexterity > 5 {
					max = true
					diff := 5 - stats.dexterity
					num3 = (num3 + stats.dexterity) - 5
					stats.dexterity = 5
					stats.dexterity2 = stats.dexterity
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "dumbbell":
			if stats.strength == 5 {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+stats.strength <= 5 {
					stats.strength += num3
					stats.strength2 = stats.strength
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+stats.strength > 5 {
					max = true
					diff := 5 - stats.strength
					num3 = (num3 + stats.strength) - 5
					stats.strength = 5
					stats.strength2 = stats.strength
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "dice":
			if stats.luck == 5 {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+stats.luck <= 5 {
					stats.luck += num3
					stats.luck2 = stats.luck
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+stats.luck > 5 {
					max = true
					diff := 5 - stats.luck
					num3 = (num3 + stats.luck) - 5
					stats.luck = 5
					stats.luck2 = stats.luck
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "eyeball":
			if stats.perception == 5 {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+stats.perception <= 5 {
					stats.perception += num3
					stats.perception2 = stats.perception
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+stats.perception > 5 {
					max = true
					diff := 5 - stats.perception
					num3 = (num3 + stats.perception) - 5
					stats.perception = 5
					stats.perception2 = stats.perception
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "brain":
			if stats.intelligence == 5 {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+stats.intelligence <= 5 {
					stats.intelligence += num3
					stats.intelligence2 = stats.intelligence
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+stats.intelligence > 5 {
					max = true
					diff := 5 - stats.intelligence
					num3 = (num3 + stats.intelligence) - 5
					stats.intelligence = 5
					stats.intelligence2 = stats.intelligence
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "medikit":
			if medikitnum == medikitmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+medikitnum <= medikitmax {
					medikitnum += num3
					beartrapnum += num3
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+medikitnum > medikitmax {
					max = true
					diff := medikitmax - medikitnum
					num3 = (num3 + medikitnum) - medikitmax
					medikitnum = medikitmax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "backpack":
			if len(player.inventory) == inventoryMax {
				max = true
				admsg("inventory max", rl.Red)
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+len(player.inventory) <= inventoryMax {
					for i := 0; i < num3; i++ {
						player.inventory = append(player.inventory, Item{})
					}
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+len(player.inventory) > inventoryMax {
					max = true
					admsg("inventory max", rl.Red)
					diff := inventoryMax - len(player.inventory)
					for i := 0; i < diff; i++ {
						player.inventory = append(player.inventory, Item{})
					}
					num3 = (num3 + len(player.inventory)) - inventoryMax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "gas can":
			if gascannum == gascanmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+gascannum <= gascanmax {
					gascannum += num3
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+gascannum > gascanmax {
					max = true
					diff := gascanmax - gascannum
					num3 = (num3 + gascannum) - gascanmax
					gascannum = gascanmax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "bottle of death":
			if deathbottlenum == deathbottlemax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+deathbottlenum <= deathbottlemax {
					deathbottlenum += num3
					gascannum += num3
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+deathbottlenum > deathbottlemax {
					max = true
					diff := deathbottlemax - deathbottlenum
					num3 = (num3 + deathbottlenum) - deathbottlemax
					deathbottlenum = deathbottlemax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "cleaver":
			if cleavernum == cleavermax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+cleavernum <= cleavermax {
					cleavernum += num3
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+cleavernum > cleavermax {
					max = true
					diff := cleavermax - cleavernum
					num3 = (num3 + cleavernum) - cleavermax
					cleavernum = cleavermax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "tenderiser":
			if tenderisernum == tenderisermax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+tenderisernum <= tenderisermax {
					tenderisernum += num3
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+tenderisernum > tenderisermax {
					max = true
					diff := tenderisermax - tenderisernum
					num3 = (num3 + tenderisernum) - tenderisermax
					tenderisernum = tenderisermax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "garlic":
			if garlicnum == garlicmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+garlicnum <= garlicmax {
					garlicnum += num3
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+garlicnum > garlicmax {
					max = true
					diff := garlicmax - garlicnum
					num3 = (num3 + garlicnum) - garlicmax
					garlicnum = garlicmax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "drill":
			if !drillon {
				drillon = true
				num3--
				max = true
				storeItm[num].numof = 1
				player.art = append(player.art, storeItm[num])
			} else {
				max = true
			}
		case "broccoli":
			if broccolinum == broccolimax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+broccolinum <= broccolimax {
					broccolinum += num3
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+broccolinum > broccolimax {
					max = true
					diff := broccolimax - broccolinum
					num3 = (num3 + broccolinum) - broccolimax
					broccolinum = broccolimax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "basketball":
			if basketballnum == basketballmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+basketballnum <= basketballmax {
					basketballnum += num3
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+basketballnum > basketballmax {
					max = true
					diff := basketballmax - basketballnum
					num3 = (num3 + basketballnum) - basketballmax
					basketballnum = basketballmax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "sunglasses":
			if stats.critical == stats.critical2 {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+stats.critical <= stats.critical2 {
					stats.critical += num3
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+stats.critical > stats.critical2 {
					max = true
					diff := stats.critical2 - stats.critical
					num3 = (num3 + stats.critical) - stats.critical2
					stats.critical = stats.critical2
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}
		case "sneakers":
			if sneakersnum == sneakersmax {
				max = true
			} else {
				numArtSame, foundArt := foundsameart(storeItm[num].name)
				if num3+sneakersnum <= sneakersmax {
					sneakersnum += num3
					if player.speed2 < player.speedMax {
						player.speed2 += float32(num3)
						if player.speed2 > player.speedMax {
							player.speed2 = player.speedMax
						}
						player.speed = player.speed2
					}
					if foundArt {
						player.art[numArtSame].numof += num3
					} else {
						player.art = append(player.art, storeItm[num])
					}
				} else if num3+sneakersnum > sneakersmax {
					max = true
					diff := sneakersmax - sneakersnum
					player.speed2 = player.speedMax
					player.speed = player.speed2
					num3 = (num3 + sneakersnum) - sneakersmax
					sneakersnum = sneakersmax
					if foundArt {
						player.art[numArtSame].numof += diff
					} else {
						player.art = append(player.art, storeItm[num])
						player.art[len(player.art)-1].numof = diff
					}
				}
			}

		}

		if max {
			rl.PlaySound(audfx[121])
			if msgT == 0 {
				admsg("artifact > "+storeItm[num].name+" > max", rl.Red)
			}
			found = false
			for i := 0; i < len(player.inventory); i++ {
				if player.inventory[i].name == storeItm[num].name {
					player.inventory[i].numof += num3
					if msgT == 0 {
						admsg("in backpack > store for next run", rl.Magenta)
						msgT = fps
					}
					storeItm[num] = Item{}
					storeItm[num].isOff = true
					found = true
				}
			}
			if !found {
				if nxInvnNum != blankint {
					player.inventory[nxInvnNum] = storeItm[num]
					player.inventory[nxInvnNum].numof = num3
					findnxinvnum()
					if msgT == 0 {
						admsg("in backpack > store for next run", rl.Magenta)
						msgT = fps
					}
					storeItm[num] = Item{}
					storeItm[num].isOff = true
				} else {
					if msgT == 0 {
						admsg("inventory full > drop, stack or use", rl.Red)
						msgT = fps
					}
				}
			}
			msgT = fps / 2
		} else {
			rl.PlaySound(audfx[74])
			found, numSame := checkArtSameItm(storeItm[num])
			if found {
				player.art[numSame].numof += num3
			} else {
				storeItm[num].numof = num3
				player.art = append(player.art, storeItm[num])
			}
			admsg("collected artifact "+storeItm[num].name, rl.Magenta)
			storeItm[num] = Item{}
			storeItm[num].isOff = true
		}

	} else {

		found = false
		empty := blankint
		for i := 0; i < len(player.inventory); i++ {
			if empty == blankint {
				if player.inventory[i].name == "" {
					empty = i
				}
			}
			if player.inventory[i].name == storeItm[num].name {
				player.inventory[i].numof += storeItm[num].numof
				storeItm[num] = Item{}
				found = true
				break
			}
		}
		if !found && !storeItm[num].notquick && !storeItm[num].art {
			for i := 0; i < len(player.quik); i++ {
				if player.quik[i].name == storeItm[num].name {
					player.quik[i].numof += storeItm[num].numof
					storeItm[num] = Item{}
					found = true
					break
				}
			}
		}
		if !found && !storeItm[num].notquick && !storeItm[num].art {
			for i := 0; i < len(player.quik); i++ {
				if player.quik[i].name == "" {
					player.quik[i] = storeItm[num]
					storeItm[num] = Item{}
					found = true
					break
				}
			}
		}
		if !found && empty != blankint {
			player.inventory[empty] = storeItm[num]
			storeItm[num] = Item{}
			found = true
		}

	}

	upInvenClearArt()

	return found
}

func useitm(num, inven0quik1 int) { //MARK: USE ITEM
	audnum := 0
	itnm := ""
	remove := true
	if inven0quik1 == 0 {
		itnm = player.inventory[num].name
	} else {
		itnm = player.quik[num].name
	}
	switch itnm {
	case "salt":
		if saltT == 0 {
			rl.PlaySound(audfx[102])
			saltT = fps * 30
			if inven0quik1 == 0 {
				player.inventory[num].cooldownTimer = fps * 90
			} else {
				player.quik[num].cooldownTimer = fps * 90
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "fart gas":
		if fartT == 0 {
			rl.PlaySound(audfx[97])
			fartT = fps * 30
			if inven0quik1 == 0 {
				player.inventory[num].cooldownTimer = fps * 90
			} else {
				player.quik[num].cooldownTimer = fps * 90
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "boots":
		if bootsT == 0 {
			rl.PlaySound(audfx[96])
			bootsT = fps * 30
			if inven0quik1 == 0 {
				player.inventory[num].cooldownTimer = fps * 60
			} else {
				player.quik[num].cooldownTimer = fps * 60
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "psychedelics":
		if psychedelicsT == 0 {
			rl.PlaySound(audfx[95])
			psychedelicsT = fps * 60
			if inven0quik1 == 0 {
				player.inventory[num].cooldownTimer = fps * 60
			} else {
				player.quik[num].cooldownTimer = fps * 60
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "bomb":
		rl.PlaySound(audfx[93])
		zfx := Effect{}
		zfx.imageRectangle = otherTiles[123]
		zfx.rectangle = player.rectangle
		zfx.name = "bomb"
		zfx.timer = fps * 3
		zfx.isBelow = true
		effect = append(effect, zfx)
	case "popcorn":
		rl.PlaySound(audfx[87])
		siz := bq3
		ztile := Tile{}
		ztile.image = otherTiles[122]
		ztile.rectangle = rl.NewRectangle(player.center.X-siz/2, player.center.Y-siz/2, siz, siz)
		ztile.name = "popcornturret"
		ztile.center = makecnt(ztile.rectangle)
		ztile.vector = ztile.center
		ztile.vector.X += b
		ztile.vector.Y -= b
		ztile.moveTimer = fps
		levels[levNum].otherTiles = append(levels[levNum].otherTiles, ztile)
	case "fried eggs":
		if eggsT == 0 {
			rl.PlaySound(audfx[92])
			eggsT = fps * 60
			admsg("chicky boom boom", rl.Yellow)
			zproj := Weapon{}
			zproj.moveT = fps * 2
			siz := b
			zproj.rec = rl.NewRectangle(player.center.X-siz/2, player.center.Y-siz/2, siz, siz)
			zproj.crec = zproj.rec
			zproj.image = animation[102].rectangle
			zproj.center = makecnt(zproj.rec)
			zproj.fade = 1
			zproj.col = rl.White
			zproj.damage = 0
			zproj.speed = 2
			zproj.dirX = RandF32(-zproj.speed, zproj.speed)
			zproj.dirY = RandF32(-zproj.speed, zproj.speed)
			zproj.name = "chickenProj"
			playerProjectiles = append(playerProjectiles, zproj)
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "honeycomb":
		if honeycombT == 0 {
			rl.PlaySound(audfx[91])
			honeycombT = fps * 60
			admsg("buzzy bees", rl.Yellow)
			zproj := Weapon{}
			zproj.moveT = fps / 2
			siz := b / 2
			zproj.rec = rl.NewRectangle(player.center.X-siz/2, player.center.Y-siz/2, siz, siz)
			zproj.crec = zproj.rec
			zproj.image = animation[100].rectangle
			zproj.center = makecnt(zproj.rec)
			zproj.fade = 1
			zproj.col = rl.White
			zproj.damage = 5
			zproj.speed = 2
			zproj.dirX = RandF32(-zproj.speed, zproj.speed)
			zproj.dirY = RandF32(-zproj.speed, zproj.speed)
			zproj.name = "beeProj"
			for i := 0; i < 20; i++ {
				playerProjectiles = append(playerProjectiles, zproj)
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "lollipop":
		if lollipopT == 0 {
			rl.PlaySound(audfx[90])
			lollipopT = fps * 30
			admsg("mana regeneration", rl.Green)
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "television":
		if tvT == 0 {
			rl.PlaySound(audfx[89])
			tvT = fps * 10
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
		}
	case "orange slice":
		if orangeT == 0 {
			rl.PlaySound(audfx[88])
			orangeT = fps * 30
			admsg("health regeneration", rl.Green)
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "ladybug":
		rl.PlaySound(audfx[84])
		siz := bq3
		ztile := Tile{}
		ztile.image = otherTiles[112]
		ztile.rectangle = rl.NewRectangle(player.center.X-siz/2, player.center.Y-siz/2, siz, siz)
		ztile.name = "ladybugturret"
		ztile.center = makecnt(ztile.rectangle)
		ztile.vector = ztile.center
		ztile.vector.X += b
		ztile.vector.Y -= b
		ztile.angle = 0
		ztile.moveTimer = fps
		ztile.rotation = 0
		levels[levNum].otherTiles = append(levels[levNum].otherTiles, ztile)
	case "beetroot":
		if beetrootT == 0 {
			rl.PlaySound(audfx[83])
			beetrootT = fps * 3
			num2 := 20
			zfx := Effect{}
			zfx.name = "beetroot"
			zfx.imageRectangle = otherTiles[104]
			countbreak := 100
			siz := b4
			for num2 > 0 {
				v2 := player.center
				v2.X += RandF32(-b10, b10)
				v2.Y += RandF32(-b10, b10)
				if checkV2inRooms(v2) {
					zfx.v1 = append(zfx.v1, v2)
					zfx.rectangles2 = append(zfx.rectangles2, rl.NewRectangle(v2.X-siz/2, v2.Y-siz/2, siz, siz))
					v2.Y -= inRec.Height
					zfx.v2 = append(zfx.v2, v2)
					zfx.isOn = append(zfx.isOn, false)
					num2--
				}
				countbreak--
				if countbreak == 0 {
					break
				}
			}
			effect = append(effect, zfx)
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "quail egg":
		if quailT == 0 {
			rl.PlaySound(audfx[82])
			admsg("a blustery day", rl.Yellow)
			quailT = fps * 30
			zfx := Effect{}
			zfx.name = "tornado"
			zfx.imageRectangle = animation[90].rectangle
			zfx.rectangle = player.rectangle
			zfx.rectangle.X -= b
			zfx.rectangle.Y -= b
			zfx.rectangle.Width += b2
			zfx.rectangle.Height += b2
			zfx.collisionRectangle = zfx.rectangle
			zfx.collisionRectangle.X += zfx.collisionRectangle.Width / 4
			zfx.collisionRectangle.Width = zfx.collisionRectangle.Width - zfx.collisionRectangle.Width/2
			zfx.speed = 3
			countbreak := 100
			for {
				zfx.dirX = RandF32(-zfx.speed, zfx.speed)
				zfx.dirY = RandF32(-zfx.speed, zfx.speed)
				if Abs(zfx.dirX) > 1 || Abs(zfx.dirY) > 1 {
					break
				}
				countbreak--
				if countbreak == 0 {
					break
				}
			}
			zfx.center = makecnt(zfx.rectangle)
			effect = append(effect, zfx)
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "steroids":
		if steroidsT == 0 {
			rl.PlaySound(audfx[75])
			admsg("rambo returns", rl.Yellow)
			steroidsT = fps * 30
			stats.strength2 = stats.strength
			stats.strength = 5
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "scroll of power":
		canspell := false
		if inven0quik1 == 0 {
			if player.mana >= player.inventory[num].mana {
				player.mana -= player.inventory[num].mana
				canspell = true
			}
		} else {
			if player.mana >= player.quik[num].mana {
				player.mana -= player.quik[num].mana
				canspell = true
			}
		}
		if canspell {
			rl.PlaySound(audfx[72])
			admsg("i got the power", rl.Yellow)
			powerT = fps * 30
			stats.dexterity2 = stats.dexterity
			stats.intelligence2 = stats.intelligence
			stats.luck2 = stats.luck
			stats.perception2 = stats.perception
			stats.strength2 = stats.strength
			stats.dexterity = 5
			stats.intelligence = 5
			stats.luck = 5
			stats.perception = 5
			stats.strength = 5

			zfx := Effect{}
			zfx.imageRectangle = animation[186].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "scrollfx"
			effect = append(effect, zfx)
		} else {
			rl.PlaySound(audfx[43])
			admsg("not enough mana", rl.Red)
			remove = false
		}
	case "scroll of inflict":
		canspell := false
		if inven0quik1 == 0 {
			if player.mana >= player.inventory[num].mana {
				player.mana -= player.inventory[num].mana
				canspell = true
			}
		} else {
			if player.mana >= player.quik[num].mana {
				player.mana -= player.quik[num].mana
				canspell = true
			}
		}
		if canspell {
			rl.PlaySound(audfx[71])
			admsg("take that you nasty beasts", rl.Yellow)
			inflictT = fps / 2
			for i := 0; i < len(levels[levNum].enemies); i++ {
				if !levels[levNum].enemies[i].nodmg {
					levels[levNum].enemies[i].hp -= stats.intelligence
				}
				if levels[levNum].enemies[i].hp <= 0 && !levels[levNum].enemies[i].off {
					player.xp += levels[levNum].enemies[i].xp
					makeEnDeathFx(i)
					levels[levNum].enemies[i].off = true
				} else {
					if !levels[levNum].enemies[i].nodmg {
						levels[levNum].enemies[i].hpT = fps
						levels[levNum].enemies[i].hpY = bq3
						levels[levNum].enemies[i].hpY2 = 0
						if isBossOn {
							levels[levNum].enemies[i].hpY = b
							levels[levNum].enemies[i].hpY2 = b / 2
						}
					}
				}
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("not enough mana", rl.Red)
			remove = false
		}
	case "scroll of beginning":
		canspell := false
		if inven0quik1 == 0 {
			if player.mana >= player.inventory[num].mana {
				player.mana -= player.inventory[num].mana
				canspell = true
			}
		} else {
			if player.mana >= player.quik[num].mana {
				player.mana -= player.quik[num].mana
				canspell = true
			}
		}
		if canspell {
			rl.PlaySound(audfx[70])
			zfx := Effect{}
			zfx.imageRectangle = animation[186].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "scrollfx"
			effect = append(effect, zfx)

			admsg("back to the beginning", rl.Yellow)
			teleportT = fps / 2
			telCntr = true
		} else {
			rl.PlaySound(audfx[43])
			admsg("not enough mana", rl.Red)
			remove = false
		}
	case "scroll of home":
		canspell := false
		if inven0quik1 == 0 {
			if player.mana >= player.inventory[num].mana {
				player.mana -= player.inventory[num].mana
				canspell = true
			}
		} else {
			if player.mana >= player.quik[num].mana {
				player.mana -= player.quik[num].mana
				canspell = true
			}
		}
		if canspell {
			rl.PlaySound(audfx[69])
			zfx := Effect{}
			zfx.imageRectangle = animation[186].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "scrollfx"
			effect = append(effect, zfx)

			admsg("bye bye", rl.Yellow)
			teleportT = fps / 2
			telBase = true
		} else {
			rl.PlaySound(audfx[43])
			admsg("not enough mana", rl.Red)
			remove = false
		}
	case "scroll of detection":
		canspell := false
		if inven0quik1 == 0 {
			if player.mana >= player.inventory[num].mana {
				player.mana -= player.inventory[num].mana
				canspell = true
			}
		} else {
			if player.mana >= player.quik[num].mana {
				player.mana -= player.quik[num].mana
				canspell = true
			}
		}
		if canspell {
			zfx := Effect{}
			zfx.imageRectangle = animation[186].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "scrollfx"
			effect = append(effect, zfx)

			admsg("abracadabra", rl.Yellow)
			for i := 0; i < len(levels[levNum].items); i++ {
				if levels[levNum].items[i].isInvisible {
					levels[levNum].items[i].isInvisible = false
					zfx := Effect{}
					zfx.imageRectangle = animation[108].rectangle
					zfx.rectangle = levels[levNum].items[i].rectangle
					zfx.rectangle.X -= b
					zfx.rectangle.Y -= b
					zfx.rectangle.Width += b2
					zfx.rectangle.Height += b2
					zfx.name = "summonitem"
					effect = append(effect, zfx)
					admsg("invisible loot revealed", rl.Magenta)
				}
			}
			rl.PlaySound(audfx[39])
		} else {
			rl.PlaySound(audfx[43])
			admsg("not enough mana", rl.Red)
			remove = false
		}
	case "scroll of intangibility":
		canspell := false
		if inven0quik1 == 0 {
			if player.mana >= player.inventory[num].mana {
				player.mana -= player.inventory[num].mana
				canspell = true
			}
		} else {
			if player.mana >= player.quik[num].mana {
				player.mana -= player.quik[num].mana
				canspell = true
			}
		}
		if canspell {
			rl.PlaySound(audfx[68])
			zfx := Effect{}
			zfx.imageRectangle = animation[186].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "scrollfx"
			effect = append(effect, zfx)

			admsg("idclip", rl.Yellow)
			intangibleT = fps * 30
			if stats.intelligence > 1 {
				diff := stats.intelligence - 1
				for diff > 0 {
					diff--
					intangibleT += fps * 5
				}
				admsg("spell improved > intelligence", rl.Magenta)
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("not enough mana", rl.Red)
			remove = false
		}
	case "scroll of frogs":
		canspell := false
		if inven0quik1 == 0 {
			if player.mana >= player.inventory[num].mana {
				player.mana -= player.inventory[num].mana
				canspell = true
			}
		} else {
			if player.mana >= player.quik[num].mana {
				player.mana -= player.quik[num].mana
				canspell = true
			}
		}
		if canspell {
			rl.PlaySound(audfx[67])
			zfx := Effect{}
			zfx.imageRectangle = animation[186].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "scrollfx"
			effect = append(effect, zfx)

			admsg("reign in frogs", rl.Yellow)
			zproj := Weapon{}
			zproj.T = fps * 120
			zproj.moveT = fps / 6
			siz = b + b/2
			zproj.rec = rl.NewRectangle(player.center.X-siz/2, player.center.Y-siz/2, siz, siz)
			zproj.crec = zproj.rec
			zproj.crec.X += zproj.crec.Width / 4
			zproj.crec.Y += zproj.crec.Height / 4
			zproj.crec.Width = zproj.crec.Width / 2
			zproj.crec.Height = zproj.crec.Height / 2
			zproj.image = animation[78].rectangle
			zproj.center = makecnt(zproj.rec)
			zproj.fade = 1
			zproj.col = rl.White
			zproj.damage = 5
			zproj.speed = 2
			zproj.name = "frogProj"
			for i := 0; i < stats.intelligence*4; i++ {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			if stats.intelligence > 1 {
				admsg("spell improved > intelligence", rl.Magenta)
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("not enough mana", rl.Red)
			remove = false
		}
	case "scroll of poison gas":
		canspell := false
		if inven0quik1 == 0 {
			if player.mana >= player.inventory[num].mana {
				player.mana -= player.inventory[num].mana
				canspell = true
			}
		} else {
			if player.mana >= player.quik[num].mana {
				player.mana -= player.quik[num].mana
				canspell = true
			}
		}
		if canspell {
			rl.PlaySound(audfx[66])
			zfx := Effect{}
			zfx.imageRectangle = animation[186].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "scrollfx"
			effect = append(effect, zfx)

			admsg("excuse me i farted", rl.Yellow)
			zproj := Weapon{}
			zproj.T = fps * 30
			siz = b4
			zproj.rec = rl.NewRectangle(player.center.X-siz/2, player.center.Y-siz/2, siz, siz)
			zproj.crec = zproj.rec
			zproj.crec.X += zproj.crec.Width / 4
			zproj.crec.Y += zproj.crec.Height / 4
			zproj.crec.Width = zproj.crec.Width / 2
			zproj.crec.Height = zproj.crec.Height / 2
			zproj.image = animation[76].rectangle
			zproj.center = makecnt(zproj.rec)
			zproj.fade = 1
			zproj.col = rl.White
			zproj.rotationSpeed = RandF32(2, 4)
			if FlipCoin() {
				zproj.rotationSpeed = -zproj.rotationSpeed
			}
			zproj.damage = 1
			zproj.speed = 4
			zproj.dirX = RandF32(-zproj.speed, zproj.speed)
			zproj.dirY = RandF32(-zproj.speed, zproj.speed)
			zproj.name = "poisongas"
			playerProjectiles = append(playerProjectiles, zproj)
			if stats.intelligence > 1 {
				for i := 1; i < stats.intelligence; i++ {
					zproj.dirX = RandF32(-zproj.speed, zproj.speed)
					zproj.dirY = RandF32(-zproj.speed, zproj.speed)
					playerProjectiles = append(playerProjectiles, zproj)
				}
				admsg("spell improved > intelligence", rl.Magenta)
			}
		} else {
			rl.PlaySound(audfx[43])
			admsg("not enough mana", rl.Red)
			remove = false
		}
	case "armor potion quarter":
		if player.armorTimer == 0 {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			player.armorTimer = fps * 15
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "armor potion half":
		if player.armorTimer == 0 {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			player.armorTimer = fps * 30
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "armor potion full":
		if player.armorTimer == 0 {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			player.armorTimer = fps * 60
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "invisibility quarter":
		if player.invisibleTimer == 0 {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			player.invisibleTimer = fps * 30
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "invisibility half":
		if player.invisibleTimer == 0 {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			player.invisibleTimer = fps * 60
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "invisibility full":
		if player.invisibleTimer == 0 {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			player.invisibleTimer = fps * 90
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "resist poison quarter":
		if player.resistPoisonTimer == 0 {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			if player.poisonTimer > 0 {
				player.poisonTimer = 0
				admsg("poison cured", rl.Green)
			}
			player.resistPoisonTimer = fps * 30
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "resist poison half":
		if player.resistPoisonTimer == 0 {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			if player.poisonTimer > 0 {
				player.poisonTimer = 0
				admsg("poison cured", rl.Green)
			}
			player.resistPoisonTimer = fps * 60
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "resist poison full":
		if player.resistPoisonTimer == 0 {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			if player.poisonTimer > 0 {
				player.poisonTimer = 0
				admsg("poison cured", rl.Green)
			}
			player.resistPoisonTimer = fps * 120
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "resist fire quarter":
		if player.resistFireTimer == 0 {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			if player.burnTimer > 0 {
				player.burnTimer = 0
				admsg("flames extinguished", rl.Yellow)
			}
			player.burnTimer = 0
			player.resistFireTimer = fps * 30
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "resist fire half":
		if player.resistFireTimer == 0 {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			if player.burnTimer > 0 {
				player.burnTimer = 0
				admsg("flames extinguished", rl.Green)
			}
			player.resistFireTimer = fps * 60
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "resist fire full":
		if player.resistFireTimer == 0 {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			if player.burnTimer > 0 {
				player.burnTimer = 0
				admsg("flames extinguished", rl.Green)
			}
			player.resistFireTimer = fps * 120
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "mana potion quarter":
		if player.mana < player.manaMax {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			player.mana += 1
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("mana already full", rl.Red)
			remove = false
		}
	case "mana potion half":
		if player.mana < player.manaMax {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			player.mana += 2
			if player.mana > player.manaMax {
				player.mana = player.manaMax
			}
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("mana already full", rl.Red)
			remove = false
		}
	case "mana potion full":
		if player.mana < player.manaMax {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			player.mana = player.manaMax
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("mana already full", rl.Red)
			remove = false
		}
	case "hp potion quarter":
		if player.hp < player.hpMax {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			player.hp += 1
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("hp already full", rl.Red)
			remove = false
		}
	case "hp potion half":
		if player.hp < player.hpMax {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			player.hp += 3
			if player.hp > player.hpMax {
				player.hp = player.hpMax
			}
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("hp already full", rl.Red)
			remove = false
		}
	case "hp potion full":
		if player.hp < player.hpMax {
			zfx := Effect{}
			zfx.imageRectangle = animation[188].rectangle
			siz := b4
			zfx.center = player.center
			zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
			zfx.name = "potionfx"
			effect = append(effect, zfx)
			player.hp = player.hpMax
			player.poisonTimer = 0
			player.burnTimer = 0
			player.freezeTimer = 0
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("hp already full", rl.Red)
			remove = false
		}
	case "ice lolly":
		if icelollyT == 0 {
			rl.PlaySound(audfx[81])
			player.burnTimer = 0
			admsg("cool like a brussel sprout", rl.Yellow)
			icelollyT = fps * 15
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "jar of blood":
		if bloodT == 0 {
			admsg("count dracula", rl.Yellow)
			bloodT = fps * 30
			for i := 0; i < len(levels[levNum].enemies); i++ {
				levels[levNum].enemies[i].bleed = 0
			}
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "jar of gas":
		if gasT == 0 {
			admsg("burn baby burn", rl.Yellow)
			gasT = fps * 30
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "ice cream":
		if icecreamT == 0 {
			rl.PlaySound(audfx[80])
			admsg("use the opportunity", rl.Yellow)
			icecreamT = fps * 10
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "soda":
		if sodaT == 0 {
			admsg("boosted", rl.Yellow)
			sodaT = fps * 30
			if player.hp < player.hpMax {
				player.hp++
			}
			audnum = 1
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "turtle":
		if turtleT == 0 {
			rl.PlaySound(audfx[79])
			admsg("TMNT", rl.Yellow)
			turtleT = fps * 15
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "pistol":
		if pistolT == 0 {
			rl.PlaySound(audfx[78])
			admsg("attack, attack, attack!", rl.Yellow)
			pistolT = fps * 30
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "flask of slug pee":
		if slugT == 0 {
			admsg("run like the wind", rl.Yellow)
			slugT = fps * 30
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
		audnum = 1
	case "shrimp":
		if shrimpnum == 0 {
			rl.PlaySound(audfx[77])
			admsg("+3 shrimp shells", rl.Yellow)
			shrimpnum = 3
		} else {
			rl.PlaySound(audfx[43])
			admsg("currently active", rl.Red)
			remove = false
		}
	case "watch":
		rl.PlaySound(audfx[76])
		admsg("hurry up while you can", rl.Yellow)
		watchT = fps * 30
		if inven0quik1 == 0 {
			player.inventory[num].cooldownTimer = fps * 60
		} else {
			player.quik[num].cooldownTimer = fps * 60
		}

	case "long range scope":
		rl.PlaySound(audfx[73])
		admsg("enjoy the view", rl.Yellow)
		cam2Zorig = cam2.Zoom
		scopeZmax = cam2.Zoom - scopeZ
		if scopeZmax < 0.5 {
			scopeZmax = 0.5
		}
		scopeon = true
		scopeT = fps
		if inven0quik1 == 0 {
			player.inventory[num].cooldownTimer = fps * 10
		} else {
			player.quik[num].cooldownTimer = fps * 10
		}
	}
	//REMOVE FROM QUIK OR INVEN

	if remove {
		if itnm != "long range scope" && itnm != "watch" && itnm != "psychedelics" && itnm != "boots" && itnm != "fart gas" && itnm != "salt" {
			if inven0quik1 == 0 {
				if player.inventory[num].numof > 1 {
					player.inventory[num].numof--
				} else {
					player.inventory[num] = Item{}
				}
			} else {
				if player.quik[num].numof > 1 {
					player.quik[num].numof--
				} else {
					player.quik[num] = Item{}
				}
			}
		}
		switch audnum {
		case 1:
			rl.PlaySound(audfx[16])
		}
	}
}
func brec(rec rl.Rectangle, dist float32) rl.Rectangle { //MARK: MAKE BLUR REC
	rec.X += RandF32(-dist, dist)
	rec.Y += RandF32(-dist, dist)
	return rec
}
func packStore() { //MARK: PACK STORE
	invCopy := make([]Item, len(storeItm))
	copy(invCopy, storeItm)
	for i := 0; i < len(storeItm); i++ {
		storeItm[i] = Item{}
	}
	count := 0
	for i := 0; i < len(invCopy); i++ {
		if invCopy[i].name != "" {
			storeItm[count] = invCopy[i]
			count++
		}
	}
}
func pack() { //MARK: PACK
	invCopy := make([]Item, len(player.inventory))
	copy(invCopy, player.inventory)
	for i := 0; i < len(player.inventory); i++ {
		player.inventory[i] = Item{}
	}
	count := 0
	for i := 0; i < len(invCopy); i++ {
		if invCopy[i].name != "" {
			player.inventory[count] = invCopy[i]
			count++
		}
	}
	findnxinvnum()
}
func stackStore() { //MARK: STACK STORE
	found := false
	countbreak := 100
	for {
		for i := 0; i < len(storeItm); i++ {
			for j := 0; j < len(storeItm); j++ {
				if i != j {
					if storeItm[i].name == storeItm[j].name {
						found = true
					}
				}
			}
		}
		if found {
			for i := 0; i < len(storeItm); i++ {
				for j := 0; j < len(storeItm); j++ {
					if i != j {
						if storeItm[i].name == storeItm[j].name && !storeItm[j].isOff {
							storeItm[j].isOff = true
							storeItm[i].numof += storeItm[j].numof
							storeItm[j].numof = 0
							storeItm[j].name = ""
						}
					}
				}
			}
			found = false
			for i := 0; i < len(storeItm); i++ {
				if storeItm[i].isOff {
					storeItm[i] = Item{}
				}
			}
		}
		countbreak--
		if countbreak == 0 || !found {
			break
		}
	}
}
func stack() { //MARK: STACK
	found := false
	countbreak := 100
	for {
		for i := 0; i < len(player.inventory); i++ {
			for j := 0; j < len(player.inventory); j++ {
				if i != j {
					if player.inventory[i].name == player.inventory[j].name {
						found = true
					}
				}
			}
		}
		if found {
			for i := 0; i < len(player.inventory); i++ {
				for j := 0; j < len(player.inventory); j++ {
					if i != j {
						if player.inventory[i].name == player.inventory[j].name && !player.inventory[j].isOff {
							player.inventory[j].isOff = true
							player.inventory[i].numof += player.inventory[j].numof
							player.inventory[j].numof = 0
							player.inventory[j].name = ""
						}
					}
				}
			}
			found = false
			for i := 0; i < len(player.inventory); i++ {
				if player.inventory[i].isOff {
					player.inventory[i] = Item{}
				}
			}
		}
		countbreak--
		if countbreak == 0 || !found {
			break
		}
	}

	findnxinvnum()
}
func cleardoorblocks(lev x1scr) x1scr { //MARK: CLEAR DOOR BLOCKS
	clear := false
	for i := 0; i < len(lev.walls); i++ {
		for j := 0; j < len(lev.doors); j++ {
			if rl.CheckCollisionRecs(lev.doors[j], lev.walls[i].rectangle) {
				lev.walls[i].isOff = true
				clear = true
			}
		}
	}
	if clear {
		for i := 0; i < len(lev.walls); i++ {
			if lev.walls[i].isOff {
				lev.walls = RemoveTile(lev.walls, i)
			}
		}
	}
	return lev
}
func movequik2invn(num int) { //MARK: MOVE QUIK TO INVN
	found, numSame := checkInvnSameItm(player.quik[num])
	if found {
		player.inventory[numSame].numof++
	} else {
		player.inventory[nxInvnNum] = player.quik[num]
		findnxinvnum()
	}
	player.quik[num] = Item{}
}
func collectfromchest(chestnum, itemnum int) { //MARK: COLLECT FROM CHEST
	didnotadd := false
	if levels[levNum].chests[0].item[itemnum].name == "xp update" {
		rl.PlaySound(audfx[103])
		num4 := RandInt(200, 401)
		player.xp += num4
		levels[levNum].chests[0].item[itemnum] = Item{}
		levels[levNum].chests[0].item[itemnum].isOff = true
		admsg(fmt.Sprint(num4)+" xp added", rl.Green)
	} else {
		if levels[levNum].chests[0].item[itemnum].art {

			if levels[levNum].chests[0].item[itemnum].numof > 1 {

				max := false
				num3 := levels[levNum].chests[0].item[itemnum].numof

				switch levels[levNum].chests[0].item[itemnum].name {
				//NON BOSS ARTIFACTS MUST ALSO BE ADDED TO COLLECT FROM CHEST

				case "rollo":
					if !rollo {
						rollo = true
						num3--
						max = true
						player.hpMax += 1
						player.hp += 1
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "landmine":
					if !landmine {
						landmine = true
						num3--
						max = true
						landmineT = fps * 7
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "batty":
					if !batty {
						batty = true
						num3--
						max = true
						player.hpMax += 1
						player.hp += 1
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "zombie head":
					if !zombiehead {
						zombiehead = true
						zombienum = 2
						if player.hp == player.hpMax {
							player.hp--
						}
						player.hpMax -= 1
						num3--
						max = true
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "pyroball":
					if !pyroball {
						pyroball = true
						num3--
						max = true
						pyroballT = fps * 7
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "space helmet":
					if spacehelmetnum == spacehelmetmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+spacehelmetnum <= spacehelmetmax {
							spacehelmetnum += num3
							for j := 0; j < num3; j++ {
								for i := 0; i < len(itemList); i++ {
									if !itemList[i].isNoCrate {
										if itemList[i].price >= 35 {
											itemList[i].price -= 25
										}
									}
								}
							}
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}

						} else if num3+spacehelmetnum > spacehelmetmax {
							max = true
							diff := spacehelmetmax - spacehelmetnum
							for j := 0; j < diff; j++ {
								for i := 0; i < len(itemList); i++ {
									if !itemList[i].isNoCrate {
										if itemList[i].price >= 35 {
											itemList[i].price -= 25
										}
									}
								}
							}
							num3 = (num3 + spacehelmetnum) - spacehelmetmax
							spacehelmetnum = spacehelmetmax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
					if spacehelmetnum < spacehelmetmax {
						spacehelmetnum++
						for i := 0; i < len(itemList); i++ {
							if !itemList[i].isNoCrate {
								if itemList[i].price >= 35 {
									itemList[i].price -= 25
								}
							}
						}
					} else {
						max = true
					}
				case "spinna":
					if !spinna {
						spinna = true
						num3--
						max = true
						spinnaT = fps * 7
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "mr frisbee's frisbee":
					if !mrfrisbee {
						mrfrisbee = true
						num3--
						max = true
						mrfrisbeeT = fps * 7
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "ice crystal":
					if !icecrystal {
						icecrystal = true
						num3--
						max = true
						icecrystalT = fps * 7
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}

				case "weapon case":
					if weaponcasenum == weaponcasemax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+weaponcasenum <= weaponcasemax {
							for i := 0; i < num3; i++ {
								player.weapons = append(player.weapons, Weapon{})
								weaponcasenum++
							}
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+weaponcasenum > weaponcasemax {
							max = true
							diff := int(weaponcasemax - weaponcasenum)
							num3 = (num3 + weaponcasenum) - weaponcasemax
							weaponcasenum = weaponcasemax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "umbrella":
					if !umbrella {
						umbrella = true
						num3--
						max = true
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "map chest pin":
					if !chestpin {
						chestpin = true
						num3--
						max = true
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "map exit pin":
					if !mappin {
						mappin = true
						num3--
						max = true
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "gas mask":
					if gasmasknum == gasmaskmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+int(gasmasknum) <= int(gasmaskmax) {
							gasmasknum += int32(num3)
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+int(gasmasknum) > int(gasmaskmax) {
							max = true
							diff := int(gasmaskmax - gasmasknum)
							num3 = (num3 + int(gasmasknum)) - int(gasmaskmax)
							gasmasknum = gasmaskmax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
						if gasmaskT == 0 {
							gasmaskT = fps*8 - (gasmasknum * fps)
						}
					}
				case "noodles":
					if !noodles {
						noodles = true
						num3--
						max = true
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "oven glove":
					if ovenglovenum == ovenglovemax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+ovenglovenum <= ovenglovemax {
							ovenglovenum += num3
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+ovenglovenum > ovenglovemax {
							max = true
							diff := int(ovenglovemax - ovenglovenum)
							num3 = (num3 + ovenglovenum) - ovenglovemax
							ovenglovenum = ovenglovemax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "toaster":
					if !toaster {
						toaster = true
						num3--
						max = true
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "ninja star":
					if ninjanum == ninjamax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+ninjanum <= ninjamax {
							ninjanum += num3
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+ninjanum > ninjamax {
							max = true
							diff := int(ninjamax - ninjanum)
							num3 = (num3 + ninjanum) - ninjamax
							ninjanum = ninjamax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "flamingo":
					if flamingonum == flamingomax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+int(flamingonum) <= int(flamingomax) {
							flamingonum += int32(num3)
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+int(flamingonum) > int(flamingomax) {
							max = true
							diff := int(flamingomax - flamingonum)
							num3 = (num3 + int(flamingonum)) - int(flamingomax)
							flamingonum = flamingomax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
						if flamingoT == 0 {
							flamingoT = (fps + fps/2) / flamingonum
						}
					}
				case "mug of tea":
					if teanum == teamax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+teanum <= teamax {
							teanum += num3
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+teanum > teamax {
							max = true
							diff := int(teamax - teanum)
							num3 = (num3 + teanum) - teamax
							teanum = teamax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "cloak of sparks":
					if !cloak {
						cloak = true
						num3--
						max = true
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "feather":
					if !feather {
						feather = true
						num3--
						max = true
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "mugging":
					if mugnum == mugmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+mugnum <= mugmax {
							mugnum += num3
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+mugnum > mugmax {
							max = true
							diff := int(mugmax - mugnum)
							num3 = (num3 + mugnum) - mugmax
							mugnum = mugmax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "lightbulb":
					if lightbulbnum == lightbulbmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+lightbulbnum <= lightbulbmax {
							lightbulbnum += num3
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+lightbulbnum > lightbulbmax {
							max = true
							diff := int(lightbulbmax - lightbulbnum)
							num3 = (num3 + mugnum) - lightbulbmax
							lightbulbnum = lightbulbmax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "candy cane":
					if candycanenum == candycanemax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+int(candycanenum) <= int(candycanemax) {
							candycanenum += int32(num3)
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+int(candycanenum) > int(candycanemax) {
							max = true
							diff := int(candycanemax - candycanenum)
							num3 = (num3 + int(candycanenum)) - int(candycanemax)
							candycanenum = candycanemax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "pearl":
					if pearlnum == pearlmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+pearlnum <= pearlmax {
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
							pearlnum += num3
							player.hpMax += num3
							player.hp += num3
						} else if num3+pearlnum > pearlmax {
							max = true
							diff := pearlmax - pearlnum
							num3 = (num3 + pearlnum) - pearlmax
							pearlnum = pearlmax
							player.hpMax += diff
							player.hp += diff
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "magicians hat":
					if magicianshatnum == magicianshatmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+magicianshatnum <= magicianshatmax {
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
							magicianshatnum += num3
							player.manaMax += num3
							player.mana += num3
						} else if num3+magicianshatnum > magicianshatmax {
							max = true
							diff := magicianshatmax - magicianshatnum
							num3 = (num3 + magicianshatnum) - magicianshatmax
							magicianshatnum = magicianshatmax
							player.manaMax += diff
							player.mana += diff
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "throwing knife":
					if throwingknifenum == throwingknifemax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+throwingknifenum <= throwingknifemax {
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
							throwingknifenum += num3
						} else if num3+throwingknifenum > throwingknifemax {
							max = true
							diff := throwingknifemax - throwingknifenum
							num3 = (num3 + throwingknifenum) - throwingknifemax
							throwingknifenum = throwingknifemax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "toxic sludge":
					if !toxic {
						toxic = true
						num3--
						max = true
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "mirror":
					if !mirror {
						mirror = true
						num3--
						max = true
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "belt of whipping":
					if beltnum == beltmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+beltnum <= beltmax {
							beltnum += num3
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+beltnum > beltmax {
							max = true
							diff := beltmax - beltnum
							num3 = (num3 + beltnum) - beltmax
							beltnum = beltmax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "amulet of disc":
					if !frisbee {
						frisbee = true
						num3--
						max = true
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "amulet of purple rain":
					if !purplerain {
						purplerain = true
						num3--
						max = true
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "tesla coil":
					if !tesla {
						tesla = true
						num3--
						max = true
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "ring of twin":
					if !twin {
						twin = true
						num3--
						max = true
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "ring of thorns":
					if !thornson {
						thornson = true
						num3--
						max = true
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "ring of vine":
					if !vineRing {
						vineRing = true
						if player.hp == 1 {
							player.hp = 2
						}
						num3--
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
						max = true
					} else {
						max = true
					}
				case "toilet paper":
					if toiletpapernum == toiletpapermax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+toiletpapernum <= toiletpapermax {
							toiletpapernum += num3
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+toiletpapernum > toiletpapermax {
							max = true
							diff := toiletpapermax - toiletpapernum
							num3 = (num3 + toiletpapernum) - toiletpapermax
							toiletpapernum = toiletpapermax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "bear trap":
					if beartrapnum == beartrapmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+beartrapnum <= beartrapmax {
							beartrapnum += num3
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+beartrapnum > beartrapmax {
							max = true
							diff := beartrapmax - beartrapnum
							num3 = (num3 + beartrapnum) - beartrapmax
							beartrapnum = beartrapmax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
						beartrapT = (fps * 12) - (int32(beartrapnum*2) * fps)
					}
				case "basketball sneakers":
					if stats.dexterity == 5 {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+stats.dexterity <= 5 {
							stats.dexterity += num3
							stats.dexterity2 = stats.dexterity
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+stats.dexterity > 5 {
							max = true
							diff := 5 - stats.dexterity
							num3 = (num3 + stats.dexterity) - 5
							stats.dexterity = 5
							stats.dexterity2 = stats.dexterity
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "dumbbell":
					if stats.strength == 5 {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+stats.strength <= 5 {
							stats.strength += num3
							stats.strength2 = stats.strength
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+stats.strength > 5 {
							max = true
							diff := 5 - stats.strength
							num3 = (num3 + stats.strength) - 5
							stats.strength = 5
							stats.strength2 = stats.strength
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "dice":
					if stats.luck == 5 {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+stats.luck <= 5 {
							stats.luck += num3
							stats.luck2 = stats.luck
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+stats.luck > 5 {
							max = true
							diff := 5 - stats.luck
							num3 = (num3 + stats.luck) - 5
							stats.luck = 5
							stats.luck2 = stats.luck
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "eyeball":
					if stats.perception == 5 {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+stats.perception <= 5 {
							stats.perception += num3
							stats.perception2 = stats.perception
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+stats.perception > 5 {
							max = true
							diff := 5 - stats.perception
							num3 = (num3 + stats.perception) - 5
							stats.perception = 5
							stats.perception2 = stats.perception
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "brain":
					if stats.intelligence == 5 {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+stats.intelligence <= 5 {
							stats.intelligence += num3
							stats.intelligence2 = stats.intelligence
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+stats.intelligence > 5 {
							max = true
							diff := 5 - stats.intelligence
							num3 = (num3 + stats.intelligence) - 5
							stats.intelligence = 5
							stats.intelligence2 = stats.intelligence
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "medikit":
					if medikitnum == medikitmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+medikitnum <= medikitmax {
							medikitnum += num3
							beartrapnum += num3
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+medikitnum > medikitmax {
							max = true
							diff := medikitmax - medikitnum
							num3 = (num3 + medikitnum) - medikitmax
							medikitnum = medikitmax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "backpack":
					if len(player.inventory) == inventoryMax {
						max = true
						admsg("inventory max", rl.Red)
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+len(player.inventory) <= inventoryMax {
							for i := 0; i < num3; i++ {
								player.inventory = append(player.inventory, Item{})
							}
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+len(player.inventory) > inventoryMax {
							max = true
							admsg("inventory max", rl.Red)
							diff := inventoryMax - len(player.inventory)
							for i := 0; i < diff; i++ {
								player.inventory = append(player.inventory, Item{})
							}
							num3 = (num3 + len(player.inventory)) - inventoryMax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "gas can":
					if gascannum == gascanmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+gascannum <= gascanmax {
							gascannum += num3
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+gascannum > gascanmax {
							max = true
							diff := gascanmax - gascannum
							num3 = (num3 + gascannum) - gascanmax
							gascannum = gascanmax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "bottle of death":
					if deathbottlenum == deathbottlemax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+deathbottlenum <= deathbottlemax {
							deathbottlenum += num3
							gascannum += num3
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+deathbottlenum > deathbottlemax {
							max = true
							diff := deathbottlemax - deathbottlenum
							num3 = (num3 + deathbottlenum) - deathbottlemax
							deathbottlenum = deathbottlemax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "cleaver":
					if cleavernum == cleavermax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+cleavernum <= cleavermax {
							cleavernum += num3
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+cleavernum > cleavermax {
							max = true
							diff := cleavermax - cleavernum
							num3 = (num3 + cleavernum) - cleavermax
							cleavernum = cleavermax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "tenderiser":
					if tenderisernum == tenderisermax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+tenderisernum <= tenderisermax {
							tenderisernum += num3
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+tenderisernum > tenderisermax {
							max = true
							diff := tenderisermax - tenderisernum
							num3 = (num3 + tenderisernum) - tenderisermax
							tenderisernum = tenderisermax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "garlic":
					if garlicnum == garlicmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+garlicnum <= garlicmax {
							garlicnum += num3
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+garlicnum > garlicmax {
							max = true
							diff := garlicmax - garlicnum
							num3 = (num3 + garlicnum) - garlicmax
							garlicnum = garlicmax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "drill":
					if !drillon {
						drillon = true
						num3--
						max = true
						levels[levNum].chests[0].item[itemnum].numof = 1
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					} else {
						max = true
					}
				case "broccoli":
					if broccolinum == broccolimax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+broccolinum <= broccolimax {
							broccolinum += num3
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+broccolinum > broccolimax {
							max = true
							diff := broccolimax - broccolinum
							num3 = (num3 + broccolinum) - broccolimax
							broccolinum = broccolimax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "basketball":
					if basketballnum == basketballmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+basketballnum <= basketballmax {
							basketballnum += num3
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+basketballnum > basketballmax {
							max = true
							diff := basketballmax - basketballnum
							num3 = (num3 + basketballnum) - basketballmax
							basketballnum = basketballmax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "sunglasses":
					if stats.critical == stats.critical2 {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+stats.critical <= stats.critical2 {
							stats.critical += num3
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+stats.critical > stats.critical2 {
							max = true
							diff := stats.critical2 - stats.critical
							num3 = (num3 + stats.critical) - stats.critical2
							stats.critical = stats.critical2
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}
				case "sneakers":
					if sneakersnum == sneakersmax {
						max = true
					} else {
						numArtSame, foundArt := foundsameart(levels[levNum].chests[0].item[itemnum].name)
						if num3+sneakersnum <= sneakersmax {
							sneakersnum += num3
							if player.speed2 < player.speedMax {
								player.speed2 += float32(num3)
								if player.speed2 > player.speedMax {
									player.speed2 = player.speedMax
								}
								player.speed = player.speed2
							}
							if foundArt {
								player.art[numArtSame].numof += num3
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
							}
						} else if num3+sneakersnum > sneakersmax {
							max = true
							diff := sneakersmax - sneakersnum
							player.speed2 = player.speedMax
							player.speed = player.speed2
							num3 = (num3 + sneakersnum) - sneakersmax
							sneakersnum = sneakersmax
							if foundArt {
								player.art[numArtSame].numof += diff
							} else {
								player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
								player.art[len(player.art)-1].numof = diff
							}
						}
					}

				}

				if max {
					rl.PlaySound(audfx[121])
					if msgT == 0 {
						admsg("artifact > "+levels[levNum].chests[0].item[itemnum].name+" > max", rl.Red)
					}
					found := false
					for i := 0; i < len(player.inventory); i++ {
						if player.inventory[i].name == levels[levNum].chests[0].item[itemnum].name {
							player.inventory[i].numof += num3
							if msgT == 0 {
								admsg("in backpack > store for next run", rl.Magenta)
								msgT = fps
							}
							levels[levNum].chests[0].item[itemnum] = Item{}
							levels[levNum].chests[0].item[itemnum].isOff = true
							found = true
						}
					}
					if !found {
						if nxInvnNum != blankint {
							player.inventory[nxInvnNum] = levels[levNum].chests[0].item[itemnum]
							player.inventory[nxInvnNum].numof = num3
							findnxinvnum()
							if msgT == 0 {
								admsg("in backpack > store for next run", rl.Magenta)
								msgT = fps
							}
							levels[levNum].chests[0].item[itemnum] = Item{}
							levels[levNum].chests[0].item[itemnum].isOff = true
						} else {
							if msgT == 0 {
								admsg("inventory full > drop, stack or use", rl.Red)
								msgT = fps
							}
						}
					}
					msgT = fps / 2
				} else {
					rl.PlaySound(audfx[74])
					found, numSame := checkArtSameItm(levels[levNum].chests[0].item[itemnum])
					if found {
						player.art[numSame].numof += num3
					} else {
						levels[levNum].chests[0].item[itemnum].numof = num3
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					}
					admsg("collected artifact "+levels[levNum].chests[0].item[itemnum].name, rl.Magenta)
					levels[levNum].chests[0].item[itemnum] = Item{}
					levels[levNum].chests[0].item[itemnum].isOff = true
				}

			} else {

				max := false
				switch levels[levNum].chests[0].item[itemnum].name {
				case "rollo":
					if !rollo {
						rollo = true
						player.hpMax += 1
						player.hp += 1
					} else {
						max = true
					}
				case "landmine":
					if !landmine {
						landmine = true
						landmineT = fps * 7
					} else {
						max = true
					}
				case "batty":
					if !batty {
						batty = true
						player.hpMax += 1
						player.hp += 1
					} else {
						max = true
					}
				case "zombie head":
					if !zombiehead {
						zombiehead = true
						zombienum = 2
						if player.hp == player.hpMax {
							player.hp--
						}
						player.hpMax -= 1
					} else {
						max = true
					}
				case "pyroball":
					if !pyroball {
						pyroball = true
						pyroballT = fps * 7
					} else {
						max = true
					}
				case "space helmet":
					if spacehelmetnum < spacehelmetmax {
						spacehelmetnum++
						for i := 0; i < len(itemList); i++ {
							if !itemList[i].isNoCrate {
								if itemList[i].price >= 35 {
									itemList[i].price -= 25
								}
							}
						}
					} else {
						max = true
					}
				case "spinna":
					if !spinna {
						spinna = true
						spinnaT = fps * 7
					} else {
						max = true
					}
				case "mr frisbee's frisbee":
					if !mrfrisbee {
						mrfrisbee = true
						mrfrisbeeT = fps * 7
					} else {
						max = true
					}
				case "ice crystal":
					if !icecrystal {
						icecrystal = true
						icecrystalT = fps * 5
					} else {
						max = true
					}

				//NON BOSS ARTIFACTS MUST ALSO BE ADDED TO COLLECT FROM INVEN FOR DROP ARTIFACT
				case "weapon case":
					if weaponcasenum < weaponcasemax {
						player.weapons = append(player.weapons, Weapon{})
						weaponcasenum++
					} else {
						max = true
					}
				case "umbrella":
					if !umbrella {
						umbrella = true
					} else {
						max = true
					}
				case "map chest pin":
					if !chestpin {
						chestpin = true
					} else {
						max = true
					}
				case "map exit pin":
					if !mappin {
						mappin = true
					} else {
						max = true
					}
				case "gas mask":
					if gasmasknum < gasmaskmax {
						gasmasknum++
						if gasmaskT == 0 {
							gasmaskT = fps*8 - (gasmasknum * fps)
						}
					} else {
						max = true
					}
				case "noodles":
					if !noodles {
						noodles = true
					} else {
						max = true
					}
				case "oven glove":
					if ovenglovenum < ovenglovemax {
						ovenglovenum++
					} else {
						max = true
					}
				case "toaster":
					if !toaster {
						toaster = true
					} else {
						max = true
					}
				case "ninja star":
					if ninjanum < ninjamax {
						ninjanum++
					} else {
						max = true
					}
				case "flamingo":
					if flamingonum < flamingomax {
						flamingonum++
						if flamingoT == 0 {
							flamingoT = (fps + fps/2) / flamingonum
						}
					} else {
						max = true
					}
				case "mug of tea":
					if teanum < teamax {
						teanum++
					} else {
						max = true
					}
				case "cloak of sparks":
					if !cloak {
						cloak = true
					} else {
						max = true
					}
				case "feather":
					if !feather {
						feather = true
					} else {
						max = true
					}
				case "mugging":
					if mugnum < mugmax {
						mugnum++
					} else {
						max = true
					}
				case "lightbulb":
					if lightbulbnum < lightbulbmax {
						lightbulbnum++
					} else {
						max = true
					}
				case "candy cane":
					if candycanenum < candycanemax {
						candycanenum++
					} else {
						max = true
					}
				case "pearl":
					if pearlnum < pearlmax {
						pearlnum++
						player.hpMax++
						player.hp++
					} else {
						max = true
					}
				case "magicians hat":
					if magicianshatnum < magicianshatmax {
						magicianshatnum++
						player.manaMax++
						player.mana++
					} else {
						max = true
					}
				case "throwing knife":
					if throwingknifenum < throwingknifemax {
						throwingknifenum++
					} else {
						max = true
					}
				case "toxic sludge":
					if !toxic {
						toxic = true
					} else {
						max = true
					}
				case "mirror":
					if !mirror {
						mirror = true
					} else {
						max = true
					}
				case "belt of whipping":
					if beltnum < beltmax {
						beltnum++
					} else {
						max = true
					}
				case "amulet of disc":
					if !frisbee {
						frisbee = true
					} else {
						max = true
					}
				case "amulet of purple rain":
					if !purplerain {
						purplerain = true
					} else {
						max = true
					}
				case "tesla coil":
					if !tesla {
						tesla = true
					} else {
						max = true
					}
				case "ring of twin":
					if !twin {
						twin = true
					} else {
						max = true
					}
				case "ring of thorns":
					if !thornson {
						thornson = true
					} else {
						max = true
					}
				case "ring of vine":
					if !vineRing {
						vineRing = true
						if player.hp == 1 {
							player.hp = 2
						}
					} else {
						max = true
					}
				case "toilet paper":
					if toiletpapernum < toiletpapermax {
						toiletpapernum++
					} else {
						max = true
					}
				case "bear trap":
					if beartrapnum < beartrapmax {
						beartrapnum++
						beartrapT = (fps * 12) - (int32(beartrapnum*2) * fps)
					} else {
						max = true
					}
				case "basketball sneakers":
					if stats.dexterity < 5 {
						stats.dexterity++
						stats.dexterity2 = stats.dexterity
					} else {
						max = true
					}
				case "dumbbell":
					if stats.strength < 5 {
						stats.strength++
						stats.strength2 = stats.strength
					} else {
						max = true
					}
				case "dice":
					if stats.luck < 5 {
						stats.luck++
						stats.luck2 = stats.luck
					} else {
						max = true
					}
				case "eyeball":
					if stats.perception < 5 {
						stats.perception++
						stats.perception2 = stats.perception
					} else {
						max = true
					}
				case "brain":
					if stats.intelligence < 5 {
						stats.intelligence++
						stats.intelligence2 = stats.intelligence
					} else {
						max = true
					}
				case "medikit":
					if medikitnum < medikitmax {
						medikiton = true
					} else {
						max = true
					}
				case "backpack":
					if len(player.inventory) < inventoryMax {
						player.inventory = append(player.inventory, Item{})
					} else {
						max = true
						admsg("inventory max", rl.Red)
					}
				case "gas can":
					if gascannum < gascanmax {
						gascannum++
					} else {
						max = true
					}
				case "bottle of death":
					if deathbottlenum < deathbottlemax {
						deathbottlenum++
					} else {
						max = true
					}
				case "cleaver":
					if cleavernum < cleavermax {
						cleavernum++
					} else {
						max = true
					}
				case "tenderiser":
					if tenderisernum < tenderisermax {
						tenderisernum++
					} else {
						max = true
					}
				case "garlic":
					if garlicnum < garlicmax {
						garlicnum++
					} else {
						max = true
					}
				case "drill":
					if !drillon {
						drillon = true
					} else {
						max = true
					}
				case "broccoli":
					if broccolinum < broccolimax {
						broccolinum++
					} else {
						max = true
					}
				case "basketball":
					if basketballnum < basketballmax {
						basketballnum++
					} else {
						max = true
					}
				case "sunglasses":
					if stats.critical < stats.critical2 {
						stats.critical++
					} else {
						max = true
					}
				case "sneakers":
					if sneakersnum < sneakersmax {
						sneakersnum++
						if player.speed2 < player.speedMax {
							player.speed2++
							player.speed = player.speed2
						}
					} else {
						max = true
					}

				}
				if max {
					rl.PlaySound(audfx[121])
					admsg("artifact > "+levels[levNum].chests[0].item[itemnum].name+" > max", rl.Red)
					found := false
					for i := 0; i < len(player.inventory); i++ {
						if player.inventory[i].name == levels[levNum].chests[0].item[itemnum].name {
							player.inventory[i].numof++
							if msgT == 0 {
								admsg("in backpack > store for next run", rl.Magenta)
								msgT = fps
							}
							levels[levNum].chests[0].item[itemnum].isOff = true
							levels[levNum].chests[0].item[itemnum] = Item{}
							found = true
						}
					}
					if !found {
						if nxInvnNum != blankint {
							player.inventory[nxInvnNum] = levels[levNum].chests[0].item[itemnum]
							findnxinvnum()
							if msgT == 0 {
								admsg("in backpack > store for next run", rl.Magenta)
								msgT = fps
							}
							levels[levNum].chests[0].item[itemnum].isOff = true
							levels[levNum].chests[0].item[itemnum] = Item{}
						} else {
							if msgT == 0 {
								admsg("inventory full > drop, stack or use", rl.Red)
								msgT = fps
							}
						}
					}
				} else {
					rl.PlaySound(audfx[74])
					found, numSame := checkArtSameItm(levels[levNum].chests[0].item[itemnum])
					if found {
						player.art[numSame].numof++
					} else {
						player.art = append(player.art, levels[levNum].chests[0].item[itemnum])
					}
					admsg("collected artifact "+levels[levNum].chests[0].item[itemnum].name, rl.Magenta)
					levels[levNum].chests[0].item[itemnum].isOff = true
					levels[levNum].chests[0].item[itemnum] = Item{}
				}
			}
		} else {
			foundsame := false
			for i := 0; i < len(player.quik); i++ {
				if levels[levNum].chests[0].item[itemnum].name == player.quik[i].name {
					player.quik[i].numof += levels[levNum].chests[0].item[itemnum].numof
					foundsame = true
					break
				}
			}
			if !foundsame {
				for i := 0; i < len(player.inventory); i++ {
					if levels[levNum].chests[0].item[itemnum].name == player.inventory[i].name {
						levels[levNum].chests[0].item[itemnum].isOff = true
						levels[levNum].chests[0].item[itemnum] = Item{}
						player.inventory[i].numof += levels[levNum].chests[0].item[itemnum].numof
						foundsame = true
						break
					}
				}
			}
			if !foundsame {
				if nxQuikNum != blankint {
					if levels[levNum].chests[0].item[itemnum].notquick {
						player.inventory[nxInvnNum] = levels[levNum].chests[0].item[itemnum]
						levels[levNum].chests[0].item[itemnum].isOff = true
						levels[levNum].chests[0].item[itemnum] = Item{}
						findnxinvnum()
					} else {
						player.quik[nxQuikNum] = levels[levNum].chests[0].item[itemnum]
						levels[levNum].chests[0].item[itemnum].isOff = true
					}
				} else if nxQuikNum == blankint && nxInvnNum != blankint {
					player.inventory[nxInvnNum] = levels[levNum].chests[chestnum].item[itemnum]
					findnxinvnum()
				} else if nxQuikNum == blankint && nxInvnNum == blankint {
					if msgT == 0 {
						admsg("inventory full > drop, stack or use", rl.Red)
						msgT = fps
					}
					didnotadd = true
				}
			}
			if !didnotadd {
				admsg("collected "+levels[levNum].chests[chestnum].item[itemnum].name, rl.Magenta)
				levels[levNum].chests[0].item[itemnum].isOff = true
				levels[levNum].chests[0].item[itemnum] = Item{}
				rl.PlaySound(audfx[7])
			}
		}

	}

}
func checkaddscroll(num int) bool { //MARK: CHECK IF INVEN STORE FULL ADD SCROLL

	found2 := false
	foundQuik, _ := checkQuikSameItm(scrollList[num])
	if foundQuik {
		found2 = true
	} else if nxQuikNum != blankint && !foundQuik {
		found2 = true
	} else if nxQuikNum == blankint && nxInvnNum != blankint {
		found2 = true
	} else if nxQuikNum == blankint && nxInvnNum == blankint {
		found, _ := checkInvnSameItm(scrollList[num])
		if found {
			found2 = true
		}
		if !found2 {
			if isStoreUnlocked {
				for i := 0; i < len(storeItm); i++ {
					if storeItm[i].name == scrollList[num].name {
						found2 = true
						break
					}
				}
				if !found2 {
					for i := 0; i < len(storeItm); i++ {
						if storeItm[i].name == "" {
							found2 = true
							break
						}
					}
				}
			}
		}
	}
	return found2
}
func addscroll(num int) bool { //MARK: ADD CRAFTED SCROLL TO INVEN / STORE

	found2 := false
	foundQuik, numSame := checkQuikSameItm(scrollList[num])
	if foundQuik {
		player.quik[numSame].numof++
		found2 = true
	} else if nxQuikNum != blankint && !foundQuik {
		player.quik[nxQuikNum] = scrollList[num]
		found2 = true
	} else if nxQuikNum == blankint && nxInvnNum != blankint {
		found, numSame := checkInvnSameItm(scrollList[num])
		if found {
			player.inventory[numSame].numof++
		} else {
			player.inventory[nxInvnNum] = scrollList[num]
			findnxinvnum()
		}
		found2 = true
	} else if nxQuikNum == blankint && nxInvnNum == blankint {
		found, numSame := checkInvnSameItm(scrollList[num])
		if found {
			player.inventory[numSame].numof++
			found2 = true
		}
		if !found2 {
			if isStoreUnlocked {
				for i := 0; i < len(storeItm); i++ {
					if storeItm[i].name == scrollList[num].name {
						storeItm[i].numof++
						found2 = true
						break
					}
				}
				if !found2 {
					for i := 0; i < len(storeItm); i++ {
						if storeItm[i].name == "" {
							storeItm[i] = scrollList[num]
							found2 = true
							break
						}
					}
				}
			}
		}
	}
	return found2
}
func checkaddpotion(num int) bool { //MARK: CHECK STORE INVEN FULL ADD POTION

	found2 := false
	foundQuik, _ := checkQuikSameItm(potionList[num])
	if foundQuik {
		found2 = true
	} else if nxQuikNum != blankint && !foundQuik {
		found2 = true
	} else if nxQuikNum == blankint && nxInvnNum != blankint {
		found2 = true
	} else if nxQuikNum == blankint && nxInvnNum == blankint {
		found, _ := checkInvnSameItm(potionList[num])
		if found {
			found2 = true
		}
		if !found2 {
			if isStoreUnlocked {
				for i := 0; i < len(storeItm); i++ {
					if storeItm[i].name == potionList[num].name {
						found2 = true
						break
					}
				}
				if !found2 {
					for i := 0; i < len(storeItm); i++ {
						if storeItm[i].name == "" {
							found2 = true
							break
						}
					}
				}
			}
		}
	}
	return found2
}
func addpotion(num int) bool { //MARK: ADD CRAFTED POTION TO INVEN / STORE

	found2 := false
	foundQuik, numSame := checkQuikSameItm(potionList[num])
	if foundQuik {
		player.quik[numSame].numof++
		found2 = true
	} else if nxQuikNum != blankint && !foundQuik {
		player.quik[nxQuikNum] = potionList[num]
		found2 = true
	} else if nxQuikNum == blankint && nxInvnNum != blankint {
		found, numSame := checkInvnSameItm(potionList[num])
		if found {
			player.inventory[numSame].numof++
		} else {
			player.inventory[nxInvnNum] = potionList[num]
			findnxinvnum()
		}
		found2 = true
	} else if nxQuikNum == blankint && nxInvnNum == blankint {
		found, numSame := checkInvnSameItm(potionList[num])
		if found {
			player.inventory[numSame].numof++
			found2 = true
		}
		if !found2 {
			if isStoreUnlocked {
				for i := 0; i < len(storeItm); i++ {
					if storeItm[i].name == potionList[num].name {
						storeItm[i].numof++
						found2 = true
						break
					}
				}
				if !found2 {
					for i := 0; i < len(storeItm); i++ {
						if storeItm[i].name == "" {
							storeItm[i] = potionList[num]
							found2 = true
							break
						}
					}
				}
			}
		}
	}
	return found2
}
func collectinvn(num int) { //MARK: COLLECT INVENTORY QUICK SLOTS

	if levels[levNum].items[num].name == "xp update" {
		rl.PlaySound(audfx[103])
		num4 := RandInt(200, 401)
		player.xp += num4
		levels[levNum].items[num] = Item{}
		levels[levNum].items[num].isOff = true
		admsg(fmt.Sprint(num4)+" xp added", rl.Green)
	} else {
		didnotcollect := true
		if levels[levNum].items[num].notquick || !levels[levNum].items[num].notquick && nxQuikNum == blankint {
			foundQuik, numSame := checkQuikSameItm(levels[levNum].items[num])
			if foundQuik {
				player.quik[numSame].numof++
			} else {
				found, numSame := checkInvnSameItm(levels[levNum].items[num])
				if found {
					player.inventory[numSame].numof++
				} else {
					if nxInvnNum == blankint {
						if msgT == 0 {
							admsg("inventory full > drop, stack or use", rl.Red)
							msgT = fps
						}
						didnotcollect = false
					} else {
						player.inventory[nxInvnNum] = levels[levNum].items[num]
						findnxinvnum()
					}
				}
			}
		} else if !levels[levNum].items[num].notquick && nxQuikNum != blankint {
			foundQuik, numSame := checkQuikSameItm(levels[levNum].items[num])
			if foundQuik {
				player.quik[numSame].numof++
			} else {
				player.quik[nxQuikNum] = levels[levNum].items[num]
			}
		}

		if didnotcollect {
			txt := "collected " + levels[levNum].items[num].name
			if levels[levNum].items[num].numof > 1 {
				txt = "collected " + fmt.Sprint(levels[levNum].items[num].numof) + " " + levels[levNum].items[num].name
			}
			admsg(txt, rl.Green)
			levels[levNum].items[num] = Item{}
			levels[levNum].items[num].isOff = true
			pack()
			rl.PlaySound(audfx[1])
		}
	}
}
func collectart(num int) { //MARK: COLLECT ARTIFACT
	if !levels[levNum].items[num].isOff {

		if levels[levNum].items[num].numof > 1 {

			max := false
			num3 := levels[levNum].items[num].numof

			switch levels[levNum].items[num].name {
			//NON BOSS ARTIFACTS MUST ALSO BE ADDED TO COLLECT FROM CHEST

			case "rollo":
				if !rollo {
					rollo = true
					num3--
					max = true
					player.hpMax += 1
					player.hp += 1
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "landmine":
				if !landmine {
					landmine = true
					num3--
					max = true
					landmineT = fps * 7
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "batty":
				if !batty {
					batty = true
					num3--
					max = true
					player.hpMax += 1
					player.hp += 1
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "zombie head":
				if !zombiehead {
					zombiehead = true
					zombienum = 2
					if player.hp == player.hpMax {
						player.hp--
					}
					player.hpMax -= 1
					num3--
					max = true
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "pyroball":
				if !pyroball {
					pyroball = true
					num3--
					max = true
					pyroballT = fps * 7
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "space helmet":
				if spacehelmetnum == spacehelmetmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+spacehelmetnum <= spacehelmetmax {
						spacehelmetnum += num3
						for j := 0; j < num3; j++ {
							for i := 0; i < len(itemList); i++ {
								if !itemList[i].isNoCrate {
									if itemList[i].price >= 35 {
										itemList[i].price -= 25
									}
								}
							}
						}
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}

					} else if num3+spacehelmetnum > spacehelmetmax {
						max = true
						diff := spacehelmetmax - spacehelmetnum
						for j := 0; j < diff; j++ {
							for i := 0; i < len(itemList); i++ {
								if !itemList[i].isNoCrate {
									if itemList[i].price >= 35 {
										itemList[i].price -= 25
									}
								}
							}
						}
						num3 = (num3 + spacehelmetnum) - spacehelmetmax
						spacehelmetnum = spacehelmetmax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
				if spacehelmetnum < spacehelmetmax {
					spacehelmetnum++
					for i := 0; i < len(itemList); i++ {
						if !itemList[i].isNoCrate {
							if itemList[i].price >= 35 {
								itemList[i].price -= 25
							}
						}
					}
				} else {
					max = true
				}
			case "spinna":
				if !spinna {
					spinna = true
					num3--
					max = true
					spinnaT = fps * 7
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "mr frisbee's frisbee":
				if !mrfrisbee {
					mrfrisbee = true
					num3--
					max = true
					mrfrisbeeT = fps * 7
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "ice crystal":
				if !icecrystal {
					icecrystal = true
					num3--
					max = true
					icecrystalT = fps * 7
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}

			case "weapon case":
				if weaponcasenum == weaponcasemax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+weaponcasenum <= weaponcasemax {
						for i := 0; i < num3; i++ {
							player.weapons = append(player.weapons, Weapon{})
							weaponcasenum++
						}
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+weaponcasenum > weaponcasemax {
						max = true
						diff := int(weaponcasemax - weaponcasenum)
						num3 = (num3 + weaponcasenum) - weaponcasemax
						weaponcasenum = weaponcasemax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "umbrella":
				if !umbrella {
					umbrella = true
					num3--
					max = true
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "map chest pin":
				if !chestpin {
					chestpin = true
					num3--
					max = true
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "map exit pin":
				if !mappin {
					mappin = true
					num3--
					max = true
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "gas mask":
				if gasmasknum == gasmaskmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+int(gasmasknum) <= int(gasmaskmax) {
						gasmasknum += int32(num3)
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+int(gasmasknum) > int(gasmaskmax) {
						max = true
						diff := int(gasmaskmax - gasmasknum)
						num3 = (num3 + int(gasmasknum)) - int(gasmaskmax)
						gasmasknum = gasmaskmax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
					if gasmaskT == 0 {
						gasmaskT = fps*8 - (gasmasknum * fps)
					}
				}
			case "noodles":
				if !noodles {
					noodles = true
					num3--
					max = true
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "oven glove":
				if ovenglovenum == ovenglovemax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+ovenglovenum <= ovenglovemax {
						ovenglovenum += num3
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+ovenglovenum > ovenglovemax {
						max = true
						diff := int(ovenglovemax - ovenglovenum)
						num3 = (num3 + ovenglovenum) - ovenglovemax
						ovenglovenum = ovenglovemax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "toaster":
				if !toaster {
					toaster = true
					num3--
					max = true
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "ninja star":
				if ninjanum == ninjamax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+ninjanum <= ninjamax {
						ninjanum += num3
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+ninjanum > ninjamax {
						max = true
						diff := int(ninjamax - ninjanum)
						num3 = (num3 + ninjanum) - ninjamax
						ninjanum = ninjamax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "flamingo":
				if flamingonum == flamingomax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+int(flamingonum) <= int(flamingomax) {
						flamingonum += int32(num3)
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+int(flamingonum) > int(flamingomax) {
						max = true
						diff := int(flamingomax - flamingonum)
						num3 = (num3 + int(flamingonum)) - int(flamingomax)
						flamingonum = flamingomax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
					if flamingoT == 0 {
						flamingoT = (fps + fps/2) / flamingonum
					}
				}
			case "mug of tea":
				if teanum == teamax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+teanum <= teamax {
						teanum += num3
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+teanum > teamax {
						max = true
						diff := int(teamax - teanum)
						num3 = (num3 + teanum) - teamax
						teanum = teamax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "cloak of sparks":
				if !cloak {
					cloak = true
					num3--
					max = true
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "feather":
				if !feather {
					feather = true
					num3--
					max = true
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "mugging":
				if mugnum == mugmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+mugnum <= mugmax {
						mugnum += num3
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+mugnum > mugmax {
						max = true
						diff := int(mugmax - mugnum)
						num3 = (num3 + mugnum) - mugmax
						mugnum = mugmax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "lightbulb":
				if lightbulbnum == lightbulbmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+lightbulbnum <= lightbulbmax {
						lightbulbnum += num3
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+lightbulbnum > lightbulbmax {
						max = true
						diff := int(lightbulbmax - lightbulbnum)
						num3 = (num3 + mugnum) - lightbulbmax
						lightbulbnum = lightbulbmax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "candy cane":
				if candycanenum == candycanemax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+int(candycanenum) <= int(candycanemax) {
						candycanenum += int32(num3)
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+int(candycanenum) > int(candycanemax) {
						max = true
						diff := int(candycanemax - candycanenum)
						num3 = (num3 + int(candycanenum)) - int(candycanemax)
						candycanenum = candycanemax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "pearl":
				if pearlnum == pearlmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+pearlnum <= pearlmax {
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
						pearlnum += num3
						player.hpMax += num3
						player.hp += num3
					} else if num3+pearlnum > pearlmax {
						max = true
						diff := pearlmax - pearlnum
						num3 = (num3 + pearlnum) - pearlmax
						pearlnum = pearlmax
						player.hpMax += diff
						player.hp += diff
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "magicians hat":
				if magicianshatnum == magicianshatmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+magicianshatnum <= magicianshatmax {
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
						magicianshatnum += num3
						player.manaMax += num3
						player.mana += num3
					} else if num3+magicianshatnum > magicianshatmax {
						max = true
						diff := magicianshatmax - magicianshatnum
						num3 = (num3 + magicianshatnum) - magicianshatmax
						magicianshatnum = magicianshatmax
						player.manaMax += diff
						player.mana += diff
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "throwing knife":
				if throwingknifenum == throwingknifemax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+throwingknifenum <= throwingknifemax {
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
						throwingknifenum += num3
					} else if num3+throwingknifenum > throwingknifemax {
						max = true
						diff := throwingknifemax - throwingknifenum
						num3 = (num3 + throwingknifenum) - throwingknifemax
						throwingknifenum = throwingknifemax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "toxic sludge":
				if !toxic {
					toxic = true
					num3--
					max = true
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "mirror":
				if !mirror {
					mirror = true
					num3--
					max = true
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "belt of whipping":
				if beltnum == beltmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+beltnum <= beltmax {
						beltnum += num3
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+beltnum > beltmax {
						max = true
						diff := beltmax - beltnum
						num3 = (num3 + beltnum) - beltmax
						beltnum = beltmax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "amulet of disc":
				if !frisbee {
					frisbee = true
					num3--
					max = true
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "amulet of purple rain":
				if !purplerain {
					purplerain = true
					num3--
					max = true
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "tesla coil":
				if !tesla {
					tesla = true
					num3--
					max = true
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "ring of twin":
				if !twin {
					twin = true
					num3--
					max = true
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "ring of thorns":
				if !thornson {
					thornson = true
					num3--
					max = true
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "ring of vine":
				if !vineRing {
					vineRing = true
					if player.hp == 1 {
						player.hp = 2
					}
					num3--
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
					max = true
				} else {
					max = true
				}
			case "toilet paper":
				if toiletpapernum == toiletpapermax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+toiletpapernum <= toiletpapermax {
						toiletpapernum += num3
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+toiletpapernum > toiletpapermax {
						max = true
						diff := toiletpapermax - toiletpapernum
						num3 = (num3 + toiletpapernum) - toiletpapermax
						toiletpapernum = toiletpapermax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "bear trap":
				if beartrapnum == beartrapmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+beartrapnum <= beartrapmax {
						beartrapnum += num3
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+beartrapnum > beartrapmax {
						max = true
						diff := beartrapmax - beartrapnum
						num3 = (num3 + beartrapnum) - beartrapmax
						beartrapnum = beartrapmax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
					beartrapT = (fps * 12) - (int32(beartrapnum*2) * fps)
				}
			case "basketball sneakers":
				if stats.dexterity == 5 {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+stats.dexterity <= 5 {
						stats.dexterity += num3
						stats.dexterity2 = stats.dexterity
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+stats.dexterity > 5 {
						max = true
						diff := 5 - stats.dexterity
						num3 = (num3 + stats.dexterity) - 5
						stats.dexterity = 5
						stats.dexterity2 = stats.dexterity
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "dumbbell":
				if stats.strength == 5 {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+stats.strength <= 5 {
						stats.strength += num3
						stats.strength2 = stats.strength
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+stats.strength > 5 {
						max = true
						diff := 5 - stats.strength
						num3 = (num3 + stats.strength) - 5
						stats.strength = 5
						stats.strength2 = stats.strength
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "dice":
				if stats.luck == 5 {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+stats.luck <= 5 {
						stats.luck += num3
						stats.luck2 = stats.luck
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+stats.luck > 5 {
						max = true
						diff := 5 - stats.luck
						num3 = (num3 + stats.luck) - 5
						stats.luck = 5
						stats.luck2 = stats.luck
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "eyeball":
				if stats.perception == 5 {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+stats.perception <= 5 {
						stats.perception += num3
						stats.perception2 = stats.perception
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+stats.perception > 5 {
						max = true
						diff := 5 - stats.perception
						num3 = (num3 + stats.perception) - 5
						stats.perception = 5
						stats.perception2 = stats.perception
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "brain":
				if stats.intelligence == 5 {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+stats.intelligence <= 5 {
						stats.intelligence += num3
						stats.intelligence2 = stats.intelligence
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+stats.intelligence > 5 {
						max = true
						diff := 5 - stats.intelligence
						num3 = (num3 + stats.intelligence) - 5
						stats.intelligence = 5
						stats.intelligence2 = stats.intelligence
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "medikit":
				if medikitnum == medikitmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+medikitnum <= medikitmax {
						medikitnum += num3
						beartrapnum += num3
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+medikitnum > medikitmax {
						max = true
						diff := medikitmax - medikitnum
						num3 = (num3 + medikitnum) - medikitmax
						medikitnum = medikitmax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "backpack":
				if len(player.inventory) == inventoryMax {
					max = true
					admsg("inventory max", rl.Red)
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+len(player.inventory) <= inventoryMax {
						for i := 0; i < num3; i++ {
							player.inventory = append(player.inventory, Item{})
						}
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+len(player.inventory) > inventoryMax {
						max = true
						admsg("inventory max", rl.Red)
						diff := inventoryMax - len(player.inventory)
						for i := 0; i < diff; i++ {
							player.inventory = append(player.inventory, Item{})
						}
						num3 = (num3 + len(player.inventory)) - inventoryMax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "gas can":
				if gascannum == gascanmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+gascannum <= gascanmax {
						gascannum += num3
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+gascannum > gascanmax {
						max = true
						diff := gascanmax - gascannum
						num3 = (num3 + gascannum) - gascanmax
						gascannum = gascanmax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "bottle of death":
				if deathbottlenum == deathbottlemax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+deathbottlenum <= deathbottlemax {
						deathbottlenum += num3
						gascannum += num3
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+deathbottlenum > deathbottlemax {
						max = true
						diff := deathbottlemax - deathbottlenum
						num3 = (num3 + deathbottlenum) - deathbottlemax
						deathbottlenum = deathbottlemax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "cleaver":
				if cleavernum == cleavermax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+cleavernum <= cleavermax {
						cleavernum += num3
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+cleavernum > cleavermax {
						max = true
						diff := cleavermax - cleavernum
						num3 = (num3 + cleavernum) - cleavermax
						cleavernum = cleavermax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "tenderiser":
				if tenderisernum == tenderisermax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+tenderisernum <= tenderisermax {
						tenderisernum += num3
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+tenderisernum > tenderisermax {
						max = true
						diff := tenderisermax - tenderisernum
						num3 = (num3 + tenderisernum) - tenderisermax
						tenderisernum = tenderisermax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "garlic":
				if garlicnum == garlicmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+garlicnum <= garlicmax {
						garlicnum += num3
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+garlicnum > garlicmax {
						max = true
						diff := garlicmax - garlicnum
						num3 = (num3 + garlicnum) - garlicmax
						garlicnum = garlicmax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "drill":
				if !drillon {
					drillon = true
					num3--
					max = true
					levels[levNum].items[num].numof = 1
					player.art = append(player.art, levels[levNum].items[num])
				} else {
					max = true
				}
			case "broccoli":
				if broccolinum == broccolimax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+broccolinum <= broccolimax {
						broccolinum += num3
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+broccolinum > broccolimax {
						max = true
						diff := broccolimax - broccolinum
						num3 = (num3 + broccolinum) - broccolimax
						broccolinum = broccolimax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "basketball":
				if basketballnum == basketballmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+basketballnum <= basketballmax {
						basketballnum += num3
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+basketballnum > basketballmax {
						max = true
						diff := basketballmax - basketballnum
						num3 = (num3 + basketballnum) - basketballmax
						basketballnum = basketballmax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "sunglasses":
				if stats.critical == stats.critical2 {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+stats.critical <= stats.critical2 {
						stats.critical += num3
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+stats.critical > stats.critical2 {
						max = true
						diff := stats.critical2 - stats.critical
						num3 = (num3 + stats.critical) - stats.critical2
						stats.critical = stats.critical2
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}
			case "sneakers":
				if sneakersnum == sneakersmax {
					max = true
				} else {
					numArtSame, foundArt := foundsameart(levels[levNum].items[num].name)
					if num3+sneakersnum <= sneakersmax {
						sneakersnum += num3
						if player.speed2 < player.speedMax {
							player.speed2 += float32(num3)
							if player.speed2 > player.speedMax {
								player.speed2 = player.speedMax
							}
							player.speed = player.speed2
						}
						if foundArt {
							player.art[numArtSame].numof += num3
						} else {
							player.art = append(player.art, levels[levNum].items[num])
						}
					} else if num3+sneakersnum > sneakersmax {
						max = true
						diff := sneakersmax - sneakersnum
						player.speed2 = player.speedMax
						player.speed = player.speed2
						num3 = (num3 + sneakersnum) - sneakersmax
						sneakersnum = sneakersmax
						if foundArt {
							player.art[numArtSame].numof += diff
						} else {
							player.art = append(player.art, levels[levNum].items[num])
							player.art[len(player.art)-1].numof = diff
						}
					}
				}

			}

			if max {
				rl.PlaySound(audfx[121])
				if msgT == 0 {
					admsg("artifact > "+levels[levNum].items[num].name+" > max", rl.Red)
				}
				found := false
				for i := 0; i < len(player.inventory); i++ {
					if player.inventory[i].name == levels[levNum].items[num].name {
						player.inventory[i].numof += num3
						if msgT == 0 {
							admsg("in backpack > store for next run", rl.Magenta)
							msgT = fps
						}
						levels[levNum].items[num] = Item{}
						levels[levNum].items[num].isOff = true
						found = true
					}
				}
				if !found {
					if nxInvnNum != blankint {
						player.inventory[nxInvnNum] = levels[levNum].items[num]
						player.inventory[nxInvnNum].numof = num3
						findnxinvnum()
						if msgT == 0 {
							admsg("in backpack > store for next run", rl.Magenta)
							msgT = fps
						}
						levels[levNum].items[num] = Item{}
						levels[levNum].items[num].isOff = true
					} else {
						if msgT == 0 {
							admsg("inventory full > drop, stack or use", rl.Red)
							msgT = fps
						}
					}
				}
				msgT = fps / 2
			} else {
				rl.PlaySound(audfx[74])
				found, numSame := checkArtSameItm(levels[levNum].items[num])
				if found {
					player.art[numSame].numof += num3
				} else {
					levels[levNum].items[num].numof = num3
					player.art = append(player.art, levels[levNum].items[num])
				}
				admsg("collected artifact "+levels[levNum].items[num].name, rl.Magenta)
				levels[levNum].items[num] = Item{}
				levels[levNum].items[num].isOff = true
			}

		} else {
			max := false
			switch levels[levNum].items[num].name {
			//NON BOSS ARTIFACTS MUST ALSO BE ADDED TO COLLECT FROM CHEST

			case "weapon case":
				if weaponcasenum < weaponcasemax {
					player.weapons = append(player.weapons, Weapon{})
					weaponcasenum++
				} else {
					max = true
				}
			case "umbrella":
				if !umbrella {
					umbrella = true
				} else {
					max = true
				}
			case "map chest pin":
				if !chestpin {
					chestpin = true
				} else {
					max = true
				}
			case "map exit pin":
				if !mappin {
					mappin = true
				} else {
					max = true
				}
			case "gas mask":
				if gasmasknum < gasmaskmax {
					gasmasknum++
					if gasmaskT == 0 {
						gasmaskT = fps*8 - (gasmasknum * fps)
					}
				} else {
					max = true
				}
			case "noodles":
				if !noodles {
					noodles = true
				} else {
					max = true
				}
			case "oven glove":
				if ovenglovenum < ovenglovemax {
					ovenglovenum++
				} else {
					max = true
				}
			case "toaster":
				if !toaster {
					toaster = true
				} else {
					max = true
				}
			case "ninja star":
				if ninjanum < ninjamax {
					ninjanum++
				} else {
					max = true
				}
			case "flamingo":
				if flamingonum < flamingomax {
					flamingonum++
					if flamingoT == 0 {
						flamingoT = (fps + fps/2) / flamingonum
					}
				} else {
					max = true
				}
			case "mug of tea":
				if teanum < teamax {
					teanum++
				} else {
					max = true
				}
			case "cloak of sparks":
				if !cloak {
					cloak = true
				} else {
					max = true
				}
			case "feather":
				if !feather {
					feather = true
				} else {
					max = true
				}
			case "mugging":
				if mugnum < mugmax {
					mugnum++
				} else {
					max = true
				}
			case "lightbulb":
				if lightbulbnum < lightbulbmax {
					lightbulbnum++
				} else {
					max = true
				}
			case "candy cane":
				if candycanenum < candycanemax {
					candycanenum++
				} else {
					max = true
				}
			case "pearl":
				if pearlnum < pearlmax {
					pearlnum++
					player.hpMax++
					player.hp++
				} else {
					max = true
				}
			case "magicians hat":
				if magicianshatnum < magicianshatmax {
					magicianshatnum++
					player.manaMax++
					player.mana++
				} else {
					max = true
				}
			case "throwing knife":
				if throwingknifenum < throwingknifemax {
					throwingknifenum++
				} else {
					max = true
				}
			case "toxic sludge":
				if !toxic {
					toxic = true
				} else {
					max = true
				}
			case "mirror":
				if !mirror {
					mirror = true
				} else {
					max = true
				}
			case "belt of whipping":
				if beltnum < beltmax {
					beltnum++
				} else {
					max = true
				}
			case "amulet of disc":
				if !frisbee {
					frisbee = true
				} else {
					max = true
				}
			case "amulet of purple rain":
				if !purplerain {
					purplerain = true
				} else {
					max = true
				}
			case "tesla coil":
				if !tesla {
					tesla = true
				} else {
					max = true
				}
			case "ring of twin":
				if !twin {
					twin = true
				} else {
					max = true
				}
			case "ring of thorns":
				if !thornson {
					thornson = true
				} else {
					max = true
				}
			case "ring of vine":
				if !vineRing {
					vineRing = true
					if player.hp == 1 {
						player.hp = 2
					}
				} else {
					max = true
				}
			case "toilet paper":
				if toiletpapernum < toiletpapermax {
					toiletpapernum++
				} else {
					max = true
				}
			case "bear trap":
				if beartrapnum < beartrapmax {
					beartrapnum++
					beartrapT = (fps * 12) - (int32(beartrapnum*2) * fps)
				} else {
					max = true
				}
			case "basketball sneakers":
				if stats.dexterity < 5 {
					stats.dexterity++
					stats.dexterity2 = stats.dexterity
				} else {
					max = true
				}
			case "dumbbell":
				if stats.strength < 5 {
					stats.strength++
					stats.strength2 = stats.strength
				} else {
					max = true
				}
			case "dice":
				if stats.luck < 5 {
					stats.luck++
					stats.luck2 = stats.luck
				} else {
					max = true
				}
			case "eyeball":
				if stats.perception < 5 {
					stats.perception++
					stats.perception2 = stats.perception
				} else {
					max = true
				}
			case "brain":
				if stats.intelligence < 5 {
					stats.intelligence++
					stats.intelligence2 = stats.intelligence
				} else {
					max = true
				}
			case "medikit":
				if medikitnum < medikitmax {
					medikiton = true
					medikitnum++
				} else {
					max = true
				}
			case "backpack":
				if len(player.inventory) < inventoryMax {
					player.inventory = append(player.inventory, Item{})
				} else {
					max = true
					admsg("inventory max", rl.Red)
				}
			case "gas can":
				if gascannum < gascanmax {
					gascannum++
				} else {
					max = true
				}
			case "bottle of death":
				if deathbottlenum < deathbottlemax {
					deathbottlenum++
				} else {
					max = true
				}
			case "cleaver":
				if cleavernum < cleavermax {
					cleavernum++
				} else {
					max = true
				}
			case "tenderiser":
				if tenderisernum < tenderisermax {
					tenderisernum++
				} else {
					max = true
				}
			case "garlic":
				if garlicnum < garlicmax {
					garlicnum++
				} else {
					max = true
				}
			case "drill":
				if !drillon {
					drillon = true
				} else {
					max = true
				}
			case "broccoli":
				if broccolinum < broccolimax {
					broccolinum++
				} else {
					max = true
				}
			case "basketball":
				if basketballnum < basketballmax {
					basketballnum++
				} else {
					max = true
				}
			case "sunglasses":
				if stats.critical < stats.critical2 {
					stats.critical++
				} else {
					max = true
				}
			case "sneakers":
				if sneakersnum < sneakersmax {
					sneakersnum++
					if player.speed2 < player.speedMax {
						player.speed2++
						player.speed = player.speed2
					}
				} else {
					max = true
				}
			}
			if max {
				rl.PlaySound(audfx[121])
				if msgT == 0 {
					admsg("artifact > "+levels[levNum].items[num].name+" > max", rl.Red)
				}
				found := false
				for i := 0; i < len(player.inventory); i++ {
					if player.inventory[i].name == levels[levNum].items[num].name {
						player.inventory[i].numof++
						if msgT == 0 {
							admsg("in backpack > store for next run", rl.Magenta)
							msgT = fps
						}
						levels[levNum].items[num] = Item{}
						levels[levNum].items[num].isOff = true
						found = true
					}
				}
				if !found {
					if nxInvnNum != blankint {
						player.inventory[nxInvnNum] = levels[levNum].items[num]
						findnxinvnum()
						if msgT == 0 {
							admsg("in backpack > store for next run", rl.Magenta)
							msgT = fps
						}
						levels[levNum].items[num] = Item{}
						levels[levNum].items[num].isOff = true
					} else {
						if msgT == 0 {
							admsg("inventory full > drop, stack or use", rl.Red)
							msgT = fps
						}
					}
				}
				msgT = fps / 2
			} else {
				rl.PlaySound(audfx[74])
				found, numSame := checkArtSameItm(levels[levNum].items[num])
				if found {
					player.art[numSame].numof++
				} else {
					player.art = append(player.art, levels[levNum].items[num])
				}
				admsg("collected artifact "+levels[levNum].items[num].name, rl.Magenta)
				levels[levNum].items[num] = Item{}
				levels[levNum].items[num].isOff = true
			}
		}
	}
}
func dropweap(num, numType int) { //MARK: DROP WEAPON
	checkrec := player.rectangle
	checkrec.X -= checkrec.Width
	xorig := checkrec.X
	checkrec.Y -= checkrec.Height
	countbreak := 8
	count := 0

	if numType == 0 {
		for {
			canadd := checkRecChests(checkrec)
			if canadd {
				canadd = checkRecWalls(checkrec)
			}
			if canadd {
				canadd = checkRecSolid(checkrec)
			}
			if canadd {
				canadd = checkItemItem(checkrec)
			}
			if canadd {
				canadd = checkWeapWeap(checkrec)
			}
			countbreak--
			if canadd || countbreak == 0 {
				if canadd {
					cntr := makecnt(checkrec)
					zweap := player.weapons[num]
					zweap.dropTimer = fps
					zweap.rec = rl.NewRectangle(cntr.X-zweap.rec.Width/2, cntr.Y-zweap.rec.Height/2, zweap.rec.Width, zweap.rec.Height)
					if zweap.name == "raspberry" {
						zweap.rec.X -= be
						zweap.rec.Y -= be
						zweap.rec.Width += bq
						zweap.rec.Height += bq
					}
					levels[levNum].weapons = append(levels[levNum].weapons, zweap)
					admsg("dropped "+player.weapons[num].name, rl.Blue)
					player.weapons[num] = Weapon{}
					break
				}
				if countbreak == 0 {
					admsg("no space nearby... move please ", rl.Red)
					break
				}
			}
			checkrec.X += checkrec.Width
			count++
			if count == 3 || count == 5 {
				checkrec.X = xorig
				checkrec.Y += checkrec.Height
			}
			if count == 4 {
				checkrec.X += checkrec.Width
			}
		}
	} else {
		for {
			canadd := checkRecChests(checkrec)
			if canadd {
				canadd = checkRecWalls(checkrec)
			}
			if canadd {
				canadd = checkRecSolid(checkrec)
			}
			if canadd {
				canadd = checkItemItem(checkrec)
			}
			if canadd {
				canadd = checkWeapWeap(checkrec)
			}
			countbreak--
			if canadd || countbreak == 0 {
				if canadd {
					cntr := makecnt(checkrec)
					zweap := player.weapon2
					zweap.dropTimer = fps
					zweap.rec = rl.NewRectangle(cntr.X-zweap.rec.Width/2, cntr.Y-zweap.rec.Height/2, zweap.rec.Width, zweap.rec.Height)
					if zweap.name == "raspberry" {
						zweap.rec.X -= be
						zweap.rec.Y -= be
						zweap.rec.Width += bq
						zweap.rec.Height += bq
					}
					levels[levNum].weapons = append(levels[levNum].weapons, zweap)
					admsg("dropped "+player.weapon2.name, rl.Blue)
					player.weapon2 = Weapon{}
					break
				}
				if countbreak == 0 {
					admsg("no space nearby... move please ", rl.Red)
					break
				}
			}
			checkrec.X += checkrec.Width
			count++
			if count == 3 || count == 5 {
				checkrec.X = xorig
				checkrec.Y += checkrec.Height
			}
			if count == 4 {
				checkrec.X += checkrec.Width
			}
		}
	}
}
func dropitm(num, inven0quik1 int) { //MARK: DROP ITEM
	checkrec := player.rectangle
	checkrec.X -= checkrec.Width
	xorig := checkrec.X
	checkrec.Y -= checkrec.Height
	countbreak := 8
	count := 0
	for {
		canadd := checkRecChests(checkrec)
		if canadd {
			canadd = checkRecWalls(checkrec)
		}
		if canadd {
			canadd = checkRecSolid(checkrec)
		}
		if canadd {
			canadd = checkItemItem(checkrec)
		}
		countbreak--
		if canadd || countbreak == 0 {
			if canadd {
				cntr := makecnt(checkrec)
				zitm := player.inventory[num]
				if inven0quik1 == 1 {
					zitm = player.quik[num]
				}
				zitm.dropTimer = fps
				zitm.rectangle = rl.NewRectangle(cntr.X-zitm.rectangle.Width/2, cntr.Y-zitm.rectangle.Height/2, zitm.rectangle.Width, zitm.rectangle.Height)
				levels[levNum].items = append(levels[levNum].items, zitm)
				if inven0quik1 == 1 {
					admsg("dropped "+player.quik[num].name, rl.Blue)
					player.quik[num] = Item{}
				} else {
					admsg("dropped "+player.inventory[num].name, rl.Blue)
					player.inventory[num] = Item{}
				}
				break
			}
			if countbreak == 0 {
				admsg("no space nearby... move please ", rl.Red)
				break
			}
		}
		checkrec.X += checkrec.Width
		count++
		if count == 3 || count == 5 {
			checkrec.X = xorig
			checkrec.Y += checkrec.Height
		}
		if count == 4 {
			checkrec.X += checkrec.Width
		}
	}
}
func destroycrate(num int) { //MARK: DESTROY CRATE
	//ITEMS
	if levels[levNum].otherTiles[num].image == otherTiles[2] { //OLD CRATE
		if Roll6() > 3 {
			zitm := itemList[43]
			zitm.rectangle = rl.NewRectangle(levels[levNum].otherTiles[num].center.X-zitm.rectangle.Width/2, levels[levNum].otherTiles[num].center.Y-zitm.rectangle.Height/2, zitm.rectangle.Width, zitm.rectangle.Height)
			levels[levNum].items = append(levels[levNum].items, zitm)
		}
		if toiletpapernum > 0 {
			if Roll6() <= toiletpapernum {
				zitm := itemList[43]
				zitm.rectangle = rl.NewRectangle(levels[levNum].otherTiles[num].center.X-zitm.rectangle.Width/2, levels[levNum].otherTiles[num].center.Y-zitm.rectangle.Height/2, zitm.rectangle.Width, zitm.rectangle.Height)
				levels[levNum].items = append(levels[levNum].items, zitm)
			}
		}
	} else if levels[levNum].otherTiles[num].image == otherTiles[4] { //NEW CRATE
		zitm := itemList[43]
		zitm.rectangle = rl.NewRectangle(levels[levNum].otherTiles[num].center.X-zitm.rectangle.Width/2, levels[levNum].otherTiles[num].center.Y-zitm.rectangle.Height/2, zitm.rectangle.Width, zitm.rectangle.Height)
		levels[levNum].items = append(levels[levNum].items, zitm)
		if Roll6() > 3 {
			zitm := itemList[43]
			zitm.rectangle = rl.NewRectangle(levels[levNum].otherTiles[num].center.X-zitm.rectangle.Width/2, levels[levNum].otherTiles[num].center.Y-zitm.rectangle.Height/2, zitm.rectangle.Width, zitm.rectangle.Height)
			levels[levNum].items = append(levels[levNum].items, zitm)
		}
		if toiletpapernum > 0 {
			if Roll6() <= toiletpapernum {
				zitm := itemList[43]
				zitm.rectangle = rl.NewRectangle(levels[levNum].otherTiles[num].center.X-zitm.rectangle.Width/2, levels[levNum].otherTiles[num].center.Y-zitm.rectangle.Height/2, zitm.rectangle.Width, zitm.rectangle.Height)
				levels[levNum].items = append(levels[levNum].items, zitm)
			}
		}
	} else if levels[levNum].otherTiles[num].image == otherTiles[1] { //PINK CRATE
		zitm := crateitm[RandInt(0, len(crateitm))]
		zitm.rectangle = rl.NewRectangle(levels[levNum].otherTiles[num].center.X-zitm.rectangle.Width/2, levels[levNum].otherTiles[num].center.Y-zitm.rectangle.Height/2, zitm.rectangle.Width, zitm.rectangle.Height)
		if zitm.name == "lead" || zitm.name == "bronze" || zitm.name == "silver" || zitm.name == "gold" || zitm.name == "platinum" {
			zitm.numof = RandInt(10, 21)
		}
		levels[levNum].items = append(levels[levNum].items, zitm)
		//LUK
		if stats.luck > 1 {
			if Roll6() <= stats.luck {
				zitm = Item{}
				zitm = crateitm[RandInt(0, len(crateitm))]
				zitm.rectangle = rl.NewRectangle(levels[levNum].otherTiles[num].center.X-zitm.rectangle.Width/2, levels[levNum].otherTiles[num].center.Y-zitm.rectangle.Height/2, zitm.rectangle.Width, zitm.rectangle.Height)
				zitm.rectangle = finddropside(zitm.rectangle, 1)
				if zitm.rectangle != blankRec {
					if zitm.name == "lead" || zitm.name == "bronze" || zitm.name == "silver" || zitm.name == "gold" || zitm.name == "platinum" {
						zitm.numof = RandInt(10, 21)
					}
					levels[levNum].items = append(levels[levNum].items, zitm)
				}
			}
		}

	} else if levels[levNum].otherTiles[num].image == otherTiles[3] { //BLUE CRATE
		zitm := crateitm[RandInt(0, len(crateitm))]
		zitm.rectangle = rl.NewRectangle(levels[levNum].otherTiles[num].center.X-zitm.rectangle.Width/2, levels[levNum].otherTiles[num].center.Y-zitm.rectangle.Height/2, zitm.rectangle.Width, zitm.rectangle.Height)
		if zitm.name == "lead" || zitm.name == "bronze" || zitm.name == "silver" || zitm.name == "gold" || zitm.name == "platinum" {
			zitm.numof = RandInt(10, 21)
		}
		levels[levNum].items = append(levels[levNum].items, zitm)
		//LUK
		if stats.luck > 1 {
			if Roll6() <= stats.luck {
				zitm = Item{}
				zitm = crateitm[RandInt(0, len(crateitm))]
				zitm.rectangle = rl.NewRectangle(levels[levNum].otherTiles[num].center.X-zitm.rectangle.Width/2, levels[levNum].otherTiles[num].center.Y-zitm.rectangle.Height/2, zitm.rectangle.Width, zitm.rectangle.Height)
				zitm.rectangle = finddropside(zitm.rectangle, 1)
				if zitm.rectangle != blankRec {
					if zitm.name == "lead" || zitm.name == "bronze" || zitm.name == "silver" || zitm.name == "gold" || zitm.name == "platinum" {
						zitm.numof = RandInt(10, 21)
					}
					levels[levNum].items = append(levels[levNum].items, zitm)
				}
			}
		}
	}
	//FX
	zfx := Effect{}
	zfx.name = "desCrate"
	zfx.timer = fps / 2
	cntr := levels[levNum].otherTiles[num].center
	num2 := RandInt(40, 51)
	for num2 > 0 {
		siz := RandF32(b/8, b/2)
		zrec := Rectangle{}
		if levels[levNum].otherTiles[num].image == otherTiles[2] || levels[levNum].otherTiles[num].image == otherTiles[4] {
			zrec.color = RandBrown()
		} else if levels[levNum].otherTiles[num].image == otherTiles[1] {
			zrec.color = RandPink()
		} else if levels[levNum].otherTiles[num].image == otherTiles[3] {
			zrec.color = RandCyan()
		}
		zrec.fade = RandF32(0.3, 0.7)
		zrec.rectangle = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
		zrec.speed = b / 2
		zrec.dirX = RandF32(-zrec.speed, zrec.speed)
		zrec.dirY = RandF32(-zrec.speed, zrec.speed)
		zfx.rectangles = append(zfx.rectangles, zrec)
		num2--
	}
	effect = append(effect, zfx)
	rl.PlaySound(audfx[2])

	//FIREWORKS
	if levels[levNum].otherTiles[num].firework {
		rl.PlaySound(audfx[109])
		siz := b / 2
		spd := float32(5)
		zproj := Weapon{}
		zproj.name = "firework"
		zproj.rec2 = animation[201].rectangle
		zproj.image = otherTiles[210]
		zproj.col = rl.White
		zproj.fade = 1
		zproj.center = levels[levNum].otherTiles[num].center
		zproj.rec = rl.NewRectangle(zproj.center.X-siz/2, zproj.center.Y-siz/2, siz, siz)
		zproj.dirX = spd
		zproj.rotation = 45
		playerProjectiles = append(playerProjectiles, zproj)
		zproj.rotation = -135
		zproj.dirX = -spd
		playerProjectiles = append(playerProjectiles, zproj)
		zproj.rotation = 135
		zproj.dirX = 0
		zproj.dirY = spd
		playerProjectiles = append(playerProjectiles, zproj)
		zproj.rotation = -45
		zproj.dirY = -spd
		playerProjectiles = append(playerProjectiles, zproj)
		zproj.rotation = 90
		zproj.dirY = 0
		zproj.dirX = 0
		zproj.dirY = spd
		zproj.dirX = spd
		playerProjectiles = append(playerProjectiles, zproj)
		zproj.rotation = 180
		zproj.dirY = spd
		zproj.dirX = -spd
		playerProjectiles = append(playerProjectiles, zproj)
		zproj.rotation = 270
		zproj.dirY = -spd
		zproj.dirX = -spd
		playerProjectiles = append(playerProjectiles, zproj)
		zproj.rotation = 0
		zproj.dirY = -spd
		zproj.dirX = spd
		playerProjectiles = append(playerProjectiles, zproj)
	}
}

func admsg(txt string, col rl.Color) { //MARK:ADD MSG
	zmsg := Message{}
	zmsg.txt = txt
	zmsg.col = col
	msg = append(msg, zmsg)
}
func Remove(num int) { //MARK:REMOVE FROM SLICE
	switch num {
	case 4: //ENEMIES
		if len(effect) == 0 {
			for i := 0; i < len(levels[levNum].enemies); i++ {
				if levels[levNum].enemies[i].off {
					levels[levNum].enemies = RemoveEnemy(levels[levNum].enemies, i)
				}
			}
		}
	case 3: //ITEM
		for i := 0; i < len(levels[levNum].items); i++ {
			if levels[levNum].items[i].isOff {
				levels[levNum].items = RemoveItem(levels[levNum].items, i)
			}
		}
	case 2: //ETC TILE
		for i := 0; i < len(levels[levNum].otherTiles); i++ {
			if levels[levNum].otherTiles[i].isOff {
				levels[levNum].otherTiles = RemoveTile(levels[levNum].otherTiles, i)
			}
		}
	case 1: //FX
		for i := 0; i < len(effect); i++ {
			if effect[i].isOff {
				effect = RemoveEffects(effect, i)
			}
		}
	}
}
func playerDeath() { //MARK:PLAYER DEATH
	if medikiton {
		player.burnTimer = 0
		player.poisonTimer = 0
		player.freezeTimer = 0
		player.dampTimer = 0
		medikiton = false
		player.hp = player.hpMax
		player.center = currentPosition
		updatePlayerRectangle()
		reviveT = fps / 2
		for i := 0; i < len(player.art); i++ {
			if player.art[i].name == "medikit" {
				player.art[i].isOff = true
				break
			}
		}
		admsg("revived by medikit", rl.Green)
	} else if zombienum > 0 {
		player.burnTimer = 0
		player.poisonTimer = 0
		player.freezeTimer = 0
		player.dampTimer = 0
		player.hpMax--
		player.hp = player.hpMax
		player.center = currentPosition
		updatePlayerRectangle()
		reviveT = fps / 2
		zombienum--
		if zombienum == 0 {
			for i := 0; i < len(player.art); i++ {
				if player.art[i].name == "zombie head" {
					player.art[i].isOff = true
				}
			}
		}
		admsg("revived by zombie head", rl.Green)
	} else {
		rl.PlaySound(audfx[123])
		player.gameover = true
		gameOverRec = rl.NewRectangle(currentPosition.X-b2, currentPosition.Y-b2, b4, b4)
		gameOverFade = 0
		gameoverRotation = 0
		gameOverReset = false
		gameOver = true

	}
}
func hitPLEnProj(num int) { //MARK:HIT PLAYER ENEMY PROJECTILE SEE ALSO HIT PLAYER BELOW

	if !invincible {

		if vineon {
			if msgT == 0 {
				admsg("vine saves dmg", rl.Green)
				msgT = fps
			}
		} else if turtleT > 0 {
			if msgT == 0 {
				admsg("turtle shell saves dmg", rl.Green)
				msgT = fps
			}
		} else if player.armorTimer > 0 {
			if msgT == 0 {
				admsg("armor shield saves dmg", rl.Green)
				msgT = fps
			}
		} else if shrimpnum > 0 {
			if player.hpTimer == 0 {
				player.hpTimer = fps * 2
				shrimpnum--
				admsg("shrimp shell saves dmg", rl.Green)
			}
		} else {
			if player.hpTimer == 0 {
				if player.hp > 0 {
					player.hp -= enemyProjectiles[num].damage
					//HP LOSS SFX
					if prevplayHP > player.hp {
						rl.PlaySound(audfx[14])
						prevplayHP = player.hp
					} else if prevplayHP < player.hp {
						prevplayHP = player.hp
					}
					player.hpTimer = fps * 2
					admsg("-"+fmt.Sprint(enemyProjectiles[num].damage)+" dmg", rl.Red)
					if enemyProjectiles[num].name == "icemanProj" && player.freezeTimer == 0 && saltT == 0 {
						player.freezeTimer = fps * 2
						admsg("frozen", rl.Red)
					} else if saltT > 0 {
						if msgT == 0 {
							admsg("salt saves freeze", rl.Green)
							msgT = fps
						}
					}
					if enemyProjectiles[num].name == "yellowdinobull" || enemyProjectiles[num].name == "reddevilFlame" {
						if player.burnTimer == 0 && player.dampTimer == 0 && icelollyT == 0 && player.resistFireTimer == 0 {
							if ovenglovenum > 0 {
								if Roll6() <= ovenglovenum {
									admsg("oven glove saves burn", rl.Green)
								} else {
									admsg("burning...", rl.Orange)
									player.burnTimer += fps * 3
								}
							} else {
								admsg("burning...", rl.Orange)
								player.burnTimer += fps * 3
							}
						} else if player.burnTimer == 0 && player.dampTimer != 0 && icelollyT == 0 && player.resistFireTimer == 0 {
							admsg("damp saves burn", rl.Green)
						} else if player.burnTimer == 0 && player.dampTimer == 0 && icelollyT != 0 && player.resistFireTimer == 0 {
							admsg("ice lolly saves burn", rl.Green)
						} else if player.burnTimer == 0 && player.dampTimer == 0 && icelollyT == 0 && player.resistFireTimer != 0 {
							admsg("resist fire saves burn", rl.Green)
						}
					}
					if enemyProjectiles[num].name == "dart" {
						player.poisonTimer += fps * 3
					}
					//FX
					zfx := Effect{}
					zfx.name = "plblood"
					zfx.imageRectangle = splat[RandInt(0, len(splat))]
					zfx.color = RandRed()
					zfx.fade = 0.8
					zfx.rectangle = player.rectangle
					zfx.rectangle.X -= b
					zfx.rectangle.Y -= b
					zfx.rectangle.Width += b2
					zfx.rectangle.Height += b2
					effect = append(effect, zfx)
				}
				//THORNS
				if thornson {
					thorns()
				}
				//CLOAK
				if cloak && cloakT == 0 {
					cloakT = fps / 2
					siz := b2
					zfx := Effect{}
					zfx.imageRectangle = animation[96].rectangle
					zfx.name = "cloaksparks"
					num := 10
					countbreak := 100
					for num > 0 {
						v2 := player.center
						v2.X += RandF32(-b8, b8)
						v2.Y += RandF32(-b8, b8)
						if checkV2inRooms(v2) {
							num--
							rec := rl.NewRectangle(v2.X-siz/2, v2.Y-siz/2, siz, siz)
							zfx.rectangles2 = append(zfx.rectangles2, rec)
							crec := rec
							crec.X += rec.Width / 3
							crec.Y += rec.Height / 3
							crec.Width = rec.Width / 3
							crec.Height = rec.Height / 3
							zfx.collisionRectangles = append(zfx.collisionRectangles, crec)
						}
						countbreak--
						if countbreak == 0 {
							break
						}
					}
					effect = append(effect, zfx)
				}
			}
		}
		if player.hp == 1 && vineRing && !player.art[vineRingArtNum].isOff {
			admsg("just in the nick of vine", rl.Green)
			player.burnTimer = 0
			player.freezeTimer = 0
			player.poisonTimer = 0
			player.dampTimer = 0
			player.animationNum = 0
			player.art[vineRingArtNum].isOff = true
			vineon = true
		}
		if player.hp <= 0 {
			playerDeath()
		}
	}
}
func hitPL(num int) { //MARK:HIT PLAYER SEE ALSO HIT PLAYER ENEMY PROJECTILE ABOVE
	if !invincible {
		if vineon {
			if msgT == 0 {
				admsg("vine saves dmg", rl.Green)
				msgT = fps
			}
		} else if turtleT > 0 {
			if msgT == 0 {
				admsg("turtle shell saves dmg", rl.Green)
				msgT = fps
			}
		} else if player.armorTimer > 0 {
			if msgT == 0 {
				admsg("armor shield saves dmg", rl.Green)
				msgT = fps
			}
		} else if shrimpnum > 0 {
			if player.hpTimer == 0 {
				player.hpTimer = fps * 2
				shrimpnum--
				admsg("shrimp shell saves dmg", rl.Green)
			}
		} else {
			switch num {
			case 2: //-HP NO HP PAUSE BURN DMG
				if player.hp > 0 && player.hpTimer == 0 {
					player.hpTimer = fps
					player.hp--
					admsg("-1 dmg", rl.Red)
					//HP LOSS SFX
					if prevplayHP > player.hp {
						rl.PlaySound(audfx[14])
						prevplayHP = player.hp
					} else if prevplayHP < player.hp {
						prevplayHP = player.hp
					}
				}
			case 1: //-HP & HP PAUSE
				if player.hpTimer == 0 {
					if player.hp > 0 {
						player.hp--
						//HP LOSS SFX
						if prevplayHP > player.hp {
							rl.PlaySound(audfx[14])
							prevplayHP = player.hp
						} else if prevplayHP < player.hp {
							prevplayHP = player.hp
						}
						player.hpTimer = fps * 2
						admsg("-1 dmg", rl.Red)
						zfx := Effect{}
						zfx.name = "plblood"
						zfx.imageRectangle = splat[RandInt(0, len(splat))]
						zfx.color = RandRed()
						zfx.fade = 0.8
						zfx.rectangle = player.rectangle
						zfx.rectangle.X -= b
						zfx.rectangle.Y -= b
						zfx.rectangle.Width += b2
						zfx.rectangle.Height += b2
						effect = append(effect, zfx)
					}
				}
			}
			//THORNS
			if thornson {
				thorns()
			}
			//CLOAK
			if cloak && cloakT == 0 {
				cloakT = fps / 2
				siz := b2
				zfx := Effect{}
				zfx.imageRectangle = animation[96].rectangle
				zfx.name = "cloaksparks"
				num := 10
				countbreak := 100
				for num > 0 {
					v2 := player.center
					v2.X += RandF32(-b5, b5)
					v2.Y += RandF32(-b5, b5)
					if checkV2inRooms(v2) {
						num--
						rec := rl.NewRectangle(v2.X-siz/2, v2.Y-siz/2, siz, siz)
						zfx.rectangles2 = append(zfx.rectangles2, rec)
						crec := rec
						crec.X += rec.Width / 3
						crec.Y += rec.Height / 3
						crec.Width = rec.Width / 3
						crec.Height = rec.Height / 3
						zfx.collisionRectangles = append(zfx.collisionRectangles, crec)
					}
					countbreak--
					if countbreak == 0 {
						break
					}
				}
				effect = append(effect, zfx)
			}
		}
		if player.hp == 1 && vineRing && !player.art[vineRingArtNum].isOff {
			admsg("just in the nick of vine", rl.Green)
			player.burnTimer = 0
			player.freezeTimer = 0
			player.poisonTimer = 0
			player.dampTimer = 0
			player.animationNum = 0
			player.art[vineRingArtNum].isOff = true
			vineon = true
		}
		if player.hp <= 0 {
			playerDeath()
		}
	}
}
func thorns() { //MARK:THORNS
	siz := b8
	rec := rl.NewRectangle(player.center.X-siz/2, player.center.Y-siz/2, siz, siz)
	for i := 0; i < len(levels[levNum].enemies); i++ {
		if rl.CheckCollisionRecs(levels[levNum].enemies[i].collisionRectangle, rec) && levels[levNum].enemies[i].hpT == 0 && !levels[levNum].enemies[i].nodmg {
			levels[levNum].enemies[i].hp--
			if msgT == 0 {
				admsg("ouch... thorns", rl.Red)
				msgT = fps
				zfx := Effect{}
				zfx.name = "thorns"
				zfx.imageRectangle = animation[89].rectangle
				zfx.rectangle = player.rectangle
				zfx.rectangle.X -= b4
				zfx.rectangle.Y -= b4
				zfx.rectangle.Width += b8
				zfx.rectangle.Height += b8
				effect = append(effect, zfx)
			}
			if levels[levNum].enemies[i].hp <= 0 && !levels[levNum].enemies[i].off {
				player.xp += levels[levNum].enemies[i].xp
				makeEnDeathFx(i)
				levels[levNum].enemies[i].off = true
			} else {
				levels[levNum].enemies[i].hpT = fps
				levels[levNum].enemies[i].hpY = bq3
				levels[levNum].enemies[i].hpY2 = 0
				if isBossOn {
					levels[levNum].enemies[i].hpY = b
					levels[levNum].enemies[i].hpY2 = b / 2
				}
			}
		}
	}
}
func shrec(rec rl.Rectangle, amount float32) rl.Rectangle { //MARK:SHADOW REC
	rec.X -= amount
	rec.Y += amount
	return rec
}
func blrec(rec rl.Rectangle, amount float32) rl.Rectangle { //MARK:BLUR REC
	rec.X += RandF32(-amount, amount)
	rec.Y += RandF32(-amount, amount)
	return rec
}
func orgn(rec rl.Rectangle) rl.Vector2 { //MARK:ORIGIN
	return rl.NewVector2(rec.Width/2, rec.Height/2)
}
func drec(rec rl.Rectangle) rl.Rectangle { //MARK:DRAW REC
	rec.X += rec.Width / 2
	rec.Y += rec.Height / 2
	return rec
}

// MARK: UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP UP
func updatePlayerProjectiles() { //MARK:UP PROJ PLAYER

	clear := false
	for i := 0; i < len(playerProjectiles); i++ {
		//ENEMY COLLIS
		for j := 0; j < len(levels[levNum].enemies); j++ {
			if !levels[levNum].enemies[j].off {
				if rl.CheckCollisionRecs(playerProjectiles[i].crec, levels[levNum].enemies[j].collisionRectangle) && levels[levNum].enemies[j].hpT == 0 && playerProjectiles[i].collisionTimer == 0 {
					projEnmCollis(i, j)
				}
			}
		}
		if !playerProjectiles[i].isOff {
			if playerProjectiles[i].collisionTimer > 0 {
				playerProjectiles[i].collisionTimer--
			}

			//IMG ANIMS
			if playerProjectiles[i].name == "window cleaner" {
				if frames%4 == 0 {
					playerProjectiles[i].image.X += animation[177].width
					if playerProjectiles[i].image.X > animation[177].x+animation[177].frames*animation[177].width {
						playerProjectiles[i].image.X = animation[177].x
					}
				}
				if playerProjectiles[i].rec.Width < b2 {
					playerProjectiles[i].rec.X -= 0.5
					playerProjectiles[i].rec.Y -= 0.5
					playerProjectiles[i].rec.Width += 1
					playerProjectiles[i].rec.Height += 1
					playerProjectiles[i].center = makecnt(playerProjectiles[i].rec)
				}
			}
			if playerProjectiles[i].name == "fartfire" {
				if frames%5 == 0 {
					playerProjectiles[i].image.X += animation[185].width
					if playerProjectiles[i].image.X > animation[185].x+animation[185].frames*animation[185].width {
						playerProjectiles[i].image.X = animation[185].x
					}
				}
			}

			//LIGHTER FLAME
			if playerProjectiles[i].name == "lighter" && !rl.CheckCollisionRecs(player.caRectangle, playerProjectiles[i].rec) {
				playerProjectiles[i].T--
				if playerProjectiles[i].T <= 0 {
					playerProjectiles[i].T = fps / 3
					zfx := Effect{}
					zfx.name = "flamingoflame"
					zfx.fade = 0.8
					zfx.imageRectangle = animation[98].rectangle
					zfx.rectangle = playerProjectiles[i].rec
					zfx.rectangle.X -= b / 4
					zfx.rectangle.Y -= b / 4
					zfx.rectangle.Width += b / 2
					zfx.rectangle.Height += b / 2
					zfx.collisionRectangle = zfx.rectangle
					zfx.collisionRectangle.X += zfx.collisionRectangle.Width / 8
					zfx.collisionRectangle.Y += zfx.collisionRectangle.Height / 8
					zfx.collisionRectangle.Width -= zfx.collisionRectangle.Width / 4
					zfx.collisionRectangle.Height -= zfx.collisionRectangle.Height / 4
					zfx.timer = fps * 3
					zfx.isBelow = true
					effect = append(effect, zfx)
				}
			}
			//MUSTARD INCREASE SIZE
			if playerProjectiles[i].name == "mustard" {
				if playerProjectiles[i].rec.Width < b+b/2 {
					playerProjectiles[i].rec.X -= 0.5
					playerProjectiles[i].rec.Y -= 0.5
					playerProjectiles[i].rec.Width += 1
					playerProjectiles[i].rec.Height += 1
					playerProjectiles[i].center = makecnt(playerProjectiles[i].rec)
				}
			}
			//PINEAPPLE INCREASE SIZE
			if playerProjectiles[i].name == "pineapple" {
				if playerProjectiles[i].rec.Width < b2+b/2 {
					playerProjectiles[i].rec.X -= 0.5
					playerProjectiles[i].rec.Y -= 0.5
					playerProjectiles[i].rec.Width += 1
					playerProjectiles[i].rec.Height += 1
					playerProjectiles[i].center = makecnt(playerProjectiles[i].rec)
				}
			}

			switch playerProjectiles[i].name {
			default:
				//MOVE
				canmove := checkRecMoveWalls(playerProjectiles[i].crec, playerProjectiles[i].dirX, playerProjectiles[i].dirY)
				etcNum := 0
				if canmove {
					checkrec := playerProjectiles[i].crec
					checkrec.X += playerProjectiles[i].dirX
					checkrec.Y += playerProjectiles[i].dirY
					canmove, etcNum = checkRecEtcSolid(checkrec)
				} else { //COLLIS WALL CLEAR
					if playerProjectiles[i].bounce > 0 {
						playerProjectiles[i].bounce--
						playerProjectiles[i].dirX = playerProjectiles[i].dirX * -1
						playerProjectiles[i].dirY = playerProjectiles[i].dirY * -1
						if playerProjectiles[i].name == "bunch of carrots" || playerProjectiles[i].name == "drawing pin" || playerProjectiles[i].name == "fork" || playerProjectiles[i].name == "french fries" {
							playerProjectiles[i].rotation += 180
						}
						if playerProjectiles[i].name == "rubber duck" {

							if playerProjectiles[i].dirY > 0 {
								playerProjectiles[i].dirY = RandF32(playerProjectiles[i].speed/4, playerProjectiles[i].speed)
							} else {
								playerProjectiles[i].dirY = RandF32(-playerProjectiles[i].speed, -playerProjectiles[i].speed/4)
							}

							if playerProjectiles[i].dirX > 0 {
								playerProjectiles[i].dirX = RandF32(playerProjectiles[i].speed/4, playerProjectiles[i].speed)
							} else {
								playerProjectiles[i].dirX = RandF32(-playerProjectiles[i].speed, -playerProjectiles[i].speed/4)
							}

						}
						if len(playerProjectiles) < 50 {
							if playerProjectiles[i].name == "raspberry" {
								zproj := playerProjectiles[i]
								zproj.dirX += RandF32(-2, 2)
								zproj.dirY += RandF32(-2, 2)
								playerProjectiles = append(playerProjectiles, zproj)
							}
						}
						canmove = true
					} else { //WEAPON PROJ END COLLIS ANIM
						switch playerProjectiles[i].name {
						case "raspberry", "chilli", "ladybugproj":
							zfx := Effect{}
							zfx.imageRectangle = animation[179].rectangle
							zfx.rectangle = playerProjectiles[i].rec
							if playerProjectiles[i].name == "chilli" {
								zfx.rectangle.X -= zfx.rectangle.Width / 4
								zfx.rectangle.Y -= zfx.rectangle.Width / 4
								zfx.rectangle.Width += zfx.rectangle.Width / 2
								zfx.rectangle.Height += zfx.rectangle.Height / 2
							}
							if playerProjectiles[i].name == "raspberry" {
								zfx.rectangle.X -= zfx.rectangle.Width
								zfx.rectangle.Y -= zfx.rectangle.Width
								zfx.rectangle.Width += zfx.rectangle.Width * 2
								zfx.rectangle.Height += zfx.rectangle.Height * 2
							}
							zfx.name = "redWeapEnd"
							effect = append(effect, zfx)
						case "mint ice cream":
							zfx := Effect{}
							zfx.imageRectangle = animation[179].rectangle
							zfx.rectangle = playerProjectiles[i].rec
							zfx.name = "greenWeapEnd"
							effect = append(effect, zfx)
						case "rolling pin", "magnifying glass":
							zfx := Effect{}
							zfx.imageRectangle = animation[179].rectangle
							zfx.rectangle = playerProjectiles[i].rec
							zfx.name = "brownWeapEnd"
							effect = append(effect, zfx)
						case "window cleaner", "fork":
							zfx := Effect{}
							zfx.imageRectangle = animation[179].rectangle
							zfx.rectangle = playerProjectiles[i].rec
							zfx.name = "blueWeapEnd"
							effect = append(effect, zfx)
						case "bunch of carrots", "mustard", "emoji":
							zfx := Effect{}
							zfx.imageRectangle = animation[179].rectangle
							zfx.rectangle = playerProjectiles[i].rec
							zfx.name = "orangeWeapEnd"
							effect = append(effect, zfx)
						case "kitchen knife", "frying pan", "lighter", "hot soup", "drawing pin", "popcornProj", "battyProj":
							zfx := Effect{}
							zfx.imageRectangle = animation[179].rectangle
							zfx.rectangle = playerProjectiles[i].rec
							zfx.name = "greyWeapEnd"
							effect = append(effect, zfx)
						case "pineapple", "rubber duck", "french fries", "guitar", "rolloProj":
							zfx := Effect{}
							zfx.imageRectangle = animation[179].rectangle
							zfx.rectangle = playerProjectiles[i].rec
							zfx.name = "yellowWeapEnd"
							effect = append(effect, zfx)

						}
						playerProjectiles[i].isOff = true
						clear = true
						break
					}
				}
				if canmove { //MOVE PROJ
					playerProjectiles[i].rec.X += playerProjectiles[i].dirX + delta
					playerProjectiles[i].rec.Y += playerProjectiles[i].dirY + delta
					playerProjectiles[i].crec = playerProjectiles[i].rec
					if playerProjectiles[i].name == "fartfire" {
						playerProjectiles[i].crec.X += b / 8
						playerProjectiles[i].crec.Y += b / 8
						playerProjectiles[i].crec.Width -= b / 4
						playerProjectiles[i].crec.Height -= b / 4
					}
				} else { //COLLIS ETC
					switch levels[levNum].otherTiles[etcNum].name {
					case "crate":
						if drillon {
							if playerProjectiles[i].isFirework {
								levels[levNum].otherTiles[etcNum].firework = true
							}
							levels[levNum].otherTiles[etcNum].hp = 0
						} else {
							if levels[levNum].otherTiles[etcNum].hpTimer == 0 {
								if playerProjectiles[i].isFirework {
									levels[levNum].otherTiles[etcNum].firework = true
								}
								levels[levNum].otherTiles[etcNum].hpTimer = fps / 10
								levels[levNum].otherTiles[etcNum].hp -= playerProjectiles[i].damage + (stats.strength - 1)
							}
						}
					}
					if playerProjectiles[i].bounce > 0 {
						playerProjectiles[i].bounce--
						playerProjectiles[i].dirX = playerProjectiles[i].dirX * -1
						playerProjectiles[i].dirY = playerProjectiles[i].dirY * -1
						canmove = true
					} else {
						playerProjectiles[i].isOff = true
						clear = true
						break
					}
				}
				playerProjectiles[i].rotation += playerProjectiles[i].rotationSpeed
			case "rocket":
				checkV2 := playerProjectiles[i].center
				checkV2.X += playerProjectiles[i].dirX
				checkV2.Y += playerProjectiles[i].dirY
				canmove := checkV2inRooms(checkV2)
				if canmove {
					playerProjectiles[i].rec.X += playerProjectiles[i].dirX + delta
					playerProjectiles[i].rec.Y += playerProjectiles[i].dirY + delta
					playerProjectiles[i].rec3.X += playerProjectiles[i].dirX + delta
					playerProjectiles[i].rec3.Y += playerProjectiles[i].dirY + delta
					playerProjectiles[i].center = makecnt(playerProjectiles[i].rec)
				} else {
					rl.PlaySound(audfx[94])
					playerProjectiles[i].isOff = true
					clear = true
					zfx := Effect{}
					zfx.name = "bombExplode"
					zfx.rectangle = playerProjectiles[i].rec
					zfx.rectangle.X -= b10
					zfx.rectangle.Y -= b10
					zfx.rectangle.Width += b10 * 2
					zfx.rectangle.Height += b10 * 2
					zfx.imageRectangle = animation[106].rectangle
					effect = append(effect, zfx)
				}
			case "chickenProj":
				checkrec := playerProjectiles[i].rec
				checkrec.X += playerProjectiles[i].dirX
				checkrec.Y += playerProjectiles[i].dirY
				canmove := checkRecWalls(checkrec)
				if canmove {
					canmove = checkRecSolid(checkrec)
				}
				if canmove {
					playerProjectiles[i].rec = checkrec
				} else {
					playerProjectiles[i].dirX = RandF32(-playerProjectiles[i].speed, playerProjectiles[i].speed)
					playerProjectiles[i].dirY = RandF32(-playerProjectiles[i].speed, playerProjectiles[i].speed)
				}
				playerProjectiles[i].moveT--
				if playerProjectiles[i].moveT == 0 {
					playerProjectiles[i].moveT = fps * 2
					playerProjectiles[i].dirX = RandF32(-playerProjectiles[i].speed, playerProjectiles[i].speed)
					playerProjectiles[i].dirY = RandF32(-playerProjectiles[i].speed, playerProjectiles[i].speed)
					zfx := Effect{}
					zfx.imageRectangle = otherTiles[130]
					zfx.rectangle = playerProjectiles[i].rec
					zfx.rectangle.X += b / 4
					zfx.rectangle.Y += b / 4
					zfx.rectangle.Width -= b / 2
					zfx.rectangle.Height -= b / 2
					zfx.isBelow = true
					zfx.name = "chickenEgg"
					zfx.timer = fps * 3
					effect = append(effect, zfx)
				}
				if playerProjectiles[i].dirX > 0 {
					playerProjectiles[i].direction = true
				} else {
					playerProjectiles[i].direction = false
				}
			case "poisongas":
				playerProjectiles[i].T--
				if playerProjectiles[i].T <= 0 {
					playerProjectiles[i].isOff = true
					clear = true
				}
				checkv2 := playerProjectiles[i].center
				checkv2.X += playerProjectiles[i].dirX
				checkv2.Y += playerProjectiles[i].dirY
				if checkV2inRooms(checkv2) {
					playerProjectiles[i].center = checkv2
					playerProjectiles[i].rec = rl.NewRectangle(playerProjectiles[i].center.X-playerProjectiles[i].rec.Width/2, playerProjectiles[i].center.Y-playerProjectiles[i].rec.Height/2, playerProjectiles[i].rec.Width, playerProjectiles[i].rec.Height)
					playerProjectiles[i].crec = playerProjectiles[i].rec
					playerProjectiles[i].crec.X += playerProjectiles[i].crec.Width / 4
					playerProjectiles[i].crec.Y += playerProjectiles[i].crec.Height / 4
					playerProjectiles[i].crec.Width = playerProjectiles[i].crec.Width / 2
					playerProjectiles[i].crec.Height = playerProjectiles[i].crec.Height / 2
				} else {
					playerProjectiles[i].dirX = RandF32(-playerProjectiles[i].speed, playerProjectiles[i].speed)
					playerProjectiles[i].dirY = RandF32(-playerProjectiles[i].speed, playerProjectiles[i].speed)
				}
			case "frogProj":
				//FROG TIMERS
				playerProjectiles[i].T--
				if playerProjectiles[i].T <= 0 {
					zfx := Effect{}
					zfx.rectangle = playerProjectiles[i].rec
					zfx.imageRectangle = animation[82].rectangle
					zfx.name = "frogexit"
					zfx.timer = fps * 10
					effect = append(effect, zfx)
					playerProjectiles[i].isOff = true
					clear = true
				}
				playerProjectiles[i].moveT--
				if playerProjectiles[i].moveT <= 0 {
					playerProjectiles[i].moveT = fps * RandInt32(1, 2)
					if Abs(playerProjectiles[i].dirX) > 0 || Abs(playerProjectiles[i].dirY) > 0 {
						playerProjectiles[i].dirX = 0
						playerProjectiles[i].dirY = 0
						playerProjectiles[i].image = animation[79].rectangle
						if playerProjectiles[i].lr {
							playerProjectiles[i].image = animation[78].rectangle
						}
					} else if playerProjectiles[i].dirX == 0 && playerProjectiles[i].dirY == 0 {
						if FlipCoin() {
							playerProjectiles[i].dirX = playerProjectiles[i].speed
							if FlipCoin() {
								playerProjectiles[i].dirX = -playerProjectiles[i].speed
							}
						} else {
							playerProjectiles[i].dirY = playerProjectiles[i].speed
							if FlipCoin() {
								playerProjectiles[i].dirY = -playerProjectiles[i].speed
							}
						}
						if playerProjectiles[i].dirX > 0 {
							playerProjectiles[i].lr = false
						} else {
							playerProjectiles[i].lr = true
						}
						playerProjectiles[i].image = animation[80].rectangle
						if playerProjectiles[i].lr {
							playerProjectiles[i].image = animation[81].rectangle
						}
					}
				}
				//FROG ANIM
				if frames%4 == 0 {
					if Abs(playerProjectiles[i].dirX) > 0 || Abs(playerProjectiles[i].dirY) > 0 {
						if playerProjectiles[i].lr {
							playerProjectiles[i].image.X -= animation[81].width
							if playerProjectiles[i].image.X < animation[81].x-animation[81].frames*animation[81].width {
								playerProjectiles[i].image.X = animation[81].x
							}
						} else {
							playerProjectiles[i].image.X += animation[80].width
							if playerProjectiles[i].image.X > animation[80].x+animation[80].frames*animation[80].width {
								playerProjectiles[i].image.X = animation[80].x
							}
						}
					} else {
						if playerProjectiles[i].lr {
							playerProjectiles[i].image.X -= animation[79].width
							if playerProjectiles[i].image.X < animation[79].x-animation[79].frames*animation[79].width {
								playerProjectiles[i].image.X = animation[79].x
							}
						} else {
							playerProjectiles[i].image.X += animation[78].width
							if playerProjectiles[i].image.X > animation[78].x+animation[78].frames*animation[78].width {
								playerProjectiles[i].image.X = animation[78].x
							}
						}
					}
				}
				//FROG MOVEMENT
				canmove := checkRecMoveWalls(playerProjectiles[i].crec, playerProjectiles[i].dirX, playerProjectiles[i].dirY)
				if canmove {
					checkrec := playerProjectiles[i].crec
					checkrec.X += playerProjectiles[i].dirX
					checkrec.Y += playerProjectiles[i].dirY
					canmove, _ = checkRecEtcSolid(checkrec)
				}
				if canmove {
					playerProjectiles[i].rec.X += playerProjectiles[i].dirX
					playerProjectiles[i].rec.Y += playerProjectiles[i].dirY
					playerProjectiles[i].crec = playerProjectiles[i].rec
					playerProjectiles[i].crec.X += playerProjectiles[i].crec.Width / 4
					playerProjectiles[i].crec.X += 2
					playerProjectiles[i].crec.Y += playerProjectiles[i].crec.Height / 4
					playerProjectiles[i].crec.Y += 2
					playerProjectiles[i].crec.Width = (playerProjectiles[i].crec.Width / 2) - 4
					playerProjectiles[i].crec.Height = (playerProjectiles[i].crec.Height / 2) - 4
				}
				if !canmove {
					playerProjectiles[i].moveT = fps
					playerProjectiles[i].dirX = 0
					playerProjectiles[i].dirY = 0
					playerProjectiles[i].image = animation[79].rectangle
					if playerProjectiles[i].lr {
						playerProjectiles[i].image = animation[78].rectangle
					}
				}
			case "beeProj":
				checkv2 := playerProjectiles[i].center
				checkv2.X += playerProjectiles[i].dirX
				checkv2.Y += playerProjectiles[i].dirY
				if checkV2inRooms(checkv2) {
					playerProjectiles[i].center = checkv2
					playerProjectiles[i].rec = rl.NewRectangle(playerProjectiles[i].center.X-playerProjectiles[i].rec.Width/2, playerProjectiles[i].center.Y-playerProjectiles[i].rec.Height/2, playerProjectiles[i].rec.Width, playerProjectiles[i].rec.Height)
					playerProjectiles[i].crec = playerProjectiles[i].rec
				} else {
					playerProjectiles[i].dirX = RandF32(-playerProjectiles[i].speed, playerProjectiles[i].speed)
					playerProjectiles[i].dirY = RandF32(-playerProjectiles[i].speed, playerProjectiles[i].speed)
				}
				playerProjectiles[i].moveT--
				if playerProjectiles[i].moveT == 0 {
					playerProjectiles[i].moveT = fps / 2
					playerProjectiles[i].dirX = RandF32(-playerProjectiles[i].speed, playerProjectiles[i].speed)
					playerProjectiles[i].dirY = RandF32(-playerProjectiles[i].speed, playerProjectiles[i].speed)
				}
				if playerProjectiles[i].dirX > 0 {
					playerProjectiles[i].direction = true
				} else {
					playerProjectiles[i].direction = false
				}
			}
		} else {
			clear = true
		}
	}
	if clear {
		for i := 0; i < len(playerProjectiles); i++ {
			if playerProjectiles[i].isOff {
				playerProjectiles = RemoveWeapon(playerProjectiles, i)
			}
		}
	}

	poisongasCount = 0
	for i := 0; i < len(playerProjectiles); i++ {
		if playerProjectiles[i].name == "poisongas" {
			poisongasCount++
		}
	}
}
func upprojEn() { //MARK:UP PROJ ENEMY
	clear := false
	for i := 0; i < len(enemyProjectiles); i++ {
		if !enemyProjectiles[i].isOff {
			if !rl.CheckCollisionRecs(enemyProjectiles[i].rec, inRec) {
				enemyProjectiles[i].isOff = true
			}
			//PLAYER COLLIS
			if rl.CheckCollisionRecs(player.collisionRectangle, enemyProjectiles[i].crec) && player.hpTimer == 0 && player.enemyCollisionTimer == 0 {
				player.enemyCollisionTimer = fps
				if stats.dexterity > 1 {
					if Roll12() <= stats.dexterity {
						if msgT == 0 {
							admsg("dodged > dexterity", rl.Green)
							msgT = fps
						}
					} else {
						hitPLEnProj(i)
						if enemyProjectiles[i].name == "birdProj" {
							zfx := Effect{}
							zfx.imageRectangle = otherTiles[153]
							zfx.center = player.center
							siz := bq3
							zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
							zfx.name = "birdegg"
							zfx.fade = 1
							zfx.color = rl.White
							zfx.isBelow = true
							effect = append(effect, zfx)
							admsg("easter egg", rl.Yellow)
						}
					}
				} else {
					hitPLEnProj(i)
					if enemyProjectiles[i].name == "birdProj" {
						zfx := Effect{}
						zfx.imageRectangle = otherTiles[153]
						zfx.center = player.center
						siz := b4
						zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
						zfx.name = "birdegg"
						zfx.fade = 1
						zfx.color = rl.White
						zfx.isBelow = true
						effect = append(effect, zfx)
					}
				}
				enemyProjectiles[i].isOff = true
			}
		}
		if !enemyProjectiles[i].isOff {
			switch enemyProjectiles[i].name {
			case "redblobbull", "rolloProj": //INCREASE SIZE
				if enemyProjectiles[i].rec.Width < b3 {
					enemyProjectiles[i].rec.Width += 0.2
					enemyProjectiles[i].rec.X -= 0.1
				}
				if enemyProjectiles[i].rec.Height < b3 {
					enemyProjectiles[i].rec.Height += 0.2
					enemyProjectiles[i].rec.Y -= 0.1
				}
				enemyProjectiles[i].crec = enemyProjectiles[i].rec
				if enemyProjectiles[i].name == "rolloProj" {
					enemyProjectiles[i].crec = enemyProjectiles[i].rec
					enemyProjectiles[i].crec.X += enemyProjectiles[i].crec.Width / 8
					enemyProjectiles[i].crec.Y += enemyProjectiles[i].crec.Height / 8
					enemyProjectiles[i].crec.Width -= enemyProjectiles[i].crec.Width / 4
					enemyProjectiles[i].crec.Height -= enemyProjectiles[i].crec.Height / 4
				}
			case "pinkcartbull": //CHANGE DIREC
				enemyProjectiles[i].dirX, enemyProjectiles[i].dirY = findSpdXY(enemyProjectiles[i].center, player.center, enemyProjectiles[i].speed)
			}
			//MOVE
			canmove := checkRecMoveWalls(enemyProjectiles[i].crec, enemyProjectiles[i].dirX, enemyProjectiles[i].dirY)
			etcNum := 0
			if canmove {
				checkrec := enemyProjectiles[i].crec
				checkrec.X += enemyProjectiles[i].dirX
				checkrec.Y += enemyProjectiles[i].dirY
				canmove, etcNum = checkRecEtcSolid(checkrec)
			} else { //COLLIS WALL CLEAR
				if enemyProjectiles[i].name == "bonebull" && enemyProjectiles[i].bounce > 0 {
					enemyProjectiles[i].dirX = enemyProjectiles[i].dirX * -1
					enemyProjectiles[i].dirY = enemyProjectiles[i].dirY * -1
					enemyProjectiles[i].bounce--
					canmove = true
				} else if enemyProjectiles[i].name == "mushbossProj" && enemyProjectiles[i].bounce > 0 {
					if enemyProjectiles[i].dirX > 0 {
						enemyProjectiles[i].dirX = RandF32(-boss.speed, -boss.speed/4)
					} else {
						enemyProjectiles[i].dirX = RandF32(boss.speed/4, boss.speed)
					}
					if enemyProjectiles[i].dirY > 0 {
						enemyProjectiles[i].dirY = RandF32(-boss.speed, -boss.speed/4)
					} else {
						enemyProjectiles[i].dirY = RandF32(boss.speed/4, boss.speed)
					}
					enemyProjectiles[i].bounce--
					canmove = true
				} else if enemyProjectiles[i].name == "spinnaProj" && enemyProjectiles[i].bounce > 0 {
					enemyProjectiles[i].dirX = enemyProjectiles[i].dirX * -1
					enemyProjectiles[i].dirY = enemyProjectiles[i].dirY * -1
					enemyProjectiles[i].bounce--
					canmove = true
				} else if enemyProjectiles[i].name == "birdProj" && enemyProjectiles[i].bounce > 0 {
					enemyProjectiles[i].dirX = enemyProjectiles[i].dirX * -1
					enemyProjectiles[i].dirY = enemyProjectiles[i].dirY * -1
					enemyProjectiles[i].bounce--
					canmove = true
				} else if enemyProjectiles[i].name == "greenpigProj" && enemyProjectiles[i].bounce > 0 {
					enemyProjectiles[i].dirX = enemyProjectiles[i].dirX * -1
					enemyProjectiles[i].dirY = enemyProjectiles[i].dirY * -1
					enemyProjectiles[i].bounce--
					canmove = true
				} else if enemyProjectiles[i].name == "mrfrisbeeProj" && enemyProjectiles[i].bounce > 0 {
					if FlipCoin() {
						enemyProjectiles[i].dirX *= -1
					}
					if FlipCoin() {
						enemyProjectiles[i].dirY *= -1
					}
					enemyProjectiles[i].bounce--
					canmove = true
				} else {
					switch enemyProjectiles[i].name {
					case "mushbossProj", "redblobbull", "redantbull", "redspikeproj", "bushProj":
						zfx := Effect{}
						zfx.imageRectangle = animation[179].rectangle
						zfx.rectangle = enemyProjectiles[i].rec
						zfx.name = "redWeapEnd"
						effect = append(effect, zfx)
					case "greenpigProj", "greenplantbull", "zomboProj", "spacemanProj":
						zfx := Effect{}
						zfx.imageRectangle = animation[179].rectangle
						zfx.rectangle = enemyProjectiles[i].rec
						zfx.name = "greenWeapEnd"
						effect = append(effect, zfx)
					case "rolling pin", "magnifying glass":
						zfx := Effect{}
						zfx.imageRectangle = animation[179].rectangle
						zfx.rectangle = enemyProjectiles[i].rec
						zfx.name = "brownWeapEnd"
						effect = append(effect, zfx)
					case "spinnaProj", "bluespikeproj", "icemanProj":
						zfx := Effect{}
						zfx.imageRectangle = animation[179].rectangle
						zfx.rectangle = enemyProjectiles[i].rec
						zfx.name = "blueWeapEnd"
						effect = append(effect, zfx)
					case "bonebull", "birdProj", "battyProj":
						zfx := Effect{}
						zfx.imageRectangle = animation[179].rectangle
						zfx.rectangle = enemyProjectiles[i].rec
						zfx.name = "greyWeapEnd"
						effect = append(effect, zfx)
					case "mrfrisbeeProj", "rolloProj":
						zfx := Effect{}
						zfx.imageRectangle = animation[179].rectangle
						zfx.rectangle = enemyProjectiles[i].rec
						zfx.name = "yellowWeapEnd"
						effect = append(effect, zfx)
					case "pinkcartbull":
						zfx := Effect{}
						zfx.imageRectangle = animation[179].rectangle
						zfx.rectangle = enemyProjectiles[i].rec
						zfx.name = "pinkWeapEnd"
						effect = append(effect, zfx)
					case "pigProj":
						zfx := Effect{}
						zfx.imageRectangle = animation[179].rectangle
						zfx.rectangle = enemyProjectiles[i].rec
						zfx.name = "orangeWeapEnd"
						effect = append(effect, zfx)

					}

					enemyProjectiles[i].isOff = true
					clear = true
					break
				}
			}
			if canmove { //MOVE PROJ
				if !enemyProjectiles[i].isBelow {
					enemyProjectiles[i].rec.X += enemyProjectiles[i].dirX + delta
					enemyProjectiles[i].rec.Y += enemyProjectiles[i].dirY + delta
					enemyProjectiles[i].crec.X += enemyProjectiles[i].dirX + delta
					enemyProjectiles[i].crec.Y += enemyProjectiles[i].dirY + delta
				}
			} else { //COLLIS ETC
				if enemyProjectiles[i].name == "bonebull" && enemyProjectiles[i].bounce > 0 {
					enemyProjectiles[i].dirX = enemyProjectiles[i].dirX * -1
					enemyProjectiles[i].dirY = enemyProjectiles[i].dirY * -1
					enemyProjectiles[i].bounce--
					canmove = true
				} else {
					switch levels[levNum].otherTiles[etcNum].name {
					case "crate":
						if levels[levNum].otherTiles[etcNum].hpTimer == 0 {
							levels[levNum].otherTiles[etcNum].hpTimer = fps / 10
							levels[levNum].otherTiles[etcNum].hp--
						}
					}
					enemyProjectiles[i].isOff = true
					clear = true
					break
				}
			}
			enemyProjectiles[i].rotation += enemyProjectiles[i].rotationSpeed
		} else {
			clear = true
		}
	}
	if clear {
		for i := 0; i < len(enemyProjectiles); i++ {
			if enemyProjectiles[i].isOff {
				enemyProjectiles = RemoveWeapon(enemyProjectiles, i)
			}
		}
	}
}
func upboss() { //MARK:UP BOSS
	if len(levels[levNum].enemies) > 0 {
		if levels[levNum].enemies[0].hp > 0 {
			upprojEn()
			boss.hp = levels[levNum].enemies[0].hp
			boss.hpT = levels[levNum].enemies[0].hpT
			switch bossNum {
			case 9: //ROLLO
				if boss.atkT > 0 {
					boss.atkT--
				}
				collided := false
				checkrec := boss.collisionRectangle
				checkrec.X += boss.dirX
				checkrec.Y += boss.dirY
				if rl.CheckCollisionRecs(player.collisionRectangle, checkrec) {
					countbreak := 100
					for {
						if boss.dirX > 0 {
							boss.dirX = RandF32(-boss.speed, -boss.speed/4)
						} else {
							boss.dirX = RandF32(boss.speed/4, boss.speed)
						}
						if boss.dirY > 0 {
							boss.dirY = RandF32(-boss.speed, -boss.speed/4)
						} else {
							boss.dirY = RandF32(boss.speed/4, boss.speed)
						}
						if Abs(boss.dirX) > boss.speed/2 || Abs(boss.dirY) > boss.speed/2 {
							break
						}
						countbreak--
						if countbreak == 0 {
							break
						}
					}
					collided = true
				} else {
					if checkRecWalls(checkrec) {
						boss.rectangle.X += boss.dirX
						boss.collisionRectangle.X += boss.dirX
						boss.carec.X += boss.dirX
						boss.rectangle.Y += boss.dirY
						boss.collisionRectangle.Y += boss.dirY
						boss.carec.Y += boss.dirY
						boss.cnt = makecnt(boss.rectangle)
						levels[levNum].enemies[0].rectangle = boss.rectangle
						levels[levNum].enemies[0].collisionRectangle = boss.collisionRectangle
						levels[levNum].enemies[0].cnt = boss.cnt
					} else {
						collided = true
						countbreak := 100
						for {
							if boss.dirX > 0 {
								boss.dirX = RandF32(-boss.speed, -boss.speed/4)
							} else {
								boss.dirX = RandF32(boss.speed/4, boss.speed)
							}
							if boss.dirY > 0 {
								boss.dirY = RandF32(-boss.speed, -boss.speed/4)
							} else {
								boss.dirY = RandF32(boss.speed/4, boss.speed)
							}
							if Abs(boss.dirX) > boss.speed/2 || Abs(boss.dirY) > boss.speed/2 {
								break
							}
							countbreak--
							if countbreak == 0 {
								break
							}
						}
					}
				}
				if collided && boss.atkT == 0 {
					zproj := Weapon{}
					zproj.damage = 1
					zproj.name = "rolloProj"
					siz := b
					zproj.speed = 2
					xdiff := AbsDiff(boss.cnt.X, player.center.X)
					ydiff := AbsDiff(boss.cnt.Y, player.center.Y)
					if xdiff > ydiff {
						zproj.dirX = zproj.speed
						zproj.dirY = ydiff / (xdiff / zproj.dirX)
					} else {
						zproj.dirY = zproj.speed
						zproj.dirX = xdiff / (ydiff / zproj.dirY)
					}
					if boss.cnt.X > player.center.X {
						zproj.dirX = -zproj.dirX
					}
					if boss.cnt.Y > player.center.Y {
						zproj.dirY = -zproj.dirY
					}
					cntr2 := makecnt(boss.collisionRectangle)
					if boss.lr {
						cntr2.X -= b
					} else {
						cntr2.X += b
					}
					zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
					zproj.crec = zproj.rec
					zproj.crec.X += zproj.crec.Width / 8
					zproj.crec.Y += zproj.crec.Height / 8
					zproj.crec.Width -= zproj.crec.Width / 4
					zproj.crec.Height -= zproj.crec.Height / 4
					zproj.image = animation[155].rectangle
					enemyProjectiles = append(enemyProjectiles, zproj)
					boss.atkT = fps / 2
					collided = false
				}
				switch boss.state {
				case 1:
					if frames%3 == 0 {
						if boss.lr {
							boss.image.X -= animation[154].width
							if boss.image.X < animation[154].x-animation[154].frames*animation[154].width {
								boss.image.X = animation[154].x
							}
						} else {
							boss.image.X += animation[153].width
							if boss.image.X > animation[153].x+animation[153].frames*animation[153].width {
								boss.image.X = animation[153].x
							}
						}
					}
				case 0:
					if frames%5 == 0 {
						if boss.lr {
							boss.image.X -= animation[154].width
							if boss.image.X < animation[154].x-animation[154].frames*animation[154].width {
								boss.image.X = animation[154].x
							}
						} else {
							boss.image.X += animation[153].width
							if boss.image.X > animation[153].x+animation[153].frames*animation[153].width {
								boss.image.X = animation[153].x
							}
						}
					}
				}
				if boss.moveChangeT > 0 {
					boss.moveChangeT--
				} else {
					switch boss.state {
					case 0:
						boss.speed = 14
						countbreak := 100
						for {
							boss.dirX = RandF32(-boss.speed, boss.speed)
							boss.dirY = RandF32(-boss.speed, boss.speed)
							if Abs(boss.dirX) > boss.speed/2 || Abs(boss.dirY) > boss.speed/2 {
								break
							}
							countbreak--
							if countbreak == 0 {
								break
							}
						}
						boss.state = 1
						boss.moveChangeT = fps * RandInt32(2, 4)
					case 1:
						boss.speed = 2
						countbreak := 100
						for {
							boss.dirX = RandF32(-boss.speed, boss.speed)
							boss.dirY = RandF32(-boss.speed, boss.speed)
							if Abs(boss.dirX) > boss.speed/2 || Abs(boss.dirY) > boss.speed/2 {
								break
							}
							countbreak--
							if countbreak == 0 {
								break
							}
						}
						boss.state = 0
						boss.moveChangeT = fps * RandInt32(1, 2)
					}
				}
				if player.center.X > boss.cnt.X {
					if boss.lr {
						boss.lr = false
					}
				} else {
					if !boss.lr {
						boss.lr = true
					}
				}
			case 8: //MUSHEE
				if boss.moveChangeT > 0 {
					boss.moveChangeT--
				} else {
					switch boss.state {
					case 2:
						if FlipCoin() {
							boss.state = 0
							boss.image.Y = animation[148].y
							boss.dirX = RandF32(-boss.speed, boss.speed)
							boss.dirY = RandF32(-boss.speed, boss.speed)
							if boss.lr {
								boss.image.X = animation[149].x
							} else {
								boss.image.X = animation[148].x
							}
						} else {
							boss.state = 1
							boss.image.Y = animation[148].y
							if boss.lr {
								boss.image.X = animation[149].x
							} else {
								boss.image.X = animation[148].x
							}
						}
					case 1:
						if FlipCoin() {
							boss.state = 0
							boss.image.Y = animation[148].y
							boss.dirX = RandF32(-boss.speed, boss.speed)
							boss.dirY = RandF32(-boss.speed, boss.speed)
							if boss.lr {
								boss.image.X = animation[149].x
							} else {
								boss.image.X = animation[148].x
							}
						} else {
							boss.state = 2
							boss.image.Y = animation[150].y
							boss.atkT = fps / 2
							if boss.lr {
								boss.image.X = animation[151].x
							} else {
								boss.image.X = animation[150].x
							}
						}
					case 0:
						if FlipCoin() {
							boss.state = 1
							boss.image.Y = animation[148].y
							if boss.lr {
								boss.image.X = animation[149].x
							} else {
								boss.image.X = animation[148].x
							}
						} else {
							boss.state = 2
							boss.image.Y = animation[150].y
							boss.atkT = fps / 2
							if boss.lr {
								boss.image.X = animation[151].x
							} else {
								boss.image.X = animation[150].x
							}
						}
					}
					boss.moveChangeT = RandInt32(2, 3) * fps
				}
				if boss.state != 2 {
					if boss.atkT > 0 {
						boss.atkT--
					} else {
						if Roll6() > 4 {
							zproj := Weapon{}
							zproj.damage = 2
							zproj.isBelow = true
							zproj.name = "mushLand"
							siz := b / 2
							cntr2 := makecnt(boss.collisionRectangle)
							zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
							zproj.crec = zproj.rec
							zproj.image = otherTiles[150]
							zproj.center = makecnt(zproj.rec)
							enemyProjectiles = append(enemyProjectiles, zproj)
						}
						boss.atkT = fps / 2
					}
				}
				switch boss.state {
				case 2: //ATK
					if boss.atkT > 0 {
						boss.atkT--
					} else {
						zproj := Weapon{}
						zproj.damage = 1
						zproj.name = "mushbossProj"
						siz := b2
						zproj.speed = 2
						zproj.bounce = 3
						xdiff := AbsDiff(boss.cnt.X, player.center.X)
						ydiff := AbsDiff(boss.cnt.Y, player.center.Y)
						if xdiff > ydiff {
							zproj.dirX = zproj.speed
							zproj.dirY = ydiff / (xdiff / zproj.dirX)
						} else {
							zproj.dirY = zproj.speed
							zproj.dirX = xdiff / (ydiff / zproj.dirY)
						}
						if boss.cnt.X > player.center.X {
							zproj.dirX = -zproj.dirX
						}
						if boss.cnt.Y > player.center.Y {
							zproj.dirY = -zproj.dirY
						}
						cntr2 := makecnt(boss.collisionRectangle)
						if boss.lr {
							cntr2.X -= b
						} else {
							cntr2.X += b
						}
						zproj.rotation = AngleBetweenTwoPoints(player.center, boss.cnt) + 180
						zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.crec.X += zproj.crec.Width / 4
						zproj.crec.Y += zproj.crec.Height / 4
						zproj.crec.Width = zproj.crec.Width / 2
						zproj.crec.Height = zproj.crec.Height / 2
						zproj.image = animation[152].rectangle
						enemyProjectiles = append(enemyProjectiles, zproj)
						boss.atkT = fps / 2
					}
					if frames%4 == 0 {
						if boss.lr {
							boss.image.X -= animation[151].width
							if boss.image.X < animation[151].x-animation[151].frames*animation[151].width {
								boss.image.X = animation[151].x
							}
						} else {
							boss.image.X += animation[150].width
							if boss.image.X > animation[150].x+animation[150].frames*animation[150].width {
								boss.image.X = animation[150].x
							}
						}
					}
					if player.center.X > boss.cnt.X {
						if boss.lr {
							boss.lr = false
						}
					} else {
						if !boss.lr {
							boss.lr = true
						}
					}
				case 1: //WALK TO PLAYER
					if frames%4 == 0 {
						if boss.lr {
							boss.image.X -= animation[149].width
							if boss.image.X < animation[149].x-animation[149].frames*animation[149].width {
								boss.image.X = animation[149].x
							}
						} else {
							boss.image.X += animation[148].width
							if boss.image.X > animation[148].x+animation[148].frames*animation[148].width {
								boss.image.X = animation[148].x
							}
						}
					}
					xdiff := AbsDiff(boss.cnt.X, player.center.X)
					ydiff := AbsDiff(boss.cnt.Y, player.center.Y)
					if xdiff > ydiff {
						boss.dirX = boss.speed
						boss.dirY = ydiff / (xdiff / boss.dirX)
					} else {
						boss.dirY = boss.speed
						boss.dirX = xdiff / (ydiff / boss.dirY)
					}
					if boss.cnt.X > player.center.X {
						boss.dirX = -boss.dirX
					}
					if boss.cnt.Y > player.center.Y {
						boss.dirY = -boss.dirY
					}
					checkrec := boss.collisionRectangle
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(player.collisionRectangle, checkrec) {
						boss.dirX = RandF32(-boss.speed, boss.speed)
						boss.dirY = RandF32(-boss.speed, boss.speed)
						boss.moveChangeT = fps
					} else {
						if checkRecWalls(checkrec) {
							boss.rectangle.X += boss.dirX
							boss.collisionRectangle.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rectangle.Y += boss.dirY
							boss.collisionRectangle.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rectangle)
							levels[levNum].enemies[0].rectangle = boss.rectangle
							levels[levNum].enemies[0].collisionRectangle = boss.collisionRectangle
							levels[levNum].enemies[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.speed, boss.speed)
							boss.dirY = RandF32(-boss.speed, boss.speed)
							boss.moveChangeT = fps
						}
					}
					if player.center.X > boss.cnt.X {
						if boss.lr {
							boss.lr = false
						}
					} else {
						if !boss.lr {
							boss.lr = true
						}
					}
				case 0: //WALK RANDOM
					if frames%4 == 0 {
						if boss.lr {
							boss.image.X -= animation[149].width
							if boss.image.X < animation[149].x-animation[149].frames*animation[149].width {
								boss.image.X = animation[149].x
							}
						} else {
							boss.image.X += animation[148].width
							if boss.image.X > animation[148].x+animation[148].frames*animation[148].width {
								boss.image.X = animation[148].x
							}
						}
					}
					checkrec := boss.collisionRectangle
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(player.collisionRectangle, checkrec) {
						boss.dirX = RandF32(-boss.speed, boss.speed)
						boss.dirY = RandF32(-boss.speed, boss.speed)
						boss.moveChangeT += fps
					} else {
						if checkRecWalls(checkrec) {
							boss.rectangle.X += boss.dirX
							boss.collisionRectangle.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rectangle.Y += boss.dirY
							boss.collisionRectangle.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rectangle)
							levels[levNum].enemies[0].rectangle = boss.rectangle
							levels[levNum].enemies[0].collisionRectangle = boss.collisionRectangle
							levels[levNum].enemies[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.speed, boss.speed)
							boss.dirY = RandF32(-boss.speed, boss.speed)
							boss.moveChangeT += fps
						}
					}
					if boss.dirX > 0 {
						boss.lr = false
					} else {
						boss.lr = true
					}
				}
			case 7: // BATTY
				if boss.moveChangeT > 0 {
					boss.moveChangeT--
				} else {
					switch boss.state {
					case 4:
						choose := RandInt(1, 4)
						switch choose {
						case 3:
							boss.image.Y = animation[143].y
							boss.state = 2
							if boss.lr {
								boss.image.X = animation[144].x
							} else {
								boss.image.X = animation[143].x
							}
						case 2:
							boss.image.Y = animation[145].y
							boss.state = 0
							if boss.lr {
								boss.image.X = animation[146].x
							} else {
								boss.image.X = animation[145].x
							}
						case 1:
							boss.image.Y = animation[141].y
							boss.state = 1
							if boss.lr {
								boss.image.X = animation[142].x
							} else {
								boss.image.X = animation[141].x
							}
						}
					case 3:
						boss.image.Y = animation[143].y
						boss.state = 2
						if boss.lr {
							boss.image.X = animation[144].x
						} else {
							boss.image.X = animation[143].x
						}
					case 2:
						choose := RandInt(1, 4)
						switch choose {
						case 3:
							boss.image.Y = animation[143].y
							boss.state = 4
							if boss.lr {
								boss.image.X = animation[144].x
							} else {
								boss.image.X = animation[143].x
							}
						case 2:
							boss.image.Y = animation[145].y
							boss.state = 0
							if boss.lr {
								boss.image.X = animation[146].x
							} else {
								boss.image.X = animation[145].x
							}
						case 1:
							boss.image.Y = animation[141].y
							boss.state = 1
							if boss.lr {
								boss.image.X = animation[142].x
							} else {
								boss.image.X = animation[141].x
							}
						}
					case 1:
						choose := RandInt(1, 4)
						switch choose {
						case 3:
							boss.image.Y = animation[143].y
							boss.state = 4
							if boss.lr {
								boss.image.X = animation[144].x
							} else {
								boss.image.X = animation[143].x
							}
						case 2:
							boss.image.Y = animation[145].y
							boss.state = 0
							if boss.lr {
								boss.image.X = animation[146].x
							} else {
								boss.image.X = animation[145].x
							}
						case 1:
							boss.image.Y = animation[143].y
							boss.state = 2
							if boss.lr {
								boss.image.X = animation[144].x
							} else {
								boss.image.X = animation[143].x
							}
						}
					case 0:
						choose := RandInt(1, 4)
						switch choose {
						case 3:
							boss.image.Y = animation[143].y
							boss.state = 4
							if boss.lr {
								boss.image.X = animation[144].x
							} else {
								boss.image.X = animation[143].x
							}
						case 2:
							boss.image.Y = animation[141].y
							boss.state = 1
							if boss.lr {
								boss.image.X = animation[142].x
							} else {
								boss.image.X = animation[141].x
							}
						case 1:
							boss.image.Y = animation[143].y
							boss.state = 2
							if boss.lr {
								boss.image.X = animation[144].x
							} else {
								boss.image.X = animation[143].x
							}
						}
					}
					boss.moveChangeT = fps * RandInt32(1, 2)
				}
				switch boss.state {
				case 4:
					if boss.atkT > 0 {
						boss.atkT--
					} else {
						zproj := Weapon{}
						zproj.damage = 2
						zproj.name = "battyProj"
						siz := b3
						zproj.speed = 3
						cntr2 := makecnt(boss.collisionRectangle)
						if boss.lr {
							cntr2.X -= b
						} else {
							cntr2.X += b
						}
						zproj.rotation = 0
						zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.crec.X += zproj.crec.Width / 4
						zproj.crec.Y += zproj.crec.Height / 4
						zproj.crec.Width = zproj.crec.Width / 2
						zproj.crec.Height = zproj.crec.Height / 2
						zproj.image = animation[147].rectangle
						zproj.dirY = -zproj.speed
						zproj.rotation = -90
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.rotation = 90
						zproj.dirY = zproj.speed
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirY = 0
						zproj.dirX = -zproj.speed
						zproj.rotation = 180
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirX = zproj.speed
						zproj.rotation = 0
						enemyProjectiles = append(enemyProjectiles, zproj)
						boss.atkT = fps - (fps / 3)
					}
					if frames%2 == 0 {
						if boss.lr {
							boss.image.X -= animation[144].width
							if boss.image.X < animation[144].x-animation[144].frames*animation[144].width {
								boss.image.X = animation[144].x
							}
						} else {
							boss.image.X += animation[143].width
							if boss.image.X > animation[143].x+animation[143].frames*animation[143].width {
								boss.image.X = animation[143].x
							}
						}
					}
				case 3:
					checkrec := boss.collisionRectangle
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(player.collisionRectangle, checkrec) {
						boss.dirX = RandF32(-boss.speed, boss.speed)
						boss.dirY = RandF32(-boss.speed, boss.speed)
						boss.image.Y = animation[141].y
						boss.state = 1
						if boss.lr {
							boss.image.X = animation[142].x
						} else {
							boss.image.X = animation[141].x
						}
						boss.moveChangeT = fps
					} else {
						if checkRecWalls(checkrec) {
							boss.rectangle.X += boss.dirX
							boss.collisionRectangle.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rectangle.Y += boss.dirY
							boss.collisionRectangle.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rectangle)
							levels[levNum].enemies[0].rectangle = boss.rectangle
							levels[levNum].enemies[0].collisionRectangle = boss.collisionRectangle
							levels[levNum].enemies[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.speed, boss.speed)
							boss.dirY = RandF32(-boss.speed, boss.speed)
							boss.image.Y = animation[141].y
							boss.state = 1
							if boss.lr {
								boss.image.X = animation[142].x
							} else {
								boss.image.X = animation[141].x
							}
							boss.moveChangeT = fps
						}
					}
					if frames%2 == 0 {
						if boss.lr {
							boss.image.X -= animation[142].width
							if boss.image.X < animation[142].x-animation[142].frames*animation[142].width {
								boss.image.X = animation[142].x
							}
						} else {
							boss.image.X += animation[141].width
							if boss.image.X > animation[141].x+animation[141].frames*animation[141].width {
								boss.image.X = animation[141].x
							}
						}
					}
				case 2: //ATK FLY
					if boss.atkT > 0 {
						boss.atkT--
					} else {
						zproj := Weapon{}
						zproj.damage = 2
						zproj.name = "battyProj"
						siz := b3
						zproj.speed = 3
						xdiff := AbsDiff(boss.cnt.X, player.center.X)
						ydiff := AbsDiff(boss.cnt.Y, player.center.Y)
						if xdiff > ydiff {
							zproj.dirX = zproj.speed
							zproj.dirY = ydiff / (xdiff / zproj.dirX)
						} else {
							zproj.dirY = zproj.speed
							zproj.dirX = xdiff / (ydiff / zproj.dirY)
						}
						if boss.cnt.X > player.center.X {
							zproj.dirX = -zproj.dirX
						}
						if boss.cnt.Y > player.center.Y {
							zproj.dirY = -zproj.dirY
						}
						cntr2 := makecnt(boss.collisionRectangle)
						if boss.lr {
							cntr2.X -= b
						} else {
							cntr2.X += b
						}
						zproj.rotation = AngleBetweenTwoPoints(player.center, boss.cnt) + 180
						zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.crec.X += zproj.crec.Width / 4
						zproj.crec.Y += zproj.crec.Height / 4
						zproj.crec.Width = zproj.crec.Width / 2
						zproj.crec.Height = zproj.crec.Height / 2
						zproj.image = animation[147].rectangle
						enemyProjectiles = append(enemyProjectiles, zproj)
						boss.atkT = fps - (fps / 3)
					}
					xdiff := AbsDiff(boss.cnt.X, player.center.X)
					ydiff := AbsDiff(boss.cnt.Y, player.center.Y)
					if xdiff > ydiff {
						boss.dirX = boss.speed
						boss.dirY = ydiff / (xdiff / boss.dirX)
					} else {
						boss.dirY = boss.speed
						boss.dirX = xdiff / (ydiff / boss.dirY)
					}
					if boss.cnt.X > player.center.X {
						boss.dirX = -boss.dirX
					}
					if boss.cnt.Y > player.center.Y {
						boss.dirY = -boss.dirY
					}
					checkrec := boss.collisionRectangle
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(player.collisionRectangle, checkrec) {
						boss.dirX = RandF32(-boss.speed, boss.speed)
						boss.dirY = RandF32(-boss.speed, boss.speed)
						boss.image.Y = animation[141].y
						boss.state = 1
						if boss.lr {
							boss.image.X = animation[142].x
						} else {
							boss.image.X = animation[141].x
						}
						boss.moveChangeT = fps
					} else {
						if checkRecWalls(checkrec) {
							boss.rectangle.X += boss.dirX
							boss.collisionRectangle.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rectangle.Y += boss.dirY
							boss.collisionRectangle.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rectangle)
							levels[levNum].enemies[0].rectangle = boss.rectangle
							levels[levNum].enemies[0].collisionRectangle = boss.collisionRectangle
							levels[levNum].enemies[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.speed, boss.speed)
							boss.dirY = RandF32(-boss.speed, boss.speed)
							boss.image.Y = animation[141].y
							boss.state = 1
							if boss.lr {
								boss.image.X = animation[142].x
							} else {
								boss.image.X = animation[141].x
							}
							boss.moveChangeT = fps
						}
					}
					if frames%2 == 0 {
						if boss.lr {
							boss.image.X -= animation[144].width
							if boss.image.X < animation[144].x-animation[144].frames*animation[144].width {
								boss.image.X = animation[144].x
							}
						} else {
							boss.image.X += animation[143].width
							if boss.image.X > animation[143].x+animation[143].frames*animation[143].width {
								boss.image.X = animation[143].x
							}
						}
					}
				case 1: //FLY
					xdiff := AbsDiff(boss.cnt.X, player.center.X)
					ydiff := AbsDiff(boss.cnt.Y, player.center.Y)
					if xdiff > ydiff {
						boss.dirX = boss.speed
						boss.dirY = ydiff / (xdiff / boss.dirX)
					} else {
						boss.dirY = boss.speed
						boss.dirX = xdiff / (ydiff / boss.dirY)
					}
					if boss.cnt.X > player.center.X {
						boss.dirX = -boss.dirX
					}
					if boss.cnt.Y > player.center.Y {
						boss.dirY = -boss.dirY
					}
					checkrec := boss.collisionRectangle
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(player.collisionRectangle, checkrec) {
						boss.dirX = RandF32(-boss.speed, boss.speed)
						boss.dirY = RandF32(-boss.speed, boss.speed)
						boss.image.Y = animation[141].y
						boss.state = 3
						if boss.lr {
							boss.image.X = animation[142].x
						} else {
							boss.image.X = animation[141].x
						}
						boss.moveChangeT = fps
					} else {
						if checkRecWalls(checkrec) {
							boss.rectangle.X += boss.dirX
							boss.collisionRectangle.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rectangle.Y += boss.dirY
							boss.collisionRectangle.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rectangle)
							levels[levNum].enemies[0].rectangle = boss.rectangle
							levels[levNum].enemies[0].collisionRectangle = boss.collisionRectangle
							levels[levNum].enemies[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.speed, boss.speed)
							boss.dirY = RandF32(-boss.speed, boss.speed)
							boss.image.Y = animation[141].y
							boss.state = 3
							if boss.lr {
								boss.image.X = animation[142].x
							} else {
								boss.image.X = animation[141].x
							}
							boss.moveChangeT = fps
						}
					}
					if frames%2 == 0 {
						if boss.lr {
							boss.image.X -= animation[142].width
							if boss.image.X < animation[142].x-animation[142].frames*animation[142].width {
								boss.image.X = animation[142].x
							}
						} else {
							boss.image.X += animation[141].width
							if boss.image.X > animation[141].x+animation[141].frames*animation[141].width {
								boss.image.X = animation[141].x
							}
						}
					}
				case 0: //IDLE
					if frames%2 == 0 {
						if boss.lr {
							boss.image.X -= animation[146].width
							if boss.image.X < animation[146].x-animation[146].frames*animation[146].width {
								boss.image.X = animation[146].x
							}
						} else {
							boss.image.X += animation[145].width
							if boss.image.X > animation[145].x+animation[145].frames*animation[145].width {
								boss.image.X = animation[145].x
							}
						}
					}
				}
				changed := false
				if player.center.X > boss.cnt.X {
					if boss.lr {
						boss.lr = false
						changed = true
					}
				} else {
					if !boss.lr {
						boss.lr = true
						changed = true
					}
				}
				if changed {
					switch boss.state {
					case 2:
						boss.image.Y = animation[143].y
						if boss.lr {
							boss.image.X = animation[144].x
						} else {
							boss.image.X = animation[143].x
						}
					case 1:
						boss.image.Y = animation[141].y
						if boss.lr {
							boss.image.X = animation[142].x
						} else {
							boss.image.X = animation[141].x
						}
					case 0:
						boss.image.Y = animation[145].y
						if boss.lr {
							boss.image.X = animation[146].x
						} else {
							boss.image.X = animation[145].x
						}
					}
				}
			case 6: //ZOMBO
				if boss.atkT2 > 0 {
					boss.atkT2--
				} else {
					zproj := Weapon{}
					zproj.name = "zomboSlime"
					zproj.isBelow = true
					zproj.damage = 1
					siz := b3
					cntr2 := makecnt(boss.collisionRectangle)
					zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
					zproj.crec = zproj.rec
					zproj.crec.X += zproj.crec.Width / 8
					zproj.crec.Y += zproj.crec.Width / 8
					zproj.crec.Width -= zproj.crec.Width / 4
					zproj.crec.Height -= zproj.crec.Height / 4
					zproj.image = splat[RandInt(0, len(splat))]
					zproj.fade = 0.7
					enemyProjectiles = append(enemyProjectiles, zproj)
					boss.atkT2 = fps
				}
				if boss.atkT > 0 {
					boss.atkT--
				} else {
					zproj := Weapon{}
					zproj.damage = 2
					zproj.name = "zomboProj"
					siz := b
					zproj.speed = 2
					xdiff := AbsDiff(boss.cnt.X, player.center.X)
					ydiff := AbsDiff(boss.cnt.Y, player.center.Y)
					if xdiff > ydiff {
						zproj.dirX = zproj.speed
						zproj.dirY = ydiff / (xdiff / zproj.dirX)
					} else {
						zproj.dirY = zproj.speed
						zproj.dirX = xdiff / (ydiff / zproj.dirY)
					}
					if boss.cnt.X > player.center.X {
						zproj.dirX = -zproj.dirX
					}
					if boss.cnt.Y > player.center.Y {
						zproj.dirY = -zproj.dirY
					}
					cntr2 := makecnt(boss.collisionRectangle)
					if boss.lr {
						cntr2.X -= b
					} else {
						cntr2.X += b
					}
					zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
					zproj.crec = zproj.rec
					zproj.crec.X += zproj.crec.Width / 4
					zproj.crec.Y += zproj.crec.Height / 4
					zproj.crec.Width = zproj.crec.Width / 2
					zproj.crec.Height = zproj.crec.Height / 2
					zproj.image = animation[140].rectangle
					enemyProjectiles = append(enemyProjectiles, zproj)
					boss.atkT = fps * 2
				}
				changed := false
				if player.center.X > boss.cnt.X {
					if boss.lr {
						boss.lr = false
						changed = true
					}
				} else {
					if !boss.lr {
						boss.lr = true
						changed = true
					}
				}
				if changed {
					if boss.lr {
						boss.image.X = animation[139].x
					} else {
						boss.image.X = animation[138].x
					}
				}
				if boss.moveChangeT > 0 {
					boss.moveChangeT--
					checkrec := boss.collisionRectangle
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(player.collisionRectangle, checkrec) {
						boss.dirX = RandF32(-boss.speed, boss.speed)
						boss.dirY = RandF32(-boss.speed, boss.speed)
						boss.moveChangeT = fps
					} else {
						if checkRecWalls(checkrec) {
							boss.rectangle.X += boss.dirX
							boss.collisionRectangle.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rectangle.Y += boss.dirY
							boss.collisionRectangle.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rectangle)
							levels[levNum].enemies[0].rectangle = boss.rectangle
							levels[levNum].enemies[0].collisionRectangle = boss.collisionRectangle
							levels[levNum].enemies[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.speed, boss.speed)
							boss.dirY = RandF32(-boss.speed, boss.speed)
							boss.moveChangeT = fps
						}
					}
				} else {
					//MOVE
					xdiff := AbsDiff(boss.cnt.X, player.center.X)
					ydiff := AbsDiff(boss.cnt.Y, player.center.Y)
					if xdiff > ydiff {
						boss.dirX = boss.speed
						boss.dirY = ydiff / (xdiff / boss.dirX)
					} else {
						boss.dirY = boss.speed
						boss.dirX = xdiff / (ydiff / boss.dirY)
					}
					if boss.cnt.X > player.center.X {
						boss.dirX = -boss.dirX
					}
					if boss.cnt.Y > player.center.Y {
						boss.dirY = -boss.dirY
					}
					checkrec := boss.collisionRectangle
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(player.collisionRectangle, checkrec) {
						boss.dirX = RandF32(-boss.speed, boss.speed)
						boss.dirY = RandF32(-boss.speed, boss.speed)
						boss.moveChangeT = fps
					} else {
						if checkRecWalls(checkrec) {
							boss.rectangle.X += boss.dirX
							boss.collisionRectangle.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rectangle.Y += boss.dirY
							boss.collisionRectangle.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rectangle)
							levels[levNum].enemies[0].rectangle = boss.rectangle
							levels[levNum].enemies[0].collisionRectangle = boss.collisionRectangle
							levels[levNum].enemies[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.speed, boss.speed)
							boss.dirY = RandF32(-boss.speed, boss.speed)
							boss.moveChangeT = fps
						}
					}
				}
				if frames%4 == 0 {
					if boss.lr {
						boss.image.X -= animation[139].width
						if boss.image.X < animation[139].x-animation[139].frames*animation[139].width {
							boss.image.X = animation[139].x
						}
					} else {
						boss.image.X += animation[138].width
						if boss.image.X > animation[138].x+animation[138].frames*animation[138].width {
							boss.image.X = animation[138].x
						}
					}
				}
			case 5: // PYRO PIG
				if boss.count == 3 {
					boss.count = 0
					zproj := Weapon{}
					zproj.damage = 2
					zproj.bounce = 1
					zproj.name = "pigProj"
					siz := b2
					zproj.speed = 4
					cntr2 := makecnt(boss.collisionRectangle)
					if boss.lr {
						cntr2.X -= b
					} else {
						cntr2.X += b
					}
					zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
					zproj.crec = zproj.rec
					zproj.crec.Y += zproj.crec.Height / 4
					zproj.crec.Height = zproj.crec.Height / 2
					zproj.crec.X += zproj.crec.Width / 4
					zproj.crec.Width = zproj.crec.Width / 2
					zproj.image = animation[135].rectangle
					zproj.dirY = -zproj.speed
					zproj.rotation = 180
					enemyProjectiles = append(enemyProjectiles, zproj)
					zproj.rotation = 0
					zproj.dirY = zproj.speed
					enemyProjectiles = append(enemyProjectiles, zproj)
					zproj.rotation = -90
					zproj.dirY = 0
					zproj.dirX = zproj.speed
					enemyProjectiles = append(enemyProjectiles, zproj)
					zproj.rotation = 90
					zproj.dirX = -zproj.speed
					enemyProjectiles = append(enemyProjectiles, zproj)
					zproj.rotation = -45
					zproj.dirX = zproj.speed
					zproj.dirY = zproj.speed
					enemyProjectiles = append(enemyProjectiles, zproj)
					zproj.rotation = -135
					zproj.dirX = zproj.speed
					zproj.dirY = -zproj.speed
					enemyProjectiles = append(enemyProjectiles, zproj)
					zproj.rotation = 45
					zproj.dirX = -zproj.speed
					zproj.dirY = zproj.speed
					enemyProjectiles = append(enemyProjectiles, zproj)
					zproj.rotation = 135
					zproj.dirX = -zproj.speed
					zproj.dirY = -zproj.speed
					enemyProjectiles = append(enemyProjectiles, zproj)
				}
				if boss.moveChangeT > 0 {
					boss.moveChangeT--
					checkrec := boss.collisionRectangle
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(player.collisionRectangle, checkrec) {
						boss.dirX = RandF32(-boss.speed, boss.speed)
						boss.dirY = RandF32(-boss.speed, boss.speed)
						boss.moveChangeT = fps * 2
						boss.count++
						if player.burnTimer == 0 {
							player.burnTimer += fps * 3
						}
					} else {
						if checkRecWalls(checkrec) {
							boss.rectangle.X += boss.dirX
							boss.collisionRectangle.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rectangle.Y += boss.dirY
							boss.collisionRectangle.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rectangle)
							levels[levNum].enemies[0].rectangle = boss.rectangle
							levels[levNum].enemies[0].collisionRectangle = boss.collisionRectangle
							levels[levNum].enemies[0].cnt = boss.cnt
						} else {
							boss.count++
							boss.dirX = RandF32(-boss.speed, boss.speed)
							boss.dirY = RandF32(-boss.speed, boss.speed)
							boss.moveChangeT = fps * 2
						}
					}
					if boss.moveChangeT == 0 {
						boss.count++
						boss.atkT = fps * 4
						boss.dirX = RandF32(-boss.speed, boss.speed)
						boss.dirY = RandF32(-boss.speed, boss.speed)
					}
				} else {
					boss.atkT--
					if boss.atkT == 0 {
						boss.moveChangeT = fps * 2
						boss.count++
					}
					//PROJ
					if boss.atkT2 > 0 {
						boss.atkT2--
					} else {
						zproj := Weapon{}
						zproj.damage = 2
						zproj.bounce = 1
						zproj.name = "pigProj"
						siz := b2
						zproj.speed = 4
						xdiff := AbsDiff(boss.cnt.X, player.center.X)
						ydiff := AbsDiff(boss.cnt.Y, player.center.Y)
						if xdiff > ydiff {
							zproj.dirX = zproj.speed
							zproj.dirY = ydiff / (xdiff / zproj.dirX)
						} else {
							zproj.dirY = zproj.speed
							zproj.dirX = xdiff / (ydiff / zproj.dirY)
						}
						if boss.cnt.X > player.center.X {
							zproj.dirX = -zproj.dirX
						}
						if boss.cnt.Y > player.center.Y {
							zproj.dirY = -zproj.dirY
						}
						cntr2 := makecnt(boss.collisionRectangle)
						if boss.lr {
							cntr2.X -= b
						} else {
							cntr2.X += b
						}
						zproj.rotation = AngleBetweenTwoPoints(player.center, boss.cnt) + 90
						zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.crec.Y += zproj.crec.Height / 4
						zproj.crec.Height = zproj.crec.Height / 2
						zproj.crec.X += zproj.crec.Width / 4
						zproj.crec.Width = zproj.crec.Width / 2
						zproj.image = animation[135].rectangle
						enemyProjectiles = append(enemyProjectiles, zproj)
						boss.atkT2 = fps / 10
					}
					//MOVE
					xdiff := AbsDiff(boss.cnt.X, player.center.X)
					ydiff := AbsDiff(boss.cnt.Y, player.center.Y)
					if xdiff > ydiff {
						boss.dirX = boss.speed
						boss.dirY = ydiff / (xdiff / boss.dirX)
					} else {
						boss.dirY = boss.speed
						boss.dirX = xdiff / (ydiff / boss.dirY)
					}
					if boss.cnt.X > player.center.X {
						boss.dirX = -boss.dirX
					}
					if boss.cnt.Y > player.center.Y {
						boss.dirY = -boss.dirY
					}
					checkrec := boss.collisionRectangle
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(player.collisionRectangle, checkrec) {
						boss.dirX = RandF32(-boss.speed, boss.speed)
						boss.dirY = RandF32(-boss.speed, boss.speed)
						boss.moveChangeT = fps * 2
					} else {
						if checkRecWalls(checkrec) {
							boss.rectangle.X += boss.dirX
							boss.collisionRectangle.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rectangle.Y += boss.dirY
							boss.collisionRectangle.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rectangle)
							levels[levNum].enemies[0].rectangle = boss.rectangle
							levels[levNum].enemies[0].collisionRectangle = boss.collisionRectangle
							levels[levNum].enemies[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.speed, boss.speed)
							boss.dirY = RandF32(-boss.speed, boss.speed)
							boss.moveChangeT = fps * 2
						}
					}
				}
				changed := false
				if player.center.X > boss.cnt.X {
					if boss.lr {
						boss.lr = false
						changed = true
					}
				} else {
					if !boss.lr {
						boss.lr = true
						changed = true
					}
				}
				if changed {
					if boss.lr {
						boss.image.X = animation[134].x
					} else {
						boss.image.X = animation[133].x
					}
				}
				if frames%4 == 0 {
					if boss.lr {
						boss.image.X -= animation[134].width
						if boss.image.X < animation[134].x-animation[134].frames*animation[134].width {
							boss.image.X = animation[134].x
						}
					} else {
						boss.image.X += animation[133].width
						if boss.image.X > animation[133].x+animation[133].frames*animation[133].width {
							boss.image.X = animation[133].x
						}
					}
				}
			case 4: //SPACEMAN
				if boss.state != 2 {
					if boss.moveChangeT > 0 {
						boss.moveChangeT--
					} else {
						if boss.state == 0 {
							boss.state = 1
							if boss.lr {
								boss.image = animation[127].rectangle
							} else {
								boss.image = animation[126].rectangle
							}
							boss.moveChangeT = fps * RandInt32(2, 4)
							boss.atkT = fps / 10
						} else if boss.state == 1 {
							boss.state = 0
							boss.moveChangeT = fps * RandInt32(1, 2)
						}
					}
					if player.center.X > boss.cnt.X {
						boss.lr = false
					} else {
						boss.lr = true
					}
				}
				switch boss.state {
				case 2: //HIT
					if frames%4 == 0 {
						if boss.lr {
							boss.image.X -= animation[129].width
							if boss.image.X < animation[129].x-animation[129].frames*animation[129].width {
								boss.state = 0
								boss.moveChangeT = fps * RandInt32(1, 2)
								boss.image.X = animation[125].width
							}
						} else {
							boss.image.X += animation[128].width
							if boss.image.X > animation[128].x+animation[128].frames*animation[128].width {
								boss.state = 0
								boss.moveChangeT = fps * RandInt32(1, 2)
								boss.image.X = animation[124].width
							}
						}
					}
				case 1: //ATK WALK
					xdiff := AbsDiff(boss.cnt.X, player.center.X)
					ydiff := AbsDiff(boss.cnt.Y, player.center.Y)
					if xdiff > ydiff {
						boss.dirX = boss.speed
						boss.dirY = ydiff / (xdiff / boss.dirX)
					} else {
						boss.dirY = boss.speed
						boss.dirX = xdiff / (ydiff / boss.dirY)
					}
					if boss.cnt.X > player.center.X {
						boss.dirX = -boss.dirX
					}
					if boss.cnt.Y > player.center.Y {
						boss.dirY = -boss.dirY
					}
					checkrec := boss.collisionRectangle
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if boss.atkT > 0 {
						boss.atkT--
					} else {
						zproj := Weapon{}
						zproj.damage = 1
						zproj.bounce = 1
						zproj.name = "spacemanProj"
						siz := bq3
						zproj.speed = 4
						xdiff := AbsDiff(boss.cnt.X, player.center.X)
						ydiff := AbsDiff(boss.cnt.Y, player.center.Y)
						if xdiff > ydiff {
							zproj.dirX = zproj.speed
							zproj.dirY = ydiff / (xdiff / zproj.dirX)
						} else {
							zproj.dirY = zproj.speed
							zproj.dirX = xdiff / (ydiff / zproj.dirY)
						}
						if boss.cnt.X > player.center.X {
							zproj.dirX = -zproj.dirX
						}
						if boss.cnt.Y > player.center.Y {
							zproj.dirY = -zproj.dirY
						}
						cntr2 := makecnt(boss.collisionRectangle)
						if boss.lr {
							cntr2.X -= b
						} else {
							cntr2.X += b
						}
						zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.crec.Y += zproj.crec.Height / 4
						zproj.crec.Height -= zproj.crec.Height / 2
						zproj.image = animation[131].rectangle
						enemyProjectiles = append(enemyProjectiles, zproj)
						boss.atkT = fps / 10
					}
					if rl.CheckCollisionRecs(player.collisionRectangle, checkrec) {
						boss.moveChangeT = fps * RandInt32(1, 2)
					} else {
						if checkRecWalls(checkrec) {
							boss.rectangle.X += boss.dirX
							boss.collisionRectangle.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rectangle.Y += boss.dirY
							boss.collisionRectangle.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rectangle)
							levels[levNum].enemies[0].rectangle = boss.rectangle
							levels[levNum].enemies[0].collisionRectangle = boss.collisionRectangle
							levels[levNum].enemies[0].cnt = boss.cnt
						} else {
							boss.moveChangeT = fps * RandInt32(1, 2)
						}
					}
					if frames%4 == 0 {
						if boss.lr {
							boss.image.X -= animation[127].width
							if boss.image.X < animation[127].x-animation[127].frames*animation[127].width {
								boss.image.X = animation[127].x
							}
						} else {
							boss.image.X += animation[126].width
							if boss.image.X > animation[126].x+animation[126].frames*animation[126].width {
								boss.image.X = animation[126].x
							}
						}
					}
				case 0: //IDLE
					if frames%5 == 0 {
						if boss.lr {
							boss.image.X -= animation[125].width
							if boss.image.X < animation[125].x-animation[125].frames*animation[125].width {
								boss.image.X = animation[125].x
							}
						} else {
							boss.image.X += animation[124].width
							if boss.image.X > animation[124].x+animation[124].frames*animation[124].width {
								boss.image.X = animation[124].x
							}
						}
					}
				}
			case 3: //SPINNA
				if boss.moveChangeT > 0 {
					boss.moveChangeT--
					if boss.moveChangeT == 1 {
						if boss.state == 0 {
							boss.state = 1
							boss.image.X = animation[120].x
						} else if boss.state == 2 {
							boss.state = 3
							boss.image.X = animation[122].x
						}
					}
				}
				switch boss.state {
				case 3: //SPIN END
					if frames%3 == 0 {
						boss.image.X += animation[122].width
						if boss.image.X > animation[122].x+animation[122].frames*animation[122].width {
							boss.state = 0
							boss.moveChangeT = fps * 2
							boss.atkT = fps / 2
						}
					}
				case 2: //SPIN
					if boss.atkT > 0 {
						boss.atkT--
					} else {
						zproj := Weapon{}
						zproj.damage = 2
						zproj.bounce = 1
						zproj.name = "spinnaProj"
						siz := b2 + bq
						zproj.speed = 5
						xdiff := AbsDiff(boss.cnt.X, player.center.X)
						ydiff := AbsDiff(boss.cnt.Y, player.center.Y)
						if xdiff > ydiff {
							zproj.dirX = zproj.speed
							zproj.dirY = ydiff / (xdiff / zproj.dirX)
						} else {
							zproj.dirY = zproj.speed
							zproj.dirX = xdiff / (ydiff / zproj.dirY)
						}
						if boss.cnt.X > player.center.X {
							zproj.dirX = -zproj.dirX
						}
						if boss.cnt.Y > player.center.Y {
							zproj.dirY = -zproj.dirY
						}
						zproj.rec = rl.NewRectangle(boss.cnt.X-siz/2, boss.cnt.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.crec.Y += zproj.crec.Height / 4
						zproj.crec.Height -= zproj.crec.Height / 2
						zproj.image = animation[123].rectangle
						enemyProjectiles = append(enemyProjectiles, zproj)
						boss.atkT = fps / 2
					}
					boss.image.X += animation[121].width
					if boss.image.X > animation[121].x+animation[121].frames*animation[121].width {
						boss.image.X = animation[121].x
					}
					checkrec := boss.collisionRectangle
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(player.collisionRectangle, checkrec) {
						boss.dirX = RandF32(-boss.speed/2, boss.speed/2)
						boss.dirY *= -1
					} else {
						if checkRecWalls(checkrec) {
							boss.rectangle.X += boss.dirX
							boss.collisionRectangle.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rectangle.Y += boss.dirY
							boss.collisionRectangle.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rectangle)
							levels[levNum].enemies[0].rectangle = boss.rectangle
							levels[levNum].enemies[0].collisionRectangle = boss.collisionRectangle
							levels[levNum].enemies[0].cnt = boss.cnt
						} else {
							boss.dirX = RandF32(-boss.speed/2, boss.speed/2)
							boss.dirY *= -1
						}
					}
				case 1: //SPIN START
					if frames%3 == 0 {
						boss.image.X += animation[121].width
						if boss.image.X > animation[121].x+animation[121].frames*animation[121].width {
							boss.state = 2
							boss.moveChangeT = fps * 5
							boss.dirY = boss.speed
							if player.center.Y < boss.cnt.Y {
								boss.dirY = -boss.speed
								spdX := RandF32(boss.speed/3, boss.speed)
								if player.center.X < boss.cnt.X {
									spdX *= -1
								}
								boss.dirX = spdX
							}
						}
					}
				case 0: //IDLE
					if frames%5 == 0 {
						if boss.lr {
							boss.image.X -= animation[119].width
							if boss.image.X < animation[119].x-animation[119].frames*animation[119].width {
								boss.image.X = animation[119].x
							}
						} else {
							boss.image.X += animation[118].width
							if boss.image.X > animation[118].x+animation[118].frames*animation[118].width {
								boss.image.X = animation[118].x
							}
						}
					}
				}
				if player.center.X > boss.cnt.X {
					boss.lr = false
				} else {
					boss.lr = true
				}
			case 2: //MR FRISBEE
				if rl.CheckCollisionRecs(player.collisionRectangle, boss.carec) && player.enemyCollisionTimer == 0 {
					player.enemyCollisionTimer = fps / 2
					if player.hpTimer == 0 {
						hitPL(1)
					}
					zfx := Effect{}
					zfx.imageRectangle = animation[117].rectangle
					zfx.rectangle = boss.carec
					zfx.name = "mrfrisbeenear"
					zfx.isBelow = true
					effect = append(effect, zfx)
				}
				if player.center.X > boss.cnt.X {
					boss.dirX = boss.speed
				} else {
					boss.dirX = -boss.speed
				}
				if player.center.Y > boss.cnt.Y {
					boss.dirY = boss.speed / 3
				} else {
					boss.dirY = -boss.speed / 3
				}
				if boss.atkT > 0 {
					boss.image.Y = animation[114].y
					boss.state = 2
					boss.atkT--
					if boss.atkT2 > 0 {
						boss.atkT2--
						if boss.atkT2 == 0 {
							zproj := Weapon{}
							zproj.name = "mrfrisbeeProj"
							zproj.image = animation[116].rectangle
							zproj.damage = 2
							zproj.bounce = 12
							zproj.speed = 8
							siz := b
							zproj.rec = rl.NewRectangle(boss.cnt.X-siz/2, boss.cnt.Y-siz/2, siz, siz)
							zproj.crec = zproj.rec
							zproj.WOrig = zproj.rec.Width
							if player.center.X > boss.cnt.X {
								zproj.dirX = zproj.speed
							} else {
								zproj.dirX = -zproj.speed
							}
							if player.center.Y > boss.cnt.Y {
								zproj.dirY = zproj.speed / 4
							} else {
								zproj.dirY = -zproj.speed / 4
							}
							zproj.fade = 1
							zproj.col = rl.White
							enemyProjectiles = append(enemyProjectiles, zproj)
							if Roll6() > 4 {
								zproj.dirY = zproj.speed
								if FlipCoin() {
									if FlipCoin() {
										zproj.dirX = zproj.speed / 4
									} else {
										zproj.dirX -= zproj.speed / 4
									}
								}
								enemyProjectiles = append(enemyProjectiles, zproj)
							}
							if Roll6() > 4 {
								zproj.dirY = -zproj.speed
								if FlipCoin() {
									if FlipCoin() {
										zproj.dirX = zproj.speed / 4
									} else {
										zproj.dirX -= zproj.speed / 4
									}
								}
								enemyProjectiles = append(enemyProjectiles, zproj)
							}
							boss.atkT2 = fps / RandInt32(2, 3)
						}
					}
					if boss.atkT == 1 {
						if FlipCoin() {
							boss.idleTime = fps * RandInt32(1, 3)
						} else {
							boss.walkTime = fps * RandInt32(1, 3)
							countbreak := 100
							for {
								boss.dirX = RandF32(-boss.speed, boss.speed)
								if Abs(boss.dirX) > boss.speed/3 {
									break
								}
								countbreak--
								if countbreak == 0 {
									break
								}
							}
							boss.dirY = RandF32(-boss.speed/3, boss.speed/3)
						}
						boss.atkT = 0
					}
				}
				if boss.idleTime > 0 {
					boss.image.Y = animation[110].y
					boss.state = 0
					boss.idleTime--
					if boss.idleTime == 1 {
						if FlipCoin() {
							boss.atkT = fps * RandInt32(2, 4)
							boss.atkT2 = fps / RandInt32(2, 3)
						} else {
							boss.walkTime = fps * RandInt32(1, 3)
							countbreak := 100
							for {
								boss.dirX = RandF32(-boss.speed, boss.speed)
								if Abs(boss.dirX) > boss.speed/3 {
									break
								}
								countbreak--
								if countbreak == 0 {
									break
								}
							}
							boss.dirY = RandF32(-boss.speed/3, boss.speed/3)
						}
						boss.idleTime = 0
					}
				}
				if boss.walkTime > 0 {
					boss.image.Y = animation[112].y
					boss.state = 1
					boss.walkTime--
					if boss.walkTime == 1 {
						if FlipCoin() {
							boss.atkT = fps * RandInt32(2, 4)
							boss.atkT2 = fps / RandInt32(2, 3)
						} else {
							boss.idleTime = fps * RandInt32(1, 3)
						}
						boss.walkTime = 0
					}
				}
				if boss.dirX > 0 {
					boss.lr = false
				} else {
					boss.lr = true
				}
				switch boss.state {
				case 2: //ATK
					if frames%3 == 0 {
						if boss.lr {
							boss.image.X -= animation[115].width
							if boss.image.X < animation[115].x-animation[115].frames*animation[115].width {
								boss.image.X = animation[115].x
							}
						} else {
							boss.image.X += animation[114].width
							if boss.image.X > animation[114].x+animation[114].frames*animation[114].width {
								boss.image.X = animation[114].x
							}
						}
					}
				case 1: // WALK
					if frames%3 == 0 {
						if boss.lr {
							boss.image.X -= animation[113].width
							if boss.image.X < animation[113].x-animation[113].frames*animation[113].width {
								boss.image.X = animation[113].x
							}
						} else {
							boss.image.X += animation[112].width
							if boss.image.X > animation[112].x+animation[112].frames*animation[112].width {
								boss.image.X = animation[112].x
							}
						}
					}
					checkrec := boss.collisionRectangle
					checkrec.X += boss.dirX
					checkrec.Y += boss.dirY
					if rl.CheckCollisionRecs(player.collisionRectangle, checkrec) {
						boss.idleTime = fps
						boss.walkTime = 0
					} else {
						if checkRecWalls(checkrec) {
							boss.rectangle.X += boss.dirX
							boss.collisionRectangle.X += boss.dirX
							boss.carec.X += boss.dirX
							boss.rectangle.Y += boss.dirY
							boss.collisionRectangle.Y += boss.dirY
							boss.carec.Y += boss.dirY
							boss.cnt = makecnt(boss.rectangle)
							levels[levNum].enemies[0].rectangle = boss.rectangle
							levels[levNum].enemies[0].collisionRectangle = boss.collisionRectangle
							levels[levNum].enemies[0].cnt = boss.cnt
						} else {
							boss.idleTime = fps
							boss.walkTime = 0
						}
					}
				case 0: //IDLE
					if frames%3 == 0 {
						if boss.lr {
							boss.image.X -= animation[111].width
							if boss.image.X < animation[111].x-animation[111].frames*animation[111].width {
								boss.image.X = animation[111].x
							}
						} else {
							boss.image.X += animation[110].width
							if boss.image.X > animation[110].x+animation[110].frames*animation[110].width {
								boss.image.X = animation[110].x
							}
						}
					}
				}
			case 1: //ICEMAN
				//TIMERS
				if boss.idleTime > 0 {
					boss.state = 0
					boss.idleTime--
					if boss.idleTime == 1 {
						boss.onoff = false
						if FlipCoin() {
							boss.dirX = RandF32(-boss.speed, boss.speed)
							boss.walkTime = fps * RandInt32(1, 2)
							boss.ud = FlipCoin()
						} else {
							boss.atkT = fps * 2
						}
						boss.idleTime = 0
					}
					if !boss.onoff {
						zfx := Effect{}
						zfx.imageRectangle = animation[109].rectangle
						zfx.rectangle = boss.rectangle
						zfx.rectangle.X -= b
						zfx.rectangle.Y -= b
						zfx.rectangle.Width += b2
						zfx.rectangle.Height += b2
						zfx.collisionRectangle = zfx.rectangle
						zfx.collisionRectangle.X += b
						zfx.collisionRectangle.Y += b
						zfx.collisionRectangle.Width -= b2
						zfx.collisionRectangle.Height -= b2
						zfx.name = "icemanchange"
						effect = append(effect, zfx)
						boss.onoff = true
					}
				}
				if boss.atkT > 0 {
					if boss.atkT2 > 0 {
						boss.atkT2--
					} else {
						siz := b
						zproj := Weapon{}
						zproj.rec = rl.NewRectangle(boss.cnt.X-siz/2, boss.cnt.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.crec.X += zproj.rec.Width / 4
						zproj.crec.Width = zproj.crec.Width / 2
						zproj.image = otherTiles[148]
						zproj.dirY = 6
						zproj.damage = 2
						zproj.center = makecnt(zproj.rec)
						zproj.fade = 1
						zproj.col = rl.White
						zproj.name = "icemanProj"
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirX = zproj.dirY / 4
						zproj.rotation = -15
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirX = -zproj.dirY / 4
						zproj.rotation = 15
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirX = -zproj.dirY / 2
						zproj.rotation = 30
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirX = -zproj.dirY / 1.3
						zproj.rotation = 45
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirX = zproj.dirY / 2
						zproj.rotation = -30
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirX = zproj.dirY / 1.3
						zproj.rotation = -45
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirY = -4
						zproj.dirX = 0
						zproj.rotation = -180
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirX = zproj.dirY / 4
						zproj.rotation = -195
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirX = -zproj.dirY / 4
						zproj.rotation = 195
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirX = -zproj.dirY / 2
						zproj.rotation = 210
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirX = -zproj.dirY / 1.3
						zproj.rotation = 235
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirX = zproj.dirY / 2
						zproj.rotation = -210
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirX = zproj.dirY / 1.3
						zproj.rotation = -235
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirX = -4
						zproj.dirY = 0
						zproj.rotation = 90
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirY = zproj.dirX / 4
						zproj.rotation = 105
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirY = -zproj.dirX / 4
						zproj.rotation = 75
						enemyProjectiles = append(enemyProjectiles, zproj)
						if Roll12() > 9 {
							zproj.dirY = zproj.dirX / 2
							zproj.rotation = 120
							enemyProjectiles = append(enemyProjectiles, zproj)
							zproj.dirY = -zproj.dirX / 2
							zproj.rotation = 60
							enemyProjectiles = append(enemyProjectiles, zproj)
						}
						zproj.dirX = 4
						zproj.dirY = 0
						zproj.rotation = -90
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirY = zproj.dirX / 4
						zproj.rotation = -75
						enemyProjectiles = append(enemyProjectiles, zproj)
						zproj.dirY = -zproj.dirX / 4
						zproj.rotation = -105
						enemyProjectiles = append(enemyProjectiles, zproj)
						if Roll12() > 9 {
							zproj.dirY = zproj.dirX / 2
							zproj.rotation = -60
							enemyProjectiles = append(enemyProjectiles, zproj)
							zproj.dirY = -zproj.dirX / 2
							zproj.rotation = -120
							enemyProjectiles = append(enemyProjectiles, zproj)
						}
						boss.atkT2 = fps / 2
					}
					boss.state = 1
					boss.atkT--
					if boss.atkT == 1 {
						boss.onoff = false
						if FlipCoin() {
							boss.dirX = RandF32(-boss.speed, boss.speed)
							boss.walkTime = fps * RandInt32(1, 2)
							boss.ud = FlipCoin()
						} else {
							boss.idleTime = fps
						}
						boss.atkT = 0
					}
					if !boss.onoff {
						zfx := Effect{}
						zfx.imageRectangle = animation[109].rectangle
						zfx.rectangle = boss.rectangle
						zfx.rectangle.X -= b
						zfx.rectangle.Y -= b
						zfx.rectangle.Width += b2
						zfx.rectangle.Height += b2
						zfx.collisionRectangle = zfx.rectangle
						zfx.collisionRectangle.X += b
						zfx.collisionRectangle.Y += b
						zfx.collisionRectangle.Width -= b2
						zfx.collisionRectangle.Height -= b2
						zfx.name = "icemanchange"
						effect = append(effect, zfx)
						boss.onoff = true
					}
				}
				if boss.walkTime > 0 {
					checkrec := boss.collisionRectangle
					checkrec.X += boss.dirX
					if boss.ud {
						checkrec.Y += 1
					} else {
						checkrec.Y -= 1
					}
					// ADD BOSS MOVE PLAYER COLLIS
					if rl.CheckCollisionRecs(player.collisionRectangle, checkrec) {
						boss.idleTime = fps
						boss.walkTime = 0
					} else {
						if checkRecWalls(checkrec) {
							boss.rectangle.X += boss.dirX
							boss.collisionRectangle.X += boss.dirX
							if boss.ud {
								boss.rectangle.Y += 0.5
								boss.collisionRectangle.Y += 0.5
							} else {
								boss.rectangle.Y -= 0.5
								boss.collisionRectangle.Y -= 0.5
							}
							boss.cnt = makecnt(boss.rectangle)
							levels[levNum].enemies[0].rectangle = boss.rectangle
							levels[levNum].enemies[0].collisionRectangle = boss.collisionRectangle
							levels[levNum].enemies[0].cnt = boss.cnt
						} else {
							boss.idleTime = fps
							boss.walkTime = 0
						}
					}
					if boss.dirX > 0 {
						boss.lr = true
						boss.state = 2
					} else {
						boss.lr = false
						boss.state = 3
					}
					boss.walkTime--
					if boss.walkTime == 1 {
						boss.onoff = false
						boss.dirX = 0
						if FlipCoin() {
							boss.atkT = fps * 2
						} else {
							boss.idleTime = fps
						}
						boss.walkTime = 0
					}
					if !boss.onoff {
						zfx := Effect{}
						zfx.imageRectangle = animation[109].rectangle
						zfx.rectangle = boss.rectangle
						zfx.rectangle.X -= b
						zfx.rectangle.Y -= b
						zfx.collisionRectangle.X += b
						zfx.collisionRectangle.Y += b
						zfx.collisionRectangle.Width -= b2
						zfx.collisionRectangle.Height -= b2
						zfx.name = "icemanchange"
						effect = append(effect, zfx)
						boss.onoff = true
					}
				}
				switch boss.state {
				case 3: //WALK L
					if frames%2 == 0 {
						boss.image.X += boss.walkLeftAnimation.width
						if boss.image.X > boss.walkLeftAnimation.x+boss.walkLeftAnimation.frames*boss.walkLeftAnimation.width {
							boss.image.X = boss.walkLeftAnimation.x
						}
					}
				case 2: //WALK R
					if frames%2 == 0 {
						boss.image.X += boss.walkRightAnimation.width
						if boss.image.X > boss.walkRightAnimation.x+boss.walkRightAnimation.frames*boss.walkRightAnimation.width {
							boss.image.X = boss.walkRightAnimation.x
						}
					}
				case 1: //ATK
					if frames%2 == 0 {
						boss.image.X += boss.attackAnimation.width
						if boss.image.X > boss.attackAnimation.x+boss.attackAnimation.frames*boss.attackAnimation.width {
							boss.image.X = boss.attackAnimation.x
						}
					}
				case 0: //IDLE
					if frames%2 == 0 {
						boss.image.X += boss.idleAnimation.width
						if boss.image.X > boss.idleAnimation.x+boss.idleAnimation.frames*boss.idleAnimation.width {
							boss.image.X = boss.idleAnimation.x
						}
					}
				}
			}

		} else {
			if !levels[levNum].enemies[0].off {
				switch bossNum {
				case 9: //ROLLO
					siz := b6
					zfx := Effect{}
					zfx.name = "rollodthfx"
					zfx.imageRectangle = animation[197].rectangle
					zfx.center = levels[levNum].enemies[0].cnt
					zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
					effect = append(effect, zfx)
				case 8: //MUSHEE
					siz := b7
					zfx := Effect{}
					zfx.name = "musheedthfx"
					zfx.imageRectangle = animation[196].rectangle
					zfx.center = levels[levNum].enemies[0].cnt
					zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
					effect = append(effect, zfx)
				case 7: //BATTY
					siz := b7
					zfx := Effect{}
					zfx.name = "battydthfx"
					zfx.imageRectangle = animation[195].rectangle
					zfx.center = levels[levNum].enemies[0].cnt
					zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
					effect = append(effect, zfx)
				case 6: //ZOMBO
					siz := b7
					zfx := Effect{}
					zfx.name = "zombodthfx"
					zfx.imageRectangle = animation[194].rectangle
					zfx.center = levels[levNum].enemies[0].cnt
					zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
					effect = append(effect, zfx)
				case 5: //PYRO PIG
					siz := b9
					zfx := Effect{}
					zfx.name = "pyrodthfx"
					zfx.imageRectangle = animation[193].rectangle
					zfx.center = levels[levNum].enemies[0].cnt
					zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
					effect = append(effect, zfx)
				case 4: //SPZMAN
					siz := b7
					zfx := Effect{}
					zfx.name = "spzmandthfx"
					zfx.imageRectangle = animation[192].rectangle
					zfx.center = levels[levNum].enemies[0].cnt
					zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
					effect = append(effect, zfx)
				case 3: //SPINNA
					siz := b7
					zfx := Effect{}
					zfx.name = "spinnadthfx"
					zfx.imageRectangle = animation[191].rectangle
					zfx.center = levels[levNum].enemies[0].cnt
					zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
					effect = append(effect, zfx)
				case 2: //MR FRISBEE
					siz := b9
					zfx := Effect{}
					zfx.name = "frisbeedthfx"
					zfx.imageRectangle = animation[190].rectangle
					zfx.center = levels[levNum].enemies[0].cnt
					zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
					effect = append(effect, zfx)
				case 1: //ICEMAN
					siz := b7
					zfx := Effect{}
					zfx.name = "icedthfx"
					zfx.imageRectangle = animation[189].rectangle
					zfx.center = levels[levNum].enemies[0].cnt
					zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
					effect = append(effect, zfx)

				}
				player.xp += levels[levNum].enemies[0].xp
				player.hp = player.hpMax
				player.mana = player.manaMax

				rl.StopMusicStream(music[currentMusic])
				currentMusic = 3
				switch dispMusic {
				case 0:
					prevMusic = RandInt(4, len(music))
				case 1:
					prevMusic = 4
				case 2:
					prevMusic = 5
				case 3:
					prevMusic = 6
				}
				if !rl.IsSoundPlaying(audfx[122]) {
					rl.PlaySound(audfx[122])
				}
				rl.PlayMusicStream(music[currentMusic])

				//MAKE EXIT
				siz := b
				ztile := Tile{}
				cntr := makecnt(levels[levNum].rectangles[0])
				ztile.rectangle = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
				ztile.name = "stairs"
				ztile.image = otherTiles[147]
				levels[levNum].otherTiles = append(levels[levNum].otherTiles, ztile)

				//MAKE CHEST
				siz = b2
				zchst := Chest{}
				zchst.slots = 5
				for i := 0; i < zchst.slots; i++ {
					zchst.item = append(zchst.item, Item{})
				}
				switch bossNum {
				case 1: //ICEMAN
					zchst.item[0] = itemList[122]
				case 2: //MR FRISBEE
					zchst.item[0] = itemList[123]
				case 3: //SPINNA
					zchst.item[0] = itemList[124]
				case 4: //SPZMAN
					zchst.item[0] = itemList[125]
				case 5: //PYRO PIG
					zchst.item[0] = itemList[126]
				case 6: //ZOMBO
					zchst.item[0] = itemList[127]
				case 7: //BATTY
					zchst.item[0] = itemList[128]
				case 8: //MUSHEE
					zchst.item[0] = itemList[129]
				case 9: //ROLLO
					zchst.item[0] = itemList[130]
				}

				zchst.item[1] = itemList[83] //PEARL

				if FlipCoin() { //GOLD
					zchst.item[2] = itemList[38]
					zchst.item[2].numof = 100
				} else { //PLATINUM
					zchst.item[2] = itemList[42]
					zchst.item[2].numof = 100
				}
				if FlipCoin() { //WEAPON CASE
					zchst.item[3] = itemList[120]
				} else { //BACKPACK
					zchst.item[3] = itemList[31]
				}

				choose2 := RandInt(0, 10)
				switch choose2 {
				case 0:
					zchst.item[4] = itemList[82]
				case 1:
					zchst.item[4] = itemList[85]
				case 2:
					zchst.item[4] = itemList[70]
				case 3:
					zchst.item[4] = itemList[72]
				case 4:
					zchst.item[4] = itemList[35]
				case 5:
					zchst.item[4] = itemList[36]
				case 6:
					zchst.item[4] = itemList[69]
				case 7:
					zchst.item[4] = itemList[52]
				case 8:
					zchst.item[4] = itemList[68]
				case 9:
					zchst.item[4] = itemList[67]
				}

				zchst.item[0].isNoChestMove = true
				zchst.item[1].isNoChestMove = true
				zchst.item[2].isNoChestMove = true
				zchst.item[3].isNoChestMove = true
				zchst.item[4].isNoChestMove = true

				zchst.image = animation[4].rectangle
				zchst.center = currentPosition
				zchst.center.Y += b2
				zchst.rectangle = rl.NewRectangle(zchst.center.X-siz/2, zchst.center.Y-siz/2, siz, siz)
				zchst.center = makecnt(zchst.rectangle)
				zchst.collisionRectangle = zchst.rectangle
				zchst.collisionRectangle.X += zchst.collisionRectangle.Width / 4
				zchst.collisionRectangle.Y += zchst.collisionRectangle.Height / 2
				zchst.collisionRectangle.Y -= 4
				zchst.collisionRectangle.Width = zchst.collisionRectangle.Width / 2
				zchst.collisionRectangle.Height = (zchst.collisionRectangle.Height / 9) * 4
				levels[levNum].chests = append(levels[levNum].chests, zchst)
				bossSkillList = append(bossSkillList, bossNum)
				levels[levNum].enemies[0].off = true
				Remove(4)
			}

			//UP BOSS KEYS
			if !hasBossKeyChanged {
				if !bosskey1 {
					bosskey1 = true
					for i := 0; i < len(base.name); i++ {
						if base.name[i] == "boss key 1" && !base.isUnlocked[i] {
							base.isUnlocked[i] = true
						}
					}
				} else if !bosskey2 {
					bosskey2 = true
					for i := 0; i < len(base.name); i++ {
						if base.name[i] == "boss key 2" && !base.isUnlocked[i] {
							base.isUnlocked[i] = true
						}
					}
				} else if !bosskey3 {
					bosskey3 = true
					for i := 0; i < len(base.name); i++ {
						if base.name[i] == "boss key 3" && !base.isUnlocked[i] {
							base.isUnlocked[i] = true
						}
					}

					pause = true
					isBossOn = false
					endgame = true
				}
				hasBossKeyChanged = true
			}

		}
	}
}
func upWeapon(num, newlev int) { //MARK:UPGRADE WEAPON

	ore := 0
	switch num {
	case 0:
		player.weapon.level = newlev
		switch player.weapon.level {
		case 2:
			player.weapon.damage = player.weapon.originalDamage + 1
			weaponUpgradeText = "+1 dmg"
		case 3:
			player.weapon.damage = player.weapon.originalDamage + 2
			weaponUpgradeText = "+2 dmg"
		case 4:
			player.weapon.damage = player.weapon.originalDamage + 3
			weaponUpgradeText = "+3 dmg"
		case 5:
			player.weapon.damage = player.weapon.originalDamage + 3
			player.weapon.special = RandInt(1, 12)
			switch player.weapon.special {
			case 1:
				weaponUpgradeText = "+3 dmg +chain lightning"
			case 2:
				weaponUpgradeText = "+3 dmg +arrow wall"
			case 3:
				weaponUpgradeText = "+3 dmg +crate fireworks"
			case 4:
				weaponUpgradeText = "+3 dmg +turret drop"
			case 5:
				weaponUpgradeText = "+3 dmg +bomb drop"
			case 6:
				weaponUpgradeText = "+3 dmg +rocket"
			case 7:
				weaponUpgradeText = "+3 dmg +attack speed"
			case 8:
				weaponUpgradeText = "+3 dmg +potion drop"
			case 9:
				weaponUpgradeText = "+3 dmg +double xp"
			case 10:
				weaponUpgradeText = "+3 dmg +ring of fire"
			case 11:
				weaponUpgradeText = "+3 dmg +slude geysers"
			}

		case 6:
			player.weapon.damage = player.weapon.originalDamage + 3
			if player.weapon.special == 0 {
				player.weapon.special = RandInt(1, 12)
			}
			for {
				player.weapon.special2 = RandInt(1, 12)
				if player.weapon.special2 != player.weapon.special {
					break
				}
			}
			switch player.weapon.special {
			case 1:
				weaponUpgradeText = "+3 dmg +chain lightning"
			case 2:
				weaponUpgradeText = "+3 dmg +arrow wall"
			case 3:
				weaponUpgradeText = "+3 dmg +crate fireworks"
			case 4:
				weaponUpgradeText = "+3 dmg +turret drop"
			case 5:
				weaponUpgradeText = "+3 dmg +bomb drop"
			case 6:
				weaponUpgradeText = "+3 dmg +rocket"
			case 7:
				weaponUpgradeText = "+3 dmg +attack speed"
			case 8:
				weaponUpgradeText = "+3 dmg +potion drop"
			case 9:
				weaponUpgradeText = "+3 dmg +double xp"
			case 10:
				weaponUpgradeText = "+3 dmg +ring of fire"
			case 11:
				weaponUpgradeText = "+3 dmg +slude geysers"
			}
			switch player.weapon.special2 {
			case 1:
				weaponUpgradeText = weaponUpgradeText + " +chain lightning"
			case 2:
				weaponUpgradeText = weaponUpgradeText + " +arrow wall"
			case 3:
				weaponUpgradeText = weaponUpgradeText + " +crate fireworks"
			case 4:
				weaponUpgradeText = weaponUpgradeText + " +turret drop"
			case 5:
				weaponUpgradeText = weaponUpgradeText + " +bomb drop"
			case 6:
				weaponUpgradeText = weaponUpgradeText + " +rocket"
			case 7:
				weaponUpgradeText = weaponUpgradeText + " +attack speed"
			case 8:
				weaponUpgradeText = weaponUpgradeText + " +potion drop"
			case 9:
				weaponUpgradeText = weaponUpgradeText + " +double xp"
			case 10:
				weaponUpgradeText = weaponUpgradeText + " +ring of fire"
			case 11:
				weaponUpgradeText = weaponUpgradeText + " +slude geysers"
			}
		}
	case 1:
		player.weapon2.level = newlev
		switch player.weapon2.level {
		case 2:
			player.weapon2.damage = player.weapon2.originalDamage + 1
			weaponUpgradeText = "+1 dmg"
		case 3:
			player.weapon2.damage = player.weapon2.originalDamage + 2
			weaponUpgradeText = "+2 dmg"
		case 4:
			player.weapon2.damage = player.weapon2.originalDamage + 3
			weaponUpgradeText = "+3 dmg"
		case 5:
			player.weapon2.damage = player.weapon2.originalDamage + 3
			player.weapon2.special = RandInt(1, 12)
			switch player.weapon2.special {
			case 1:
				weaponUpgradeText = "+3 dmg +chain lightning"
			case 2:
				weaponUpgradeText = "+3 dmg +arrow wall"
			case 3:
				weaponUpgradeText = "+3 dmg +crate fireworks"
			case 4:
				weaponUpgradeText = "+3 dmg +turret drop"
			case 5:
				weaponUpgradeText = "+3 dmg +bomb drop"
			case 6:
				weaponUpgradeText = "+3 dmg +rocket"
			case 7:
				weaponUpgradeText = "+3 dmg +attack speed"
			case 8:
				weaponUpgradeText = "+3 dmg +potion drop"
			case 9:
				weaponUpgradeText = "+3 dmg +double xp"
			case 10:
				weaponUpgradeText = "+3 dmg +ring of fire"
			case 11:
				weaponUpgradeText = "+3 dmg +slude geysers"
			}
		case 6:
			player.weapon2.damage = player.weapon2.originalDamage + 3
			if player.weapon2.special == 0 {
				player.weapon2.special = RandInt(1, 12)
			}
			for {
				player.weapon2.special2 = RandInt(1, 12)
				if player.weapon2.special2 != player.weapon2.special {
					break
				}
			}
			switch player.weapon2.special {
			case 1:
				weaponUpgradeText = "+3 dmg +chain lightning"
			case 2:
				weaponUpgradeText = "+3 dmg +arrow wall"
			case 3:
				weaponUpgradeText = "+3 dmg +crate fireworks"
			case 4:
				weaponUpgradeText = "+3 dmg +turret drop"
			case 5:
				weaponUpgradeText = "+3 dmg +bomb drop"
			case 6:
				weaponUpgradeText = "+3 dmg +rocket"
			case 7:
				weaponUpgradeText = "+3 dmg +attack speed"
			case 8:
				weaponUpgradeText = "+3 dmg +potion drop"
			case 9:
				weaponUpgradeText = "+3 dmg +double xp"
			case 10:
				weaponUpgradeText = "+3 dmg +ring of fire"
			case 11:
				weaponUpgradeText = "+3 dmg +slude geysers"
			}
			switch player.weapon2.special2 {
			case 1:
				weaponUpgradeText = weaponUpgradeText + " +chain lightning"
			case 2:
				weaponUpgradeText = weaponUpgradeText + " +arrow wall"
			case 3:
				weaponUpgradeText = weaponUpgradeText + " +crate fireworks"
			case 4:
				weaponUpgradeText = weaponUpgradeText + " +turret drop"
			case 5:
				weaponUpgradeText = weaponUpgradeText + " +bomb drop"
			case 6:
				weaponUpgradeText = weaponUpgradeText + " +rocket"
			case 7:
				weaponUpgradeText = weaponUpgradeText + " +attack speed"
			case 8:
				weaponUpgradeText = weaponUpgradeText + " +potion drop"
			case 9:
				weaponUpgradeText = weaponUpgradeText + " +double xp"
			case 10:
				weaponUpgradeText = weaponUpgradeText + " +ring of fire"
			case 11:
				weaponUpgradeText = weaponUpgradeText + " +slude geysers"
			}

		}
	case 2:
		player.weapons[0].level = newlev
		switch player.weapons[0].level {
		case 2:
			player.weapons[0].damage = player.weapons[0].originalDamage + 1
			weaponUpgradeText = "+1 dmg"
		case 3:
			player.weapons[0].damage = player.weapons[0].originalDamage + 2
			weaponUpgradeText = "+2 dmg"
		case 4:
			player.weapons[0].damage = player.weapons[0].originalDamage + 3
			weaponUpgradeText = "+3 dmg"
		case 5:
			player.weapons[0].damage = player.weapons[0].originalDamage + 3
			player.weapons[0].special = RandInt(1, 12)

			switch player.weapons[0].special {
			case 1:
				weaponUpgradeText = "+3 dmg +chain lightning"
			case 2:
				weaponUpgradeText = "+3 dmg +arrow wall"
			case 3:
				weaponUpgradeText = "+3 dmg +crate fireworks"
			case 4:
				weaponUpgradeText = "+3 dmg +turret drop"
			case 5:
				weaponUpgradeText = "+3 dmg +bomb drop"
			case 6:
				weaponUpgradeText = "+3 dmg +rocket"
			case 7:
				weaponUpgradeText = "+3 dmg +attack speed"
			case 8:
				weaponUpgradeText = "+3 dmg +potion drop"
			case 9:
				weaponUpgradeText = "+3 dmg +double xp"
			case 10:
				weaponUpgradeText = "+3 dmg +ring of fire"
			case 11:
				weaponUpgradeText = "+3 dmg +slude geysers"
			}
		case 6:
			player.weapons[0].damage = player.weapons[0].originalDamage + 3
			if player.weapons[0].special == 0 {
				player.weapons[0].special = RandInt(1, 12)
			}
			for {
				player.weapons[0].special2 = RandInt(1, 12)
				if player.weapons[0].special2 != player.weapons[0].special {
					break
				}
			}

			switch player.weapons[0].special {
			case 1:
				weaponUpgradeText = "+3 dmg +chain lightning"
			case 2:
				weaponUpgradeText = "+3 dmg +arrow wall"
			case 3:
				weaponUpgradeText = "+3 dmg +crate fireworks"
			case 4:
				weaponUpgradeText = "+3 dmg +turret drop"
			case 5:
				weaponUpgradeText = "+3 dmg +bomb drop"
			case 6:
				weaponUpgradeText = "+3 dmg +rocket"
			case 7:
				weaponUpgradeText = "+3 dmg +attack speed"
			case 8:
				weaponUpgradeText = "+3 dmg +potion drop"
			case 9:
				weaponUpgradeText = "+3 dmg +double xp"
			case 10:
				weaponUpgradeText = "+3 dmg +ring of fire"
			case 11:
				weaponUpgradeText = "+3 dmg +slude geysers"
			}
			switch player.weapons[0].special2 {
			case 1:
				weaponUpgradeText = weaponUpgradeText + " +chain lightning"
			case 2:
				weaponUpgradeText = weaponUpgradeText + " +arrow wall"
			case 3:
				weaponUpgradeText = weaponUpgradeText + " +crate fireworks"
			case 4:
				weaponUpgradeText = weaponUpgradeText + " +turret drop"
			case 5:
				weaponUpgradeText = weaponUpgradeText + " +bomb drop"
			case 6:
				weaponUpgradeText = weaponUpgradeText + " +rocket"
			case 7:
				weaponUpgradeText = weaponUpgradeText + " +attack speed"
			case 8:
				weaponUpgradeText = weaponUpgradeText + " +potion drop"
			case 9:
				weaponUpgradeText = weaponUpgradeText + " +double xp"
			case 10:
				weaponUpgradeText = weaponUpgradeText + " +ring of fire"
			case 11:
				weaponUpgradeText = weaponUpgradeText + " +slude geysers"
			}
		}
	case 3:
		player.weapons[1].level = newlev
		switch player.weapons[1].level {
		case 2:
			player.weapons[1].damage = player.weapons[1].originalDamage + 1
			weaponUpgradeText = "+1 dmg"
		case 3:
			player.weapons[1].damage = player.weapons[1].originalDamage + 2
			weaponUpgradeText = "+2 dmg"
		case 4:
			player.weapons[1].damage = player.weapons[1].originalDamage + 3
			weaponUpgradeText = "+3 dmg"
		case 5:
			player.weapons[1].damage = player.weapons[1].originalDamage + 3
			player.weapons[1].special = RandInt(1, 12)
			switch player.weapons[1].special {
			case 1:
				weaponUpgradeText = "+3 dmg +chain lightning"
			case 2:
				weaponUpgradeText = "+3 dmg +arrow wall"
			case 3:
				weaponUpgradeText = "+3 dmg +crate fireworks"
			case 4:
				weaponUpgradeText = "+3 dmg +turret drop"
			case 5:
				weaponUpgradeText = "+3 dmg +bomb drop"
			case 6:
				weaponUpgradeText = "+3 dmg +rocket"
			case 7:
				weaponUpgradeText = "+3 dmg +attack speed"
			case 8:
				weaponUpgradeText = "+3 dmg +potion drop"
			case 9:
				weaponUpgradeText = "+3 dmg +double xp"
			case 10:
				weaponUpgradeText = "+3 dmg +ring of fire"
			case 11:
				weaponUpgradeText = "+3 dmg +slude geysers"
			}
		case 6:
			player.weapons[1].damage = player.weapons[1].originalDamage + 3
			if player.weapons[1].special == 0 {
				player.weapons[1].special = RandInt(1, 12)
			}
			for {
				player.weapons[1].special2 = RandInt(1, 12)
				if player.weapons[1].special2 != player.weapons[1].special {
					break
				}
			}

			switch player.weapons[1].special {
			case 1:
				weaponUpgradeText = "+3 dmg +chain lightning"
			case 2:
				weaponUpgradeText = "+3 dmg +arrow wall"
			case 3:
				weaponUpgradeText = "+3 dmg +crate fireworks"
			case 4:
				weaponUpgradeText = "+3 dmg +turret drop"
			case 5:
				weaponUpgradeText = "+3 dmg +bomb drop"
			case 6:
				weaponUpgradeText = "+3 dmg +rocket"
			case 7:
				weaponUpgradeText = "+3 dmg +attack speed"
			case 8:
				weaponUpgradeText = "+3 dmg +potion drop"
			case 9:
				weaponUpgradeText = "+3 dmg +double xp"
			case 10:
				weaponUpgradeText = "+3 dmg +ring of fire"
			case 11:
				weaponUpgradeText = "+3 dmg +slude geysers"
			}
			switch player.weapons[1].special2 {
			case 1:
				weaponUpgradeText = weaponUpgradeText + " +chain lightning"
			case 2:
				weaponUpgradeText = weaponUpgradeText + " +arrow wall"
			case 3:
				weaponUpgradeText = weaponUpgradeText + " +crate fireworks"
			case 4:
				weaponUpgradeText = weaponUpgradeText + " +turret drop"
			case 5:
				weaponUpgradeText = weaponUpgradeText + " +bomb drop"
			case 6:
				weaponUpgradeText = weaponUpgradeText + " +rocket"
			case 7:
				weaponUpgradeText = weaponUpgradeText + " +attack speed"
			case 8:
				weaponUpgradeText = weaponUpgradeText + " +potion drop"
			case 9:
				weaponUpgradeText = weaponUpgradeText + " +double xp"
			case 10:
				weaponUpgradeText = weaponUpgradeText + " +ring of fire"
			case 11:
				weaponUpgradeText = weaponUpgradeText + " +slude geysers"
			}
		}
	case 4:
		player.weapons[2].level = newlev
		switch player.weapons[2].level {
		case 2:
			player.weapons[2].damage = player.weapons[2].originalDamage + 1
			weaponUpgradeText = "+1 dmg"
		case 3:
			player.weapons[2].damage = player.weapons[2].originalDamage + 2
			weaponUpgradeText = "+2 dmg"
		case 4:
			player.weapons[2].damage = player.weapons[2].originalDamage + 3
			weaponUpgradeText = "+3 dmg"
		case 5:
			player.weapons[2].damage = player.weapons[2].originalDamage + 3
			player.weapons[2].special = RandInt(1, 12)
			switch player.weapons[2].special {
			case 1:
				weaponUpgradeText = "+3 dmg +chain lightning"
			case 2:
				weaponUpgradeText = "+3 dmg +arrow wall"
			case 3:
				weaponUpgradeText = "+3 dmg +crate fireworks"
			case 4:
				weaponUpgradeText = "+3 dmg +turret drop"
			case 5:
				weaponUpgradeText = "+3 dmg +bomb drop"
			case 6:
				weaponUpgradeText = "+3 dmg +rocket"
			case 7:
				weaponUpgradeText = "+3 dmg +attack speed"
			case 8:
				weaponUpgradeText = "+3 dmg +potion drop"
			case 9:
				weaponUpgradeText = "+3 dmg +double xp"
			case 10:
				weaponUpgradeText = "+3 dmg +ring of fire"
			case 11:
				weaponUpgradeText = "+3 dmg +slude geysers"
			}
		case 6:
			player.weapons[2].damage = player.weapons[2].originalDamage + 3
			if player.weapons[2].special == 0 {
				player.weapons[2].special = RandInt(1, 12)
			}
			for {
				player.weapons[2].special2 = RandInt(1, 12)
				if player.weapons[2].special2 != player.weapons[2].special {
					break
				}
			}
			switch player.weapons[2].special {
			case 1:
				weaponUpgradeText = "+3 dmg +chain lightning"
			case 2:
				weaponUpgradeText = "+3 dmg +arrow wall"
			case 3:
				weaponUpgradeText = "+3 dmg +crate fireworks"
			case 4:
				weaponUpgradeText = "+3 dmg +turret drop"
			case 5:
				weaponUpgradeText = "+3 dmg +bomb drop"
			case 6:
				weaponUpgradeText = "+3 dmg +rocket"
			case 7:
				weaponUpgradeText = "+3 dmg +attack speed"
			case 8:
				weaponUpgradeText = "+3 dmg +potion drop"
			case 9:
				weaponUpgradeText = "+3 dmg +double xp"
			case 10:
				weaponUpgradeText = "+3 dmg +ring of fire"
			case 11:
				weaponUpgradeText = "+3 dmg +slude geysers"
			}
			switch player.weapons[2].special2 {
			case 1:
				weaponUpgradeText = weaponUpgradeText + " +chain lightning"
			case 2:
				weaponUpgradeText = weaponUpgradeText + " +arrow wall"
			case 3:
				weaponUpgradeText = weaponUpgradeText + " +crate fireworks"
			case 4:
				weaponUpgradeText = weaponUpgradeText + " +turret drop"
			case 5:
				weaponUpgradeText = weaponUpgradeText + " +bomb drop"
			case 6:
				weaponUpgradeText = weaponUpgradeText + " +rocket"
			case 7:
				weaponUpgradeText = weaponUpgradeText + " +attack speed"
			case 8:
				weaponUpgradeText = weaponUpgradeText + " +potion drop"
			case 9:
				weaponUpgradeText = weaponUpgradeText + " +double xp"
			case 10:
				weaponUpgradeText = weaponUpgradeText + " +ring of fire"
			case 11:
				weaponUpgradeText = weaponUpgradeText + " +slude geysers"
			}
		}
	case 5:
		player.weapons[3].level = newlev
		switch player.weapons[3].level {
		case 2:
			player.weapons[3].damage = player.weapons[3].originalDamage + 1
			weaponUpgradeText = "+1 dmg"
		case 3:
			player.weapons[3].damage = player.weapons[3].originalDamage + 2
			weaponUpgradeText = "+2 dmg"
		case 4:
			player.weapons[3].damage = player.weapons[3].originalDamage + 3
			weaponUpgradeText = "+3 dmg"
		case 5:
			player.weapons[3].damage = player.weapons[3].originalDamage + 3
			player.weapons[3].special = RandInt(1, 12)
			switch player.weapons[3].special {
			case 1:
				weaponUpgradeText = "+3 dmg +chain lightning"
			case 2:
				weaponUpgradeText = "+3 dmg +arrow wall"
			case 3:
				weaponUpgradeText = "+3 dmg +crate fireworks"
			case 4:
				weaponUpgradeText = "+3 dmg +turret drop"
			case 5:
				weaponUpgradeText = "+3 dmg +bomb drop"
			case 6:
				weaponUpgradeText = "+3 dmg +rocket"
			case 7:
				weaponUpgradeText = "+3 dmg +attack speed"
			case 8:
				weaponUpgradeText = "+3 dmg +potion drop"
			case 9:
				weaponUpgradeText = "+3 dmg +double xp"
			case 10:
				weaponUpgradeText = "+3 dmg +ring of fire"
			case 11:
				weaponUpgradeText = "+3 dmg +slude geysers"
			}
		case 6:
			player.weapons[3].damage = player.weapons[3].originalDamage + 3
			if player.weapons[3].special == 0 {
				player.weapons[3].special = RandInt(1, 12)
			}
			for {
				player.weapons[3].special2 = RandInt(1, 12)
				if player.weapons[3].special2 != player.weapons[3].special {
					break
				}
			}
			switch player.weapons[3].special {
			case 1:
				weaponUpgradeText = "+3 dmg +chain lightning"
			case 2:
				weaponUpgradeText = "+3 dmg +arrow wall"
			case 3:
				weaponUpgradeText = "+3 dmg +crate fireworks"
			case 4:
				weaponUpgradeText = "+3 dmg +turret drop"
			case 5:
				weaponUpgradeText = "+3 dmg +bomb drop"
			case 6:
				weaponUpgradeText = "+3 dmg +rocket"
			case 7:
				weaponUpgradeText = "+3 dmg +attack speed"
			case 8:
				weaponUpgradeText = "+3 dmg +potion drop"
			case 9:
				weaponUpgradeText = "+3 dmg +double xp"
			case 10:
				weaponUpgradeText = "+3 dmg +ring of fire"
			case 11:
				weaponUpgradeText = "+3 dmg +slude geysers"
			}
			switch player.weapons[3].special2 {
			case 1:
				weaponUpgradeText = weaponUpgradeText + " +chain lightning"
			case 2:
				weaponUpgradeText = weaponUpgradeText + " +arrow wall"
			case 3:
				weaponUpgradeText = weaponUpgradeText + " +crate fireworks"
			case 4:
				weaponUpgradeText = weaponUpgradeText + " +turret drop"
			case 5:
				weaponUpgradeText = weaponUpgradeText + " +bomb drop"
			case 6:
				weaponUpgradeText = weaponUpgradeText + " +rocket"
			case 7:
				weaponUpgradeText = weaponUpgradeText + " +attack speed"
			case 8:
				weaponUpgradeText = weaponUpgradeText + " +potion drop"
			case 9:
				weaponUpgradeText = weaponUpgradeText + " +double xp"
			case 10:
				weaponUpgradeText = weaponUpgradeText + " +ring of fire"
			case 11:
				weaponUpgradeText = weaponUpgradeText + " +slude geysers"
			}
		}
	}

	switch newlev - 1 {
	case 1:
		ore = 1
	case 2:
		ore = 2
	case 3:
		ore = 3
	case 4:
		ore = 4
	case 5:
		ore = 5
	}

	found := false
	newcost := 0
	switch ore {
	case 5: //PLATINUM
		newcost = PLATINUM_PRICE
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].name == "platinum" {
				if storeItm[i].numof > newcost {
					storeItm[i].numof -= newcost
					found = true
					break
				} else if storeItm[i].numof == newcost {
					storeItm[i].numof = 0
					storeItm[i].isOff = true
					storeItm[i] = Item{}
					found = true
					break
				} else if storeItm[i].numof < newcost {
					newcost -= storeItm[i].numof
					storeItm[i].numof = 0
					storeItm[i].isOff = true
					storeItm[i] = Item{}
				}
			}
		}
		if !found {
			for i := 0; i < len(player.inventory); i++ {
				if player.inventory[i].name == "platinum" {
					if player.inventory[i].numof > newcost {
						player.inventory[i].numof -= newcost
						break
					} else if player.inventory[i].numof == newcost {
						player.inventory[i].numof = 0
						player.inventory[i].isOff = true
						player.inventory[i] = Item{}
						break
					} else if player.inventory[i].numof < newcost {
						newcost -= player.inventory[i].numof
						player.inventory[i].numof = 0
						player.inventory[i].isOff = true
						player.inventory[i] = Item{}
					}
				}
			}
		}

	case 4: //GOLD
		newcost = GOLD_PRICE
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].name == "gold" {
				if storeItm[i].numof > newcost {
					storeItm[i].numof -= newcost
					found = true
				} else if storeItm[i].numof == newcost {
					storeItm[i].numof = 0
					storeItm[i].isOff = true
					storeItm[i] = Item{}
					found = true
				} else if storeItm[i].numof < newcost {
					newcost -= storeItm[i].numof
					storeItm[i].numof = 0
					storeItm[i].isOff = true
					storeItm[i] = Item{}
				}
			}
		}
		if !found {
			for i := 0; i < len(player.inventory); i++ {
				if player.inventory[i].name == "gold" {
					if player.inventory[i].numof > newcost {
						player.inventory[i].numof -= newcost
					} else if player.inventory[i].numof == newcost {
						player.inventory[i].numof = 0
						player.inventory[i].isOff = true
						player.inventory[i] = Item{}
					} else if player.inventory[i].numof < newcost {
						newcost -= player.inventory[i].numof
						player.inventory[i].numof = 0
						player.inventory[i].isOff = true
						player.inventory[i] = Item{}
					}
				}
			}
		}

	case 3: //SILVER

		newcost = SILVER_PRICE
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].name == "silver" {
				if storeItm[i].numof > newcost {
					storeItm[i].numof -= newcost
					found = true
				} else if storeItm[i].numof == newcost {
					storeItm[i].numof = 0
					storeItm[i].isOff = true
					storeItm[i] = Item{}
					found = true
				} else if storeItm[i].numof < newcost {
					newcost -= storeItm[i].numof
					storeItm[i].numof = 0
					storeItm[i].isOff = true
					storeItm[i] = Item{}
				}
			}
		}
		if !found {
			for i := 0; i < len(player.inventory); i++ {
				if player.inventory[i].name == "silver" {
					if player.inventory[i].numof > newcost {
						player.inventory[i].numof -= newcost
					} else if player.inventory[i].numof == newcost {
						player.inventory[i].numof = 0
						player.inventory[i].isOff = true
						player.inventory[i] = Item{}
					} else if player.inventory[i].numof < newcost {
						newcost -= player.inventory[i].numof
						player.inventory[i].numof = 0
						player.inventory[i].isOff = true
						player.inventory[i] = Item{}
					}
				}
			}
		}

	case 2: //BRONZE
		newcost = BRONZE_PRICE
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].name == "bronze" {
				if storeItm[i].numof > newcost {
					storeItm[i].numof -= newcost
					found = true
				} else if storeItm[i].numof == newcost {
					storeItm[i].numof = 0
					storeItm[i].isOff = true
					storeItm[i] = Item{}
					found = true
				} else if storeItm[i].numof < newcost {
					newcost -= storeItm[i].numof
					storeItm[i].numof = 0
					storeItm[i].isOff = true
					storeItm[i] = Item{}
				}
			}
		}
		if !found {
			for i := 0; i < len(player.inventory); i++ {
				if player.inventory[i].name == "bronze" {
					if player.inventory[i].numof > newcost {
						player.inventory[i].numof -= newcost
					} else if player.inventory[i].numof == newcost {
						player.inventory[i].numof = 0
						player.inventory[i].isOff = true
						player.inventory[i] = Item{}
					} else if player.inventory[i].numof < newcost {
						newcost -= player.inventory[i].numof
						player.inventory[i].numof = 0
						player.inventory[i].isOff = true
						player.inventory[i] = Item{}
					}
				}
			}
		}

	case 1: //LEAD
		newcost = LEAD_PRICE
		for i := 0; i < len(storeItm); i++ {
			if storeItm[i].name == "lead" {
				if storeItm[i].numof > newcost {
					storeItm[i].numof -= newcost
					found = true
				} else if storeItm[i].numof == newcost {
					storeItm[i].numof = 0
					storeItm[i].isOff = true
					storeItm[i] = Item{}
					found = true
				} else if storeItm[i].numof < newcost {
					newcost -= storeItm[i].numof
					storeItm[i].numof = 0
					storeItm[i].isOff = true
					storeItm[i] = Item{}
				}
			}
		}
		if !found {
			for i := 0; i < len(player.inventory); i++ {
				if player.inventory[i].name == "lead" {
					if player.inventory[i].numof > newcost {
						player.inventory[i].numof -= newcost
					} else if player.inventory[i].numof == newcost {
						player.inventory[i].numof = 0
						player.inventory[i].isOff = true
						player.inventory[i] = Item{}
					} else if player.inventory[i].numof < newcost {
						newcost -= player.inventory[i].numof
						player.inventory[i].numof = 0
						player.inventory[i].isOff = true
						player.inventory[i] = Item{}
					}
				}
			}
		}

	}
	rl.PlaySound(audfx[48])
}
func up() { //MARK:UP

	if musicon {
		rl.UpdateMusicStream(music[currentMusic])
	}

	if !isBaseOn && exiting {
		exiting = false
	}

	if !pause {
		if !player.gameover {
			updatePlayer()
		}
		initCams()
		if len(effect) > 0 {
			upfxclear()
		}
		if isBossOn {
			upboss()
		}
		levT++
		if levT%fps == 0 {
			levSecs++
			if levSecs == 60 {
				levMins++
				levSecs = 0
			}
		}
	}
	if batty {
		if !pause || pause && isBaseOn {
			upbatty()
		}
	}
	if rollo {
		if !pause || pause && isBaseOn {
			uprollo()
		}
	}
	if !player.gameover {
		upquik()
		upinven()
	}
	inp()
	timers()

	if fadeblink {
		if fadeblinkF < 0.7 {
			fadeblinkF += 0.05
		} else {
			fadeblink = false
		}
	} else {
		if fadeblinkF > 0.1 {
			fadeblinkF -= 0.05
		} else {
			fadeblink = true
		}
	}
	if fadeblink2 {
		if fadeblinkF2 < 1 {
			fadeblinkF2 += 0.01
		} else {
			fadeblink2 = false
		}
	} else {
		if fadeblinkF2 > 0.5 {
			fadeblinkF2 -= 0.01
		} else {
			fadeblink2 = true
		}
	}
}
func uprollo() { //MARK:UP ROLLO

	if isBaseOn {
		canmove := false
		v2 := rollocomp.cnt
		v2.X += rollocomp.dirX
		v2.Y += rollocomp.dirY
		if rl.CheckCollisionPointRec(v2, screenBordRec) {
			canmove = true
		}
		for i := 0; i < len(base.collisionRectangle); i++ {
			if rl.CheckCollisionPointRec(v2, base.collisionRectangle[i]) {
				canmove = false
			}
		}

		if canmove {
			rollocomp.cnt = v2
			rollocomp.rectangle = rl.NewRectangle(rollocomp.cnt.X-rollocomp.rectangle.Width/2, rollocomp.cnt.Y-rollocomp.rectangle.Height/2, rollocomp.rectangle.Width, rollocomp.rectangle.Height)
		} else {
			for {
				if rollocomp.dirX > 0 {
					rollocomp.dirX = RandF32(-rollocomp.speed, -rollocomp.speed/4)
				} else {
					rollocomp.dirX = RandF32(rollocomp.speed/4, rollocomp.speed)
				}
				if rollocomp.dirY > 0 {
					rollocomp.dirY = RandF32(-rollocomp.speed, -rollocomp.speed/4)
				} else {
					rollocomp.dirY = RandF32(rollocomp.speed/4, rollocomp.speed)
				}

				if Abs(rollocomp.dirY) > rollocomp.speed/3 || Abs(rollocomp.dirX) > rollocomp.speed/3 {
					break
				}
			}
		}
		if rollocomp.dirX > 0 {
			rollocomp.lr = false
		} else {
			rollocomp.lr = true
		}
	} else {
		if rollocomp.atkT > 0 {
			rollocomp.atkT--
			if rollocomp.atkT == 1 {
				zproj := Weapon{}
				zproj.damage = 1
				zproj.name = "rolloProj"
				siz := b
				zproj.speed = 5
				zproj.rec = rl.NewRectangle(rollocomp.cnt.X-siz/2, rollocomp.cnt.Y-siz/2, siz, siz)
				zproj.crec = zproj.rec
				zproj.crec.X += zproj.crec.Width / 8
				zproj.crec.Y += zproj.crec.Height / 8
				zproj.crec.Width -= zproj.crec.Width / 4
				zproj.crec.Height -= zproj.crec.Height / 4
				zproj.image = animation[155].rectangle
				zproj.dirX = zproj.speed
				zproj.dirY = zproj.speed
				playerProjectiles = append(playerProjectiles, zproj)
				zproj.dirX = -zproj.speed
				zproj.dirY = zproj.speed
				playerProjectiles = append(playerProjectiles, zproj)
				zproj.dirX = zproj.speed
				zproj.dirY = -zproj.speed
				playerProjectiles = append(playerProjectiles, zproj)
				zproj.dirX = -zproj.speed
				zproj.dirY = -zproj.speed
				playerProjectiles = append(playerProjectiles, zproj)

				rollocomp.atkT = fps * 3
			}
		}

		checkrec := rollocomp.rectangle
		checkrec.X += rollocomp.dirX
		checkrec.Y += rollocomp.dirY
		canmove := checkRecWalls(checkrec)
		if canmove {
			canmove = checkRecSolid(checkrec)
		}
		if canmove {
			rollocomp.rectangle = checkrec
			rollocomp.cnt = makecnt(rollocomp.rectangle)
		} else {
			for {
				if rollocomp.dirX > 0 {
					rollocomp.dirX = RandF32(-rollocomp.speed, -rollocomp.speed/4)
				} else {
					rollocomp.dirX = RandF32(rollocomp.speed/4, rollocomp.speed)
				}
				if rollocomp.dirY > 0 {
					rollocomp.dirY = RandF32(-rollocomp.speed, -rollocomp.speed/4)
				} else {
					rollocomp.dirY = RandF32(rollocomp.speed/4, rollocomp.speed)
				}

				if Abs(rollocomp.dirY) > rollocomp.speed/3 || Abs(rollocomp.dirX) > rollocomp.speed/3 {
					break
				}
			}
		}
		if rollocomp.dirX > 0 {
			rollocomp.lr = false
		} else {
			rollocomp.lr = true
		}

		if frames%30 == 0 {
			if AbsDiff(player.center.X, rollocomp.cnt.X) > b5 {
				if player.center.X > rollocomp.cnt.X {
					rollocomp.dirX = rollocomp.speed
				} else {
					rollocomp.dirX = -rollocomp.speed
				}
			}
			if AbsDiff(player.center.Y, rollocomp.cnt.Y) > b5 {
				if player.center.Y > rollocomp.cnt.Y {
					rollocomp.dirY = rollocomp.speed
				} else {
					rollocomp.dirY = -rollocomp.speed
				}
			}
		}
	}

}
func upbatty() { //MARK:UP BATTY

	if isBaseOn {
		if batcomp.moveChangeT > 0 {
			batcomp.moveChangeT--
		} else {
			batcomp.moveChangeT = fps * RandInt32(1, 4)
			batcomp.dirX = RandF32(-batcomp.speed, batcomp.speed)
			batcomp.dirY = RandF32(-batcomp.speed, batcomp.speed)
		}

		if batcomp.dirX > 0 {
			batcomp.lr = false
		} else {
			batcomp.lr = true
		}

		canmove := false
		v2 := batcomp.cnt
		v2.X += batcomp.dirX
		v2.Y += batcomp.dirY
		if rl.CheckCollisionPointRec(v2, screenBordRec) {
			canmove = true
		}
		if canmove {
			batcomp.cnt.X += batcomp.dirX + delta
			batcomp.cnt.Y += batcomp.dirY + delta
			batcomp.rectangle = rl.NewRectangle(batcomp.cnt.X-batcomp.rectangle.Width/2, batcomp.cnt.Y-batcomp.rectangle.Height/2, batcomp.rectangle.Width, batcomp.rectangle.Height)
		} else {
			batcomp.dirX = RandF32(-batcomp.speed, batcomp.speed)
			batcomp.dirY = RandF32(-batcomp.speed, batcomp.speed)
		}

	} else {
		if batcomp.atkT > 0 {
			batcomp.atkT--
			if batcomp.atkT == 1 {

				zproj := Weapon{}
				zproj.damage = 2
				zproj.name = "battyProj"
				siz := b
				zproj.speed = 3
				cntr2 := makecnt(batcomp.rectangle)
				zproj.rotation = 0
				zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
				zproj.crec = zproj.rec
				zproj.crec.X += zproj.crec.Width / 4
				zproj.crec.Y += zproj.crec.Height / 4
				zproj.crec.Width = zproj.crec.Width / 2
				zproj.crec.Height = zproj.crec.Height / 2
				zproj.image = animation[147].rectangle
				zproj.dirY = -zproj.speed
				zproj.rotation = -90
				playerProjectiles = append(playerProjectiles, zproj)
				zproj.rotation = 90
				zproj.dirY = zproj.speed
				playerProjectiles = append(playerProjectiles, zproj)
				zproj.dirY = 0
				zproj.dirX = -zproj.speed
				zproj.rotation = 180
				playerProjectiles = append(playerProjectiles, zproj)
				zproj.dirX = zproj.speed
				zproj.rotation = 0
				playerProjectiles = append(playerProjectiles, zproj)

				batcomp.atkT = fps * 7
			}
		}

		if batcomp.moveChangeT > 0 {
			batcomp.moveChangeT--
		} else {
			batcomp.moveChangeT = fps * RandInt32(1, 4)
			batcomp.dirX = RandF32(-batcomp.speed, batcomp.speed)
			batcomp.dirY = RandF32(-batcomp.speed, batcomp.speed)
		}

		if batcomp.dirX > 0 {
			batcomp.lr = false
		} else {
			batcomp.lr = true
		}

		canmove := false
		v2 := batcomp.cnt
		v2.X += batcomp.dirX
		v2.Y += batcomp.dirY
		for i := 0; i < len(levels[levNum].rectangles); i++ {
			if rl.CheckCollisionPointRec(v2, levels[levNum].rectangles[i]) {
				canmove = true
			}
		}

		if canmove {
			batcomp.cnt.X += batcomp.dirX + delta
			batcomp.cnt.Y += batcomp.dirY + delta
			batcomp.rectangle = rl.NewRectangle(batcomp.cnt.X-batcomp.rectangle.Width/2, batcomp.cnt.Y-batcomp.rectangle.Height/2, batcomp.rectangle.Width, batcomp.rectangle.Height)
		} else {
			batcomp.dirX = RandF32(-batcomp.speed, batcomp.speed)
			batcomp.dirY = RandF32(-batcomp.speed, batcomp.speed)
		}

		if frames%30 == 0 {
			if AbsDiff(player.center.X, batcomp.cnt.X) > b5 {
				if player.center.X > batcomp.cnt.X {
					batcomp.dirX = batcomp.speed
				} else {
					batcomp.dirX = -batcomp.speed
				}
			}
			if AbsDiff(player.center.Y, batcomp.cnt.Y) > b5 {
				if player.center.Y > batcomp.cnt.Y {
					batcomp.dirY = batcomp.speed
				} else {
					batcomp.dirY = -batcomp.speed
				}
			}
		}
	}

}

func upInvenClearArt() { //MARK:UP INVEN CLEAR ARTIFACTS
	for i := 0; i < len(player.inventory); i++ {
		if player.inventory[i].art {
			max := false
			switch player.inventory[i].name {
			case "umbrella":
				if !umbrella {
					umbrella = true
				} else {
					max = true
				}
			case "map chest pin":
				if !chestpin {
					chestpin = true
				} else {
					max = true
				}
			case "map exit pin":
				if !mappin {
					mappin = true
				} else {
					max = true
				}
			case "gas mask":
				if gasmasknum < gasmaskmax {
					gasmasknum++
					if gasmaskT == 0 {
						gasmaskT = fps*8 - (gasmasknum * fps)
					}
				} else {
					max = true
				}
			case "noodles":
				if !noodles {
					noodles = true
				} else {
					max = true
				}
			case "oven glove":
				if ovenglovenum < ovenglovemax {
					ovenglovenum++
				} else {
					max = true
				}
			case "toaster":
				if !toaster {
					toaster = true
				} else {
					max = true
				}
			case "ninja star":
				if ninjanum < ninjamax {
					ninjanum++
				} else {
					max = true
				}
			case "flamingo":
				if flamingonum < flamingomax {
					flamingonum++
					if flamingoT == 0 {
						flamingoT = (fps + fps/2) / flamingonum
					}
				} else {
					max = true
				}
			case "mug of tea":
				if teanum < teamax {
					teanum++
				} else {
					max = true
				}
			case "cloak of sparks":
				if !cloak {
					cloak = true
				} else {
					max = true
				}
			case "feather":
				if !feather {
					feather = true
				} else {
					max = true
				}
			case "mugging":
				if mugnum < mugmax {
					mugnum++
				} else {
					max = true
				}
			case "lightbulb":
				if lightbulbnum < lightbulbmax {
					lightbulbnum++
				} else {
					max = true
				}
			case "candy cane":
				if candycanenum < candycanemax {
					candycanenum++
				} else {
					max = true
				}
			case "pearl":
				if pearlnum < pearlmax {
					pearlnum++
					player.hpMax++
					player.hp++
				} else {
					max = true
				}
			case "magicians hat":
				if magicianshatnum < magicianshatmax {
					magicianshatnum++
					player.manaMax++
					player.mana++
				} else {
					max = true
				}
			case "throwing knife":
				if throwingknifenum < throwingknifemax {
					throwingknifenum++
				} else {
					max = true
				}
			case "toxic sludge":
				if !toxic {
					toxic = true
				} else {
					max = true
				}
			case "mirror":
				if !mirror {
					mirror = true
				} else {
					max = true
				}
			case "belt of whipping":
				if beltnum < beltmax {
					beltnum++
				} else {
					max = true
				}
			case "amulet of disc":
				if !frisbee {
					frisbee = true
				} else {
					max = true
				}
			case "amulet of purple rain":
				if !purplerain {
					purplerain = true
				} else {
					max = true
				}
			case "tesla coil":
				if !tesla {
					tesla = true
				} else {
					max = true
				}
			case "ring of twin":
				if !twin {
					twin = true
				} else {
					max = true
				}
			case "ring of thorns":
				if !thornson {
					thornson = true
				} else {
					max = true
				}
			case "ring of vine":
				if !vineRing {
					vineRing = true
					if player.hp == 1 {
						player.hp = 2
					}
				} else {
					max = true
				}
			case "toilet paper":
				if toiletpapernum < toiletpapermax {
					toiletpapernum++
				} else {
					max = true
				}
			case "bear trap":
				if beartrapnum < beartrapmax {
					beartrapnum++
					beartrapT = (fps * 12) - (int32(beartrapnum*2) * fps)
				} else {
					max = true
				}
			case "basketball sneakers":
				if stats.dexterity < 5 {
					stats.dexterity++
					stats.dexterity2 = stats.dexterity
				} else {
					max = true
				}
			case "dumbbell":
				if stats.strength < 5 {
					stats.strength++
					stats.strength2 = stats.strength
				} else {
					max = true
				}
			case "dice":
				if stats.luck < 5 {
					stats.luck++
					stats.luck2 = stats.luck
				} else {
					max = true
				}
			case "eyeball":
				if stats.perception < 5 {
					stats.perception++
					stats.perception2 = stats.perception
				} else {
					max = true
				}
			case "brain":
				if stats.intelligence < 5 {
					stats.intelligence++
					stats.intelligence2 = stats.intelligence
				} else {
					max = true
				}
			case "medikit":
				if medikitnum < medikitmax {
					medikiton = true
				} else {
					max = true
				}
			case "backpack":
				if len(player.inventory) < inventoryMax {
					player.inventory = append(player.inventory, Item{})
				} else {
					max = true
					admsg("inventory max", rl.Red)
				}
			case "gas can":
				if gascannum < gascanmax {
					gascannum++
				} else {
					max = true
				}
			case "bottle of death":
				if deathbottlenum < deathbottlemax {
					deathbottlenum++
				} else {
					max = true
				}
			case "cleaver":
				if cleavernum < cleavermax {
					cleavernum++
				} else {
					max = true
				}
			case "tenderiser":
				if tenderisernum < tenderisermax {
					tenderisernum++
				} else {
					max = true
				}
			case "garlic":
				if garlicnum < garlicmax {
					garlicnum++
				} else {
					max = true
				}
			case "drill":
				if !drillon {
					drillon = true
				} else {
					max = true
				}
			case "broccoli":
				if broccolinum < broccolimax {
					broccolinum++
				} else {
					max = true
				}
			case "basketball":
				if basketballnum < basketballmax {
					basketballnum++
				} else {
					max = true
				}
			case "sunglasses":
				if stats.critical < stats.critical2 {
					stats.critical++
				} else {
					max = true
				}
			case "sneakers":
				if sneakersnum < sneakersmax {
					sneakersnum++
					if player.speed2 < player.speedMax {
						player.speed2++
						player.speed = player.speed2
					}
				} else {
					max = true
				}
			}
			if max {
				rl.PlaySound(audfx[121])
				admsg("artifact > "+player.inventory[i].name+" > max", rl.Red)
				found := false
				for j := 0; j < len(player.inventory); j++ {
					if player.inventory[i].name == player.inventory[j].name && j != i {
						player.inventory[j].numof++
						if msgT == 0 {
							admsg("in backpack > store for next run", rl.Magenta)
							msgT = fps
						}
						player.inventory[i] = Item{}
						player.inventory[i].isOff = true
						found = true
					}
				}
				if !found {
					if nxInvnNum != blankint {
						player.inventory[nxInvnNum] = player.inventory[i]
						findnxinvnum()
						if msgT == 0 {
							admsg("in backpack > store for next run", rl.Magenta)
							msgT = fps
						}
						player.inventory[i] = Item{}
						player.inventory[i].isOff = true
					} else {
						if msgT == 0 {
							admsg("inventory full > drop, stack or use", rl.Red)
							msgT = fps
						}
					}
				}
			} else {
				found, numSame := checkArtSameItm(player.inventory[i])
				if found {
					player.art[numSame].numof++
				} else {
					player.art = append(player.art, player.inventory[i])
				}
				admsg("collected artifact "+player.inventory[i].name, rl.Magenta)
				player.inventory[i] = Item{}
				player.inventory[i].isOff = true
			}
		}
	}
}
func upunlocks() { //MARK:UP UNLOCKED ITEMS
	crateitm = nil
	unlockNum = 0
	for i := 0; i < len(itemList); i++ {
		if itemList[i].isUnlocked && !itemList[i].isNoCrate {
			crateitm = append(crateitm, itemList[i])
			unlockNum++
		}
	}
}

func upfxclear() { //MARK:UP FX CLEAR
	clear := false
	for i := 0; i < len(effect); i++ {
		if effect[i].isOff {
			clear = true
		} else {
			effect[i].clearTimer++
		}
		if effect[i].clearTimer > fps*60 {
			effect[i].isOff = true
		}
	}
	if clear {
		for i := 0; i < len(effect); i++ {
			if effect[i].isOff {
				effect = RemoveEffects(effect, i)
			}
		}
	}
}
func upenm() { //MARK:UP ENEMIES
	fireson = false
	blackdotCount = 0
	//STUN STARS ANIM
	if frames%4 == 0 {
		animation[107].rectangle.X += animation[107].width
		if animation[107].rectangle.X > animation[107].x+animation[107].frames*animation[107].width {
			animation[107].rectangle.X = animation[107].x
		}
	}
	//BLACK DOT COUNT
	for i := 0; i < len(levels[levNum].enemies); i++ {
		if levels[levNum].enemies[i].name == "blackdot" {
			blackdotCount++
		}
	}
	for i := 0; i < len(levels[levNum].enemies); i++ {
		if !levels[levNum].enemies[i].off {
			//TIMERS

			if levels[levNum].enemies[i].hpT > 0 {
				levels[levNum].enemies[i].hpT--
			}
			if levels[levNum].enemies[i].stunT > 0 {
				levels[levNum].enemies[i].stunT--
			}
			if levels[levNum].enemies[i].poisonT > 0 {
				levels[levNum].enemies[i].poisonT--
				if levels[levNum].enemies[i].poisonT == fps {
					levels[levNum].enemies[i].hp--
				}
				if levels[levNum].enemies[i].poisonT == 0 {
					levels[levNum].enemies[i].hp--
				}
				if levels[levNum].enemies[i].hp <= 0 && !levels[levNum].enemies[i].off {
					player.xp += levels[levNum].enemies[i].xp
					makeEnDeathFx(i)
					levels[levNum].enemies[i].off = true
				}
			}
			if levels[levNum].enemies[i].bleedT > 0 {
				levels[levNum].enemies[i].bleedT--
				if levels[levNum].enemies[i].bleedT == fps {
					levels[levNum].enemies[i].hp -= levels[levNum].enemies[i].bleed
				}
				if levels[levNum].enemies[i].bleedT == 0 {
					levels[levNum].enemies[i].hp -= levels[levNum].enemies[i].bleed
				}
				if levels[levNum].enemies[i].hp <= 0 && !levels[levNum].enemies[i].off {
					player.xp += levels[levNum].enemies[i].xp
					makeEnDeathFx(i)
					levels[levNum].enemies[i].off = true
				}
			}
			if levels[levNum].enemies[i].burnT > 0 {
				levels[levNum].enemies[i].burnT--
				if levels[levNum].enemies[i].burnT == fps {
					levels[levNum].enemies[i].hp--
				}
				if levels[levNum].enemies[i].burnT == 0 {
					levels[levNum].enemies[i].hp--
				}
				if levels[levNum].enemies[i].hp <= 0 && !levels[levNum].enemies[i].off {
					player.xp += levels[levNum].enemies[i].xp
					makeEnDeathFx(i)
					levels[levNum].enemies[i].off = true
				}
			}

			//CLEAR BURNT FIRES
			if levels[levNum].enemies[i].name == "fire" && levels[levNum].enemies[i].burnT > 0 {
				levels[levNum].enemies[i].burnT = 0
			}
			//OIL TIMER
			if levels[levNum].enemies[i].oilT > 0 {
				levels[levNum].enemies[i].oilT--
			}
			//FREEZE TIMER
			if levels[levNum].enemies[i].freezeT > 0 {
				levels[levNum].enemies[i].freezeT--
			}
			//SWITCH FIRES ON
			if !fireson {
				if levels[levNum].enemies[i].name == "fire" {
					fireson = true
				}
			}
			//PLAYER COLLIS
			if player.hpTimer == 0 {
				if rl.CheckCollisionRecs(player.collisionRectangle, levels[levNum].enemies[i].collisionRectangle) && player.enemyCollisionTimer == 0 {
					player.enemyCollisionTimer = fps
					switch levels[levNum].enemies[i].name {
					case "fire", "flamehead":
						if player.resistFireTimer == 0 {
							hitPL(2)
						}
						if player.burnTimer == 0 && player.dampTimer == 0 && icelollyT == 0 && player.resistFireTimer == 0 {
							if ovenglovenum > 0 {
								if Roll6() <= ovenglovenum {
									admsg("oven glove saves burn", rl.Green)
								} else {
									admsg("burning...", rl.Orange)
									player.burnTimer += fps * 3
								}
							} else {
								admsg("burning...", rl.Orange)
								player.burnTimer += fps * 3
							}
						} else if player.burnTimer == 0 && player.dampTimer != 0 && icelollyT == 0 && player.resistFireTimer == 0 {
							admsg("damp saves burn", rl.Green)
						} else if player.burnTimer == 0 && player.dampTimer == 0 && icelollyT != 0 && player.resistFireTimer == 0 {
							admsg("ice lolly saves burn", rl.Green)
						} else if player.burnTimer == 0 && player.dampTimer == 0 && icelollyT == 0 && player.resistFireTimer != 0 {
							admsg("resist fire saves burn", rl.Green)
						}
					default:
						hitPL(1)
					}
				}
			}

			if !isBossOn && tvT == 0 {
				//ROCK GUY PROJ
				if levels[levNum].enemies[i].name == "bush" && !levels[levNum].enemies[i].idl {
					if frames%30 == 0 {
						zproj := Weapon{}
						zproj.name = "bushProj"
						zproj.bounce = 2
						zproj.damage = 1
						zproj.image = animation[173].rectangle
						siz := b
						zproj.rec = rl.NewRectangle(levels[levNum].enemies[i].cnt.X-siz/2, levels[levNum].enemies[i].cnt.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.col = rl.White
						zproj.fade = 1
						zproj.speed = 4
						zproj.rotationSpeed = 5
						zproj.dirX, zproj.dirY = findSpdXY(levels[levNum].enemies[i].cnt, player.center, zproj.speed)
						enemyProjectiles = append(enemyProjectiles, zproj)
					}
				}
				//GREEN PIG PROJ
				if levels[levNum].enemies[i].name == "greenpig" && levels[levNum].enemies[i].onoff {
					if frames%30 == 0 {
						zproj := Weapon{}
						zproj.name = "greenpigProj"
						zproj.bounce = 1
						zproj.damage = 1
						zproj.image = animation[132].rectangle
						siz := be3
						zproj.rec = rl.NewRectangle(levels[levNum].enemies[i].cnt.X-siz/2, levels[levNum].enemies[i].cnt.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.col = rl.White
						zproj.fade = 1
						zproj.speed = 4
						if FlipCoin() {
							zproj.dirX = zproj.speed
							enemyProjectiles = append(enemyProjectiles, zproj)
							zproj.dirX = -zproj.speed
							enemyProjectiles = append(enemyProjectiles, zproj)
							zproj.dirX = 0
							zproj.dirY = zproj.speed
							enemyProjectiles = append(enemyProjectiles, zproj)
							zproj.dirY = -zproj.speed
							enemyProjectiles = append(enemyProjectiles, zproj)
						} else {
							zproj.dirX = zproj.speed
							zproj.dirY = zproj.speed
							enemyProjectiles = append(enemyProjectiles, zproj)
							zproj.dirX = zproj.speed
							zproj.dirY = -zproj.speed
							enemyProjectiles = append(enemyProjectiles, zproj)
							zproj.dirX = -zproj.speed
							zproj.dirY = zproj.speed
							enemyProjectiles = append(enemyProjectiles, zproj)
							zproj.dirX = -zproj.speed
							zproj.dirY = -zproj.speed
							enemyProjectiles = append(enemyProjectiles, zproj)
						}
					}
				}
				//BIRD EGG PROJ
				if levels[levNum].enemies[i].name == "bird" && levels[levNum].enemies[i].follow {
					if frames%30 == 0 {
						zproj := Weapon{}
						zproj.name = "birdProj"
						zproj.bounce = 2
						zproj.damage = 1
						zproj.image = otherTiles[152]
						siz := b / 2
						zproj.rec = rl.NewRectangle(levels[levNum].enemies[i].cnt.X-siz/2, levels[levNum].enemies[i].cnt.Y-siz/2, siz, siz)
						zproj.crec = zproj.rec
						zproj.col = rl.White
						zproj.fade = 1
						zproj.speed = 4
						zproj.rotationSpeed = 5
						zproj.dirX, zproj.dirY = findSpdXY(levels[levNum].enemies[i].cnt, player.center, zproj.speed)
						enemyProjectiles = append(enemyProjectiles, zproj)
					}
				}
				if levels[levNum].enemies[i].atkT > 0 {
					levels[levNum].enemies[i].atkT--
					if levels[levNum].enemies[i].atkT == 1 && levels[levNum].enemies[i].stunT == 0 {
						switch levels[levNum].enemies[i].name {
						case "jersey":
							levels[levNum].enemies[i].onoff = !levels[levNum].enemies[i].onoff
							levels[levNum].enemies[i].atkT = fps * 2
						case "reddevil":
							zproj := Weapon{}
							zproj.isBelow = true
							zproj.name = "reddevilFlame"
							zproj.image = animation[169].rectangle
							siz := b
							zproj.rec = rl.NewRectangle(levels[levNum].enemies[i].cnt.X-siz/2, levels[levNum].enemies[i].cnt.Y-siz/2, siz, siz)
							zproj.crec = zproj.rec
							zproj.crec.Y += zproj.rec.Height / 2
							zproj.crec.Height = zproj.crec.Height / 2
							zproj.col = rl.White
							zproj.fade = 1
							enemyProjectiles = append(enemyProjectiles, zproj)
							levels[levNum].enemies[i].atkT = fps / 2
						case "greenpig":
							levels[levNum].enemies[i].onoff = !levels[levNum].enemies[i].onoff
							levels[levNum].enemies[i].atkT = fps * 2
						case "robot":
							levels[levNum].enemies[i].onoff = true
						case "redblob":
							zproj := Weapon{}
							zproj.name = "redblobbull"
							zproj.rotationSpeed = 8
							zproj.damage = 1
							zproj.image = animation[71].rectangle
							siz := b / 2
							zproj.rec = rl.NewRectangle(levels[levNum].enemies[i].cnt.X-siz/2, levels[levNum].enemies[i].cnt.Y-siz/2, siz, siz)
							zproj.crec = zproj.rec
							zproj.col = rl.White
							zproj.fade = 1
							zproj.speed = b / 20
							zproj.dirX, zproj.dirY = findSpdXY(levels[levNum].enemies[i].cnt, player.center, zproj.speed)
							enemyProjectiles = append(enemyProjectiles, zproj)
							levels[levNum].enemies[i].atkT = fps * 2
						case "skeleton":
							zproj := Weapon{}
							zproj.name = "bonebull"
							zproj.bounce = 3
							zproj.rotationSpeed = 8
							zproj.damage = 1
							zproj.image = otherTiles[31]
							siz := b / 2
							zproj.rec = rl.NewRectangle(levels[levNum].enemies[i].cnt.X-siz/2, levels[levNum].enemies[i].cnt.Y-siz/2, siz, siz)
							zproj.crec = zproj.rec
							zproj.col = rl.White
							zproj.fade = 1
							zproj.speed = b / 20
							zproj.dirX, zproj.dirY = findSpdXY(levels[levNum].enemies[i].cnt, player.center, zproj.speed)
							enemyProjectiles = append(enemyProjectiles, zproj)
							levels[levNum].enemies[i].atkT = fps * 2
						case "blackdot":
							if levels[levNum].enemies[i].numMax > 0 && blackdotCount < 50 {
								levels[levNum].enemies[i].numMax--
								zenm := enmlist[10] //BLACK DOT
								if Roll6() == 6 {
									zenm.numMax = RandInt(2, 5)
									zenm.atkT = fps * 2
								}
								zenm.cnt = levels[levNum].enemies[i].cnt
								zenm.rectangle = rl.NewRectangle(zenm.cnt.X-zenm.rectangle.Width/2, zenm.cnt.Y-zenm.rectangle.Height/2, zenm.rectangle.Width, zenm.rectangle.Height)
								zenm.collisionRectangle = zenm.rectangle
								zenm.dirX = RandF32(-zenm.speed, zenm.speed)
								zenm.dirY = RandF32(-zenm.speed, zenm.speed)
								levels[levNum].enemies = append(levels[levNum].enemies, zenm)
								levels[levNum].enemyNum++
								levels[levNum].enemies[i].atkT = fps * 2
							}
						case "yellowdino":
							zproj := Weapon{}
							zproj.name = "yellowdinobull"
							zproj.isBelow = true
							zproj.damage = 1
							zproj.image = animation[62].rectangle
							siz := b2
							zproj.rec = rl.NewRectangle(levels[levNum].enemies[i].cnt.X-siz/2, levels[levNum].enemies[i].cnt.Y-siz/2, siz, siz)
							zproj.crec = zproj.rec
							zproj.crec.Y += zproj.rec.Height / 2
							zproj.crec.Height = zproj.crec.Height / 2
							zproj.col = rl.White
							zproj.fade = 1
							enemyProjectiles = append(enemyProjectiles, zproj)
							levels[levNum].enemies[i].atkT = fps
						case "greenplant":
							zproj := Weapon{}
							zproj.name = "greenplantbull"
							zproj.damage = 1
							zproj.image = animation[61].rectangle
							siz := be5
							zproj.rec = rl.NewRectangle(levels[levNum].enemies[i].cnt.X-siz/2, levels[levNum].enemies[i].cnt.Y-siz/2, siz, siz)
							zproj.crec = zproj.rec
							zproj.col = rl.White
							zproj.fade = 1
							zproj.speed = b / 20
							zproj.dirX, zproj.dirY = findSpdXY(levels[levNum].enemies[i].cnt, player.center, zproj.speed)
							enemyProjectiles = append(enemyProjectiles, zproj)
							levels[levNum].enemies[i].atkT = fps / 4
						case "pinkcart":
							zproj := Weapon{}
							zproj.name = "pinkcartbull"
							zproj.damage = 1
							zproj.image = animation[60].rectangle
							siz := b
							zproj.rec = rl.NewRectangle(levels[levNum].enemies[i].cnt.X-siz/2, levels[levNum].enemies[i].cnt.Y-siz/2, siz, siz)
							zproj.center = makecnt(zproj.rec)
							zproj.crec = zproj.rec
							zproj.col = rl.White
							zproj.fade = 0.7
							zproj.speed = b / 12
							zproj.dirX, zproj.dirY = findSpdXY(levels[levNum].enemies[i].cnt, player.center, zproj.speed)
							enemyProjectiles = append(enemyProjectiles, zproj)
							levels[levNum].enemies[i].atkT = fps * RandInt32(1, 3)
						case "redantenna":
							zproj := Weapon{}
							zproj.name = "redantbull"
							zproj.damage = 1
							zproj.image = animation[56].rectangle
							siz := be3
							zproj.rec = rl.NewRectangle(levels[levNum].enemies[i].cnt.X-siz/2, levels[levNum].enemies[i].cnt.Y-siz/2, siz, siz)
							zproj.crec = zproj.rec
							zproj.col = rl.White
							zproj.fade = 1
							zproj.speed = b / 24
							zproj.dirX, zproj.dirY = findSpdXY(levels[levNum].enemies[i].cnt, player.center, zproj.speed)
							enemyProjectiles = append(enemyProjectiles, zproj)
							levels[levNum].enemies[i].atkT = fps
						}
					}
				}
				//MARK: UP ENEMY MOVE CHANGE
				if levels[levNum].enemies[i].moveChangeT > 0 {
					levels[levNum].enemies[i].moveChangeT--
				} else {
					switch levels[levNum].enemies[i].name {
					case "bird":
						levels[levNum].enemies[i].follow = !levels[levNum].enemies[i].follow
						levels[levNum].enemies[i].moveChangeT = fps * RandInt32(3, 8)
						if !levels[levNum].enemies[i].follow {
							levels[levNum].enemies[i].dirX = RandF32(-levels[levNum].enemies[i].speed, levels[levNum].enemies[i].speed)
							levels[levNum].enemies[i].dirY = RandF32(-levels[levNum].enemies[i].speed, levels[levNum].enemies[i].speed)
						}
					case "robot":
						if !levels[levNum].enemies[i].follow {
							levels[levNum].enemies[i].moveChangeT = fps * RandInt32(1, 2)
							levels[levNum].enemies[i].dirX = RandF32(-levels[levNum].enemies[i].speed, levels[levNum].enemies[i].speed)
							levels[levNum].enemies[i].dirY = RandF32(-levels[levNum].enemies[i].speed, levels[levNum].enemies[i].speed)
						}
					case "redblob":
						levels[levNum].enemies[i].moveChangeT = fps * RandInt32(1, 2)
						levels[levNum].enemies[i].dirX = RandF32(-levels[levNum].enemies[i].speed, levels[levNum].enemies[i].speed)
						levels[levNum].enemies[i].dirY = RandF32(-levels[levNum].enemies[i].speed, levels[levNum].enemies[i].speed)
					case "yellowdino", "greenplant", "jersey", "spike":
						levels[levNum].enemies[i].moveChangeT = fps * RandInt32(2, 4)
						levels[levNum].enemies[i].dirX = RandF32(-levels[levNum].enemies[i].speed, levels[levNum].enemies[i].speed)
						levels[levNum].enemies[i].dirY = RandF32(-levels[levNum].enemies[i].speed, levels[levNum].enemies[i].speed)
					case "redantenna":
						levels[levNum].enemies[i].moveChangeT = fps * RandInt32(1, 4)
						levels[levNum].enemies[i].dirX = 0
						levels[levNum].enemies[i].dirY = 0
						if FlipCoin() {
							countbreak := 100
							for {
								levels[levNum].enemies[i].dirX = RandF32(-levels[levNum].enemies[i].speed, levels[levNum].enemies[i].speed)
								if Abs(levels[levNum].enemies[i].dirX) > 0.4 {
									break
								}
								countbreak--
								if countbreak == 0 {
									break
								}
							}
						} else {
							countbreak := 100
							for {
								levels[levNum].enemies[i].dirY = RandF32(-levels[levNum].enemies[i].speed, levels[levNum].enemies[i].speed)
								if Abs(levels[levNum].enemies[i].dirY) > 0.4 {
									break
								}
								countbreak--
								if countbreak == 0 {
									break
								}
							}
						}
					}
				}
				//IDLE
				if levels[levNum].enemies[i].idl {
					if levels[levNum].enemies[i].idleT > 0 {
						levels[levNum].enemies[i].idleT--
					} else {
						levels[levNum].enemies[i].idlon = !levels[levNum].enemies[i].idlon
						switch levels[levNum].enemies[i].name {
						case "bluespike", "redeye", "redbomb", "pinkcart", "greenplant":
							if levels[levNum].enemies[i].idlon {
								levels[levNum].enemies[i].idleT = fps * RandInt32(1, 3)
							} else {
								levels[levNum].enemies[i].dirX = RandF32(-levels[levNum].enemies[i].speed, levels[levNum].enemies[i].speed)
								levels[levNum].enemies[i].dirY = RandF32(-levels[levNum].enemies[i].speed, levels[levNum].enemies[i].speed)
								levels[levNum].enemies[i].idleT = fps * RandInt32(3, 5)
							}
						}
					}
				}
				//DIREC
				if levels[levNum].enemies[i].dirX > 0 {
					levels[levNum].enemies[i].lr = false
				} else {
					levels[levNum].enemies[i].lr = true
				}
				//MARK: ENEMY MOVEMENT
				if !levels[levNum].enemies[i].idlon && !levels[levNum].enemies[i].stat {
					if checkMoveEnm(i) {
						if icecreamT == 0 && levels[levNum].enemies[i].stunT == 0 && levels[levNum].enemies[i].freezeT == 0 {
							if watchT > 0 || levels[levNum].enemies[i].oilT > 0 {
								levels[levNum].enemies[i].cnt.X += (levels[levNum].enemies[i].dirX / 2) + delta
								levels[levNum].enemies[i].cnt.Y += (levels[levNum].enemies[i].dirY / 2) + delta
							} else { //NORMAL ENEMY MOVEMENT
								levels[levNum].enemies[i].cnt.X += levels[levNum].enemies[i].dirX + delta
								levels[levNum].enemies[i].cnt.Y += levels[levNum].enemies[i].dirY + delta
							}
						}
						//UP ENEMY REC
						levels[levNum].enemies[i].rectangle = rl.NewRectangle(levels[levNum].enemies[i].cnt.X-levels[levNum].enemies[i].rectangle.Width/2, levels[levNum].enemies[i].cnt.Y-levels[levNum].enemies[i].rectangle.Height/2, levels[levNum].enemies[i].rectangle.Width, levels[levNum].enemies[i].rectangle.Height)
						//UP COLLIS RECS
						levels[levNum].enemies[i].collisionRectangle = levels[levNum].enemies[i].rectangle
						switch levels[levNum].enemies[i].name {
						case "bush":
							levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Width / 4
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
							levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 2
							levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 4
							levels[levNum].enemies[i].carec = levels[levNum].enemies[i].rectangle
							levels[levNum].enemies[i].carec.X -= b4
							levels[levNum].enemies[i].carec.Y -= b4
							levels[levNum].enemies[i].carec.Width += b8
							levels[levNum].enemies[i].carec.Height += b8
							if rl.CheckCollisionRecs(player.collisionRectangle, levels[levNum].enemies[i].carec) && player.invisibleTimer == 0 {
								levels[levNum].enemies[i].idl = false
								if frames%15 == 0 {
									xdiff := AbsDiff(levels[levNum].enemies[i].cnt.X, player.center.X)
									ydiff := AbsDiff(levels[levNum].enemies[i].cnt.Y, player.center.Y)
									if xdiff > ydiff {
										levels[levNum].enemies[i].dirX = levels[levNum].enemies[i].speed
										levels[levNum].enemies[i].dirY = ydiff / (xdiff / levels[levNum].enemies[i].dirX)
									} else {
										levels[levNum].enemies[i].dirY = levels[levNum].enemies[i].speed
										levels[levNum].enemies[i].dirX = xdiff / (ydiff / levels[levNum].enemies[i].dirY)
									}
									if levels[levNum].enemies[i].cnt.X > player.center.X {
										levels[levNum].enemies[i].dirX = -levels[levNum].enemies[i].dirX
									}
									if levels[levNum].enemies[i].cnt.Y > player.center.Y {
										levels[levNum].enemies[i].dirY = -levels[levNum].enemies[i].dirY
									}
									levels[levNum].enemies[i].dirY *= -1
									levels[levNum].enemies[i].dirX *= -1
								}
							} else {
								levels[levNum].enemies[i].idl = true
								levels[levNum].enemies[i].dirY = 0
								levels[levNum].enemies[i].dirX = 0
							}
						case "jersey":
							levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Width / 2
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
							levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 2
							levels[levNum].enemies[i].collisionRectangle.Height = levels[levNum].enemies[i].collisionRectangle.Height / 2
						case "bird":
							levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Width / 8
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 8
							levels[levNum].enemies[i].collisionRectangle.Width -= levels[levNum].enemies[i].collisionRectangle.Width / 4
							levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 4
							if levels[levNum].enemies[i].follow {
								if frames%15 == 0 {
									xdiff := AbsDiff(levels[levNum].enemies[i].cnt.X, player.center.X)
									ydiff := AbsDiff(levels[levNum].enemies[i].cnt.Y, player.center.Y)
									if xdiff > ydiff {
										levels[levNum].enemies[i].dirX = levels[levNum].enemies[i].speed
										levels[levNum].enemies[i].dirY = ydiff / (xdiff / levels[levNum].enemies[i].dirX)
									} else {
										levels[levNum].enemies[i].dirY = levels[levNum].enemies[i].speed
										levels[levNum].enemies[i].dirX = xdiff / (ydiff / levels[levNum].enemies[i].dirY)
									}
									if levels[levNum].enemies[i].cnt.X > player.center.X {
										levels[levNum].enemies[i].dirX = -levels[levNum].enemies[i].dirX
									}
									if levels[levNum].enemies[i].cnt.Y > player.center.Y {
										levels[levNum].enemies[i].dirY = -levels[levNum].enemies[i].dirY
									}
								}
							}
						case "greenpig":
							levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Width / 3
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 3
							levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 3
							levels[levNum].enemies[i].collisionRectangle.Height = levels[levNum].enemies[i].collisionRectangle.Height / 3
							levels[levNum].enemies[i].collisionRectangle.Y += 4
						case "robot":
							levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 2
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
							levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 2
							levels[levNum].enemies[i].collisionRectangle.Height = levels[levNum].enemies[i].collisionRectangle.Height / 2
							levels[levNum].enemies[i].carec = levels[levNum].enemies[i].collisionRectangle
							levels[levNum].enemies[i].carec.X -= b5
							levels[levNum].enemies[i].carec.Y -= b5
							levels[levNum].enemies[i].carec.Width += b10
							levels[levNum].enemies[i].carec.Height += b10
							//COLLISION AREA REC
							if rl.CheckCollisionRecs(player.collisionRectangle, levels[levNum].enemies[i].carec) && player.invisibleTimer == 0 && player.freezeTimer == 0 {
								levels[levNum].enemies[i].follow = true
								if frames%15 == 0 {
									xdiff := AbsDiff(levels[levNum].enemies[i].cnt.X, player.center.X)
									ydiff := AbsDiff(levels[levNum].enemies[i].cnt.Y, player.center.Y)
									if xdiff > ydiff {
										levels[levNum].enemies[i].dirX = levels[levNum].enemies[i].speed
										levels[levNum].enemies[i].dirY = ydiff / (xdiff / levels[levNum].enemies[i].dirX)
									} else {
										levels[levNum].enemies[i].dirY = levels[levNum].enemies[i].speed
										levels[levNum].enemies[i].dirX = xdiff / (ydiff / levels[levNum].enemies[i].dirY)
									}
									if levels[levNum].enemies[i].cnt.X > player.center.X {
										levels[levNum].enemies[i].dirX = -levels[levNum].enemies[i].dirX
									}
									if levels[levNum].enemies[i].cnt.Y > player.center.Y {
										levels[levNum].enemies[i].dirY = -levels[levNum].enemies[i].dirY
									}
								}
							} else {
								levels[levNum].enemies[i].follow = false
							}
						case "carrot":
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 8
							levels[levNum].enemies[i].collisionRectangle.Width -= levels[levNum].enemies[i].collisionRectangle.Width / 4
							levels[levNum].enemies[i].carec = levels[levNum].enemies[i].rectangle
							levels[levNum].enemies[i].carec.X -= b4
							levels[levNum].enemies[i].carec.Y -= b4
							levels[levNum].enemies[i].carec.Width += b8
							levels[levNum].enemies[i].carec.Height += b8
							//COLLISION AREA REC
							if rl.CheckCollisionRecs(player.collisionRectangle, levels[levNum].enemies[i].carec) && player.invisibleTimer == 0 {
								levels[levNum].enemies[i].speed = 4
								if frames%15 == 0 {
									xdiff := AbsDiff(levels[levNum].enemies[i].cnt.X, player.center.X)
									ydiff := AbsDiff(levels[levNum].enemies[i].cnt.Y, player.center.Y)
									if xdiff > ydiff {
										levels[levNum].enemies[i].dirX = levels[levNum].enemies[i].speed
										levels[levNum].enemies[i].dirY = ydiff / (xdiff / levels[levNum].enemies[i].dirX)
									} else {
										levels[levNum].enemies[i].dirY = levels[levNum].enemies[i].speed
										levels[levNum].enemies[i].dirX = xdiff / (ydiff / levels[levNum].enemies[i].dirY)
									}
									if levels[levNum].enemies[i].cnt.X > player.center.X {
										levels[levNum].enemies[i].dirX = -levels[levNum].enemies[i].dirX
									}
									if levels[levNum].enemies[i].cnt.Y > player.center.Y {
										levels[levNum].enemies[i].dirY = -levels[levNum].enemies[i].dirY
									}
								}
								if rl.CheckCollisionRecs(player.collisionRectangle, levels[levNum].enemies[i].collisionRectangle) {
									zfx := Effect{}
									zfx.imageRectangle = animation[57].rectangle
									zfx.center = levels[levNum].enemies[i].cnt
									siz := b7
									zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
									zfx.collisionRectangle = zfx.rectangle
									zfx.collisionRectangle.X += zfx.collisionRectangle.Width / 8
									zfx.collisionRectangle.Y += zfx.collisionRectangle.Width / 8
									zfx.collisionRectangle.Height -= zfx.collisionRectangle.Height / 4
									zfx.collisionRectangle.Width -= zfx.collisionRectangle.Width / 4
									zfx.name = "landmineExplod"
									effect = append(effect, zfx)
									levels[levNum].enemies[i].off = true
									if player.hpTimer == 0 {
										hitPL(1)
									}
									if player.burnTimer == 0 {
										player.burnTimer += fps * 3
									}
								}
							} else {
								levels[levNum].enemies[i].speed = 2
							}
						case "redblob":
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
							levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 2
							levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 2
							levels[levNum].enemies[i].collisionRectangle.Height = levels[levNum].enemies[i].collisionRectangle.Height / 2
						case "skeleton":
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
							levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 2
							levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 8
						case "orange":
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
							levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 2
							levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 3
							levels[levNum].enemies[i].collisionRectangle.Height = levels[levNum].enemies[i].collisionRectangle.Height / 2
							//AREA REC
							levels[levNum].enemies[i].carec = levels[levNum].enemies[i].rectangle
							levels[levNum].enemies[i].carec.X -= b3
							levels[levNum].enemies[i].carec.Y -= b3
							levels[levNum].enemies[i].carec.Width += b6
							levels[levNum].enemies[i].carec.Height += b6
							//COLLISION AREA REC
							if rl.CheckCollisionRecs(player.collisionRectangle, levels[levNum].enemies[i].carec) && player.invisibleTimer == 0 {
								if frames%15 == 0 {
									xdiff := AbsDiff(levels[levNum].enemies[i].cnt.X, player.center.X)
									ydiff := AbsDiff(levels[levNum].enemies[i].cnt.Y, player.center.Y)
									if xdiff > ydiff {
										levels[levNum].enemies[i].dirX = levels[levNum].enemies[i].speed
										levels[levNum].enemies[i].dirY = ydiff / (xdiff / levels[levNum].enemies[i].dirX)
									} else {
										levels[levNum].enemies[i].dirY = levels[levNum].enemies[i].speed
										levels[levNum].enemies[i].dirX = xdiff / (ydiff / levels[levNum].enemies[i].dirY)
									}
									if levels[levNum].enemies[i].cnt.X > player.center.X {
										levels[levNum].enemies[i].dirX = -levels[levNum].enemies[i].dirX
									}
									if levels[levNum].enemies[i].cnt.Y > player.center.Y {
										levels[levNum].enemies[i].dirY = -levels[levNum].enemies[i].dirY
									}
								}
							}
						case "flamehead":
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
							levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 2
							//AREA REC
							levels[levNum].enemies[i].carec = levels[levNum].enemies[i].rectangle
							levels[levNum].enemies[i].carec.X -= b3
							levels[levNum].enemies[i].carec.Y -= b3
							levels[levNum].enemies[i].carec.Width += b6
							levels[levNum].enemies[i].carec.Height += b6
							//COLLISION AREA REC
							if rl.CheckCollisionRecs(player.collisionRectangle, levels[levNum].enemies[i].carec) && player.invisibleTimer == 0 {
								if frames%15 == 0 {
									xdiff := AbsDiff(levels[levNum].enemies[i].cnt.X, player.center.X)
									ydiff := AbsDiff(levels[levNum].enemies[i].cnt.Y, player.center.Y)
									if xdiff > ydiff {
										levels[levNum].enemies[i].dirX = levels[levNum].enemies[i].speed
										levels[levNum].enemies[i].dirY = ydiff / (xdiff / levels[levNum].enemies[i].dirX)
									} else {
										levels[levNum].enemies[i].dirY = levels[levNum].enemies[i].speed
										levels[levNum].enemies[i].dirX = xdiff / (ydiff / levels[levNum].enemies[i].dirY)
									}
									if levels[levNum].enemies[i].cnt.X > player.center.X {
										levels[levNum].enemies[i].dirX = -levels[levNum].enemies[i].dirX
									}
									if levels[levNum].enemies[i].cnt.Y > player.center.Y {
										levels[levNum].enemies[i].dirY = -levels[levNum].enemies[i].dirY
									}
								}
							}
						case "fly":
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
							levels[levNum].enemies[i].collisionRectangle.Width -= levels[levNum].enemies[i].collisionRectangle.Width / 2
							levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 4
							levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 2
							//AREA REC
							levels[levNum].enemies[i].carec = levels[levNum].enemies[i].rectangle
							levels[levNum].enemies[i].carec.X -= b3
							levels[levNum].enemies[i].carec.Y -= b3
							levels[levNum].enemies[i].carec.Width += b6
							levels[levNum].enemies[i].carec.Height += b6
							//COLLISION AREA REC
							if rl.CheckCollisionRecs(player.collisionRectangle, levels[levNum].enemies[i].carec) && player.invisibleTimer == 0 {
								if frames%15 == 0 {
									xdiff := AbsDiff(levels[levNum].enemies[i].cnt.X, player.center.X)
									ydiff := AbsDiff(levels[levNum].enemies[i].cnt.Y, player.center.Y)
									if xdiff > ydiff {
										levels[levNum].enemies[i].dirX = levels[levNum].enemies[i].speed
										levels[levNum].enemies[i].dirY = ydiff / (xdiff / levels[levNum].enemies[i].dirX)
									} else {
										levels[levNum].enemies[i].dirY = levels[levNum].enemies[i].speed
										levels[levNum].enemies[i].dirX = xdiff / (ydiff / levels[levNum].enemies[i].dirY)
									}
									if levels[levNum].enemies[i].cnt.X > player.center.X {
										levels[levNum].enemies[i].dirX = -levels[levNum].enemies[i].dirX
									}
									if levels[levNum].enemies[i].cnt.Y > player.center.Y {
										levels[levNum].enemies[i].dirY = -levels[levNum].enemies[i].dirY
									}
								}
							}
						case "worm":
							levels[levNum].enemies[i].collisionRectangle.Y += (levels[levNum].enemies[i].collisionRectangle.Height / 4) * 3
							levels[levNum].enemies[i].collisionRectangle.Height = levels[levNum].enemies[i].collisionRectangle.Height / 4
						case "yellowdino":
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 8
							levels[levNum].enemies[i].collisionRectangle.Width -= levels[levNum].enemies[i].collisionRectangle.Width / 4
							levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 3
							levels[levNum].enemies[i].collisionRectangle.Height = (levels[levNum].enemies[i].collisionRectangle.Height / 3) * 2
						case "greenplant":
							levels[levNum].enemies[i].collisionRectangle.Y += (levels[levNum].enemies[i].collisionRectangle.Height / 3) * 2
							levels[levNum].enemies[i].collisionRectangle.Height = levels[levNum].enemies[i].collisionRectangle.Height / 3
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 3
							levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 3
						case "pinkcart":
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
							levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 2
							levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 2
							levels[levNum].enemies[i].collisionRectangle.Height = levels[levNum].enemies[i].collisionRectangle.Height / 2
						case "crocodile":
							levels[levNum].enemies[i].collisionRectangle.Y += (levels[levNum].enemies[i].collisionRectangle.Height / 12) * 7
							levels[levNum].enemies[i].collisionRectangle.Height = (levels[levNum].enemies[i].collisionRectangle.Height / 12) * 5
							//COLLISION AREA REC
							if rl.CheckCollisionRecs(player.collisionRectangle, levels[levNum].enemies[i].carec) && player.invisibleTimer == 0 {
								if !levels[levNum].enemies[i].fast {
									levels[levNum].enemies[i].fast = true
									if levels[levNum].enemies[i].image.X < animation[58].rectangle.X {
										levels[levNum].enemies[i].image.X = animation[58].rectangle.X
									}
									if player.center.X < levels[levNum].enemies[i].cnt.X {
										levels[levNum].enemies[i].lr = true
										levels[levNum].enemies[i].dirX = -levels[levNum].enemies[i].speed * 2
									} else {
										levels[levNum].enemies[i].lr = false
										levels[levNum].enemies[i].dirX = levels[levNum].enemies[i].speed * 2
									}
								}
							}
							//AREA
							levels[levNum].enemies[i].carec = levels[levNum].enemies[i].collisionRectangle
							levels[levNum].enemies[i].carec.X -= b4
							levels[levNum].enemies[i].carec.Width += b8
						case "balloon":
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
							levels[levNum].enemies[i].collisionRectangle.Width -= levels[levNum].enemies[i].collisionRectangle.Width / 2
							levels[levNum].enemies[i].collisionRectangle.Y += 4
							levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 2
						case "redantenna":
							levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 3
							levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 3
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 6
							levels[levNum].enemies[i].collisionRectangle.Width -= levels[levNum].enemies[i].collisionRectangle.Width / 3
						case "ghost":
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 8
							levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 8
							levels[levNum].enemies[i].collisionRectangle.Width -= levels[levNum].enemies[i].collisionRectangle.Width / 4
							levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 4
							//AREA REC
							levels[levNum].enemies[i].carec = levels[levNum].enemies[i].rectangle
							levels[levNum].enemies[i].carec.X -= b3
							levels[levNum].enemies[i].carec.Y -= b3
							levels[levNum].enemies[i].carec.Width += b6
							levels[levNum].enemies[i].carec.Height += b6
							//COLLISION AREA REC
							if rl.CheckCollisionRecs(player.collisionRectangle, levels[levNum].enemies[i].carec) && player.invisibleTimer == 0 {
								if frames%15 == 0 {
									xdiff := AbsDiff(levels[levNum].enemies[i].cnt.X, player.center.X)
									ydiff := AbsDiff(levels[levNum].enemies[i].cnt.Y, player.center.Y)
									if xdiff > ydiff {
										levels[levNum].enemies[i].dirX = levels[levNum].enemies[i].speed
										levels[levNum].enemies[i].dirY = ydiff / (xdiff / levels[levNum].enemies[i].dirX)
									} else {
										levels[levNum].enemies[i].dirY = levels[levNum].enemies[i].speed
										levels[levNum].enemies[i].dirX = xdiff / (ydiff / levels[levNum].enemies[i].dirY)
									}
									if levels[levNum].enemies[i].cnt.X > player.center.X {
										levels[levNum].enemies[i].dirX = -levels[levNum].enemies[i].dirX
									}
									if levels[levNum].enemies[i].cnt.Y > player.center.Y {
										levels[levNum].enemies[i].dirY = -levels[levNum].enemies[i].dirY
									}
								}
							}
						case "redeye", "redbomb":
							levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 4
							levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 4
						case "bluespike":
							levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 8
							levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 8
							levels[levNum].enemies[i].collisionRectangle.Width -= levels[levNum].enemies[i].collisionRectangle.Width / 4
							levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 4
						}
						//CHECK ENEMY ETC COLLIS
						if !levels[levNum].enemies[i].fly {
							for j := 0; j < len(levels[levNum].otherTiles); j++ {
								if levels[levNum].otherTiles[j].name == "beartrap" && !levels[levNum].otherTiles[j].onoff {
									if !levels[levNum].enemies[i].nodmg {
										if rl.CheckCollisionRecs(levels[levNum].otherTiles[j].cRectangle, levels[levNum].enemies[i].collisionRectangle) {
											levels[levNum].otherTiles[j].onoff = true
											levels[levNum].enemies[i].stunT = fps
											levels[levNum].enemies[i].stunF = 0.9
											levels[levNum].enemies[i].stunY = levels[levNum].enemies[i].cnt.Y
											levels[levNum].enemies[i].stunSiz = b / 4
											levels[levNum].enemies[i].hp -= 1
											if levels[levNum].enemies[i].hp <= 0 && !levels[levNum].enemies[i].off {
												player.xp += levels[levNum].enemies[i].xp
												makeEnDeathFx(i)
												levels[levNum].enemies[i].off = true
											} else {
												levels[levNum].enemies[i].hpT = fps
												levels[levNum].enemies[i].hpY = bq3
												levels[levNum].enemies[i].hpY2 = 0
												if isBossOn {
													levels[levNum].enemies[i].hpY = b
													levels[levNum].enemies[i].hpY2 = b / 2
												}
											}
											//FX
											zfx := Effect{}
											zfx.name = "beartrap"
											zfx.imageRectangle = animation[87].rectangle
											siz := b4
											zfx.rectangle = rl.NewRectangle(levels[levNum].otherTiles[j].center.X-siz/2, levels[levNum].otherTiles[j].center.Y-siz, siz, siz)
											effect = append(effect, zfx)
										}
									}
								}

								if levels[levNum].otherTiles[j].name == "landmine" && !levels[levNum].otherTiles[j].onoff {
									if !levels[levNum].enemies[i].nodmg {
										if rl.CheckCollisionRecs(levels[levNum].otherTiles[j].cRectangle, levels[levNum].enemies[i].collisionRectangle) {
											levels[levNum].otherTiles[j].isOff = true
											levels[levNum].enemies[i].hp -= 2
											if levels[levNum].enemies[i].hp <= 0 && !levels[levNum].enemies[i].off {
												player.xp += levels[levNum].enemies[i].xp
												makeEnDeathFx(i)
												levels[levNum].enemies[i].off = true
											} else {
												levels[levNum].enemies[i].hpT = fps
												levels[levNum].enemies[i].hpY = bq3
												levels[levNum].enemies[i].hpY2 = 0
												if isBossOn {
													levels[levNum].enemies[i].hpY = b
													levels[levNum].enemies[i].hpY2 = b / 2
												}
												if levels[levNum].enemies[i].burnT == 0 {
													if levels[levNum].enemies[i].name == "flamehead" || levels[levNum].enemies[i].name == "yellowdino" || levels[levNum].enemies[i].name == "ghost" || levels[levNum].enemies[i].name == "fly" || levels[levNum].enemies[i].name == "reddevil" {
														if msgT == 0 {
															admsg("immune to burn", rl.Yellow)
															msgT = fps
														}
													} else {
														levels[levNum].enemies[i].burnT = fps * 3
													}
												}
											}
											zfx := Effect{}
											zfx.imageRectangle = animation[57].rectangle
											zfx.center = levels[levNum].otherTiles[j].center
											siz := b5
											zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
											zfx.collisionRectangle = zfx.rectangle
											zfx.collisionRectangle.X += zfx.collisionRectangle.Width / 8
											zfx.collisionRectangle.Y += zfx.collisionRectangle.Width / 8
											zfx.collisionRectangle.Height -= zfx.collisionRectangle.Height / 4
											zfx.collisionRectangle.Width -= zfx.collisionRectangle.Width / 4
											zfx.name = "landmineExplod"
											effect = append(effect, zfx)
										}
									}
								}
							}
						}
					} else { //MARK: ENEMY COLLIS CHANGE DIREC
						if !isBossOn {
							switch levels[levNum].enemies[i].name {
							case "reddevil":
								if levels[levNum].enemies[i].dirX < 0 {
									levels[levNum].enemies[i].dirX = -levels[levNum].enemies[i].speed
								} else {
									levels[levNum].enemies[i].dirX = levels[levNum].enemies[i].speed
								}
								levels[levNum].enemies[i].dirX *= -1
								if FlipCoin() {
									levels[levNum].enemies[i].dirX *= -1
								}
								levels[levNum].enemies[i].dirY = levels[levNum].enemies[i].speed / RandF32(2, 5)
								if FlipCoin() {
									levels[levNum].enemies[i].dirY = -levels[levNum].enemies[i].dirY
								}
							case "crocodile", "worm", "redantenna":
								if levels[levNum].enemies[i].fast { //SLOW DOWN CROCODILE
									levels[levNum].enemies[i].fast = false
								}
								countbreak := 100
								for {
									levels[levNum].enemies[i].dirX = RandF32(-levels[levNum].enemies[i].speed, levels[levNum].enemies[i].speed)
									if Abs(levels[levNum].enemies[i].dirX) > 0.4 {
										break
									}
									countbreak--
									if countbreak == 0 {
										break
									}
								}
							case "ghost", "balloon", "blackdot", "fly", "yellowdino", "flamehead", "orange", "skeleton", "redblob", "carrot", "robot", "greenpig", "bush", "bird", "jersey", "spike":
								if levels[levNum].enemies[i].dirX > 0 {
									levels[levNum].enemies[i].dirX = RandF32(-levels[levNum].enemies[i].speed, 0)
								} else {
									levels[levNum].enemies[i].dirX = RandF32(0, levels[levNum].enemies[i].speed)
								}
								if levels[levNum].enemies[i].dirY > 0 {
									levels[levNum].enemies[i].dirY = RandF32(-levels[levNum].enemies[i].speed, 0)
								} else {
									levels[levNum].enemies[i].dirY = RandF32(0, levels[levNum].enemies[i].speed)
								}
							case "bluespike", "redeye", "redbomb", "pinkcart", "greenplant":
								levels[levNum].enemies[i].idlon = true
								levels[levNum].enemies[i].idleT = fps * RandInt32(1, 3)
								if levels[levNum].enemies[i].dirX > 0 {
									levels[levNum].enemies[i].dirX = RandF32(-levels[levNum].enemies[i].speed, 0)
								} else {
									levels[levNum].enemies[i].dirX = RandF32(0, levels[levNum].enemies[i].speed)
								}
								if levels[levNum].enemies[i].dirY > 0 {
									levels[levNum].enemies[i].dirY = RandF32(-levels[levNum].enemies[i].speed, 0)
								} else {
									levels[levNum].enemies[i].dirY = RandF32(0, levels[levNum].enemies[i].speed)
								}
								countbreak := 100
								for {
									levels[levNum].enemies[i].dirX = RandF32(-levels[levNum].enemies[i].speed, levels[levNum].enemies[i].speed)
									levels[levNum].enemies[i].dirY = RandF32(-levels[levNum].enemies[i].speed, levels[levNum].enemies[i].speed)
									if Abs(levels[levNum].enemies[i].dirX) > 0.4 && Abs(levels[levNum].enemies[i].dirY) > 0.4 {
										break
									}
									countbreak--
									if countbreak == 0 {
										break
									}
								}
							}
						}
					}
				}
			}
		}
	}
}
func upquik() { //MARK:UP QUICK SLOTS
	nxQuikNum = blankint
	for i := 0; i < len(player.quik); i++ {
		//TIMERS
		if !pause {
			if player.quik[i].cooldownTimer > 0 {
				player.quik[i].cooldownTimer--
			}
		}
		//FIND NEXT EMPTY SLOT
		if player.quik[i].name == "" {
			nxQuikNum = i
			break
		}
		switch player.quik[i].name {
		//ANIM
		case "armor potion full":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[20].width
				if player.quik[i].image.X > animation[20].x+animation[20].frames*animation[20].width {
					player.quik[i].image.X = animation[20].x
				}
			}
		case "armor potion half":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[18].width
				if player.quik[i].image.X > animation[18].x+animation[18].frames*animation[18].width {
					player.quik[i].image.X = animation[18].x
				}
			}
		case "armor potion quarter":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[19].width
				if player.quik[i].image.X > animation[19].x+animation[19].frames*animation[19].width {
					player.quik[i].image.X = animation[19].x
				}
			}
		case "invisibility full":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[17].width
				if player.quik[i].image.X > animation[17].x+animation[17].frames*animation[17].width {
					player.quik[i].image.X = animation[17].x
				}
			}
		case "invisibility half":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[18].width
				if player.quik[i].image.X > animation[18].x+animation[18].frames*animation[18].width {
					player.quik[i].image.X = animation[18].x
				}
			}
		case "invisibility quarter":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[19].width
				if player.quik[i].image.X > animation[19].x+animation[19].frames*animation[19].width {
					player.quik[i].image.X = animation[19].x
				}
			}
		case "resist poison full":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[14].width
				if player.quik[i].image.X > animation[14].x+animation[14].frames*animation[14].width {
					player.quik[i].image.X = animation[14].x
				}
			}
		case "resist poison half":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[15].width
				if player.quik[i].image.X > animation[15].x+animation[15].frames*animation[15].width {
					player.quik[i].image.X = animation[15].x
				}
			}
		case "resist poison quarter":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[16].width
				if player.quik[i].image.X > animation[16].x+animation[16].frames*animation[16].width {
					player.quik[i].image.X = animation[16].x
				}
			}
		case "resist fire full":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[11].width
				if player.quik[i].image.X > animation[11].x+animation[11].frames*animation[11].width {
					player.quik[i].image.X = animation[11].x
				}
			}
		case "resist fire half":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[12].width
				if player.quik[i].image.X > animation[12].x+animation[12].frames*animation[12].width {
					player.quik[i].image.X = animation[12].x
				}
			}
		case "resist fire quarter":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[13].width
				if player.quik[i].image.X > animation[13].x+animation[13].frames*animation[13].width {
					player.quik[i].image.X = animation[13].x
				}
			}
		case "mana potion full":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[8].width
				if player.quik[i].image.X > animation[8].x+animation[8].frames*animation[8].width {
					player.quik[i].image.X = animation[8].x
				}
			}
		case "mana potion half":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[9].width
				if player.quik[i].image.X > animation[9].x+animation[9].frames*animation[9].width {
					player.quik[i].image.X = animation[9].x
				}
			}
		case "mana potion quarter":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[10].width
				if player.quik[i].image.X > animation[10].x+animation[10].frames*animation[10].width {
					player.quik[i].image.X = animation[10].x
				}
			}
		case "hp potion full":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[5].width
				if player.quik[i].image.X > animation[5].x+animation[5].frames*animation[5].width {
					player.quik[i].image.X = animation[5].x
				}
			}
		case "hp potion half":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[6].width
				if player.quik[i].image.X > animation[6].x+animation[6].frames*animation[6].width {
					player.quik[i].image.X = animation[6].x
				}
			}
		case "hp potion quarter":
			if frames%6 == 0 {
				player.quik[i].image.X += animation[7].width
				if player.quik[i].image.X > animation[7].x+animation[7].frames*animation[7].width {
					player.quik[i].image.X = animation[7].x
				}
			}
		}
	}
}
func upinven() { //MARK:UP INVENTORY
	nxInvnNum = blankint
	scrapNum = 0
	for i := 0; i < len(player.inventory); i++ {
		//TIMERS
		if !pause {
			if player.inventory[i].cooldownTimer > 0 {
				player.inventory[i].cooldownTimer--
			}
		}
		//FIND NEXT EMPTY SLOT
		if player.inventory[i].name == "" {
			nxInvnNum = i
			break
		}
		switch player.inventory[i].name {
		//POTION ANIM
		case "armor potion full":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[20].width
				if player.inventory[i].image.X > animation[20].x+animation[20].frames*animation[20].width {
					player.inventory[i].image.X = animation[20].x
				}
			}
		case "armor potion half":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[18].width
				if player.inventory[i].image.X > animation[18].x+animation[18].frames*animation[18].width {
					player.inventory[i].image.X = animation[18].x
				}
			}
		case "armor potion quarter":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[19].width
				if player.inventory[i].image.X > animation[19].x+animation[19].frames*animation[19].width {
					player.inventory[i].image.X = animation[19].x
				}
			}
		case "invisibility full":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[17].width
				if player.inventory[i].image.X > animation[17].x+animation[17].frames*animation[17].width {
					player.inventory[i].image.X = animation[17].x
				}
			}
		case "invisibility half":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[18].width
				if player.inventory[i].image.X > animation[18].x+animation[18].frames*animation[18].width {
					player.inventory[i].image.X = animation[18].x
				}
			}
		case "invisibility quarter":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[19].width
				if player.inventory[i].image.X > animation[19].x+animation[19].frames*animation[19].width {
					player.inventory[i].image.X = animation[19].x
				}
			}
		case "resist poison full":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[14].width
				if player.inventory[i].image.X > animation[14].x+animation[14].frames*animation[14].width {
					player.inventory[i].image.X = animation[14].x
				}
			}
		case "resist poison half":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[15].width
				if player.inventory[i].image.X > animation[15].x+animation[15].frames*animation[15].width {
					player.inventory[i].image.X = animation[15].x
				}
			}
		case "resist poison quarter":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[16].width
				if player.inventory[i].image.X > animation[16].x+animation[16].frames*animation[16].width {
					player.inventory[i].image.X = animation[16].x
				}
			}
		case "resist fire full":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[11].width
				if player.inventory[i].image.X > animation[11].x+animation[11].frames*animation[11].width {
					player.inventory[i].image.X = animation[11].x
				}
			}
		case "resist fire half":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[12].width
				if player.inventory[i].image.X > animation[12].x+animation[12].frames*animation[12].width {
					player.inventory[i].image.X = animation[12].x
				}
			}
		case "resist fire quarter":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[13].width
				if player.inventory[i].image.X > animation[13].x+animation[13].frames*animation[13].width {
					player.inventory[i].image.X = animation[13].x
				}
			}
		case "mana potion full":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[8].width
				if player.inventory[i].image.X > animation[8].x+animation[8].frames*animation[8].width {
					player.inventory[i].image.X = animation[8].x
				}
			}
		case "mana potion half":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[9].width
				if player.inventory[i].image.X > animation[9].x+animation[9].frames*animation[9].width {
					player.inventory[i].image.X = animation[9].x
				}
			}
		case "mana potion quarter":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[10].width
				if player.inventory[i].image.X > animation[10].x+animation[10].frames*animation[10].width {
					player.inventory[i].image.X = animation[10].x
				}
			}
		case "hp potion full":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[5].width
				if player.inventory[i].image.X > animation[5].x+animation[5].frames*animation[5].width {
					player.inventory[i].image.X = animation[5].x
				}
			}
		case "hp potion half":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[6].width
				if player.inventory[i].image.X > animation[6].x+animation[6].frames*animation[6].width {
					player.inventory[i].image.X = animation[6].x
				}
			}
		case "hp potion quarter":
			if frames%6 == 0 {
				player.inventory[i].image.X += animation[7].width
				if player.inventory[i].image.X > animation[7].x+animation[7].frames*animation[7].width {
					player.inventory[i].image.X = animation[7].x
				}
			}
		}
	}

	maxWeapDmg = 0
	if player.weapon.name != "" {
		maxWeapDmg = player.weapon.damage
	}
	if player.weapon2.name != "" {
		if maxWeapDmg < player.weapon2.damage {
			maxWeapDmg = player.weapon2.damage
		}
	}
	if len(player.weapons) > 0 {
		for i := 0; i < len(player.weapons); i++ {
			if maxWeapDmg < player.weapons[i].damage {
				maxWeapDmg = player.weapons[i].damage
			}
		}
	}

}

func updatePlayer() { //MARK:UP PLAYER
	if !isBaseOn {

		//TIMERS
		if player.collectTimer > 0 {
			player.collectTimer--
		}
		if player.freezeTimer > 0 {
			player.freezeTimer--
		}
		if player.poisonTimer > 0 {
			player.poisonTimer--
		}
		if player.enemyCollisionTimer > 0 {
			player.enemyCollisionTimer--
		}
		if player.armorTimer > 0 {
			player.armorTimer--
		}
		if player.invisibleTimer > 0 {
			player.invisibleTimer--
		}
		if player.resistPoisonTimer > 0 {
			player.resistPoisonTimer--
		}
		if player.resistFireTimer > 0 {
			player.resistFireTimer--
		}
		if player.attackTimer > 0 {
			player.attackTimer--
		}
		if player.hpTimer > 0 {
			player.hpTimer--
		}
		if player.burnTimer > 0 {
			player.burnTimer--
			if player.dampTimer > 0 {
				player.burnTimer = 0
			} else {
				if player.burnTimer%fps == 0 {
					admsg("burning...", rl.Orange)
					hitPL(2)
				}
				if player.burnTimer <= 1 {
					admsg("flames extinguished", rl.Green)
				}
			}
		}
		if player.poisonTimer > 0 {
			if player.resistPoisonTimer > 0 {
				player.poisonTimer = 0
				admsg("resist poison saves poisoning", rl.Green)
			} else {
				if player.poisonTimer%fps == 0 {
					admsg("poisoned...", rl.Red)
					hitPL(2)
				}
			}
		}
		if player.dampTimer > 0 && slugT == 0 && sodaT == 0 {
			if player.dampTimer%fps == 0 {
				admsg("-2 speed", rl.Red)
			}
			player.dampTimer--
			player.speed = player.speed2 - 2
			if player.dampTimer == 1 {
				admsg("dry again", rl.Green)
			}
		} else if slugT > 0 && player.dampTimer == 0 && sodaT == 0 {
			player.speed = player.speed2 + 2
		} else if slugT > 0 && player.dampTimer == 0 && sodaT > 0 {
			player.speed = player.speed2 + 3
			if player.speed > player.speedMax {
				player.speed = player.speedMax
			}
		} else if slugT > 0 && player.dampTimer > 0 && sodaT == 0 {
			player.speed = player.speed2
		} else if slugT > 0 && player.dampTimer > 0 && sodaT > 0 {
			player.speed = player.speed2
		} else if slugT == 0 && player.dampTimer > 0 && sodaT > 0 {
			player.speed = player.speed2
		} else if slugT == 0 && player.dampTimer == 0 && sodaT > 0 {
			player.speed = player.speed2 + 1
		} else {
			player.speed = player.speed2
		}
		//INP
		if vineon {
			if vineon2 {
				if player.center.Y < currentPosition.Y {
					player.center.Y += player.speed
				} else {
					player.hp += 2
					player.hpTimer = fps * 2
					vineon = false
					vineon2 = false
				}
			} else {
				player.center.Y -= player.speed
				if player.center.Y <= inRec.Y {
					player.center.X = currentPosition.X
					vineon2 = true
				}
			}
		} else {
			if player.freezeTimer == 0 {
				movedown := false
				if player.attackTimer == 0 && !inquick && !inchestslot {
					atkNum := 0
					if rl.IsMouseButtonDown(rl.MouseButtonLeft) || rl.IsGamepadButtonDown(0, 12) {
						atkNum = 1
					}
					if rl.IsMouseButtonDown(rl.MouseButtonRight) || rl.IsGamepadButtonDown(0, 10) {
						atkNum = 2
					}

					if atkNum != 0 {
						if pistolT > 0 {
							player.attackTimer = fps / 10
						} else {
							if candycanenum > 4 {
								if atkNum == 1 && player.weapon.special == 7 || atkNum == 1 && player.weapon.special2 == 7 {
									player.attackTimer = fps / 8
								} else if atkNum == 2 && player.weapon2.special == 7 || atkNum == 2 && player.weapon2.special2 == 7 {
									player.attackTimer = fps / 8
								} else {
									player.attackTimer = fps / candycanenum
								}
							} else {
								if atkNum == 1 && player.weapon.special == 7 || atkNum == 1 && player.weapon.special2 == 7 {
									player.attackTimer = fps / 8
								} else if atkNum == 2 && player.weapon2.special == 7 || atkNum == 2 && player.weapon2.special2 == 7 {
									player.attackTimer = fps / 8
								} else {
									player.attackTimer = fps / 3
								}
							}
						}
						atkV2 = cursorV2cam
						atkCNT = player.center
						makeplproj(atkNum)
						//BELT
						if beltnum > 0 {
							beltAtk++
							if beltAtk == 11-beltnum {
								beltAtk = 0
								zfx := Effect{}
								zfx.name = "belt"
								zfx.imageRectangle = animation[94].rectangle
								zfx.rectangle = player.rectangle
								zfx.rectangle.X -= b3
								zfx.rectangle.Y -= b3
								zfx.rectangle.Width += b6
								zfx.rectangle.Height += b6
								effect = append(effect, zfx)
							}
						}

					}
				}
				plWorldScreenV2 := rl.GetWorldToScreen2D(player.center, cam2)
				if cursorV2.X < plWorldScreenV2.X && player.pushTimer == 0 {
					player.direction = true
				} else if cursorV2.X > plWorldScreenV2.X && player.pushTimer == 0 {
					player.direction = false
				}
				player.animationNum = 0
				if player.direction {
					player.animationNum = 1
				}

				if rl.IsKeyDown(rl.KeyW) || rl.IsKeyDown(rl.KeyUp) || rl.GetGamepadAxisMovement(0, 1) < 0 { //UP
					if checkplayermove(1) {
						player.center.Y -= player.speed + delta
					}
					player.animationNum = 4
				}
				if rl.IsKeyDown(rl.KeyS) || rl.IsKeyDown(rl.KeyDown) || rl.GetGamepadAxisMovement(0, 1) > 0 { //DOWN
					if checkplayermove(3) {
						player.center.Y += player.speed + delta
					}
					player.animationNum = 2
					if player.direction {
						player.animationNum = 3
					}
					movedown = true
				}
				if rl.IsKeyDown(rl.KeyA) || rl.IsKeyDown(rl.KeyLeft) || rl.GetGamepadAxisMovement(0, 0) < 0 { //LEFT
					if checkplayermove(4) {
						player.center.X -= player.speed + delta
					}
					player.animationNum = 3
					player.direction = true
				}
				if rl.IsKeyDown(rl.KeyD) || rl.IsKeyDown(rl.KeyRight) || rl.GetGamepadAxisMovement(0, 0) > 0 { //RIGHT
					if checkplayermove(2) {
						player.center.X += player.speed + delta
					}
					player.animationNum = 2
					player.direction = false
				}

				if player.pushTimer > 0 {
					if player.animationNum != 4 {
						if !movedown {
							player.animationNum = 7
							if player.direction {
								player.animationNum = 8
							}
						}
					}
					player.pushTimer--
					if !rl.IsSoundPlaying(audfx[15]) {
						rl.PlaySound(audfx[15])
					}
				} else {
					if rl.IsSoundPlaying(audfx[15]) {
						rl.StopSound(audfx[15])
					}
				}
				if player.attackTimer > 0 {
					player.animationNum = 5
					if player.direction {
						player.animationNum = 6
					}
				}
			}
		}
		//UP PLAYER REC
		updatePlayerRectangle()
		//UP ROOM VISITED
		if !isBossOn && !treasureRoom {
			for i := 0; i < len(levels[levNum].rectangles); i++ {
				if rl.CheckCollisionRecs(player.rectangle, levels[levNum].rectangles[i]) {
					if !levels[levNum].inf[i].isVisible {
						levels[levNum].inf[i].isVisible = true
					}
					playerRoom = i
				}
			}
		}
	}
}
func updatePlayerRectangle() { //MARK:UP PLAYER REC
	if isBaseOn {
		player2.rectangle = rl.NewRectangle(player2.center.X-player2.rectangle.Width/2, player2.center.Y-player2.rectangle.Height/2, player2.rectangle.Width, player2.rectangle.Height)
		player2.collisionRectangle = player2.rectangle
		player2.collisionRectangle.X += 4
		player2.collisionRectangle.Width -= 8
		player2.caRectangle = rl.NewRectangle(player2.center.X-player2.caRectangle.Width/2, player2.center.Y-player2.caRectangle.Height/2, player2.caRectangle.Width, player2.caRectangle.Height)
		player.perceptionRectangle = player.caRectangle
		player.perceptionRectangle.X -= b / 2
		player.perceptionRectangle.Y -= b / 2
		player.perceptionRectangle.Width += b
		player.perceptionRectangle.Height += b
		if stats.perception > 1 {
			diff := stats.perception - 1
			for diff > 0 {
				player.perceptionRectangle.X -= b / 2
				player.perceptionRectangle.Y -= b / 2
				player.perceptionRectangle.Width += b
				player.perceptionRectangle.Height += b
				diff--
			}
		}
	} else {
		player.rectangle = rl.NewRectangle(player.center.X-player.rectangle.Width/2, player.center.Y-player.rectangle.Height/2, player.rectangle.Width, player.rectangle.Height)
		player.collisionRectangle = player.rectangle
		player.collisionRectangle.X += 4
		player.collisionRectangle.Width -= 8
		player.caRectangle = rl.NewRectangle(player.center.X-player.caRectangle.Width/2, player.center.Y-player.caRectangle.Height/2, player.caRectangle.Width, player.caRectangle.Height)
		player.perceptionRectangle = player.caRectangle
		player.perceptionRectangle.X -= b / 2
		player.perceptionRectangle.Y -= b / 2
		player.perceptionRectangle.Width += b
		player.perceptionRectangle.Height += b
		if stats.perception > 1 {
			diff := stats.perception - 1
			for diff > 0 {
				player.perceptionRectangle.X -= b / 2
				player.perceptionRectangle.Y -= b / 2
				player.perceptionRectangle.Width += b
				player.perceptionRectangle.Height += b
				diff--
			}
		}
	}
}

// MARK:MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE MAKE
func makesound() { //MARK:MAKE SOUND

	music = append(music, rl.LoadMusicStream("music/title.ogg"))
	music = append(music, rl.LoadMusicStream("music/boss.ogg"))
	music = append(music, rl.LoadMusicStream("music/camp.ogg"))
	music = append(music, rl.LoadMusicStream("music/treasure.ogg"))
	music = append(music, rl.LoadMusicStream("music/01.ogg"))
	music = append(music, rl.LoadMusicStream("music/02.ogg"))
	music = append(music, rl.LoadMusicStream("music/03.ogg"))

	for i := 0; i < len(music); i++ {
		music[i].Looping = true
	}

	audfx = append(audfx, rl.LoadSound("fx/00.ogg"))  // 0 KNIFE PROJ
	audfx = append(audfx, rl.LoadSound("fx/01.ogg"))  // 1 COLLECT ITEM
	audfx = append(audfx, rl.LoadSound("fx/02.ogg"))  // 2 DESTROY CRATE
	audfx = append(audfx, rl.LoadSound("fx/03.ogg"))  // 3 OPEN CHEST
	audfx = append(audfx, rl.LoadSound("fx/04.ogg"))  // 4 BUTTON
	audfx = append(audfx, rl.LoadSound("fx/05.ogg"))  // 5 CLOSE CHEST
	audfx = append(audfx, rl.LoadSound("fx/06.ogg"))  // 6 WATER SPLASH
	audfx = append(audfx, rl.LoadSound("fx/07.ogg"))  // 7 MOVE CHEST ITEM
	audfx = append(audfx, rl.LoadSound("fx/08.ogg"))  // 8 ENEMY HIT
	audfx = append(audfx, rl.LoadSound("fx/09.ogg"))  // 9 ENEMY DEATH 1
	audfx = append(audfx, rl.LoadSound("fx/10.ogg"))  // 10 ENEMY DEATH 2
	audfx = append(audfx, rl.LoadSound("fx/11.ogg"))  // 11 ENEMY DEATH 3
	audfx = append(audfx, rl.LoadSound("fx/12.ogg"))  // 12 SPIKE TRAP
	audfx = append(audfx, rl.LoadSound("fx/13.ogg"))  // 13 FLAME TRAP
	audfx = append(audfx, rl.LoadSound("fx/14.ogg"))  // 14 PLAYER HIT
	audfx = append(audfx, rl.LoadSound("fx/15.ogg"))  // 15 PUSH CRATE
	audfx = append(audfx, rl.LoadSound("fx/16.ogg"))  // 16 DRINK POTION
	audfx = append(audfx, rl.LoadSound("fx/17.ogg"))  // 17 OPEN INVENTORY
	audfx = append(audfx, rl.LoadSound("fx/18.ogg"))  // 18 MOVE INVENTORY ITEM
	audfx = append(audfx, rl.LoadSound("fx/19.ogg"))  // 19 OPEN OPTIONS
	audfx = append(audfx, rl.LoadSound("fx/20.ogg"))  // 20 CARROTS PROJ
	audfx = append(audfx, rl.LoadSound("fx/21.ogg"))  // 21 WINDOW CLEANER PROJ
	audfx = append(audfx, rl.LoadSound("fx/22.ogg"))  // 22 RUBBER DUCK PROJ
	audfx = append(audfx, rl.LoadSound("fx/23.ogg"))  // 23 FRYING PAN PROJ
	audfx = append(audfx, rl.LoadSound("fx/24.ogg"))  // 24 ROLLING PIN PROJ
	audfx = append(audfx, rl.LoadSound("fx/25.ogg"))  // 25 MUSTARD PROJ
	audfx = append(audfx, rl.LoadSound("fx/26.ogg"))  // 26 ICE CREAM PROJ
	audfx = append(audfx, rl.LoadSound("fx/27.ogg"))  // 27 ZIPPO PROJ
	audfx = append(audfx, rl.LoadSound("fx/28.ogg"))  // 28 MAGNIFYING GLASS PROJ
	audfx = append(audfx, rl.LoadSound("fx/29.ogg"))  // 29 RASPBERRY PROJ
	audfx = append(audfx, rl.LoadSound("fx/30.ogg"))  // 30 ORBITAL LOLLY PROJ
	audfx = append(audfx, rl.LoadSound("fx/31.ogg"))  // 31 PINEAPPLE PROJ
	audfx = append(audfx, rl.LoadSound("fx/32.ogg"))  // 32 FORK PROJ
	audfx = append(audfx, rl.LoadSound("fx/33.ogg"))  // 33 CHILLI PROJ
	audfx = append(audfx, rl.LoadSound("fx/34.ogg"))  // 34 EMOJI PROJ
	audfx = append(audfx, rl.LoadSound("fx/35.ogg"))  // 35 FRENCH FRIES PROJ
	audfx = append(audfx, rl.LoadSound("fx/36.ogg"))  // 36 SOUP PROJ
	audfx = append(audfx, rl.LoadSound("fx/37.ogg"))  // 37 GUITAR PROJ
	audfx = append(audfx, rl.LoadSound("fx/38.ogg"))  // 38 DRAWING PIN PROJ
	audfx = append(audfx, rl.LoadSound("fx/39.ogg"))  // 39 SCROLL OF DETECTION
	audfx = append(audfx, rl.LoadSound("fx/40.ogg"))  // 40 SAVE SLOT INVEN MENU CLICK
	audfx = append(audfx, rl.LoadSound("fx/41.ogg"))  // 41 LOAD SAVE
	audfx = append(audfx, rl.LoadSound("fx/42.ogg"))  // 42 DELETE SAVE
	audfx = append(audfx, rl.LoadSound("fx/43.ogg"))  // 43 CONFIRM DELETE SAVE DROP ITEM GENERAL ERROR
	audfx = append(audfx, rl.LoadSound("fx/44.ogg"))  // 44 PRESS START INVEN MENU
	audfx = append(audfx, rl.LoadSound("fx/45.ogg"))  // 45 TELEPORTER
	audfx = append(audfx, rl.LoadSound("fx/46.ogg"))  // 46 BASE UNLOCK
	audfx = append(audfx, rl.LoadSound("fx/47.ogg"))  // 47 BASE UPGRADE
	audfx = append(audfx, rl.LoadSound("fx/48.ogg"))  // 48 WEAPON UPGRADE
	audfx = append(audfx, rl.LoadSound("fx/49.ogg"))  // 49 ENTER STRUCTURE
	audfx = append(audfx, rl.LoadSound("fx/50.ogg"))  // 50 ENTER DUNGEON LAUGH
	audfx = append(audfx, rl.LoadSound("fx/51.ogg"))  // 51 ENTER DUNGEON LAUGH
	audfx = append(audfx, rl.LoadSound("fx/52.ogg"))  // 52 ENTER DUNGEON LAUGH
	audfx = append(audfx, rl.LoadSound("fx/53.ogg"))  // 53 ENTER DUNGEON LAUGH
	audfx = append(audfx, rl.LoadSound("fx/54.ogg"))  // 54 ENTER DUNGEON LAUGH
	audfx = append(audfx, rl.LoadSound("fx/55.ogg"))  // 55 ENTER DUNGEON LAUGH
	audfx = append(audfx, rl.LoadSound("fx/56.ogg"))  // 56 ENTER DUNGEON LAUGH
	audfx = append(audfx, rl.LoadSound("fx/57.ogg"))  // 57 ENTER DUNGEON LAUGH
	audfx = append(audfx, rl.LoadSound("fx/58.ogg"))  // 58 OPEN BOOK
	audfx = append(audfx, rl.LoadSound("fx/59.ogg"))  // 59 OPEN BOOK
	audfx = append(audfx, rl.LoadSound("fx/60.ogg"))  // 60 OPEN BOOK
	audfx = append(audfx, rl.LoadSound("fx/61.ogg"))  // 61 OPEN BOOK
	audfx = append(audfx, rl.LoadSound("fx/62.ogg"))  // 62 OPEN BOOK
	audfx = append(audfx, rl.LoadSound("fx/63.ogg"))  // 63 OPEN BOOK
	audfx = append(audfx, rl.LoadSound("fx/64.ogg"))  // 64 OPEN BOOK
	audfx = append(audfx, rl.LoadSound("fx/65.ogg"))  // 65 COLLECT MUSHROOM STRUCTURE
	audfx = append(audfx, rl.LoadSound("fx/66.ogg"))  // 66 SCROLL POISON GAS
	audfx = append(audfx, rl.LoadSound("fx/67.ogg"))  // 67 SCROLL FROGS
	audfx = append(audfx, rl.LoadSound("fx/68.ogg"))  // 68 SCROLL INTANGIBILITY
	audfx = append(audfx, rl.LoadSound("fx/69.ogg"))  // 69 SCROLL HOME
	audfx = append(audfx, rl.LoadSound("fx/70.ogg"))  // 70 SCROLL BEGINNING
	audfx = append(audfx, rl.LoadSound("fx/71.ogg"))  // 71 SCROLL INFLICT
	audfx = append(audfx, rl.LoadSound("fx/72.ogg"))  // 72 SCROLL POWER
	audfx = append(audfx, rl.LoadSound("fx/73.ogg"))  // 73 LONG RANGE SCOPE
	audfx = append(audfx, rl.LoadSound("fx/74.ogg"))  // 74 COLLECT ARTIFACT
	audfx = append(audfx, rl.LoadSound("fx/75.ogg"))  // 75 STEROIDS
	audfx = append(audfx, rl.LoadSound("fx/76.ogg"))  // 76 WATCH
	audfx = append(audfx, rl.LoadSound("fx/77.ogg"))  // 77 SHRIMP
	audfx = append(audfx, rl.LoadSound("fx/78.ogg"))  // 78 PISTOL
	audfx = append(audfx, rl.LoadSound("fx/79.ogg"))  // 79 TURTLE
	audfx = append(audfx, rl.LoadSound("fx/80.ogg"))  // 80 ICE CREAM
	audfx = append(audfx, rl.LoadSound("fx/81.ogg"))  // 81 ICE LOLLY
	audfx = append(audfx, rl.LoadSound("fx/82.ogg"))  // 82 QUAIL EGG
	audfx = append(audfx, rl.LoadSound("fx/83.ogg"))  // 83 BEETROOT
	audfx = append(audfx, rl.LoadSound("fx/84.ogg"))  // 84 LADYBUG
	audfx = append(audfx, rl.LoadSound("fx/85.ogg"))  // 85 LADYBUG PROJ
	audfx = append(audfx, rl.LoadSound("fx/86.ogg"))  // 86 POPCORN PROJ
	audfx = append(audfx, rl.LoadSound("fx/87.ogg"))  // 87 POPCORN
	audfx = append(audfx, rl.LoadSound("fx/88.ogg"))  // 88 ORANGE SLICE
	audfx = append(audfx, rl.LoadSound("fx/89.ogg"))  // 89 TV
	audfx = append(audfx, rl.LoadSound("fx/90.ogg"))  // 90 LOLLIPOP
	audfx = append(audfx, rl.LoadSound("fx/91.ogg"))  // 91 BEES
	audfx = append(audfx, rl.LoadSound("fx/92.ogg"))  // 92 EGGS
	audfx = append(audfx, rl.LoadSound("fx/93.ogg"))  // 93 BOMB
	audfx = append(audfx, rl.LoadSound("fx/94.ogg"))  // 94 BOMB EXPLODE
	audfx = append(audfx, rl.LoadSound("fx/95.ogg"))  // 95 PSYCHEDELIC
	audfx = append(audfx, rl.LoadSound("fx/96.ogg"))  // 96 BOOTS
	audfx = append(audfx, rl.LoadSound("fx/97.ogg"))  // 97 FART GAS
	audfx = append(audfx, rl.LoadSound("fx/98.ogg"))  // 98 FART
	audfx = append(audfx, rl.LoadSound("fx/99.ogg"))  // 99 FART
	audfx = append(audfx, rl.LoadSound("fx/100.ogg")) // 100 FART
	audfx = append(audfx, rl.LoadSound("fx/101.ogg")) // 101 FART
	audfx = append(audfx, rl.LoadSound("fx/102.ogg")) // 102 SALT
	audfx = append(audfx, rl.LoadSound("fx/103.ogg")) // 103 XP BONUS
	audfx = append(audfx, rl.LoadSound("fx/104.ogg")) // 104 RED BOMB EXPLODE
	audfx = append(audfx, rl.LoadSound("fx/105.ogg")) // 105 FRYING PAN COLLIS
	audfx = append(audfx, rl.LoadSound("fx/106.ogg")) // 106 VINE
	audfx = append(audfx, rl.LoadSound("fx/107.ogg")) // 107 LIGHTNING
	audfx = append(audfx, rl.LoadSound("fx/108.ogg")) // 108 ARROWS
	audfx = append(audfx, rl.LoadSound("fx/109.ogg")) // 109 CRATE FIREWORKS
	audfx = append(audfx, rl.LoadSound("fx/110.ogg")) // 110 PROJ TURRET DROP
	audfx = append(audfx, rl.LoadSound("fx/111.ogg")) // 111 ROCKET
	audfx = append(audfx, rl.LoadSound("fx/112.ogg")) // 112 ROCKET
	audfx = append(audfx, rl.LoadSound("fx/113.ogg")) // 113 SLUDGE GEYSER
	audfx = append(audfx, rl.LoadSound("fx/114.ogg")) // 114 SWITCH ORE
	audfx = append(audfx, rl.LoadSound("fx/115.ogg")) // 115 SWITCH DARTS
	audfx = append(audfx, rl.LoadSound("fx/116.ogg")) // 116 SWITCH ENEMY
	audfx = append(audfx, rl.LoadSound("fx/117.ogg")) // 117 WEAPON CRATE
	audfx = append(audfx, rl.LoadSound("fx/118.ogg")) // 118 DESTROY WEAPON CRATE
	audfx = append(audfx, rl.LoadSound("fx/119.ogg")) // 119 COLLECT WEAPON
	audfx = append(audfx, rl.LoadSound("fx/120.ogg")) // 120 CHILLI BURN
	audfx = append(audfx, rl.LoadSound("fx/121.ogg")) // 121 IN BACKPACK
	audfx = append(audfx, rl.LoadSound("fx/122.ogg")) // 122 BOSS CHEER
	audfx = append(audfx, rl.LoadSound("fx/123.ogg")) // 123 PLAYER DEATH
	audfx = append(audfx, rl.LoadSound("fx/124.ogg")) // 124 NEXT LEVEL
	audfx = append(audfx, rl.LoadSound("fx/125.ogg")) // 125 NEXT LEVEL
	audfx = append(audfx, rl.LoadSound("fx/126.ogg")) // 126 NEXT LEVEL
	audfx = append(audfx, rl.LoadSound("fx/127.ogg")) // 127 NEXT LEVEL
	audfx = append(audfx, rl.LoadSound("fx/128.ogg")) // 128 NEXT LEVEL

}
func makeitems(lev x1scr) x1scr { //MARK:MAKE ITEMS

	/*
		zitm := itmlist[122]
		zitm.cnt = pl.cnt
		zitm.cnt.X -= b2
		zitm.cnt.Y -= b
		zitm.rec = rl.NewRectangle(zitm.cnt.X-zitm.rec.Width/2, zitm.cnt.Y-zitm.rec.Height/2, zitm.rec.Width, zitm.rec.Height)
		lev.itm = append(lev.itm, zitm)
	*/

	//INVIS
	num := RandInt(1, 4)
	for num > 0 {
		zitm := Item{}
		zitm = invisItm[RandInt(0, len(invisItm))]
		zitm.isInvisible = true
		countbreak := 100
		for {
			zitm.center = findRanCntLev(lev)
			zitm.rectangle = rl.NewRectangle(zitm.center.X-zitm.rectangle.Width/2, zitm.center.Y-zitm.rectangle.Height/2, zitm.rectangle.Width, zitm.rectangle.Height)
			canadd := checkaddtilerecInner(zitm.rectangle, lev)
			if canadd {
				canadd = checkaddetc(zitm.rectangle, lev)
				lev.items = append(lev.items, zitm)
				num--
			}
			if canadd || countbreak == 0 {
				break
			}
			countbreak--
		}
	}
	return lev
}

func makeweaponsINTIIAL() { //MARK:MAKE WEAPONS INITIAL
	siz := b / 2
	zweap := Weapon{}
	zweap.col = rl.White
	zweap.fade = 1
	zweap.num = 1
	//0 KITCHEN KNIFE
	zweap.name = "kitchen knife"
	zweap.level = 1
	zweap.weapListNum = 0
	zweap.image = otherTiles[8]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 1
	zweap.originalDamage = zweap.damage
	zweap.speed = 4
	zweap.rotationSpeed = 8
	zweap.description = "ye olde trusty knife"
	zweap.description2 = "what better way to start any adventure than"
	zweap.description3 = "a trusty old kitchen knife? perhaps not the"
	zweap.description4 = "most formidable of choices though serves"
	zweap.description5 = "the purpose of hacking all the dungeon baddies"
	zweap.descrition6 = "into little pieces, like chopping onions"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//1 CARROTS
	zweap.name = "bunch of carrots"
	zweap.weapListNum = 1
	zweap.image = otherTiles[154]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 1
	zweap.originalDamage = zweap.damage
	zweap.speed = 5
	zweap.rotationSpeed = 0
	zweap.description = "3x projectiles"
	zweap.description2 = "vitamins are your friends unless, of course,"
	zweap.description3 = "you happen to be a dungeon baddie and mr"
	zweap.description4 = "snuggles is wielding a bunch of carrots."
	zweap.description5 = "all the minions in the dungeon cringe at the"
	zweap.descrition6 = "sight though at least it's not brussels sprouts"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//2 WINDOW CLEANER
	zweap.name = "window cleaner"
	zweap.weapListNum = 2
	zweap.image = otherTiles[156]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 1
	zweap.originalDamage = zweap.damage
	zweap.speed = 6
	zweap.rotationSpeed = 0
	zweap.description = "projectiles increase in size"
	zweap.description2 = "what could be better than lovely shiny, clean"
	zweap.description3 = "windows? well, a shiny, clean dungeon would"
	zweap.description4 = "be one thing, a few less baddies to terrorise"
	zweap.description5 = "poor mr snuggles is always a good thing. don't"
	zweap.descrition6 = "ponder the logistics of deadly window cleaner"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//3 RUBBER DUCK
	zweap.name = "rubber duck"
	zweap.weapListNum = 3
	zweap.image = otherTiles[157]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 1
	zweap.originalDamage = zweap.damage
	zweap.speed = 4
	zweap.rotationSpeed = 5
	zweap.description = "bounce & squeak"
	zweap.description2 = "remember when you were younger and bathing"
	zweap.description3 = "was a favourite past time? well, that has"
	zweap.description4 = "absolutely nothing to do with this game."
	zweap.description5 = "anyway, apart from the sometimes annoying"
	zweap.descrition6 = "squeak the rubber duck is a great weapon"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//4 FRYING PAN
	zweap.name = "frying pan"
	zweap.weapListNum = 4
	zweap.image = otherTiles[158]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 2
	zweap.originalDamage = zweap.damage
	zweap.speed = 4
	zweap.rotationSpeed = 5
	zweap.description = "collision shock wave"
	zweap.description2 = "there are a lot of kitchen implements in"
	zweap.description3 = "this game and the frying pan is perhaps"
	zweap.description4 = "one of the more useful ones. whilst a"
	zweap.description5 = "slightly slower pojectile, on enemy kill"
	zweap.descrition6 = "it releases a shockwave that stuns"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//5 ROLLING PIN
	zweap.name = "rolling pin"
	zweap.weapListNum = 5
	zweap.image = otherTiles[159]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 1
	zweap.originalDamage = zweap.damage
	zweap.speed = 5
	zweap.rotationSpeed = 7
	zweap.description = "collision > splinter projectiles"
	zweap.description2 = "making cookies, rolling pizzas, the"
	zweap.description3 = "trusty rolling pin has many uses and"
	zweap.description4 = "so why not use it to slay baddies in"
	zweap.description5 = "the dungeon? even better, as it is"
	zweap.descrition6 = "wood, it splinters on enemy kill"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//6 MUSTARD
	zweap.name = "mustard"
	zweap.weapListNum = 6
	zweap.image = otherTiles[160]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 1
	zweap.originalDamage = zweap.damage
	zweap.speed = 5
	zweap.rotationSpeed = 7
	zweap.description = "projectiles increase in size"
	zweap.description2 = "more kitchen mayhem in this rpg"
	zweap.description3 = "roguelike dungeon crawler. mustard"
	zweap.description4 = "is an erratic weapon, shooting 3"
	zweap.description5 = "projectiles, generally in slightly"
	zweap.descrition6 = "random directions with spread"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//7 MINT ICE CREAM
	zweap.name = "mint ice cream"
	zweap.weapListNum = 7
	zweap.image = otherTiles[163]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 1
	zweap.originalDamage = zweap.damage
	zweap.speed = 5
	zweap.rotationSpeed = 4
	zweap.description = "puddle of freeze"
	zweap.description2 = "what could be better than a mint"
	zweap.description3 = "ice cream cone on a hot summer's"
	zweap.description4 = "day or even on a gloomy, dingy"
	zweap.description5 = "and dank day in the dungeon?"
	zweap.descrition6 = "freezing sludge on enemy kill"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//8 LIGHTER
	zweap.name = "lighter"
	zweap.weapListNum = 8
	zweap.image = otherTiles[164]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 1
	zweap.originalDamage = zweap.damage
	zweap.speed = 5
	zweap.rotationSpeed = 4
	zweap.description = "burning trail"
	zweap.description2 = "not to be tried at home, the metal"
	zweap.description3 = "lighter is a bit of a double-edged"
	zweap.description4 = "sword, not only  inflicting damage"
	zweap.description5 = "on impact but also leaving a trail"
	zweap.descrition6 = "of fire in its path"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//9 MAGNIFYING GLASS
	zweap.name = "magnifying glass"
	zweap.weapListNum = 9
	zweap.image = otherTiles[165]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 2
	zweap.originalDamage = zweap.damage
	zweap.speed = 4
	zweap.rotationSpeed = 4
	zweap.description = "enemies increase in size"
	zweap.description2 = "officially the stupidest weapon"
	zweap.description3 = "in mr snuggles dungeon adventure"
	zweap.description4 = "the magnifying glass has a higher"
	zweap.description5 = "damage and also increases enemy size"
	zweap.descrition6 = "on hit, making aiming easier"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//10 RASPBERRY
	zweap.name = "raspberry"
	zweap.weapListNum = 10
	zweap.image = otherTiles[166]
	zweap.rec = rl.NewRectangle(0, 0, siz/3, siz/3)
	zweap.damage = 1
	zweap.originalDamage = zweap.damage
	zweap.speed = 5
	zweap.rotationSpeed = 10
	zweap.description = "bounce & split"
	zweap.description2 = "sometimes smaller can be better and"
	zweap.description3 = "the raspberry is an excellent example"
	zweap.description4 = "of this. on bounce, the projectile"
	zweap.description5 = "duplicates and pretty soon the room"
	zweap.descrition6 = "is filled with deadly berries"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//11 PINEAPPLE
	zweap.name = "pineapple"
	zweap.weapListNum = 11
	zweap.image = otherTiles[168]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 2
	zweap.originalDamage = zweap.damage
	zweap.speed = 3
	zweap.rotationSpeed = 3
	zweap.description = "increases in size"
	zweap.description2 = "should people be allowed to use"
	zweap.description3 = "pineapple on pizza? well, if it"
	zweap.description4 = "was illegal it would be pretty"
	zweap.description5 = "difficult to police so if you want"
	zweap.descrition6 = "to then just go ahead and do it"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//12 FORK
	zweap.name = "fork"
	zweap.weapListNum = 12
	zweap.image = otherTiles[170]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 1
	zweap.originalDamage = zweap.damage
	zweap.speed = 7
	zweap.rotationSpeed = 0
	zweap.description = "multiple fast projectiles"
	zweap.description2 = "much like the prongs of a fork"
	zweap.description3 = "this projectile offers a 3 pronged"
	zweap.description4 = "accurate attack meaning that if one"
	zweap.description5 = "projectile strikes the remaining"
	zweap.descrition6 = "two carry on going"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//13 CHILLI
	zweap.name = "chilli"
	zweap.weapListNum = 13
	zweap.image = otherTiles[171]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 1
	zweap.originalDamage = zweap.damage
	zweap.speed = 5
	zweap.rotationSpeed = 7
	zweap.description = "burn on hit"
	zweap.description2 = "a chilli is a strange thing, on"
	zweap.description3 = "occasion, when cooking, you can add"
	zweap.description4 = "10 to a dish and still find it fairly"
	zweap.description5 = "mild. then, another day, you add just"
	zweap.descrition6 = "1 and it burns like fire"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//14 EMOJI
	zweap.name = "emoji"
	zweap.weapListNum = 14
	zweap.image = otherTiles[172]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 1
	zweap.originalDamage = zweap.damage
	zweap.speed = 10
	zweap.rotationSpeed = 5
	zweap.description = "fast bounce"
	zweap.description2 = "happiness is something that is often"
	zweap.description3 = "expressed using emojis when chatting"
	zweap.description4 = "and has become almost a part of our"
	zweap.description5 = "digital language. in this game they"
	zweap.descrition6 = "are, however, used to kill baddies"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//15 FRIES
	zweap.name = "french fries"
	zweap.weapListNum = 15
	zweap.image = otherTiles[173]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 1
	zweap.originalDamage = zweap.damage
	zweap.speed = 8
	zweap.rotationSpeed = 0
	zweap.description = "oil slick"
	zweap.description2 = "ever been attacked in the dark of the"
	zweap.description3 = "night by someone wielding a box of"
	zweap.description4 = "french fries? probably not, though if"
	zweap.description5 = "you are then maybe just laugh as it is"
	zweap.descrition6 = "very silly and the person will go away"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//16 HOT SOUP
	zweap.name = "hot soup"
	zweap.weapListNum = 16
	zweap.image = otherTiles[174]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 1
	zweap.originalDamage = zweap.damage
	zweap.speed = 5
	zweap.rotationSpeed = 4
	zweap.description = "puddle of hot soup burns"
	zweap.description2 = "the logistics of mr snuggles running"
	zweap.description3 = "around the dungeon carrying a ladle"
	zweap.description4 = "of hot soup is something that you"
	zweap.description5 = "may ponder on long, boring nights"
	zweap.descrition6 = "and if you work it out, good for you"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//17 GUITAR
	zweap.name = "guitar"
	zweap.weapListNum = 17
	zweap.image = otherTiles[176]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 1
	zweap.originalDamage = zweap.damage
	zweap.speed = 5
	zweap.rotationSpeed = 0
	zweap.description = "multiple fast projectiles"
	zweap.description2 = "a musical interlude is a great way to"
	zweap.description3 = "break the mundanity of playing endlessly"
	zweap.description4 = "and what better way to liven things up"
	zweap.description5 = "then by playing a bit of guitar and also"
	zweap.descrition6 = "killing dungoeon nasties"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
	//18 DRAWING PIN
	zweap.name = "drawing pin"
	zweap.weapListNum = 18
	zweap.image = otherTiles[177]
	zweap.rec = rl.NewRectangle(0, 0, siz, siz)
	zweap.damage = 1
	zweap.originalDamage = zweap.damage
	zweap.speed = 7
	zweap.rotationSpeed = 0
	zweap.description = "enemies freeze in place"
	zweap.description2 = "great if you are wanting to stop enemies"
	zweap.description3 = "in their tracks, this weapon will freeze"
	zweap.description4 = "enemies in place on hit. so, if you have"
	zweap.description5 = "a wave of dungeon nasties on the way then"
	zweap.descrition6 = "nail them to floor with drawing pins"
	zweap.description7 = "dmg > " + fmt.Sprint(zweap.damage)
	weapons = append(weapons, zweap)
}

func makeitemsINITAL() { //MARK:MAKE ITEMS INITIAL
	siz := be5
	//POTIONS
	zitm := Item{}
	zitm.numof = 1
	zitm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zitm.image = animation[5].rectangle
	zitm.listNum = 0
	zitm.price = 100
	zitm.name = "hp potion full"
	zitm.des = "restores full hp"
	zitm.des2 = "while you are sleeping, every night mr snuggles gets up,"
	zitm.des3 = "leaves his tent & searches high & low for ingredients to"
	zitm.des4 = "make his potions. He doesn't just use mushrooms, often he"
	zitm.des5 = "might require berries, herbs, squirrel sweat, bark, bat"
	zitm.des6 = "testicles, lizzard toenails & other essentials to complete"
	zitm.des7 = "his secret brew. good luck mr snuggles!"
	itemList = append(itemList, zitm) //0
	zitm.image = animation[6].rectangle
	zitm.listNum = 1
	zitm.price = 75
	zitm.potionPrice = nil
	zitm.name = "hp potion half"
	zitm.des = "restores half hp"
	zitm.des2 = "while you are sleeping, every night mr snuggles gets up,"
	zitm.des3 = "leaves his tent & searches high & low for ingredients to"
	zitm.des4 = "make his potions. He doesn't just use mushrooms, often he"
	zitm.des5 = "might require berries, herbs, squirrel sweat, bark, bat"
	zitm.des6 = "testicles, lizzard toenails & other essentials to complete"
	zitm.des7 = "his secret brew. good luck mr snuggles!"
	itemList = append(itemList, zitm) //1
	zitm.image = animation[7].rectangle
	zitm.listNum = 2
	zitm.isUnlocked = true
	zitm.potionPrice = nil
	zitm.name = "hp potion quarter"
	zitm.des = "restores quarter hp"
	zitm.des2 = "while you are sleeping, every night mr snuggles gets up,"
	zitm.des3 = "leaves his tent & searches high & low for ingredients to"
	zitm.des4 = "make his potions. He doesn't just use mushrooms, often he"
	zitm.des5 = "might require berries, herbs, squirrel sweat, bark, bat"
	zitm.des6 = "testicles, lizzard toenails & other essentials to complete"
	zitm.des7 = "his secret brew. good luck mr snuggles!"
	itemList = append(itemList, zitm) //2
	zitm.image = animation[8].rectangle
	zitm.listNum = 3
	zitm.price = 100
	zitm.isUnlocked = false
	zitm.potionPrice = nil
	zitm.name = "mana potion full"
	zitm.des = "restores full mana"
	zitm.des2 = "while you are sleeping, every night mr snuggles gets up,"
	zitm.des3 = "leaves his tent & searches high & low for ingredients to"
	zitm.des4 = "make his potions. He doesn't just use mushrooms, often he"
	zitm.des5 = "might require berries, herbs, squirrel sweat, bark, bat"
	zitm.des6 = "testicles, lizzard toenails & other essentials to complete"
	zitm.des7 = "his secret brew. good luck mr snuggles!"
	itemList = append(itemList, zitm) //3
	zitm.image = animation[9].rectangle
	zitm.listNum = 4
	zitm.price = 75
	zitm.potionPrice = nil
	zitm.name = "mana potion half"
	zitm.des = "restores half mana"
	zitm.des2 = "while you are sleeping, every night mr snuggles gets up,"
	zitm.des3 = "leaves his tent & searches high & low for ingredients to"
	zitm.des4 = "make his potions. He doesn't just use mushrooms, often he"
	zitm.des5 = "might require berries, herbs, squirrel sweat, bark, bat"
	zitm.des6 = "testicles, lizzard toenails & other essentials to complete"
	zitm.des7 = "his secret brew. good luck mr snuggles!"
	itemList = append(itemList, zitm) //4
	zitm.image = animation[10].rectangle
	zitm.listNum = 5
	zitm.isUnlocked = true
	zitm.potionPrice = nil
	zitm.name = "mana potion quarter"
	zitm.des = "restores quarter mana"
	zitm.des2 = "while you are sleeping, every night mr snuggles gets up,"
	zitm.des3 = "leaves his tent & searches high & low for ingredients to"
	zitm.des4 = "make his potions. He doesn't just use mushrooms, often he"
	zitm.des5 = "might require berries, herbs, squirrel sweat, bark, bat"
	zitm.des6 = "testicles, lizzard toenails & other essentials to complete"
	zitm.des7 = "his secret brew. good luck mr snuggles!"
	itemList = append(itemList, zitm) //5
	zitm.image = animation[11].rectangle
	zitm.listNum = 6
	zitm.price = 100
	zitm.isUnlocked = false
	zitm.potionPrice = nil
	zitm.name = "resist fire full"
	zitm.des = "extinguish & immune fire > 120s"
	zitm.des2 = "burn baby burn"
	zitm.des3 = "disco inferno"
	zitm.des4 = "can be resisted for"
	zitm.des5 = "120 seconds (2 minutes)"
	zitm.des6 = "by using this potion"
	zitm.des7 = ""
	itemList = append(itemList, zitm) //6
	zitm.image = animation[12].rectangle
	zitm.listNum = 7
	zitm.price = 75
	zitm.potionPrice = nil
	zitm.name = "resist fire half"
	zitm.des = "extinguish & immune fire > 60s"
	zitm.des2 = "burn baby burn"
	zitm.des3 = "disco inferno"
	zitm.des4 = "can be resisted for"
	zitm.des5 = "60 seconds (1 minute)"
	zitm.des6 = "by using this potion"
	zitm.des7 = ""
	itemList = append(itemList, zitm) //7
	zitm.image = animation[13].rectangle
	zitm.listNum = 8
	zitm.isUnlocked = true
	zitm.potionPrice = nil
	zitm.name = "resist fire quarter"
	zitm.des = "extinguish & immune fire > 30s"
	zitm.des2 = "burn baby burn"
	zitm.des3 = "disco inferno"
	zitm.des4 = "can be resisted for"
	zitm.des5 = "30 seconds by"
	zitm.des6 = "using this potion"
	zitm.des7 = ""
	itemList = append(itemList, zitm) //8
	zitm.image = animation[14].rectangle
	zitm.listNum = 9
	zitm.price = 100
	zitm.isUnlocked = false
	zitm.potionPrice = nil
	zitm.name = "resist poison full"
	zitm.des = "cures & resist poison > 120s"
	zitm.des2 = "if you grew up a very long time ago"
	zitm.des3 = "then you may remember a famous song"
	zitm.des4 = "by alice cooper all about poison that"
	zitm.des5 = "was (and still is to some people)"
	zitm.des6 = "very popular. mr snuggles loves the"
	zitm.des7 = "song as well, so it must be good"
	itemList = append(itemList, zitm) //9
	zitm.image = animation[15].rectangle
	zitm.listNum = 10
	zitm.price = 75
	zitm.potionPrice = nil
	zitm.name = "resist poison half"
	zitm.des = "cures & resist poison > 60s"
	zitm.des2 = "if you grew up a very long time ago"
	zitm.des3 = "then you may remember a famous song"
	zitm.des4 = "by alice cooper all about poison that"
	zitm.des5 = "was (and still is to some people)"
	zitm.des6 = "very popular. mr snuggles loves the"
	zitm.des7 = "song as well, so it must be good"
	itemList = append(itemList, zitm) //10
	zitm.image = animation[16].rectangle
	zitm.listNum = 11
	zitm.isUnlocked = true
	zitm.potionPrice = nil
	zitm.name = "resist poison quarter"
	zitm.des = "cures & resist poison > 30s"
	zitm.des2 = "if you grew up a very long time ago"
	zitm.des3 = "then you may remember a famous song"
	zitm.des4 = "by alice cooper all about poison that"
	zitm.des5 = "was (and still is to some people)"
	zitm.des6 = "very popular. mr snuggles loves the"
	zitm.des7 = "song as well, so it must be good"
	itemList = append(itemList, zitm) //11
	zitm.image = animation[17].rectangle
	zitm.listNum = 12
	zitm.price = 100
	zitm.isUnlocked = false
	zitm.potionPrice = nil
	zitm.name = "invisibility full"
	zitm.des = "enemies don't follow > 90s"
	zitm.des2 = "as you already know smells are invisible"
	zitm.des3 = "though if the enemies in the dungeon"
	zitm.des4 = "tracked by smell then mr snuggles would"
	zitm.des5 = "never get any peace as he happens"
	zitm.des6 = "to be quite a smelly farter"
	zitm.des7 = ""
	itemList = append(itemList, zitm) //12
	zitm.image = animation[18].rectangle
	zitm.listNum = 13
	zitm.price = 75
	zitm.potionPrice = nil
	zitm.name = "invisibility half"
	zitm.des = "enemies don't follow > 60s"
	zitm.des2 = "as you already know smells are invisible"
	zitm.des3 = "though if the enemies in the dungeon"
	zitm.des4 = "tracked by smell then mr snuggles would"
	zitm.des5 = "never get any peace as he happens"
	zitm.des6 = "to be quite a smelly farter"
	zitm.des7 = ""
	itemList = append(itemList, zitm) //13
	zitm.image = animation[19].rectangle
	zitm.listNum = 14
	zitm.price = 50
	zitm.potionPrice = nil
	zitm.name = "invisibility quarter"
	zitm.des = "enemies don't follow > 30s"
	zitm.des2 = "as you already know smells are invisible"
	zitm.des3 = "though if the enemies in the dungeon"
	zitm.des4 = "tracked by smell then mr snuggles would"
	zitm.des5 = "never get any peace as he happens"
	zitm.des6 = "to be quite a smelly farter"
	zitm.des7 = ""
	itemList = append(itemList, zitm) //14
	zitm.image = animation[20].rectangle
	zitm.listNum = 15
	zitm.price = 200
	zitm.potionPrice = nil
	zitm.name = "armor potion full"
	zitm.des = "no damage > 60s"
	zitm.des2 = "mr snuggles is quite proud of his"
	zitm.des3 = "armor potion formula and it has, on"
	zitm.des4 = "numerous occasions, saved him from"
	zitm.des5 = "certain death. unfortunately, once it"
	zitm.des6 = "wears off, he then often dies shortly"
	zitm.des7 = "afterwards, though a valiant effort"
	itemList = append(itemList, zitm) //15
	zitm.image = animation[21].rectangle
	zitm.listNum = 16
	zitm.price = 150
	zitm.potionPrice = nil
	zitm.name = "armor potion half"
	zitm.des = "no damage > 30s"
	zitm.des2 = "mr snuggles is quite proud of his"
	zitm.des3 = "armor potion formula and it has, on"
	zitm.des4 = "numerous occasions, saved him from"
	zitm.des5 = "certain death. unfortunately, once it"
	zitm.des6 = "wears off, he then often dies shortly"
	zitm.des7 = "afterwards, though a valiant effort"
	itemList = append(itemList, zitm) //16
	zitm.image = animation[22].rectangle
	zitm.listNum = 17
	zitm.price = 100
	zitm.potionPrice = nil
	zitm.name = "armor potion quarter"
	zitm.des = "no damage > 15s"
	zitm.des2 = "mr snuggles is quite proud of his"
	zitm.des3 = "armor potion formula and it has, on"
	zitm.des4 = "numerous occasions, saved him from"
	zitm.des5 = "certain death. unfortunately, once it"
	zitm.des6 = "wears off, he then often dies shortly"
	zitm.des7 = "afterwards, though a valiant effort"
	itemList = append(itemList, zitm) //17
	//SCROLLS
	zitm.image = otherTiles[9]
	zitm.listNum = 18
	zitm.price = 100
	zitm.mana = 1
	zitm.name = "scroll of poison gas"
	zitm.des = "creates poison gas > +int"
	zitm.des2 = "one day mr snuggles farted on a"
	zitm.des3 = "piece of paper and, in the process,"
	zitm.des4 = "accidentally created a poison gas"
	zitm.des5 = "scroll. he still credits himself as"
	zitm.des6 = "the inventor though this is disputed"
	zitm.des7 = "max int 5 = 5 gas clouds > mana cost > 1"
	itemList = append(itemList, zitm) //18
	zitm.image = otherTiles[10]
	zitm.listNum = 19
	zitm.price = 150
	zitm.mana = 2
	zitm.name = "scroll of frogs"
	zitm.des = "spawns frogs > +int"
	zitm.des2 = "mr snuggles has never liked frogs and"
	zitm.des3 = "hence he does not like using this scroll"
	zitm.des4 = "however his enemies all cower in fear when"
	zitm.des5 = "the dreaded scroll of frogs is used"
	zitm.des6 = "mana cost > 2"
	zitm.des7 = "max int 5 = 20 (5x4) frogs"
	itemList = append(itemList, zitm) //19
	zitm.image = otherTiles[11]
	zitm.listNum = 20
	zitm.price = 50
	zitm.mana = 2
	zitm.name = "scroll of intangibility"
	zitm.des = "walk through some walls > 30s"
	zitm.des2 = "whether or not we live in a tangible world"
	zitm.des3 = "is a debatable point until you bump your head"
	zitm.des4 = "on something pointy. following this you realise"
	zitm.des5 = "that these types of discussions are generally"
	zitm.des6 = "rubbish and lacking any substance."
	zitm.des7 = "mana cost > 2 > return to dungeon center at end"
	itemList = append(itemList, zitm) //20
	zitm.image = otherTiles[12]
	zitm.listNum = 21
	zitm.price = 75
	zitm.mana = 1
	zitm.name = "scroll of detection"
	zitm.des = "reveals invisible items/rooms"
	zitm.des2 = "the world around us may hide many things that"
	zitm.des3 = "we cannot see, unless of course you happen to"
	zitm.des4 = "have a handy scroll of detection lying around"
	zitm.des5 = "which makes all those invisible items visible"
	zitm.des6 = "again to be plundered for loot"
	zitm.des7 = "mana cost > 1"
	itemList = append(itemList, zitm) //21
	zitm.image = otherTiles[13]
	zitm.listNum = 22
	zitm.price = 125
	zitm.mana = 3
	zitm.name = "scroll of home"
	zitm.des = "teleport back to camp"
	zitm.des2 = "everyone gets that feeling sometimes, when you"
	zitm.des3 = "just want to go home. not to worry, the handy"
	zitm.des4 = "scroll of home will sort that all out in a jiffy."
	zitm.des5 = "have a quick read of the scroll, snap your fingers"
	zitm.des6 = "(or teddy paws) and you are back at camp"
	zitm.des7 = "mana cost > 3"
	itemList = append(itemList, zitm) //22
	zitm.image = otherTiles[14]
	zitm.listNum = 23
	zitm.price = 100
	zitm.mana = 2
	zitm.name = "scroll of beginning"
	zitm.des = "teleport to dungeon center"
	zitm.des2 = "being attacked by a swarm of devious"
	zitm.des3 = "dungeon critters? never fear, the scroll"
	zitm.des4 = "of beginning is here. take a quick trip"
	zitm.des5 = "back to the dungeon center and save"
	zitm.des6 = "mr snuggles from certain death"
	zitm.des7 = "mana cost > 2"
	itemList = append(itemList, zitm) //23
	zitm.image = otherTiles[15]
	zitm.listNum = 24
	zitm.price = 200
	zitm.mana = 4
	zitm.name = "scroll of inflict"
	zitm.des = "damage all enemies > +int"
	zitm.des2 = "though not someone that generally enjoys"
	zitm.des3 = "the idea of inflicting pain onto others"
	zitm.des4 = "this is an unfortunate part of mr snuggles'"
	zitm.des5 = "job and the scroll of inflict is just the thing"
	zitm.des6 = "mana cost > 4"
	zitm.des7 = "damage = intelligence"
	itemList = append(itemList, zitm) //24
	zitm.image = otherTiles[16]
	zitm.listNum = 25
	zitm.price = 250
	zitm.mana = 5
	zitm.name = "scroll of power"
	zitm.des = "max all stats for 30s"
	zitm.des2 = "ever wanted to be superman with super"
	zitm.des3 = "powers? the scroll of power does a"
	zitm.des4 = "pretty good job and maxes all your"
	zitm.des5 = "stats to allow you to feel like a super"
	zitm.des6 = "hero without the kryptonite worries"
	zitm.des7 = "mana cost > 5"
	itemList = append(itemList, zitm) //25
	//ETC
	zitm.image = otherTiles[17]
	zitm.listNum = 26
	zitm.price = 50
	zitm.mana = 0
	zitm.name = "long range scope"
	zitm.des = "bird's eye view"
	zitm.des2 = "flying above the world like an eagle"
	zitm.des3 = "is not something you will ever experience"
	zitm.des4 = "however the long range scope gives you"
	zitm.des5 = "a pretty good idea of what the dungeon looks"
	zitm.des6 = "like from above, despite not being a bird"
	zitm.des7 = "cooldown > 10s"
	itemList = append(itemList, zitm) //26
	zitm.image = otherTiles[18]
	zitm.isNoCrate = true
	zitm.listNum = 27
	zitm.price = 50
	zitm.notquick = true
	zitm.name = "tools"
	zitm.des = ""
	zitm.des2 = ""
	zitm.des3 = ""
	zitm.des4 = ""
	zitm.des5 = ""
	zitm.des6 = ""
	zitm.des7 = ""
	itemList = append(itemList, zitm) //27
	zitm.image = otherTiles[19]
	zitm.isNoCrate = false
	zitm.listNum = 28
	zitm.price = 75
	zitm.notquick = false
	zitm.art = true
	zitm.name = "gas can"
	zitm.des = "explosion chance > stacks"
	zitm.des2 = "whilst not a violent person, under the"
	zitm.des3 = "circumstances mr snuggles has had to"
	zitm.des4 = "adapt and hence learned to fashion"
	zitm.des5 = "explosive gas bombs that inflict damage on"
	zitm.des6 = "adjacent enemies. possibly not as creative"
	zitm.des7 = "as knitting, though it passes the time"
	itemList = append(itemList, zitm) //28
	zitm.image = otherTiles[20]
	zitm.isNoCrate = true
	zitm.listNum = 29
	zitm.price = 50
	zitm.art = false
	zitm.notquick = true
	zitm.name = "battery"
	zitm.des = ""
	zitm.des2 = ""
	zitm.des3 = ""
	zitm.des4 = ""
	zitm.des5 = ""
	zitm.des6 = ""
	zitm.des7 = ""
	itemList = append(itemList, zitm) //29
	zitm.image = otherTiles[21]
	zitm.isNoCrate = false
	zitm.listNum = 30
	zitm.price = 100
	zitm.name = "map"
	zitm.des = "reveals location of interest"
	zitm.des2 = "be warned, the promise of treasure"
	zitm.des3 = "has lured many dungeon adventurers"
	zitm.des4 = "to untimely deaths. chasing after"
	zitm.des5 = "loot without preparing first can be"
	zitm.des6 = "a very unwise decision."
	zitm.des7 = "can only be used at camp"
	itemList = append(itemList, zitm) //30
	zitm.image = otherTiles[22]
	zitm.listNum = 31
	zitm.price = 75
	zitm.art = true
	zitm.name = "backpack"
	zitm.des = "adds one inventory slot"
	zitm.des2 = "how any video game character is ever"
	zitm.des3 = "expected to carry as much as they do is"
	zitm.des4 = "something that has always puzzled mr"
	zitm.des5 = "snuggles. that was until he discovered"
	zitm.des6 = "the magical backpack, like carrying narnia"
	zitm.des7 = "around in a handy, portable accessory."
	itemList = append(itemList, zitm) //31
	zitm.image = otherTiles[23]
	zitm.isNoCrate = true
	zitm.listNum = 32
	zitm.price = 75
	zitm.art = false
	zitm.name = "ammo box"
	zitm.des = ""
	zitm.des2 = ""
	zitm.des3 = ""
	zitm.des4 = ""
	zitm.des5 = ""
	zitm.des6 = ""
	zitm.des7 = ""
	itemList = append(itemList, zitm) //32
	zitm.image = otherTiles[24]
	zitm.isNoCrate = false
	zitm.listNum = 33
	zitm.price = 75
	zitm.notquick = false
	zitm.name = "steroids"
	zitm.des = "strength = 5 max > 30s"
	zitm.des2 = "not normally one to toy with such serious"
	zitm.des3 = "things, under dire circumstances mr snuggles"
	zitm.des4 = "has had to forgo his virtuous nature as a"
	zitm.des5 = "means to survive the treacherous dungeon."
	zitm.des6 = "it is also a lot of fun to be very strong as"
	zitm.des7 = "enemies die a lot faster"
	itemList = append(itemList, zitm) //33
	zitm.image = otherTiles[25]
	zitm.listNum = 34
	zitm.price = 200
	zitm.art = true
	zitm.name = "medikit"
	zitm.des = "revives mr snuggles on death"
	zitm.des2 = "how does it work you may ask, the answer"
	zitm.des3 = "is no one knows. a magical device that,"
	zitm.des4 = "just in the nick of time, manages to revive"
	zitm.des5 = "poor mr snuggles and return him to full health"
	zitm.des6 = "until the next time it happens"
	zitm.des7 = "full hp > return to dungeon center"
	itemList = append(itemList, zitm) //34
	zitm.image = otherTiles[26]
	zitm.listNum = 35
	zitm.price = 150
	zitm.name = "brain"
	zitm.des = "+1 intelligence"
	zitm.des2 = "not to be confused with zombie brains"
	zitm.des3 = "mr snuggles uses only the finest rat"
	zitm.des4 = "brains that he can find in the dank,"
	zitm.des5 = "dingy dungeon to bolster his intellect"
	zitm.des6 = "and help him to cast better spells"
	zitm.des7 = "+1 int > max = 5"
	zitm.art = true
	itemList = append(itemList, zitm) //35
	zitm.image = otherTiles[27]
	zitm.listNum = 36
	zitm.price = 150
	zitm.name = "eyeball"
	zitm.des = "+1 perception"
	zitm.des2 = "as you can imagine, dungeons often have an"
	zitm.des3 = "abundance of items you generally won't find"
	zitm.des4 = "anywhere else and bat eyeballs is one of the"
	zitm.des5 = "more useful bits and bobs that mr snuggles uses"
	zitm.des6 = "to help him seek out invisible loot"
	zitm.des7 = "+1 per > max = 5"
	itemList = append(itemList, zitm) //36
	zitm.image = otherTiles[28]
	zitm.listNum = 37
	zitm.price = 150
	zitm.name = "bear trap"
	zitm.des = "leave traps behind > stacks"
	zitm.des2 = "stuck in a tight situation? then a bear"
	zitm.des3 = "trap might be the culprit so check that"
	zitm.des4 = "you are not standing in one, though it"
	zitm.des5 = "would probably be apparent from the"
	zitm.des6 = "significant pain being experienced"
	zitm.des7 = "more traps = more drops > max 5"
	itemList = append(itemList, zitm) //37
	zitm.image = otherTiles[50]
	zitm.listNum = 38
	zitm.price = 100
	zitm.name = "gold"
	zitm.des = "used for upgrades"
	zitm.art = false
	zitm.notquick = true
	zitm.des2 = "all that glitters is not gold, except gold which is."
	zitm.des3 = "mr snuggles uses the gold that he finds in the dungeon"
	zitm.des4 = "to upgrade his equipment so he can repeat the cycle"
	zitm.des5 = "of bashing crates, finding more precious items that he"
	zitm.des6 = "can upgrade to repeat the cycle of bashing more crates"
	zitm.des7 = "and so on, until you get bored of this game"
	itemList = append(itemList, zitm) //38
	zitm.image = otherTiles[51]
	zitm.listNum = 39
	zitm.price = 75
	zitm.name = "silver"
	zitm.des = "used for upgrades"
	zitm.des2 = "silver is not the stuff used for tin foil hats that"
	zitm.des3 = "protect you from the television's brainwashing waves."
	zitm.des4 = "whilst this may be misinformation, if you ever feel you"
	zitm.des5 = "may be at risk of brainswashing from your tv then google"
	zitm.des6 = "tin foil hat tv brainwashing and the wikipedia entry has"
	zitm.des7 = "some interesting facts you may want to read"
	itemList = append(itemList, zitm) //39
	zitm.image = otherTiles[52]
	zitm.listNum = 40
	zitm.price = 50
	zitm.name = "bronze"
	zitm.des = "used for upgrades"
	zitm.des2 = "bronzer is something any 80's child may remember from"
	zitm.des3 = "popular television shows where men with too much facial"
	zitm.des4 = "hair drove around in fancy cars wearing hawaiian shirts."
	zitm.des5 = "these men were generally 'bronzed' which was acheived by"
	zitm.des6 = "the application of a 'bronzer' or, as you may know it,"
	zitm.des7 = "fake tanning lotion"
	itemList = append(itemList, zitm) //40
	zitm.image = otherTiles[53]
	zitm.listNum = 41
	zitm.price = 25
	zitm.name = "lead"
	zitm.des = "used for upgrades"
	zitm.des2 = "lead is something that has always intrigued the narrator"
	zitm.des3 = "so heavy and solid, yet when you take a swiss army knife"
	zitm.des4 = "to it, it can be easily marked, quite a remarkable metal."
	zitm.des5 = "the most common place you will have seen lead would be"
	zitm.des6 = "used as fishing weights or 'sinkers'"
	zitm.des7 = ""
	itemList = append(itemList, zitm) //41
	zitm.image = otherTiles[54]
	zitm.listNum = 42
	zitm.name = "platinum"
	zitm.price = 150
	zitm.des = "used for upgrades"
	zitm.des2 = "this stuff is expensive so use it sparingly please"
	zitm.des3 = "the ultimate in upgrade material, platinum will"
	zitm.des4 = "help mr snuggles to reach his goal of conquering"
	zitm.des5 = "the nasties in the dungeon and reaching the end"
	zitm.des6 = "of this incredibly silly game about a teddy bear"
	zitm.des7 = "in a dungeon"
	itemList = append(itemList, zitm) //42
	zitm.image = otherTiles[55]
	zitm.listNum = 43
	zitm.isUnlocked = true
	zitm.name = "scrap"
	zitm.des = "used for unlocks"
	zitm.des2 = "scrap is found throughout the dungeon and is"
	zitm.des3 = "obtained by destroying crates, a tedious chore"
	zitm.des4 = "you may sometimes think, however, how else will"
	zitm.des5 = "you ever finish the game? so keep bashing"
	zitm.des6 = "crates and onto glory mr snuggles!"
	zitm.des7 = ""
	itemList = append(itemList, zitm) //43
	zitm.image = otherTiles[56]
	zitm.unique = true
	zitm.listNum = 44
	zitm.price = 50
	zitm.isUnlocked = false
	zitm.name = "watch"
	zitm.des = "slower enemies > 30s"
	zitm.notquick = false
	zitm.des2 = "if i could turn back time was a song that"
	zitm.des3 = "was popular and is somewhat related to"
	zitm.des4 = "the power of the watch. though mr snuggles"
	zitm.des5 = "cannot turn back time he is able to slow it"
	zitm.des6 = "down a bit and dungeon nasties move slower"
	zitm.des7 = "cooldown 30s"
	itemList = append(itemList, zitm) //44
	zitm.image = otherTiles[57]
	zitm.unique = false
	zitm.listNum = 45
	zitm.price = 50
	zitm.name = "shrimp"
	zitm.des = "+3 shrimp shell armor"
	zitm.des2 = "ever had a shrimp with a super tough shell"
	zitm.des3 = "and thought maybe i could use this as armor"
	zitm.des4 = "if i was a teddy bear trapped in a dungeon?"
	zitm.des5 = "probably not, though the next time you eat"
	zitm.des6 = "a tough shrimp then remember these words and"
	zitm.des7 = "try and fashion yourself some shrimp scale mail"
	itemList = append(itemList, zitm) //45
	zitm.image = otherTiles[58]
	zitm.listNum = 46
	zitm.price = 75
	zitm.name = "flask of slug pee"
	zitm.des = "move faster > 30s"
	zitm.des2 = "whilst the slug is a slow moving creature,"
	zitm.des3 = "you would be surprised to know that a"
	zitm.des4 = "little known extract from slug pee can"
	zitm.des5 = "have the most amazing effect on a teddy bear's"
	zitm.des6 = "walking speed. just a little sip and mr"
	zitm.des7 = "snuggles moves around at double pace"
	itemList = append(itemList, zitm) //46
	zitm.image = otherTiles[59]
	zitm.listNum = 47
	zitm.price = 75
	zitm.name = "pistol"
	zitm.des = "faster attack > 30s"
	zitm.des2 = "mr snuggles the game as an entity and the"
	zitm.des3 = "character himself do not condone violence in"
	zitm.des4 = "video games, hence this game is very cutesy"
	zitm.des5 = "wutsey. however sometimes it is necessary to add"
	zitm.des6 = "guns to spice things up a bit though this"
	zitm.des7 = "remains a surrealist recreational experience"
	itemList = append(itemList, zitm) //47
	zitm.image = otherTiles[60]
	zitm.listNum = 48
	zitm.price = 100
	zitm.name = "turtle"
	zitm.des = "take no damage > 15s"
	zitm.des2 = "turtles have thick shells and act as armor"
	zitm.des3 = "for their soft insides and, for this reason,"
	zitm.des4 = "they make an excellent choice for any dungeon"
	zitm.des5 = "adventurer seeking to protect himself from"
	zitm.des6 = "harm from the various dreadful creatures"
	zitm.des7 = "lurking the dungeon depths"
	itemList = append(itemList, zitm) //48
	zitm.image = otherTiles[61]
	zitm.listNum = 49
	zitm.price = 125
	zitm.art = true
	zitm.name = "sneakers"
	zitm.des = "+1 move speed > stacks"
	zitm.des2 = "there is nothing like a brisk stroll"
	zitm.des3 = "to clear one's mind and sneakers help"
	zitm.des4 = "mr snuggles move just a little faster."
	zitm.des5 = "collect more and he moves even quicker"
	zitm.des6 = "making it easier to escape the range of"
	zitm.des7 = "horrible nasty dungeon creatures"
	itemList = append(itemList, zitm) //49
	zitm.image = otherTiles[62]
	zitm.listNum = 50
	zitm.price = 50
	zitm.art = false
	zitm.name = "soda"
	zitm.des = "+1 hp & faster movement > 30s"
	zitm.des2 = "nothing like a refreshing soda to"
	zitm.des3 = "liven oneself up and mr snuggles"
	zitm.des4 = "really enjoys a refreshing drink"
	zitm.des5 = "whilst completing the arduous task"
	zitm.des6 = "of clearing the dungeon of nasty"
	zitm.des7 = "creatures and baddies"
	itemList = append(itemList, zitm) //50
	zitm.image = otherTiles[63]
	zitm.listNum = 51
	zitm.isNoCrate = true
	zitm.notquick = true
	zitm.name = "key"
	zitm.des = "store room key > unlock"
	zitm.des2 = ""
	zitm.des3 = ""
	zitm.des4 = ""
	zitm.des5 = ""
	zitm.des6 = ""
	zitm.des7 = ""
	itemList = append(itemList, zitm) //51
	zitm.image = otherTiles[64]
	zitm.listNum = 52
	zitm.price = 75
	zitm.isNoCrate = false
	zitm.art = true
	zitm.notquick = false
	zitm.name = "sunglasses"
	zitm.des = "+1 critical hit chance > stacks"
	zitm.des2 = "whilst sunglasses probably do not"
	zitm.des3 = "improve one's visual acuity in a"
	zitm.des4 = "dingy dungeon as, one would assume,"
	zitm.des5 = "everything would get darker please"
	zitm.des6 = "try and not take things so seriously"
	zitm.des7 = "this is a video game, not real life"
	itemList = append(itemList, zitm) //52
	zitm.image = otherTiles[65]
	zitm.listNum = 53
	zitm.price = 50
	zitm.art = false
	zitm.name = "ice cream"
	zitm.des = "freeze enemies > 10s"
	zitm.des2 = "the horrible sludge of melted ice"
	zitm.des3 = "cream is an excellent way of"
	zitm.des4 = "slowing down any potential enemies"
	zitm.des5 = "heading in mr snuggles direction"
	zitm.des6 = "freezing them in place giving him"
	zitm.des7 = "ample opportunity to attack"
	itemList = append(itemList, zitm) //53
	zitm.image = otherTiles[66]
	zitm.listNum = 54
	zitm.price = 100
	zitm.art = true
	zitm.name = "basketball"
	zitm.des = "projectiles bounce > stacks"
	zitm.des2 = "what could be better than recycling"
	zitm.des3 = "a weapon projectile via a bounce? well"
	zitm.des4 = "possibly recycling a projectile more"
	zitm.des5 = "than once if you collect more than one"
	zitm.des6 = "basketball. mr snuggles weapons will now"
	zitm.des7 = "bounce against the walls"
	itemList = append(itemList, zitm) //54
	zitm.image = otherTiles[67]
	zitm.listNum = 55
	zitm.price = 50
	zitm.art = false
	zitm.name = "jar of gas"
	zitm.des = "chance to inflict burn > 30s"
	zitm.des2 = "mr snuggles uses the jar of gas to"
	zitm.des3 = "douse his weapons meaning that when"
	zitm.des4 = "they impact with nasties and baddies"
	zitm.des5 = "that there is a chance that they will"
	zitm.des6 = "inflict burn which means that over a"
	zitm.des7 = "few seconds more damage is done"
	itemList = append(itemList, zitm) //55
	zitm.image = otherTiles[68]
	zitm.listNum = 56
	zitm.price = 50
	zitm.name = "jar of blood"
	zitm.des = "chance to inflict bleed > 30s"
	zitm.des2 = "the jar of blood is used to further"
	zitm.des3 = "enhance mr snuggles weapons meaning"
	zitm.des4 = "that they inflict further bleed damage"
	zitm.des5 = "over time. the nice thing, if that is the"
	zitm.des6 = "correct word, is that bleed damage stacks"
	zitm.des7 = "with more hits on the same enemy"
	itemList = append(itemList, zitm) //56
	zitm.image = otherTiles[69]
	zitm.isNoCrate = true
	zitm.listNum = 57
	zitm.price = 25
	zitm.name = "record"
	zitm.des = "unlocks new music"
	zitm.des2 = ""
	zitm.des3 = ""
	zitm.des4 = ""
	zitm.des5 = ""
	zitm.des6 = ""
	zitm.des7 = ""
	itemList = append(itemList, zitm) //57
	zitm.image = otherTiles[70]
	zitm.isNoCrate = false
	zitm.listNum = 58
	zitm.price = 75
	zitm.art = true
	zitm.name = "broccoli"
	zitm.des = "poison gas on hit > stacks"
	zitm.des2 = "smelly, smelly brocolli may be good for you"
	zitm.des3 = "though when used to make a poison gas can be"
	zitm.des4 = "quite harmful to all the dreadful foes in the"
	zitm.des5 = "dungeon, so baddies beware."
	zitm.des6 = "increased stack > increased chance of gas"
	zitm.des7 = "max 6 > rolls 1 dice > 6 = 100% chance"
	itemList = append(itemList, zitm) //58
	zitm.image = otherTiles[71]
	zitm.listNum = 59
	zitm.price = 10
	zitm.name = "drill"
	zitm.des = "single hit destroys crates"
	zitm.des2 = "at the start of every new run mr snuggles"
	zitm.des3 = "will be bashing crates repeatedly as a"
	zitm.des4 = "means of annoyance. the drill makes it much"
	zitm.des5 = "easier for him to break open crates and saves"
	zitm.des6 = "you the exertion of having to press mouse"
	zitm.des7 = "or controller buttons extra times"
	itemList = append(itemList, zitm) //59
	zitm.image = otherTiles[72]
	zitm.listNum = 60
	zitm.price = 150
	zitm.art = false
	zitm.notquick = true
	zitm.name = "cook book"
	zitm.des = "1 free unlock < 100xp "
	zitm.des2 = "the dungeon is filled with weird &"
	zitm.des3 = "wonderful things so what better place"
	zitm.des4 = "to write a cook book using all the odd"
	zitm.des5 = "things that mr snuggles finds whilst"
	zitm.des6 = "wandering the dingy corridors of these"
	zitm.des7 = "gloomy depths"
	itemList = append(itemList, zitm) //60
	zitm.image = otherTiles[73]
	zitm.listNum = 61
	zitm.price = 50
	zitm.notquick = false
	zitm.name = "ice lolly"
	zitm.des = "extinguish & immune fire > 15s"
	zitm.des2 = "nothing like a cool ice lolly on a hot"
	zitm.des3 = "summer's day or if mr snuggles is, or"
	zitm.des4 = "going to be, on fire. the coolness of"
	zitm.des5 = "the lolly really helps when the flames"
	zitm.des6 = "are quickly melting his cheap polyester "
	zitm.des7 = "fluff on their way to his stuffing"
	itemList = append(itemList, zitm) //61
	zitm.image = otherTiles[74]
	zitm.listNum = 62
	zitm.price = 50
	zitm.art = true
	zitm.name = "toilet paper"
	zitm.des = "more (s)crap drop > stacks"
	zitm.des2 = "whether this is an anagram, a pun, or"
	zitm.des3 = "merely a clever play on words is anyone's"
	zitm.des4 = "guess however the author/developer of this"
	zitm.des5 = "game thought that he was quite clever to"
	zitm.des6 = "have accidentally thought of it"
	zitm.des7 = "max 6 > rolls 1 dice > 6 = 100% chance"
	itemList = append(itemList, zitm) //62
	zitm.image = otherTiles[75]
	zitm.listNum = 63
	zitm.price = 100
	zitm.name = "garlic"
	zitm.des = "chance to heal on kill > stacks"
	zitm.des2 = "vampires are known to not like garlic"
	zitm.des3 = "very much though mr snuggles loves it."
	zitm.des4 = "when not toiling away in the dungeon he"
	zitm.des5 = "loves to make pasta sauces & garlic"
	zitm.des6 = "makes them even more delicious."
	zitm.des7 = "max 12 > rolls 2 dice > 12 = 100% chance"
	itemList = append(itemList, zitm) //63
	zitm.image = otherTiles[76]
	zitm.listNum = 64
	zitm.price = 75
	zitm.name = "tenderiser"
	zitm.des = "stun on hit > stacks"
	zitm.des2 = "one would not think that tenderisers and"
	zitm.des3 = "any other kitchen equipment would be"
	zitm.des4 = "quite so prevalent in a dungeon as they"
	zitm.des5 = "are in this video game. this leaves the"
	zitm.des6 = "player something to ponder for the evening"
	zitm.des7 = "max 6 > rolls 1 dice > 6 = 100% chance"
	itemList = append(itemList, zitm) //64
	zitm.image = otherTiles[77]
	zitm.listNum = 65
	zitm.price = 75
	zitm.name = "cleaver"
	zitm.des = "split projectile on hit > stacks"
	zitm.des2 = "one would probably, or possibly, have seen"
	zitm.des3 = "coconuts being halved using a large knife or"
	zitm.des4 = "machete. the cleaver works very much on the"
	zitm.des5 = "same prinicple, splitting the weapon into two"
	zitm.des6 = "and sending the duplicate in a new direction"
	zitm.des7 = "max 6 > rolls 1 dice > 6 = 100% chance"
	itemList = append(itemList, zitm) //65
	zitm.image = otherTiles[78]
	zitm.listNum = 66
	zitm.price = 100
	zitm.name = "bottle of death"
	zitm.des = "extra xp per kill > stacks"
	zitm.des2 = "xp is how mr snuggles unlocks the various"
	zitm.des3 = "items that he finds in the crates and then"
	zitm.des4 = "uses to help reach the end of the dungeon."
	zitm.des5 = "so he won't be complaining when he acquires"
	zitm.des6 = "this artifact increasing xp per kill"
	zitm.des7 = "max 5"
	itemList = append(itemList, zitm) //66
	zitm.image = otherTiles[92]
	zitm.listNum = 67
	zitm.price = 150
	zitm.name = "basketball sneakers"
	zitm.des = "+1 dexterity > stacks"
	zitm.des2 = "dexterity is something you may not think"
	zitm.des3 = "you need or actually see happening in the"
	zitm.des4 = "game however when you have 1 hp left and"
	zitm.des5 = "accidently stand on a spike trap that kills"
	zitm.des6 = "you then remember dexterity & dodge chance"
	zitm.des7 = "+1 dex > max = 5"
	itemList = append(itemList, zitm) //67
	zitm.image = otherTiles[91]
	zitm.listNum = 68
	zitm.name = "dumbbell"
	zitm.price = 200
	zitm.des = "+1 strength > stacks"
	zitm.des2 = "funnily enough this makes mr snuggles"
	zitm.des3 = "stronger and therefore increases attack"
	zitm.des4 = "damage meaning that nasties will require"
	zitm.des5 = "less hits to die. this will make the game"
	zitm.des6 = "easier & might be something to unlock first"
	zitm.des7 = "+1 str > max = 5"
	itemList = append(itemList, zitm) //68
	zitm.image = otherTiles[90]
	zitm.listNum = 69
	zitm.price = 150
	zitm.name = "dice"
	zitm.des = "+1 luck > stacks"
	zitm.des2 = "when christmas arrives and you only have"
	zitm.des3 = "one present under the tree and you think"
	zitm.des4 = "i really hope this magically transforms"
	zitm.des5 = "into two is exactly how luck works, extra"
	zitm.des6 = "loots drops with higher luck"
	zitm.des7 = "+1 luk > max = 5"
	itemList = append(itemList, zitm) //69
	zitm.image = otherTiles[93]
	zitm.listNum = 70
	zitm.price = 150
	zitm.name = "ring of vine"
	zitm.rectangle = rl.NewRectangle(0, 0, be3, be3)
	zitm.des = "escapes on 1 hp > +2 hp"
	zitm.des2 = "the developer cannot remember where he"
	zitm.des3 = "got this idea from though it is copied"
	zitm.des4 = "from another video game he played a long"
	zitm.des5 = "time ago and remains a good idea, when hp"
	zitm.des6 = "is low mr snuggles is rescued by a vine"
	zitm.des7 = "1 use per run"
	itemList = append(itemList, zitm) //70
	zitm.image = otherTiles[94]
	zitm.listNum = 71
	zitm.price = 125
	zitm.name = "ring of thorns"
	zitm.des = "damages enemies on player hit"
	zitm.des2 = "no one likes getting hit and neither does"
	zitm.des3 = "mr snuggles. the ring of thorns offers a"
	zitm.des4 = "form of retribution when mr snuggles loses"
	zitm.des5 = "hp damaging nearby enemies and thereby"
	zitm.des6 = "helping them to empathise"
	zitm.des7 = "any player dmg > dmg nearby enemies"
	itemList = append(itemList, zitm) //71
	zitm.image = otherTiles[95]
	zitm.listNum = 72
	zitm.price = 125
	zitm.name = "ring of twin"
	zitm.des = "fire backwards"
	zitm.des2 = "why settle for weapon projectiles in"
	zitm.des3 = "one direction when you could have two"
	zitm.des4 = "sets of projectiles being fired at the"
	zitm.des5 = "same time? the ring of twin does just"
	zitm.des6 = "that and helps to ensure that any nasty"
	zitm.des7 = "in the opposing direction also gets hit"
	itemList = append(itemList, zitm) //72
	zitm.image = otherTiles[96]
	zitm.listNum = 73
	zitm.price = 75
	zitm.art = false
	zitm.name = "quail egg"
	zitm.des = "creates tornado stuns > 30s"
	zitm.des2 = "how does a quail egg summon a"
	zitm.des3 = "tornado? mr snuggles has pondered"
	zitm.des4 = "this question many an evening in"
	zitm.des5 = "front of the camp fire and it"
	zitm.des6 = "remains one of the many unsolved"
	zitm.des7 = "mysteries of the dungeon"
	itemList = append(itemList, zitm) //73
	zitm.image = otherTiles[97]
	zitm.listNum = 74
	zitm.price = 125
	zitm.art = true
	zitm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zitm.name = "tesla coil"
	zitm.des = "electric field every 5 kills"
	zitm.des2 = "one of the more 'shocking' items"
	zitm.des3 = "found in the dungeon, excuse the pun."
	zitm.des4 = "after making a certain number of kills"
	zitm.des5 = "a field of electricity will stun and"
	zitm.des6 = "damage nearby baddies and nasties and"
	zitm.des7 = "is an excellent addition to any run"
	itemList = append(itemList, zitm) //74
	zitm.image = otherTiles[98]
	zitm.listNum = 75
	zitm.price = 100
	zitm.name = "amulet of purple rain"
	zitm.des = "damaging rain every 4 kills"
	zitm.des2 = "there used to be a musician by the"
	zitm.des3 = "name of prince after which one of"
	zitm.des4 = "his songs this item is named. his"
	zitm.des5 = "own particular name became"
	zitm.des6 = "increasingly difficult to"
	zitm.des7 = "determine & remains unclear"
	itemList = append(itemList, zitm) //75
	zitm.image = otherTiles[99]
	zitm.listNum = 76
	zitm.price = 100
	zitm.name = "amulet of disc"
	zitm.des = "damaging disc every 7 kills"
	zitm.des2 = "if you are reading this and are maybe"
	zitm.des3 = "wondering what is a disc or disk then"
	zitm.des4 = "you started playing video games a long"
	zitm.des5 = "time after i did so please don't ask"
	zitm.des6 = "silly questions & rather play the game"
	zitm.des7 = "10s duration"
	itemList = append(itemList, zitm) //76
	zitm.image = otherTiles[100]
	zitm.listNum = 77
	zitm.price = 100
	zitm.name = "belt of whipping"
	zitm.des = "inflicts bleed > stacks"
	zitm.des2 = "a rather cruel though effective use for a"
	zitm.des3 = "belt, every certain number of attacks"
	zitm.des4 = "nearby enemies will be whipped by mr"
	zitm.des5 = "snuggles belt though it remains a"
	zitm.des6 = "dastardly form of punishment"
	zitm.des7 = "more belts = more whips"
	itemList = append(itemList, zitm) //77
	zitm.image = otherTiles[101]
	zitm.listNum = 78
	zitm.price = 150
	zitm.name = "mirror"
	zitm.des = "does what it says on the box"
	zitm.des2 = "what could be better than mr snuggles?"
	zitm.des3 = "well, two mr snuggles maybe & the mirror"
	zitm.des4 = "does exactly that, making a mirror copy"
	zitm.des5 = "of mr snuggles who attacks in the opposite"
	zitm.des6 = "direction & theoretically should assist"
	zitm.des7 = "though aiming can be tricky"
	itemList = append(itemList, zitm) //78
	zitm.image = otherTiles[102]
	zitm.listNum = 79
	zitm.price = 100
	zitm.name = "toxic sludge"
	zitm.des = "trail of poison sludge "
	zitm.des2 = "a classic video game & comic book idea,"
	zitm.des3 = "the ubiquitous 'toxic sludge' did of"
	zitm.des4 = "course make an appearance in mr snuggles"
	zitm.des5 = "dungeon adventure and is likely to appear"
	zitm.des6 = "in many future video games all around the"
	zitm.des7 = "world so watch this space"
	itemList = append(itemList, zitm) //79
	zitm.image = otherTiles[103]
	zitm.listNum = 80
	zitm.price = 75
	zitm.name = "throwing knife"
	zitm.des = "auto knives > stacks"
	zitm.des2 = "classic rpg fare, what dungeon adventure"
	zitm.des3 = "is complete without throwing knives. the"
	zitm.des4 = "knives will automatically fire at interval"
	zitm.des5 = "damaging any nasties in their path, the"
	zitm.des6 = "more you collect the more knives are thrown"
	zitm.des7 = "max 8 > 8 directions"
	itemList = append(itemList, zitm) //80
	zitm.image = otherTiles[104]
	zitm.listNum = 81
	zitm.price = 50
	zitm.art = false
	zitm.name = "beetroot"
	zitm.des = "inflicts 'rain of beetroot'"
	zitm.des2 = "the lost 11th plague of the bible that"
	zitm.des3 = "no one talks about - 'rain of beetroot'."
	zitm.des4 = "the scourge of all dungeon critters this"
	zitm.des5 = "attack causes a high damage rain of"
	zitm.des6 = "taproots, the stuff of nightmares, note"
	zitm.des7 = "not to be used in soup preparation."
	itemList = append(itemList, zitm) //81
	zitm.image = otherTiles[105]
	zitm.listNum = 82
	zitm.price = 125
	zitm.art = true
	zitm.name = "magicians hat"
	zitm.des = "+1 mana > stacks"
	zitm.des2 = "using scrolls uses mana and, just like"
	zitm.des3 = "hp this is in short supply and will"
	zitm.des4 = "need to be refilled. the more mana you"
	zitm.des5 = "have the more powerful scrolls can be used"
	zitm.des6 = "hence the magicians hat is a must have item"
	zitm.des7 = "max 5 = +5 mana"
	itemList = append(itemList, zitm) //82
	zitm.image = otherTiles[106]
	zitm.listNum = 83
	zitm.price = 200
	zitm.rectangle = rl.NewRectangle(0, 0, be3, be3)
	zitm.name = "pearl"
	zitm.des = "+1 hp > stacks"
	zitm.des2 = "as in most video games, hp is a crucial"
	zitm.des3 = "element of your success or failure in"
	zitm.des4 = "mr snuggles dungeon adventure and having"
	zitm.des5 = "a higher hp max will increase your chances"
	zitm.des6 = "of success, so collect pearls"
	zitm.des7 = "max 5 = +5 hp"
	itemList = append(itemList, zitm) //83
	zitm.image = otherTiles[107]
	zitm.listNum = 84
	zitm.price = 100
	zitm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zitm.name = "candy cane"
	zitm.des = "faster attack > stacks"
	zitm.des2 = "the faster mr snuggles throws projectiles"
	zitm.des3 = "the faster that enemies die, in theory, as"
	zitm.des4 = "this is based on many factors including wind"
	zitm.des5 = "speed, trajectory, skill of game player &"
	zitm.des6 = "hit pause, however shooting faster is also cool"
	zitm.des7 = "max 8"
	itemList = append(itemList, zitm) //84
	zitm.image = otherTiles[108]
	zitm.listNum = 85
	zitm.price = 200
	zitm.name = "lightbulb"
	zitm.des = "circle of light > stacks"
	zitm.des2 = "possibly one of the more useful items in the"
	zitm.des3 = "game, the lightbulb creates a circle of light"
	zitm.des4 = "around mr snuggles and will stun any baddie or"
	zitm.des5 = "nasty that enters it, preventing mr snuggles"
	zitm.des6 = "from colliding & losing hp"
	zitm.des7 = "stuns > max 5 = larger circle"
	itemList = append(itemList, zitm) //85
	zitm.image = otherTiles[109]
	zitm.listNum = 86
	zitm.price = 75
	zitm.name = "mugging"
	zitm.des = "enemies drop scrap > stacks"
	zitm.des2 = "scrap is an essential part of the game as there is"
	zitm.des3 = "annoyingly no real save feature apart from the"
	zitm.des4 = "store room. this means that you need to keep"
	zitm.des5 = "collecting scrap, and this item helps to ensure"
	zitm.des6 = "that you get maximum scrap from kills"
	zitm.des7 = "max 6 > rolls 1 dice > 6 = 100% chance"
	itemList = append(itemList, zitm) //86
	zitm.image = otherTiles[110]
	zitm.listNum = 87
	zitm.price = 75
	zitm.name = "feather"
	zitm.des = "cushions > no spike damage"
	zitm.des2 = "personally mr snuggles is not a big fan of"
	zitm.des3 = "feathers as they remiind him of pillow"
	zitm.des4 = "stuffing which is a little too close to"
	zitm.des5 = "home with him being a teddy  bear, similar"
	zitm.des6 = "to someone handing you an intestine"
	zitm.des7 = "zero damage > spike traps & blocks"
	itemList = append(itemList, zitm) //87
	zitm.image = otherTiles[111]
	zitm.listNum = 88
	zitm.price = 100
	zitm.name = "cloak of sparks"
	zitm.des = "player hit > damaging sparks"
	zitm.des2 = "very similar to thorns, this cloak will"
	zitm.des3 = "create an aura of nearby sparks when mr"
	zitm.des4 = "snuggles takes damage. this help his"
	zitm.des5 = "attackers to empathise better with his"
	zitm.des6 = "situation which is not a bad thing"
	zitm.des7 = "10 sparks > 1 damage each"
	itemList = append(itemList, zitm) //88
	zitm.image = otherTiles[112]
	zitm.listNum = 89
	zitm.price = 100
	zitm.art = false
	zitm.name = "ladybug"
	zitm.des = "creates a ladybug turret"
	zitm.des2 = "is this is a game about fairies? no, it"
	zitm.des3 = "is not you would say, then you would ask"
	zitm.des4 = "why does it have ladybug turrets and not"
	zitm.des5 = "nuclear rocket turrets? the game developer"
	zitm.des6 = "does not condone violence so live with it"
	zitm.des7 = "single use > no timer expiration"
	itemList = append(itemList, zitm) //89
	zitm.image = otherTiles[113]
	zitm.listNum = 90
	zitm.price = 75
	zitm.art = true
	zitm.name = "mug of tea"
	zitm.des = "orbital croissants > stacks"
	zitm.des2 = "do you know what the percentage chance is"
	zitm.des3 = "being stunned by an orbiting croissant?"
	zitm.des4 = "neither do i, and i am not sure that there"
	zitm.des5 = "is a mathematical calculation that exists"
	zitm.des6 = "that would determine the probability"
	zitm.des7 = "max 2"
	itemList = append(itemList, zitm) //90
	zitm.image = otherTiles[114]
	zitm.listNum = 91
	zitm.price = 75
	zitm.name = "flamingo"
	zitm.des = "leave a flaming trail > stacks"
	zitm.des2 = "flaming-o, yet another clever play on"
	zitm.des3 = "words that leaves the gamer giggling or"
	zitm.des4 = "perhaps querying the sanity of the game"
	zitm.des5 = "developer. neither of these could be"
	zitm.des6 = "deemed as an inappropriate response"
	zitm.des7 = "+flamingos > +flames > max 5"
	itemList = append(itemList, zitm) //91
	zitm.image = otherTiles[115]
	zitm.listNum = 92
	zitm.price = 75
	zitm.name = "ninja star"
	zitm.des = "orbital shurikens > stacks"
	zitm.des2 = "there is no better accompaniment to any"
	zitm.des3 = "dungeon adventure than orbiting ninja"
	zitm.des4 = "stars, or shurikens for purists. why"
	zitm.des5 = "bother attacking when the orbiting"
	zitm.des6 = "metal discs take care of everything"
	zitm.des7 = "max 2"
	itemList = append(itemList, zitm) //92
	zitm.image = otherTiles[116]
	zitm.listNum = 93
	zitm.price = 100
	zitm.art = false
	zitm.name = "orange slice"
	zitm.des = "regenerate health > 30s"
	zitm.des2 = "refreshing & nutritious the orange"
	zitm.des3 = "slice will mean that mr snuggles hp"
	zitm.des4 = "will regenerate over time until it"
	zitm.des5 = "reaches maximum again and is a"
	zitm.des6 = "really, really, really"
	zitm.des7 = "useful item to have"
	itemList = append(itemList, zitm) //93
	zitm.image = otherTiles[117]
	zitm.listNum = 94
	zitm.price = 150
	zitm.name = "television"
	zitm.des = "pause everything > 10s"
	zitm.des2 = "in the good old days pausing TV was not"
	zitm.des3 = "really a thing, unless it was recorded on"
	zitm.des4 = "a tape. what is a tape some of the younger"
	zitm.des5 = "audience may be asking? you might be able"
	zitm.des6 = "to find it in the encyclopedia in the library"
	zitm.des7 = "if you know what either of those is"
	itemList = append(itemList, zitm) //94
	zitm.image = otherTiles[118]
	zitm.listNum = 95
	zitm.price = 125
	zitm.art = true
	zitm.name = "toaster"
	zitm.des = "shockwave in puddles"
	zitm.des2 = "not to be attempted at home - acquiring"
	zitm.des3 = "a toaster means that when mr snuggles"
	zitm.des4 = "wallks through a puddle of water an"
	zitm.des5 = "electric shockwave emanates causing"
	zitm.des6 = "stun & damage to nearby enemies"
	zitm.des7 = "damage + stun"
	itemList = append(itemList, zitm) //95
	zitm.image = otherTiles[119]
	zitm.listNum = 96
	zitm.price = 75
	zitm.art = false
	zitm.name = "lollipop"
	zitm.des = "regenerate mana > 30s"
	zitm.des2 = "run out of mana? well a lollipop is"
	zitm.des3 = "an item you are gonna wanna find asap"
	zitm.des4 = "using it will mean mana regeneration"
	zitm.des5 = "over time until mana reaches maximum"
	zitm.des6 = "which will alllow you to use more scrolls"
	zitm.des7 = "and then need more mana and so on"
	itemList = append(itemList, zitm) //96
	zitm.image = otherTiles[120]
	zitm.listNum = 97
	zitm.price = 150
	zitm.name = "honeycomb"
	zitm.des = "swarm of deadly bees > 60s"
	zitm.des2 = "bees are not generally deadly however"
	zitm.des3 = "this is a video game and these are"
	zitm.des4 = "particularly deadly bees meaning that"
	zitm.des5 = "when released any baddies that encounter"
	zitm.des6 = "them are likely to die a quick & nasty"
	zitm.des7 = "death, serves them right"
	itemList = append(itemList, zitm) //97
	zitm.image = otherTiles[121]
	zitm.listNum = 98
	zitm.price = 125
	zitm.name = "fried eggs"
	zitm.des = "chicken of fiery eggs > 60s"
	zitm.des2 = "the chicken that lays exploding eggs"
	zitm.des3 = "is not a typical addition to an rpg"
	zitm.des4 = "game however now that one has been"
	zitm.des5 = "added surely the next game you play"
	zitm.des6 = "you will ask yourself, why don't they"
	zitm.des7 = "have a chicken that lays exploding eggs"
	itemList = append(itemList, zitm) //98
	zitm.image = otherTiles[122]
	zitm.listNum = 99
	zitm.price = 75
	zitm.name = "popcorn"
	zitm.des = "creates a popcorn turret"
	zitm.des2 = "being a generally non-violent, comic,"
	zitm.des3 = "cutesy game means that compromises in"
	zitm.des4 = "terms of items have had to be made. so,"
	zitm.des5 = "instead of a deadly missile turret we"
	zitm.des6 = "have a deadly bucket of popcorn which"
	zitm.des7 = "is much more wholesome & family friendly"
	itemList = append(itemList, zitm) //99
	zitm.image = otherTiles[123]
	zitm.listNum = 100
	zitm.price = 100
	zitm.name = "bomb"
	zitm.des = "drops a bomb > 3s timer"
	zitm.des2 = "in the old days, before the internet"
	zitm.des3 = "there used to be something called a"
	zitm.des4 = "magazine and in mad magazines there"
	zitm.des5 = "was spy vs spy and these guys made"
	zitm.des6 = "use of a lot of bombs, therefore the"
	zitm.des7 = "classic bomb made an appearance"
	itemList = append(itemList, zitm) //100
	zitm.image = otherTiles[124]
	zitm.listNum = 101
	zitm.price = 75
	zitm.art = true
	zitm.name = "oven glove"
	zitm.des = "reduces risk of burn > stacks"
	zitm.des2 = "quite a simple and effective item that"
	zitm.des3 = "reduces the chance that mr snuggles will"
	zitm.des4 = "start burning when he stands on flame traps"
	zitm.des5 = "or bumps into floating flames in the dungeon"
	zitm.des6 = "so get yours today"
	zitm.des7 = "max 5 > rolls 1 dice = 83% chance of save"
	itemList = append(itemList, zitm) //101
	zitm.image = otherTiles[125]
	zitm.listNum = 102
	zitm.price = 75
	zitm.name = "noodles"
	zitm.des = "pulls in items"
	zitm.des2 = "stringy, bouncy noodles pull back into shape"
	zitm.des3 = "hence this item pulls items on the dungeon floor"
	zitm.des4 = "toward mr snuggles meaning that he doesn't"
	zitm.des5 = "have to walk as far as without them. this is"
	zitm.des6 = "particularly useful in flaming areas meaning"
	zitm.des7 = "he often doesn't need to walk through fire"
	itemList = append(itemList, zitm) //102
	zitm.image = otherTiles[126]
	zitm.listNum = 103
	zitm.price = 200
	zitm.name = "gas mask"
	zitm.des = "releases poison gas"
	zitm.des2 = "poison gas damages baddies over time, meaning"
	zitm.des3 = "that they may die without mr snuggles even"
	zitm.des4 = "being in the same room, which is not a bad"
	zitm.des5 = "thing as mr snuggles has seen too much death"
	zitm.des6 = "in his life, being such a great dungeoneer"
	zitm.des7 = "more gas masks = faster release"
	itemList = append(itemList, zitm) //103
	zitm.image = otherTiles[127]
	zitm.listNum = 104
	zitm.price = 25
	zitm.art = false
	zitm.notquick = true
	zitm.name = "teleporter crystal"
	zitm.des = "activates teleporter"
	zitm.des2 = "teleporting back & forth in the dungeon"
	zitm.des3 = "is an essential activity if you want to"
	zitm.des4 = "complete the game and without a teleporter"
	zitm.des5 = "crystal you can't so be sure to find them"
	zitm.des6 = "using switches or in crates if unlocked"
	zitm.des7 = "1 crystal = 1 teleport"
	itemList = append(itemList, zitm) //104
	zitm.image = otherTiles[139]
	zitm.listNum = 105
	zitm.isNoCrate = true
	zitm.name = "amethyst mushroom"
	zitm.des = "potion ingredient"
	zitm.des2 = "mr snuggles quite enjoys brewing potions"
	zitm.des3 = "in his spare time and they help him make"
	zitm.des4 = "his way through the dungeon much more"
	zitm.des5 = "easily than if he didn't. so, if you want"
	zitm.des6 = "mr snuggles to survive then collect mushrooms"
	zitm.des7 = "and they are also useful to scrap"
	itemList = append(itemList, zitm) //105
	zitm.image = otherTiles[140]
	zitm.listNum = 106
	zitm.isNoCrate = true
	zitm.name = "zircon mushroom"
	zitm.des = "potion ingredient"
	zitm.des2 = "mr snuggles quite enjoys brewing potions"
	zitm.des3 = "in his spare time and they help him make"
	zitm.des4 = "his way through the dungeon much more"
	zitm.des5 = "easily than if he didn't. so, if you want"
	zitm.des6 = "mr snuggles to survive then collect mushrooms"
	zitm.des7 = "and they are also useful to scrap"
	itemList = append(itemList, zitm) //106
	zitm.image = otherTiles[141]
	zitm.listNum = 107
	zitm.isNoCrate = true
	zitm.name = "topaz mushroom"
	zitm.des = "potion ingredient"
	zitm.des2 = "mr snuggles quite enjoys brewing potions"
	zitm.des3 = "in his spare time and they help him make"
	zitm.des4 = "his way through the dungeon much more"
	zitm.des5 = "easily than if he didn't. so, if you want"
	zitm.des6 = "mr snuggles to survive then collect mushrooms"
	zitm.des7 = "and they are also useful to scrap"
	itemList = append(itemList, zitm) //107
	zitm.image = otherTiles[142]
	zitm.listNum = 108
	zitm.isNoCrate = true
	zitm.name = "rubelite mushroom"
	zitm.des = "potion ingredient"
	zitm.des2 = "mr snuggles quite enjoys brewing potions"
	zitm.des3 = "in his spare time and they help him make"
	zitm.des4 = "his way through the dungeon much more"
	zitm.des5 = "easily than if he didn't. so, if you want"
	zitm.des6 = "mr snuggles to survive then collect mushrooms"
	zitm.des7 = "and they are also useful to scrap"
	itemList = append(itemList, zitm) //108
	zitm.image = otherTiles[143]
	zitm.listNum = 109
	zitm.isNoCrate = true
	zitm.name = "jade mushroom"
	zitm.des = "potion ingredient"
	zitm.des2 = "mr snuggles quite enjoys brewing potions"
	zitm.des3 = "in his spare time and they help him make"
	zitm.des4 = "his way through the dungeon much more"
	zitm.des5 = "easily than if he didn't. so, if you want"
	zitm.des6 = "mr snuggles to survive then collect mushrooms"
	zitm.des7 = "and they are also useful to scrap"
	itemList = append(itemList, zitm) //109
	zitm.image = otherTiles[144]
	zitm.listNum = 110
	zitm.isNoCrate = true
	zitm.name = "larimar mushroom"
	zitm.des = "potion ingredient"
	zitm.des2 = "mr snuggles quite enjoys brewing potions"
	zitm.des3 = "in his spare time and they help him make"
	zitm.des4 = "his way through the dungeon much more"
	zitm.des5 = "easily than if he didn't. so, if you want"
	zitm.des6 = "mr snuggles to survive then collect mushrooms"
	zitm.des7 = "and they are also useful to scrap"
	itemList = append(itemList, zitm) //110
	zitm.image = otherTiles[145]
	zitm.listNum = 111
	zitm.isNoCrate = true
	zitm.name = "scroll paper"
	zitm.des = "scroll component"
	zitm.des2 = "not to be confused with toilet paper, this"
	zitm.des3 = "items allows mr snuggles to craft scrolls"
	zitm.des4 = "once he has unlocked the appropriate"
	zitm.des5 = "structure at camp. scrolls have a variety"
	zitm.des6 = "of different uses & can be the difference"
	zitm.des7 = "between mr snuggles surviving or not"
	itemList = append(itemList, zitm) //111
	zitm.image = otherTiles[146]
	zitm.listNum = 112
	zitm.isNoCrate = true
	zitm.name = "scroll ink"
	zitm.des = "scroll component"
	zitm.des2 = "not to be confused with snot, scroll ink"
	zitm.des3 = "allows mr snuggles to craft scrolls"
	zitm.des4 = "once he has unlocked the appropriate"
	zitm.des5 = "structure at camp. scrolls have a variety"
	zitm.des6 = "of different uses & can be the difference"
	zitm.des7 = "between mr snuggles surviving or not"
	itemList = append(itemList, zitm) //112
	zitm.image = animation[175].rectangle
	zitm.listNum = 113
	zitm.price = 100
	zitm.isNoCrate = false
	zitm.art = true
	zitm.name = "map exit pin"
	zitm.des = "marks exits room in minimap"
	zitm.des2 = "tired of wandering back & forth looking"
	zitm.des3 = "for the exit stairs? the handy map exit"
	zitm.des4 = "pin is here to help and will mark the"
	zitm.des5 = "appropriate room on the minimap that"
	zitm.des6 = "has the exit. this saves you time & allows"
	zitm.des7 = "you to 'speed run' more easily"
	itemList = append(itemList, zitm) //113
	zitm.image = animation[176].rectangle
	zitm.listNum = 114
	zitm.price = 100
	zitm.name = "map chest pin"
	zitm.des = "marks chest room in minimap"
	zitm.des2 = "chests hold items & any items placed in"
	zitm.des3 = "chests will be placed in the store room"
	zitm.des4 = "if it is unlocked at the end of the level."
	zitm.des5 = "collecting items for future runs is an"
	zitm.des6 = "essential tactic to complete the game"
	zitm.des7 = "as it is pretty darn difficult"
	itemList = append(itemList, zitm) //114
	zitm.image = otherTiles[182]
	zitm.unique = true
	zitm.listNum = 115
	zitm.price = 75
	zitm.art = false
	zitm.notquick = false
	zitm.mana = 0
	zitm.name = "psychedelics"
	zitm.des = "colorize the world > 60s"
	zitm.des2 = "why is everything black, white & grey"
	zitm.des3 = "you may ask yourself when looking at"
	zitm.des4 = "the background scenery in the dungeon."
	zitm.des5 = "well, no need to worry any longer as"
	zitm.des6 = "this item helps you see rainbows"
	zitm.des7 = "cooldown > 60s"
	itemList = append(itemList, zitm) //115
	zitm.image = otherTiles[183]
	zitm.listNum = 116
	zitm.price = 150
	zitm.mana = 0
	zitm.name = "boots"
	zitm.des = "no floor trap damage > 30s"
	zitm.des2 = "how many times has mr snuggles died"
	zitm.des3 = "by standing on a floor trap that you"
	zitm.des4 = "didn't see as you were rushing through"
	zitm.des5 = "the dungeon? probably a lot more than you"
	zitm.des6 = "realise & boots really help a lot"
	zitm.des7 = "cooldown > 60s"
	itemList = append(itemList, zitm) //116
	zitm.image = otherTiles[184]
	zitm.listNum = 117
	zitm.price = 125
	zitm.mana = 0
	zitm.name = "fart gas"
	zitm.des = "flaming fart > 30s"
	zitm.des2 = "is this too crude? the short answer is"
	zitm.des3 = "yes it is, however what better way to"
	zitm.des4 = "generate cheap laughs than the inclusion"
	zitm.des5 = "of an auto fart gas fireball cannon? i"
	zitm.des6 = "don't think there is a better way"
	zitm.des7 = "cooldown > 90s"
	itemList = append(itemList, zitm) //117
	zitm.image = otherTiles[186]
	zitm.listNum = 118
	zitm.price = 50
	zitm.mana = 0
	zitm.name = "salt"
	zitm.des = "prevents freeze > 30s"
	zitm.des2 = "did you know that salt helps to prevent"
	zitm.des3 = "freezing? well, if you didn't then now"
	zitm.des4 = "you do and this item will be particularly"
	zitm.des5 = "useful in the later stages of the game as"
	zitm.des6 = "there are some horrible ice robots"
	zitm.des7 = "cooldown > 90s"
	itemList = append(itemList, zitm) //118
	zitm.image = otherTiles[187]
	zitm.unique = false
	zitm.art = true
	zitm.listNum = 119
	zitm.price = 75
	zitm.mana = 0
	zitm.name = "umbrella"
	zitm.des = "no puddle slow down & no damp"
	zitm.des2 = "very much a yin & yang item, if you are"
	zitm.des3 = "on fire and step in a puddle then the"
	zitm.des4 = "flame is extinguished unless of course"
	zitm.des5 = "you have an umbrella. so, whilst, there"
	zitm.des6 = "is no slowdown in puddles anymore there"
	zitm.des7 = "is also a higher burn risk"
	itemList = append(itemList, zitm) //119
	zitm.image = otherTiles[188]
	zitm.listNum = 120
	zitm.price = 125
	zitm.mana = 0
	zitm.name = "weapon case"
	zitm.des = "unlocks backpack weapon slot"
	zitm.des2 = "carrying more weapons allows"
	zitm.des3 = "mr snuggles to better mix and"
	zitm.des4 = "match his attacks based on the"
	zitm.des5 = "situation and a weapon case"
	zitm.des6 = "unlocks a slot to store a weapon"
	zitm.des7 = "in the backpack"
	itemList = append(itemList, zitm) //120
	zitm.image = otherTiles[197]
	zitm.art = false
	zitm.listNum = 121
	zitm.price = 1000
	zitm.mana = 0
	zitm.name = "xp update"
	zitm.des = "large quantity of xp added"
	zitm.des2 = "the xp update is a great item"
	zitm.des3 = "to have when you want to unlock"
	zitm.des4 = "a lot of things all at once to"
	zitm.des5 = "make things a little easier &"
	zitm.des6 = "gives mr snuggles a big chunk of"
	zitm.des7 = "xp to use in the book"
	itemList = append(itemList, zitm) //121
	zitm.image = otherTiles[200]
	zitm.isNoCrate = true
	zitm.art = true
	zitm.listNum = 122
	zitm.price = 0
	zitm.mana = 0
	zitm.name = "ice crystal"
	zitm.des = "freezing ring every 5s"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "boss item > not found in crates"
	itemList = append(itemList, zitm) //122
	zitm.image = otherTiles[202]
	zitm.listNum = 123
	zitm.price = 0
	zitm.mana = 0
	zitm.name = "mr frisbee's frisbee"
	zitm.des = "fires frisbees every 7s"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "boss item > not found in crates"
	itemList = append(itemList, zitm) //123
	zitm.image = otherTiles[203]
	zitm.listNum = 124
	zitm.price = 0
	zitm.mana = 0
	zitm.name = "spinna"
	zitm.des = "damaging spin every 7s"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "boss item > not found in crates"
	itemList = append(itemList, zitm) //124
	zitm.image = otherTiles[204]
	zitm.listNum = 125
	zitm.price = 0
	zitm.mana = 0
	zitm.name = "space helmet"
	zitm.des = "book items 25xp less > stacks"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "max 4 = 100xp less cost > min 10xp"
	itemList = append(itemList, zitm) //125
	zitm.image = otherTiles[205]
	zitm.listNum = 126
	zitm.price = 0
	zitm.mana = 0
	zitm.name = "pyroball"
	zitm.des = "fireballs every 7s"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "boss item > not found in crates"
	itemList = append(itemList, zitm) //126
	zitm.image = otherTiles[206]
	zitm.listNum = 127
	zitm.price = 0
	zitm.mana = 0
	zitm.name = "zombie head"
	zitm.des = "revive from death twice > -1 hp max"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "boss item > not found in crates"
	itemList = append(itemList, zitm) //127
	zitm.image = otherTiles[207]
	zitm.listNum = 128
	zitm.price = 0
	zitm.mana = 0
	zitm.name = "batty"
	zitm.des = "a bat companion > +1 hp"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "boss item > not found in crates"
	itemList = append(itemList, zitm) //128
	zitm.image = otherTiles[150]
	zitm.listNum = 129
	zitm.price = 0
	zitm.mana = 0
	zitm.name = "landmine"
	zitm.des = "drops a landmine every 7s"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "boss item > not found in crates"
	itemList = append(itemList, zitm) //129
	zitm.image = otherTiles[208]
	zitm.listNum = 130
	zitm.price = 0
	zitm.mana = 0
	zitm.name = "rollo"
	zitm.des = "rolling companion > +1 hp"
	zitm.des2 = "boss items are a great addition to"
	zitm.des3 = "any rpg / roguelike adventure game"
	zitm.des4 = "that motivates the player to kill"
	zitm.des5 = "all the bosses & discover what"
	zitm.des6 = "items they drop so keep gaming"
	zitm.des7 = "boss item > not found in crates"
	itemList = append(itemList, zitm) //130

	//INVIS ITEMS LIST
	invisItm = append(invisItm, itemList[30])
	invisItm = append(invisItm, itemList[115])
	invisItm = append(invisItm, itemList[60])
	invisItm = append(invisItm, itemList[67])
	invisItm = append(invisItm, itemList[68])
	invisItm = append(invisItm, itemList[69])
	invisItm = append(invisItm, itemList[15])
	invisItm = append(invisItm, itemList[12])
	invisItm = append(invisItm, itemList[9])
	invisItm = append(invisItm, itemList[6])
	invisItm = append(invisItm, itemList[3])
	invisItm = append(invisItm, itemList[0])
	invisItm = append(invisItm, itemList[19])
	invisItm = append(invisItm, itemList[20])
	invisItm = append(invisItm, itemList[22])
	invisItm = append(invisItm, itemList[35])
	invisItm = append(invisItm, itemList[36])
	invisItm = append(invisItm, itemList[121])
	invisItm = append(invisItm, itemList[63])
	invisItm = append(invisItm, itemList[84])
	invisItm = append(invisItm, itemList[85])
	invisItm = append(invisItm, itemList[74])
	invisItm = append(invisItm, itemList[75])
	invisItm = append(invisItm, itemList[76])
	invisItm = append(invisItm, itemList[78])
	invisItm = append(invisItm, itemList[83])
	invisItm = append(invisItm, itemList[90])
	invisItm = append(invisItm, itemList[116])
	invisItm = append(invisItm, itemList[117])
	invisItm = append(invisItm, itemList[118])
	invisItm = append(invisItm, itemList[119])
	invisItm = append(invisItm, itemList[120])

	for i := 0; i < len(itemList); i++ {
		if !itemList[i].isNoCrate {
			crateItmLen++
		}
	}

	upunlocks()

}

func makeplayer() { //MARK:MAKE PLAYER

	siz := b - (b / 4)
	player.weaponMax = 4
	player.center = currentPosition
	player.rectangle = rl.NewRectangle(player.center.X-siz/2, player.center.Y-siz/2, siz, siz)
	player.collisionRectangle = player.rectangle
	player.collisionRectangle.X += 4
	player.collisionRectangle.Width -= 8
	player.caRectangle = player.rectangle
	player.caRectangle.X -= b / 2
	player.caRectangle.Y -= b / 2
	player.caRectangle.Width += b
	player.caRectangle.Height += b
	player.perceptionRectangle = player.caRectangle
	player.perceptionRectangle.X -= b / 2
	player.perceptionRectangle.Y -= b / 2
	player.perceptionRectangle.Width += b
	player.perceptionRectangle.Height += b
	player.speed = 8
	player.speed2 = player.speed
	player.speedMax = 12
	player.hpMax = 7
	player.hp = player.hpMax
	prevplayHP = player.hp
	player.manaMax = 3
	player.mana = player.manaMax
	zanim := Animation{}
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(0, 118, 32, 32)
	player.anim = append(player.anim, zanim) //0 IDLE R
	zanim.rectangle = rl.NewRectangle(224, 118, 32, 32)
	zanim.x = zanim.rectangle.X
	player.anim = append(player.anim, zanim) //1 IDLE L
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(256, 118, 32, 32)
	zanim.x = zanim.rectangle.X
	player.anim = append(player.anim, zanim) //2 RUN R
	zanim.rectangle = rl.NewRectangle(608, 118, 32, 32)
	zanim.x = zanim.rectangle.X
	player.anim = append(player.anim, zanim) //3 RUN L
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(640, 118, 32, 32)
	zanim.x = zanim.rectangle.X
	player.anim = append(player.anim, zanim) //4 RUN U
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(768, 118, 32, 32)
	zanim.x = zanim.rectangle.X
	player.anim = append(player.anim, zanim) //5 ATK R
	zanim.rectangle = rl.NewRectangle(1120, 118, 32, 32)
	zanim.x = zanim.rectangle.X
	player.anim = append(player.anim, zanim) //6 ATK L
	zanim.rectangle = rl.NewRectangle(1152, 118, 32, 32)
	zanim.x = zanim.rectangle.X
	player.anim = append(player.anim, zanim) //7 PUSH R
	zanim.rectangle = rl.NewRectangle(1504, 118, 32, 32)
	zanim.x = zanim.rectangle.X
	player.anim = append(player.anim, zanim) //8 PUSH L
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(0, 85, 32, 32)
	zanim.x = zanim.rectangle.X
	player.anim = append(player.anim, zanim) //9 JUMP R
	zanim.rectangle = rl.NewRectangle(480, 85, 32, 32)
	zanim.x = zanim.rectangle.X
	player.anim = append(player.anim, zanim) //9 JUMP L
	for i := 0; i < 4; i++ {
		player.quik = append(player.quik, Item{})
	}
	sizInvn := 18
	for i := 0; i < sizInvn; i++ {
		player.inventory = append(player.inventory, Item{})
	}

	stats.dexterity = 1
	stats.intelligence = 1
	stats.luck = 1
	stats.perception = 1
	stats.strength = 1
	stats.dexterity2 = stats.dexterity
	stats.intelligence2 = stats.intelligence
	stats.luck2 = stats.luck
	stats.perception2 = stats.perception
	stats.strength2 = stats.strength
	stats.critical2 = 6

	//BASE PLAYER
	player2 = player
	player2.rectangle.X -= b / 4
	player2.rectangle.Y -= b / 4
	player2.rectangle.Width += b / 2
	player2.rectangle.Height += b / 2
	player2.collisionRectangle = player2.rectangle
	player2.collisionRectangle.X += 4
	player2.collisionRectangle.Width -= 8
	player2.caRectangle = player2.rectangle
	player2.caRectangle.X -= b / 2
	player2.caRectangle.Y -= b / 2

	//BOSS PLAYER
	player3 = player
	player3.rectangle.X -= b / 4
	player3.rectangle.Y -= b / 4
	player3.rectangle.Width += b / 2
	player3.rectangle.Height += b / 2
	player3.collisionRectangle = player3.rectangle
	player3.collisionRectangle.X += 4
	player3.collisionRectangle.Width -= 8
	player3.caRectangle = player3.rectangle
	player3.caRectangle.X -= b / 2
	player3.caRectangle.Y -= b / 2

	player.weapon = weapons[0]

}
func makeplProjSpecial(weapNum, spec1or2 int) { //MARK:MAKE PLAYER PROJ SPECIAL
	/*
		1 LIGHTNING
		2 ARROWS
		3 FIREWORKS
		4 TURRET
		5 BOMB
		6 ROCKET
		7 ATTACK SPEED
		8 POTION
		9 DOUBLE XP
		10 RING OF FIRE
		11 SLUDGE GEYSER
	*/

	num := 0
	if weapNum == 1 {
		if spec1or2 == 1 {
			num = player.weapon.special
		} else if spec1or2 == 2 {
			num = player.weapon.special2
		}
	} else if weapNum == 2 {
		if spec1or2 == 1 {
			num = player.weapon2.special
		} else if spec1or2 == 2 {
			num = player.weapon2.special2
		}
	}

	switch num {
	case 6: //ROCKET
		if len(levels[levNum].enemies) > 1 {
			rl.PlaySound(audfx[111])
			siz := b
			spd := float32(7)
			zproj := Weapon{}
			zproj.name = "rocket"
			zproj.center = player.center
			zproj.rec = rl.NewRectangle(zproj.center.X-siz/2, zproj.center.Y-siz/2, siz, siz)
			zproj.crec = zproj.rec
			zproj.speed = spd
			zproj.image = otherTiles[211]
			zproj.col = rl.White
			zproj.fade = 1
			choose := RandInt(0, len(levels[levNum].enemies))
			zproj.rotation = AngleBetweenTwoPoints(player.center, levels[levNum].enemies[choose].cnt) + 90
			xdiff := AbsDiff(player.center.X, levels[levNum].enemies[choose].cnt.X)
			ydiff := AbsDiff(player.center.Y, levels[levNum].enemies[choose].cnt.Y)
			if xdiff > ydiff {
				zproj.dirX = zproj.speed
				zproj.dirY = ydiff / (xdiff / zproj.dirX)
			} else {
				zproj.dirY = zproj.speed
				zproj.dirX = xdiff / (ydiff / zproj.dirY)
			}
			if player.center.X > levels[levNum].enemies[choose].cnt.X {
				zproj.dirX = -zproj.dirX
			}
			if player.center.Y > levels[levNum].enemies[choose].cnt.Y {
				zproj.dirY = -zproj.dirY
			}
			zproj.rec2 = animation[201].rectangle
			zproj.rec3 = zproj.rec
			zproj.rec3.X -= zproj.rec3.Width / 4
			zproj.rec3.Y -= zproj.rec3.Width / 4
			zproj.rec3.Width += zproj.rec3.Width / 2
			zproj.rec3.Height += zproj.rec3.Height / 2
			zproj.rec3.X -= 4 * zproj.dirX
			zproj.rec3.Y -= 4 * zproj.dirY
			playerProjectiles = append(playerProjectiles, zproj)
		}
	case 2: //ARROWS
		rl.PlaySound(audfx[108])
		siz := b / 2
		spd := float32(10)
		zproj := Weapon{}
		zproj.center = player.center
		zproj.rec = rl.NewRectangle(zproj.center.X-siz/2, zproj.center.Y-siz/2, siz, siz)
		zproj.speed = spd
		zproj.image = otherTiles[209]
		zproj.col = rl.White
		zproj.fade = 1
		zproj.damage = 1
		origRec := zproj.rec
		side := RandInt(1, 5)
		switch side {
		case 1: //UP
			zproj.dirY = -zproj.speed
			zproj.rotation = -45
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.rec.X += siz
			cntr := makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.X += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.X += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.X += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec = origRec
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
		case 2: //RIGHT
			zproj.dirX = zproj.speed
			zproj.rotation = 45
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.rec.Y += siz
			cntr := makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.Y += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.Y += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.Y += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec = origRec
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
		case 3: //DOWN
			zproj.dirY = +zproj.speed
			zproj.rotation = 135
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.rec.X += siz
			cntr := makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.X += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.X += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.X += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec = origRec
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.X -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
		case 4: //LEFT
			zproj.dirX = -zproj.speed
			zproj.rotation = 225
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.rec.Y += siz
			cntr := makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.Y += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.Y += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.Y += siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec = origRec
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
			zproj.rec.Y -= siz
			cntr = makecnt(zproj.rec)
			if checkV2inRooms(cntr) {
				playerProjectiles = append(playerProjectiles, zproj)
			}
		}
	}
}
func makeplproj(num int) { //MARK:MAKE PLAYER PROJ

	weapName := ""
	if num == 1 {
		weapName = player.weapon.name
	} else {
		weapName = player.weapon2.name
	}

	zproj := player.weapon
	if num == 2 {
		zproj = player.weapon2
	}
	if num == 1 {
		if player.weapon.special == 1 || player.weapon.special2 == 1 {
			if Roll6() > 4 {
				zproj.isLightning = true
			}
		}
		if player.weapon.special == 3 || player.weapon.special2 == 3 {
			zproj.isFirework = true
		}
		if player.weapon.special == 4 || player.weapon.special2 == 4 {
			zproj.isTurret = true
		}
		if player.weapon.special == 5 || player.weapon.special2 == 5 {
			zproj.isBomb = true
		}
		if player.weapon.special == 8 || player.weapon.special2 == 8 {
			zproj.isPotion = true
		}
		if player.weapon.special == 9 || player.weapon.special2 == 9 {
			zproj.isXp = true
		}
		if player.weapon.special == 10 || player.weapon.special2 == 10 {
			zproj.isRingOfFire = true
		}
		if player.weapon.special == 11 || player.weapon.special2 == 11 {
			zproj.isSludgeGeyser = true
		}
	} else if num == 2 {
		if player.weapon2.special == 1 || player.weapon2.special2 == 1 {
			if Roll6() > 4 {
				zproj.isLightning = true
			}
		}
		if player.weapon2.special == 3 || player.weapon2.special2 == 3 {
			zproj.isFirework = true
		}
		if player.weapon2.special == 4 || player.weapon2.special2 == 4 {
			zproj.isTurret = true
		}
		if player.weapon2.special == 5 || player.weapon2.special2 == 5 {
			zproj.isBomb = true
		}
		if player.weapon2.special == 8 || player.weapon2.special2 == 8 {
			zproj.isPotion = true
		}
		if player.weapon2.special == 9 || player.weapon2.special2 == 9 {
			zproj.isXp = true
		}
		if player.weapon2.special == 10 || player.weapon2.special2 == 10 {
			zproj.isRingOfFire = true
		}
		if player.weapon2.special == 11 || player.weapon2.special2 == 11 {
			zproj.isSludgeGeyser = true
		}
	}
	xdiff := AbsDiff(atkCNT.X, atkV2.X)
	ydiff := AbsDiff(atkCNT.Y, atkV2.Y)
	if xdiff > ydiff {
		zproj.dirX = zproj.speed
		zproj.dirY = ydiff / (xdiff / zproj.dirX)
	} else {
		zproj.dirY = zproj.speed
		zproj.dirX = xdiff / (ydiff / zproj.dirY)
	}
	if atkCNT.X > atkV2.X {
		zproj.dirX = -zproj.dirX
	}
	if atkCNT.Y > atkV2.Y {
		zproj.dirY = -zproj.dirY
	}
	zproj.rec = rl.NewRectangle(atkCNT.X-zproj.rec.Width/2, atkCNT.Y-zproj.rec.Height/2, zproj.rec.Width, zproj.rec.Height)
	zproj.crec = zproj.rec
	zproj.bounce += basketballnum

	//MAKE PROJ ORIG
	switch weapName {
	case "guitar":
		zproj.image = otherTiles[175]
		zproj.rotation = AngleBetweenTwoPoints(atkCNT, atkV2)
		if player.direction {
			zproj.rotation += 180
		}
		zproj.rec.X -= 2
		zproj.rec.Y -= 2
		zproj.rec.Width += 4
		zproj.rec.Height += 4
		playerProjectiles = append(playerProjectiles, zproj)

		zproj2 := zproj
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			playerProjectiles = append(playerProjectiles, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			playerProjectiles = append(playerProjectiles, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			proj2 := zproj
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			playerProjectiles = append(playerProjectiles, zproj)
			proj3 := zproj
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			playerProjectiles = append(playerProjectiles, zproj)
			zproj = proj3
			zproj.dirX *= -1
			zproj.dirY *= -1
			playerProjectiles = append(playerProjectiles, zproj)
			proj3 = zproj
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			playerProjectiles = append(playerProjectiles, zproj)
			zproj = proj2
			zproj.dirX *= -1
			zproj.dirY *= -1
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.rec.X += zproj.dirX * 4
			zproj.rec.Y += zproj.dirY * 4
			playerProjectiles = append(playerProjectiles, zproj)
		}

		zproj = zproj2
		zproj.rec.X += zproj.dirX * 4
		zproj.rec.Y += zproj.dirY * 4
		playerProjectiles = append(playerProjectiles, zproj)
		zproj.rec.X += zproj.dirX * 4
		zproj.rec.Y += zproj.dirY * 4
		playerProjectiles = append(playerProjectiles, zproj)
		zproj.rec.X += zproj.dirX * 4
		zproj.rec.Y += zproj.dirY * 4
		playerProjectiles = append(playerProjectiles, zproj)
	case "fork":
		zproj.rec.X -= 4
		zproj.rec.Y -= 4
		zproj.rec.Width += 8
		zproj.rec.Height += 8
		zproj.rotation = AngleBetweenTwoPoints(atkCNT, atkV2) + 45
		playerProjectiles = append(playerProjectiles, zproj)
		zprojORIG := zproj
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			zproj.rotation = MirrorAngle(zproj.rotation) + 90
			playerProjectiles = append(playerProjectiles, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X -= zproj.rec.Width / 2
			} else {
				zproj.rec.Y -= zproj.rec.Width / 2
			}
			playerProjectiles = append(playerProjectiles, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X += zproj.rec.Width
			} else {
				zproj.rec.Y += zproj.rec.Width
			}
			playerProjectiles = append(playerProjectiles, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X -= zproj.rec.Width / 2
			} else {
				zproj.rec.Y -= zproj.rec.Width / 2
			}
			playerProjectiles = append(playerProjectiles, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X += zproj.rec.Width
			} else {
				zproj.rec.Y += zproj.rec.Width
			}
			playerProjectiles = append(playerProjectiles, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			zproj.rotation = MirrorAngle(zproj.rotation) + 90
			playerProjectiles = append(playerProjectiles, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X -= zproj.rec.Width / 2
			} else {
				zproj.rec.Y -= zproj.rec.Width / 2
			}
			playerProjectiles = append(playerProjectiles, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X += zproj.rec.Width
			} else {
				zproj.rec.Y += zproj.rec.Width
			}
			playerProjectiles = append(playerProjectiles, zproj)

			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X -= zproj.rec.Width / 2
			} else {
				zproj.rec.Y -= zproj.rec.Width / 2
			}
			playerProjectiles = append(playerProjectiles, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X += zproj.rec.Width
			} else {
				zproj.rec.Y += zproj.rec.Width
			}
			playerProjectiles = append(playerProjectiles, zproj)

			zproj = zprojORIG
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X -= zproj.rec.Width / 2
			} else {
				zproj.rec.Y -= zproj.rec.Width / 2
			}
			playerProjectiles = append(playerProjectiles, zproj)
			if Abs(zproj.dirY) > Abs(zproj.dirX) {
				zproj.rec.X += zproj.rec.Width
			} else {
				zproj.rec.Y += zproj.rec.Width
			}
			playerProjectiles = append(playerProjectiles, zproj)
		}
		zproj = zprojORIG
		if Abs(zproj.dirY) > Abs(zproj.dirX) {
			zproj.rec.X -= zproj.rec.Width / 2
		} else {
			zproj.rec.Y -= zproj.rec.Width / 2
		}
		playerProjectiles = append(playerProjectiles, zproj)
		if Abs(zproj.dirY) > Abs(zproj.dirX) {
			zproj.rec.X += zproj.rec.Width
		} else {
			zproj.rec.Y += zproj.rec.Width
		}
		playerProjectiles = append(playerProjectiles, zproj)
	case "pineapple":
		zproj.bounce += 3
		zproj.rec.X -= 4
		zproj.rec.Y -= 4
		zproj.rec.Width += 8
		zproj.rec.Height += 8
		zproj.image = otherTiles[169]
		playerProjectiles = append(playerProjectiles, zproj)
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			playerProjectiles = append(playerProjectiles, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			playerProjectiles = append(playerProjectiles, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			proj2 := zproj
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			playerProjectiles = append(playerProjectiles, zproj)
			zproj = proj2
			zproj.dirX *= -1
			zproj.dirY *= -1
			playerProjectiles = append(playerProjectiles, zproj)
		}
	case "mustard":
		zproj.rec.X -= 4
		zproj.rec.Y -= 4
		zproj.rec.Width += 8
		zproj.rec.Height += 8
		zproj.image = splat[RandInt(0, len(splat))]
		playerProjectiles = append(playerProjectiles, zproj)
		zprojORIG := zproj
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			zproj.rotation = -zproj.rotation
			playerProjectiles = append(playerProjectiles, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			zproj.rotation = -zproj.rotation
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
			zproj = zprojORIG
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
		}
		zproj = zprojORIG
		diff := RandF32(-4, 4)
		zproj.rec.X -= diff
		zproj.rec.Y -= diff
		zproj.rec.Width += diff * 2
		zproj.rec.Height += diff * 2
		zproj.dirX += RandF32(-2, 2)
		zproj.dirY += RandF32(-2, 2)
		zproj.image = splat[RandInt(0, len(splat))]
		playerProjectiles = append(playerProjectiles, zproj)
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			zproj.rotation = -zproj.rotation
			playerProjectiles = append(playerProjectiles, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			zproj.rotation = -zproj.rotation
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
			zproj = zprojORIG
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
		}
		zproj = zprojORIG
		diff = RandF32(-4, 4)
		zproj.rec.X -= diff
		zproj.rec.Y -= diff
		zproj.rec.Width += diff * 2
		zproj.rec.Height += diff * 2
		zproj.dirX += RandF32(-2, 2)
		zproj.dirY += RandF32(-2, 2)
		zproj.image = splat[RandInt(0, len(splat))]
		playerProjectiles = append(playerProjectiles, zproj)
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			zproj.rotation = -zproj.rotation
			playerProjectiles = append(playerProjectiles, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			zproj.rotation = -zproj.rotation
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
			zproj = zprojORIG
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
		}
	case "rubber duck":
		zproj.rec.X -= 4
		zproj.rec.Y -= 4
		zproj.rec.Width += 8
		zproj.rec.Height += 8
		zproj.bounce += 3
		playerProjectiles = append(playerProjectiles, zproj)
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			playerProjectiles = append(playerProjectiles, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			playerProjectiles = append(playerProjectiles, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj2 := zproj
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			playerProjectiles = append(playerProjectiles, zproj)
			zproj = zproj2
			zproj.dirX *= -1
			zproj.dirY *= -1
			playerProjectiles = append(playerProjectiles, zproj)
		}
	case "window cleaner":
		zproj.image = animation[177].rectangle
		playerProjectiles = append(playerProjectiles, zproj)

		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			playerProjectiles = append(playerProjectiles, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			playerProjectiles = append(playerProjectiles, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj2 := zproj
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			playerProjectiles = append(playerProjectiles, zproj)
			zproj = zproj2
			zproj.dirX *= -1
			zproj.dirY *= -1
			playerProjectiles = append(playerProjectiles, zproj)
		}
	case "bunch of carrots":
		zproj.image = otherTiles[155]
		zproj.rec.X -= 2
		zproj.rec.Y -= 2
		zproj.rec.Width += 4
		zproj.rec.Height += 4
		zproj.rotation = AngleBetweenTwoPoints(atkCNT, atkV2) - 90
		playerProjectiles = append(playerProjectiles, zproj)
		zprojORIG := zproj
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			zproj.rotation = -zproj.rotation
			playerProjectiles = append(playerProjectiles, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			zproj.rotation = -zproj.rotation
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
			zproj = zprojORIG
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
		}
		zproj = zprojORIG
		atkV3 := atkV2
		atkV3.X += RandF32(20, 41)
		atkV3.Y += RandF32(20, 41)
		xdiff = AbsDiff(atkCNT.X, atkV3.X)
		ydiff = AbsDiff(atkCNT.Y, atkV3.Y)
		if xdiff > ydiff {
			zproj.dirX = zproj.speed
			zproj.dirY = ydiff / (xdiff / zproj.dirX)
		} else {
			zproj.dirY = zproj.speed
			zproj.dirX = xdiff / (ydiff / zproj.dirY)
		}
		if atkCNT.X > atkV3.X {
			zproj.dirX = -zproj.dirX
		}
		if atkCNT.Y > atkV3.Y {
			zproj.dirY = -zproj.dirY
		}
		zproj.rotation = AngleBetweenTwoPoints(atkCNT, atkV3) - 90
		zproj.rec = rl.NewRectangle(atkCNT.X-zproj.rec.Width/2, atkCNT.Y-zproj.rec.Height/2, zproj.rec.Width, zproj.rec.Height)
		playerProjectiles = append(playerProjectiles, zproj)
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			zproj.rotation = -zproj.rotation
			playerProjectiles = append(playerProjectiles, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			zproj.rotation = -zproj.rotation
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
			zproj = zprojORIG
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
		}
		atkV3 = atkV2
		atkV3.X -= RandF32(20, 41)
		atkV3.Y -= RandF32(20, 41)
		xdiff = AbsDiff(atkCNT.X, atkV3.X)
		ydiff = AbsDiff(atkCNT.Y, atkV3.Y)
		if xdiff > ydiff {
			zproj.dirX = zproj.speed
			zproj.dirY = ydiff / (xdiff / zproj.dirX)
		} else {
			zproj.dirY = zproj.speed
			zproj.dirX = xdiff / (ydiff / zproj.dirY)
		}
		if atkCNT.X > atkV3.X {
			zproj.dirX = -zproj.dirX
		}
		if atkCNT.Y > atkV3.Y {
			zproj.dirY = -zproj.dirY
		}
		zproj.rotation = AngleBetweenTwoPoints(atkCNT, atkV3) - 90
		zproj.rec = rl.NewRectangle(atkCNT.X-zproj.rec.Width/2, atkCNT.Y-zproj.rec.Height/2, zproj.rec.Width, zproj.rec.Height)
		playerProjectiles = append(playerProjectiles, zproj)
		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			zproj.rotation = -zproj.rotation
			playerProjectiles = append(playerProjectiles, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			zproj.rotation = -zproj.rotation
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
			zproj = zprojORIG
			zproj.dirX *= -1
			zproj.dirY *= -1
			zproj.rotation += 180
			playerProjectiles = append(playerProjectiles, zproj)
		}
	case "kitchen knife", "frying pan", "rolling pin", "mint ice cream", "lighter", "magnifying glass", "raspberry", "chilli", "emoji", "french fries", "hot soup", "drawing pin":
		if zproj.name == "drawing pin" {
			zproj.rotation = AngleBetweenTwoPoints(atkCNT, atkV2) + 45
		}
		if zproj.name == "french fries" {
			zproj.image = otherTiles[178]
			zproj.rotation = AngleBetweenTwoPoints(atkCNT, atkV2) - 90
		}
		if zproj.name == "raspberry" {
			zproj.bounce += 4
		}
		if zproj.name == "emoji" {
			zproj.bounce += 3
		}
		if zproj.name == "frying pan" {
			zproj.rec.X -= 10
			zproj.rec.Y -= 10
			zproj.rec.Width += 20
			zproj.rec.Height += 20
		} else if zproj.name == "rolling pin" || zproj.name == "mint ice cream" || zproj.name == "lighter" || zproj.name == "chilli" || zproj.name == "hot soup" {
			zproj.rec.X -= 4
			zproj.rec.Y -= 4
			zproj.rec.Width += 8
			zproj.rec.Height += 8
		} else if zproj.name == "lighter" {
			zproj.T = fps / 3
			zproj.rec.X -= 2
			zproj.rec.Y -= 2
			zproj.rec.Width += 4
			zproj.rec.Height += 4
		}
		playerProjectiles = append(playerProjectiles, zproj)

		if mirror && !twin { //MIRROR
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			if zproj.name == "french fries" || zproj.name == "drawing pin" {
				zproj.rotation = MirrorAngle(zproj.rotation) + 90
			}
			playerProjectiles = append(playerProjectiles, zproj)
		} else if !mirror && twin { //TWIN
			zproj.dirX *= -1
			zproj.dirY *= -1
			if zproj.name == "french fries" || zproj.name == "drawing pin" {
				zproj.rotation += 180
			}
			playerProjectiles = append(playerProjectiles, zproj)
		} else if mirror && twin { //MIRROR & TWIN
			proj2 := zproj
			zproj.dirX *= -1
			if player.direction {
				zproj.rec.X += player.rectangle.Width
			} else {
				zproj.rec.X -= player.rectangle.Width
			}
			if zproj.name == "french fries" || zproj.name == "drawing pin" {
				zproj.rotation = MirrorAngle(zproj.rotation) + 90
			}
			playerProjectiles = append(playerProjectiles, zproj)
			zproj.dirX *= -1
			zproj.dirY *= -1
			if zproj.name == "french fries" || zproj.name == "drawing pin" {
				zproj.rotation += 180
			}
			playerProjectiles = append(playerProjectiles, zproj)
			zproj = proj2
			zproj.dirX *= -1
			zproj.dirY *= -1
			if zproj.name == "french fries" || zproj.name == "drawing pin" {
				zproj.rotation += 180
			}
			playerProjectiles = append(playerProjectiles, zproj)
		}

	}

	//SPECIAL RANDOM BONUS
	if num == 1 {
		if player.weapon.special == 2 {
			if Roll12() > 9 {
				makeplProjSpecial(1, 1)
			}
		} else if player.weapon.special == 6 {
			if Roll12() > 10 {
				makeplProjSpecial(1, 1)
			}
		}
		if player.weapon.special2 == 2 {
			if Roll12() > 9 {
				makeplProjSpecial(1, 2)
			}
		} else if player.weapon.special2 == 6 {
			if Roll12() > 10 {
				makeplProjSpecial(1, 2)
			}
		}
	} else {
		if player.weapon2.special == 2 {
			if Roll12() > 9 {
				makeplProjSpecial(2, 1)
			}
		} else if player.weapon2.special == 6 {
			if Roll12() > 10 {
				makeplProjSpecial(2, 1)
			}
		}
		if player.weapon2.special2 == 2 {
			if Roll12() > 9 {
				makeplProjSpecial(2, 2)
			}
		} else if player.weapon2.special2 == 6 {
			if Roll12() > 10 {
				makeplProjSpecial(2, 2)
			}
		}
	}

	//SOUND FX
	switch weapName {
	case "drawing pin":
		rl.PlaySound(audfx[38])
	case "guitar":
		rl.PlaySound(audfx[37])
	case "hot soup":
		rl.PlaySound(audfx[36])
	case "french fries":
		rl.PlaySound(audfx[35])
	case "emoji":
		rl.PlaySound(audfx[34])
	case "chilli":
		rl.PlaySound(audfx[33])
	case "fork":
		rl.PlaySound(audfx[32])
	case "pineapple":
		rl.PlaySound(audfx[31])
	case "raspberry":
		rl.PlaySound(audfx[29])
	case "magnifying glass":
		rl.PlaySound(audfx[28])
	case "lighter":
		rl.PlaySound(audfx[27])
	case "mint ice cream":
		rl.PlaySound(audfx[26])
	case "mustard":
		rl.PlaySound(audfx[25])
	case "rolling pin":
		rl.PlaySound(audfx[24])
	case "frying pan":
		rl.PlaySound(audfx[23])
	case "rubber duck":
		rl.PlaySound(audfx[22])
	case "window cleaner":
		rl.PlaySound(audfx[21])
	case "bunch of carrots":
		rl.PlaySound(audfx[20])
	case "kitchen knife":
		rl.PlaySound(audfx[0])
	}
}

func makebase() { //MARK:MAKE BASE

	mushroomTimerMax = 12
	mushroomTimer = 0

	base.mouse.image = animation[182].rectangle
	if FlipCoin() {
		base.mouse.image = animation[183].rectangle
		base.mouse.onoff = true
	}
	siz2 := be5
	base.mouse.rectangle = rl.NewRectangle(currentPosition.X-siz2/2, currentPosition.Y-siz2/2, siz2, siz2)
	base.mouse.speed = 2
	base.mouse.dirX = -RandF32(-base.mouse.speed, base.mouse.speed)
	base.mouse.dirY = -RandF32(-base.mouse.speed, base.mouse.speed)
	base.mouse.collisionRectangle = base.mouse.rectangle

	W := float32(1280)
	H := float32(720)
	baseBordRec = rl.NewRectangle(currentPosition.X-W/2, currentPosition.Y-H/2, W, H)

	bs1 := W / 16 //BASE UNIT = 1280/16 =80

	//TENT
	base.level = append(base.level, 0)
	siz := bs1 * 2
	rec := rl.NewRectangle(currentPosition.X-siz/2, baseBordRec.Y, siz, siz)
	crec := rec
	crec.X += crec.Width / 4
	crec.Width = crec.Width / 2
	crec.Y += crec.Height / 4
	crec.Height = crec.Height / 2
	base.name = append(base.name, "tent")
	base.imageRectangle = append(base.imageRectangle, otherTiles[33])
	base.rectangle = append(base.rectangle, rec)
	base.collisionRectangle = append(base.collisionRectangle, crec)
	base.caRectangle = append(base.caRectangle, crec)
	base.isUnlocked = append(base.isUnlocked, true)
	base.description = append(base.description, "")
	base.price = append(base.price, 0)
	base.fade = append(base.fade, 1)
	//BOOK
	base.level = append(base.level, 0)
	siz = bs1
	rec = rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/16)*9, baseBordRec.Y+baseBordRec.Height/4, siz, siz)
	crec = rec
	base.name = append(base.name, "book of unlock things")
	base.imageRectangle = append(base.imageRectangle, otherTiles[180])
	base.rectangle = append(base.rectangle, rec)
	base.collisionRectangle = append(base.collisionRectangle, crec)
	crec.X -= b / 4
	crec.Y -= b / 4
	crec.Width += b / 2
	crec.Height += b / 2
	base.caRectangle = append(base.caRectangle, crec)
	base.isUnlocked = append(base.isUnlocked, true)
	base.description = append(base.description, "")
	base.price = append(base.price, 0)
	base.fade = append(base.fade, 1)
	//WEAPON STAND
	base.level = append(base.level, 0)
	siz = bs1 + bs1/3
	rec = rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/16)*6, baseBordRec.Y+baseBordRec.Height/4, siz, siz)
	crec = rec
	crec.X += b / 4
	crec.Width -= b / 2
	base.name = append(base.name, "weapon stand")
	base.imageRectangle = append(base.imageRectangle, otherTiles[213])
	base.rectangle = append(base.rectangle, rec)
	base.collisionRectangle = append(base.collisionRectangle, crec)
	crec.X -= b / 4
	crec.Y -= b / 4
	crec.Width += b / 2
	crec.Height += b / 2
	base.caRectangle = append(base.caRectangle, crec)
	base.isUnlocked = append(base.isUnlocked, false)
	base.description = append(base.description, "")
	base.price = append(base.price, 10)
	base.fade = append(base.fade, 1)
	//ROCK
	base.level = append(base.level, 0)
	siz = bs1
	rec = rl.NewRectangle(baseBordRec.X+siz/5, baseBordRec.Y+baseBordRec.Height-(siz+siz/5), siz, siz)
	if asp1610 {
		rec.X += siz
	}
	crec = rec
	base.name = append(base.name, "an attractive rocky outcrop")
	base.imageRectangle = append(base.imageRectangle, otherTiles[39])
	base.rectangle = append(base.rectangle, rec)
	base.collisionRectangle = append(base.collisionRectangle, crec)
	base.caRectangle = append(base.caRectangle, crec)
	base.isUnlocked = append(base.isUnlocked, true)
	base.description = append(base.description, "")
	base.price = append(base.price, 0)
	base.fade = append(base.fade, 1)
	//STORE ROOM
	base.level = append(base.level, 0)
	siz = bs1 * 3
	rec = rl.NewRectangle(baseBordRec.X+b3, baseBordRec.Y+b/4, siz, siz)
	if asp1610 {
		rec.Y += siz / 8
	}
	crec = rec
	crec.Y += crec.Height / 4
	crec.Height = (crec.Height / 3) * 2
	base.name = append(base.name, "store room")
	base.imageRectangle = append(base.imageRectangle, otherTiles[40])
	base.rectangle = append(base.rectangle, rec)
	base.collisionRectangle = append(base.collisionRectangle, crec)
	crec.X -= b / 2
	crec.Y -= b / 2
	crec.Width += b
	crec.Height += b
	base.caRectangle = append(base.caRectangle, crec)
	base.isUnlocked = append(base.isUnlocked, false)
	base.description = append(base.description, "")
	base.price = append(base.price, 10)
	base.fade = append(base.fade, 0)
	//EXIT
	base.level = append(base.level, 0)
	siz = bs1 * 3
	rec = rl.NewRectangle(baseBordRec.X+baseBordRec.Width-(siz+siz/7), baseBordRec.Y+baseBordRec.Height-(siz+siz/3), siz, siz)
	if asp1610 {
		rec.X -= siz / 6
	}
	crec = rec
	crec.X += crec.Width / 4
	crec.Width = crec.Width - crec.Width/2
	crec.Y += crec.Height / 4
	crec.Height = crec.Height - crec.Height/4
	carec := crec
	carec.X -= carec.Width / 8
	carec.Width += carec.Width / 4
	base.name = append(base.name, "to the dungeon")
	base.imageRectangle = append(base.imageRectangle, otherTiles[41])
	base.rectangle = append(base.rectangle, rec)
	base.collisionRectangle = append(base.collisionRectangle, crec)
	base.caRectangle = append(base.caRectangle, carec)
	base.isUnlocked = append(base.isUnlocked, true)
	base.description = append(base.description, "")
	base.price = append(base.price, 0)
	base.fade = append(base.fade, 1)
	//WEAPON SHED
	base.level = append(base.level, 1)
	siz = bs1 * 3
	rec = rl.NewRectangle(baseBordRec.X+baseBordRec.Width/12, baseBordRec.Y+baseBordRec.Height/2-b2, siz, siz)
	if asp1610 {
		rec.Y += siz / 12
	}
	crec = rec
	crec.X += crec.Width / 4
	crec.Width = crec.Width - crec.Width/2
	crec.Y += b / 2
	crec.Height = crec.Height - crec.Height/3
	base.name = append(base.name, "weapon shed")
	base.imageRectangle = append(base.imageRectangle, otherTiles[44])
	base.rectangle = append(base.rectangle, rec)
	base.collisionRectangle = append(base.collisionRectangle, crec)
	crec.X -= b / 2
	crec.Y -= b / 2
	crec.Width += b
	crec.Height += b
	base.caRectangle = append(base.caRectangle, crec)
	base.isUnlocked = append(base.isUnlocked, false)
	base.description = append(base.description, "")
	base.price = append(base.price, 10)
	base.fade = append(base.fade, 0)
	//APOTHECARY
	base.level = append(base.level, 1)
	siz = bs1 * 3
	rec = rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/20)*15, baseBordRec.Y+baseBordRec.Height/9, siz, siz)
	crec = rec
	crec.X += crec.Width / 4
	crec.Width = crec.Width - crec.Width/2
	crec.Y += b / 2
	crec.Height = crec.Height - crec.Height/8
	base.name = append(base.name, "apothecary")
	base.imageRectangle = append(base.imageRectangle, otherTiles[45])
	base.rectangle = append(base.rectangle, rec)
	base.collisionRectangle = append(base.collisionRectangle, crec)
	crec.X -= b / 4
	crec.Y -= b / 4
	crec.Width += b / 2
	crec.Height += b / 2
	base.caRectangle = append(base.caRectangle, crec)
	base.isUnlocked = append(base.isUnlocked, false)
	base.description = append(base.description, "")
	base.price = append(base.price, 10)
	base.fade = append(base.fade, 0)
	//CAMPFIRE STONE
	base.level = append(base.level, 0)
	rec = rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/3)+b/4, baseBordRec.Y+b3-b/8, b+b/2, b+b/2)
	crec = rec
	base.name = append(base.name, "campfire stone")
	base.imageRectangle = append(base.imageRectangle, otherTiles[47])
	base.rectangle = append(base.rectangle, rec)
	base.collisionRectangle = append(base.collisionRectangle, crec)
	base.caRectangle = append(base.caRectangle, crec)
	base.isUnlocked = append(base.isUnlocked, true)
	base.description = append(base.description, "")
	base.price = append(base.price, 0)
	//CAMPFIRE
	base.level = append(base.level, 0)
	rec = rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/3)+2, baseBordRec.Y+b, b2, b2)
	crec = rec
	base.name = append(base.name, "campfire")
	base.imageRectangle = append(base.imageRectangle, animation[72].rectangle)
	base.rectangle = append(base.rectangle, rec)
	base.collisionRectangle = append(base.collisionRectangle, crec)
	base.caRectangle = append(base.caRectangle, crec)
	base.isUnlocked = append(base.isUnlocked, true)
	base.description = append(base.description, "")
	base.price = append(base.price, 0)
	//TREE
	base.level = append(base.level, 0)
	siz = bs1 * 2
	rec = rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/12)*7, baseBordRec.Y+b/8, b5, b5)
	crec = rec
	crec.X += crec.Width / 8
	crec.Width = crec.Width - crec.Width/4
	crec.Y += crec.Height / 8
	crec.Height = crec.Height - crec.Height/4
	base.name = append(base.name, "a tree")
	base.imageRectangle = append(base.imageRectangle, otherTiles[48])
	base.rectangle = append(base.rectangle, rec)
	base.collisionRectangle = append(base.collisionRectangle, crec)
	base.caRectangle = append(base.caRectangle, crec)
	base.isUnlocked = append(base.isUnlocked, true)
	base.description = append(base.description, "")
	base.price = append(base.price, 0)
	//MUSHROOM PATCH
	base.level = append(base.level, 1)
	rec = rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/3), baseBordRec.Y+baseBordRec.Height/2+b4, b6, b6)
	crec = rec
	base.name = append(base.name, "mushroom patch")
	base.imageRectangle = append(base.imageRectangle, otherTiles[49])
	base.rectangle = append(base.rectangle, rec)
	base.collisionRectangle = append(base.collisionRectangle, crec)
	crec.X -= b / 4
	crec.Y -= b / 4
	crec.Width += b / 2
	crec.Height += b / 2
	base.caRectangle = append(base.caRectangle, crec)
	base.isUnlocked = append(base.isUnlocked, false)
	base.description = append(base.description, "")
	base.price = append(base.price, 10)
	base.fade = append(base.fade, 0)
	//BOSS KEYS
	siz = (bs1 / 8) * 5
	base.level = append(base.level, 0)
	rec = rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/2)+b3, baseBordRec.Y+baseBordRec.Height-(siz+siz/3), siz, siz)
	crec = rec
	base.name = append(base.name, "boss key 1")
	base.imageRectangle = append(base.imageRectangle, otherTiles[189])
	base.rectangle = append(base.rectangle, rec)
	base.collisionRectangle = append(base.collisionRectangle, crec)
	base.caRectangle = append(base.caRectangle, crec)
	base.isUnlocked = append(base.isUnlocked, false)
	base.description = append(base.description, "kill boss > unlocks ")
	base.price = append(base.price, 0)
	base.fade = append(base.fade, 1)
	rec.X += siz + siz/5
	crec = rec
	base.level = append(base.level, 0)
	base.name = append(base.name, "boss key 2")
	base.imageRectangle = append(base.imageRectangle, otherTiles[189])
	base.rectangle = append(base.rectangle, rec)
	base.collisionRectangle = append(base.collisionRectangle, crec)
	base.caRectangle = append(base.caRectangle, crec)
	base.isUnlocked = append(base.isUnlocked, false)
	base.description = append(base.description, "kill boss > unlocks ")
	base.price = append(base.price, 0)
	base.fade = append(base.fade, 1)
	rec.X += siz + siz/5
	crec = rec
	base.level = append(base.level, 0)
	base.name = append(base.name, "boss key 3")
	base.imageRectangle = append(base.imageRectangle, otherTiles[189])
	base.rectangle = append(base.rectangle, rec)
	base.collisionRectangle = append(base.collisionRectangle, crec)
	base.caRectangle = append(base.caRectangle, crec)
	base.isUnlocked = append(base.isUnlocked, false)
	base.description = append(base.description, "kill boss > unlocks ")
	base.price = append(base.price, 0)
	base.fade = append(base.fade, 1)

	//rec3 := rl.NewRectangle(baseBordRec.X+(baseBordRec.Width/3),baseBordRec.Y+baseBordRec.Height/2+b4,b6,b6)
	//rl.DrawTexturePro(imgs,etc[49],rec3,rl.Vector2Zero(),0,rl.White)
	base.pigeon.image = animation[73].rectangle
	base.pigeon.dirX = 4
	base.pigeon.rectangle = rl.NewRectangle(baseBordRec.X+4, baseBordRec.Y+4, b, b)
	x := baseBordRec.X
	y := baseBordRec.Y
	siz = b2
	for {
		zbgi := BackgroundInformation{}
		zbgi.rectangle = rl.NewRectangle(x, y, siz, siz)
		zbgi.imageRectangle = otherTiles[34]
		if Roll6() == 6 {
			choose := RandInt(1, 5)
			switch choose {
			case 1:
				zbgi.imageRectangle = otherTiles[35]
			case 2:
				zbgi.imageRectangle = otherTiles[36]
			case 3:
				zbgi.imageRectangle = otherTiles[37]
			case 4:
				zbgi.imageRectangle = otherTiles[38]
			}
		}
		baseBG = append(baseBG, zbgi)
		x += siz
		if x >= baseBordRec.X+baseBordRec.Width {
			x = baseBordRec.X
			y += siz
		}
		if y >= baseBordRec.Y+baseBordRec.Height {
			break
		}
	}
}
func makechest(lev x1scr) x1scr { //MARK:MAKE CHEST
	siz := b2
	zchst := Chest{}
	zchst.slots = RandInt(2, 5)
	for i := 0; i < zchst.slots; i++ {
		zchst.item = append(zchst.item, Item{})
	}
	zchst.image = animation[4].rectangle
	zchst.center = currentPosition
	countbreak := 100
	found := false
	for {
		choose2 := RandInt(0, len(lev.rectangles))
		choose := lev.rectangles[choose2]
		x := choose.X + b
		y := choose.Y + b
		x += RandF32(0, choose.Width-b2-siz)
		y += RandF32(0, choose.Height-b2-siz)
		zchst.rectangle = rl.NewRectangle(x, y, siz, siz)
		canadd := checkaddtilerecInner(zchst.rectangle, lev)
		if canadd {
			canadd = checkaddetc(zchst.rectangle, lev)
		}
		if canadd {
			found = true
			chestRoomNum = choose2
			break
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	if found {
		zchst.center = makecnt(zchst.rectangle)
		zchst.collisionRectangle = zchst.rectangle
		zchst.collisionRectangle.X += zchst.collisionRectangle.Width / 4
		zchst.collisionRectangle.Y += zchst.collisionRectangle.Height / 2
		zchst.collisionRectangle.Y -= 4
		zchst.collisionRectangle.Width = zchst.collisionRectangle.Width / 2
		zchst.collisionRectangle.Height = (zchst.collisionRectangle.Height / 9) * 4
		choose := RandInt(0, 30)
		switch choose {
		case 0:
			zchst.item[0] = itemList[48]
			zchst.item[0].isNoChestMove = true
		case 1:
			zchst.item[0] = itemList[19]
			zchst.item[0].isNoChestMove = true
		case 2:
			zchst.item[0] = itemList[21]
			zchst.item[0].isNoChestMove = true
		case 3:
			zchst.item[0] = itemList[80]
			zchst.item[0].isNoChestMove = true
		case 4:
			zchst.item[0] = itemList[97]
			zchst.item[0].isNoChestMove = true
		case 5:
			zchst.item[0] = itemList[102]
			zchst.item[0].isNoChestMove = true
		case 6:
			zchst.item[0] = itemList[0]
			zchst.item[0].isNoChestMove = true
		case 7:
			zchst.item[0] = itemList[3]
			zchst.item[0].isNoChestMove = true
		case 8:
			zchst.item[0] = itemList[17]
			zchst.item[0].isNoChestMove = true
		case 9:
			zchst.item[0] = itemList[14]
			zchst.item[0].isNoChestMove = true
		case 10:
			zchst.item[0] = itemList[73]
			zchst.item[0].isNoChestMove = true
		case 11:
			zchst.item[0] = itemList[64]
			zchst.item[0].isNoChestMove = true
		case 12:
			zchst.item[0] = itemList[70]
			zchst.item[0].isNoChestMove = true
		case 13:
			zchst.item[0] = itemList[86]
			zchst.item[0].isNoChestMove = true
		case 14:
			zchst.item[0] = itemList[95]
			zchst.item[0].isNoChestMove = true
		case 15:
			zchst.item[0] = itemList[99]
			zchst.item[0].isNoChestMove = true
		case 16:
			zchst.item[0] = itemList[113]
			zchst.item[0].isNoChestMove = true
		case 17:
			zchst.item[0] = itemList[114]
			zchst.item[0].isNoChestMove = true
		case 18:
			zchst.item[0] = itemList[101]
			zchst.item[0].isNoChestMove = true
		case 19:
			zchst.item[0] = itemList[100]
			zchst.item[0].isNoChestMove = true
		case 20:
			zchst.item[0] = itemList[52]
			zchst.item[0].isNoChestMove = true
		case 21:
			zchst.item[0] = itemList[79]
			zchst.item[0].isNoChestMove = true
		case 22:
			zchst.item[0] = itemList[94]
			zchst.item[0].isNoChestMove = true
		case 23:
			zchst.item[0] = itemList[91]
			zchst.item[0].isNoChestMove = true
		case 24:
			zchst.item[0] = itemList[37]
			zchst.item[0].isNoChestMove = true
		case 25:
			zchst.item[0] = itemList[46]
			zchst.item[0].isNoChestMove = true
		case 26:
			zchst.item[0] = itemList[115]
			zchst.item[0].isNoChestMove = true
		case 27:
			zchst.item[0] = itemList[118]
			zchst.item[0].isNoChestMove = true
		case 28:
			zchst.item[0] = itemList[58]
			zchst.item[0].isNoChestMove = true
		case 29:
			zchst.item[0] = itemList[33]
			zchst.item[0].isNoChestMove = true
		}

		if Roll6() == 6 {
			zchst.item[1] = itemList[104]
			zchst.item[1].isNoChestMove = true
		}

		lev.chests = append(lev.chests, zchst)
	}

	return lev
}

func makeboss() { //MARK:MAKE BOSS
	zboss := Enemy{}
	if len(bossSkillList) > 0 {
		for {
			canadd := true
			bossNum = RandInt(1, 10)
			for i := 0; i < len(bossSkillList); i++ {
				if bossSkillList[i] == bossNum {
					canadd = false
				}
			}
			if canadd {
				break
			}
		}
	} else {
		bossNum = RandInt(1, 10)
	}
	zboss.xp = 500
	//bossnum = 9
	switch bossNum {
	case 9: //ROLLO
		siz := b2
		zboss.moveChangeT = fps * 2
		zboss.hpMax = 20
		zboss.hp = zboss.hpMax
		x := levels[levNum].rectangles[0].X + b/2
		y := levels[levNum].rectangles[0].Y + b/2
		zboss.rectangle = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rectangle)
		zboss.collisionRectangle = zboss.rectangle
		zboss.image = animation[153].rectangle
		zboss.name = "rollo"
		zboss.speed = 3
		countbreak := 100
		for {
			zboss.dirX = RandF32(-zboss.speed, zboss.speed)
			zboss.dirY = RandF32(-zboss.speed, zboss.speed)
			if Abs(zboss.dirX) > zboss.speed/2 || Abs(zboss.dirY) > zboss.speed/2 {
				break
			}
			countbreak--
			if countbreak == 0 {
				break
			}
		}
	case 8: //MUSHROOM
		siz := b5
		zboss.state = 1
		zboss.moveChangeT = fps * 2
		zboss.hpMax = 50
		zboss.hp = zboss.hpMax
		x := levels[levNum].rectangles[0].X + b/2
		y := levels[levNum].rectangles[0].Y + b/2
		zboss.rectangle = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rectangle)
		zboss.collisionRectangle = zboss.rectangle
		zboss.collisionRectangle.X += zboss.collisionRectangle.Width / 3
		zboss.collisionRectangle.Y += zboss.collisionRectangle.Width / 3
		zboss.collisionRectangle.Width = zboss.collisionRectangle.Width / 3
		zboss.collisionRectangle.Height = zboss.collisionRectangle.Height / 3
		zboss.image = animation[148].rectangle
		zboss.name = "mushee"
		zboss.speed = 2
		zboss.dirX = RandF32(-zboss.speed, zboss.speed)
		zboss.dirY = RandF32(-zboss.speed, zboss.speed)
	case 7: //RED BAT
		siz := b6
		zboss.moveChangeT = fps
		zboss.hpMax = 60
		zboss.hp = zboss.hpMax
		x := levels[levNum].rectangles[0].X + b/2
		y := levels[levNum].rectangles[0].Y + b/2
		zboss.rectangle = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rectangle)
		zboss.collisionRectangle = zboss.rectangle
		zboss.collisionRectangle.X += zboss.collisionRectangle.Width / 3
		zboss.collisionRectangle.Y += zboss.collisionRectangle.Width / 3
		zboss.collisionRectangle.Width = zboss.collisionRectangle.Width / 3
		zboss.collisionRectangle.Height = zboss.collisionRectangle.Height / 3
		zboss.image = animation[145].rectangle
		zboss.name = "batty"
		zboss.speed = 2
		zboss.dirX = RandF32(-zboss.speed, zboss.speed)
		zboss.dirY = RandF32(-zboss.speed, zboss.speed)
	case 6: //ZOMBO
		siz := b5
		zboss.atkT2 = fps
		zboss.atkT = fps * 2
		zboss.hpMax = 40
		zboss.hp = zboss.hpMax
		x := levels[levNum].rectangles[0].X + b/2
		y := levels[levNum].rectangles[0].Y + b/2
		zboss.rectangle = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rectangle)
		zboss.collisionRectangle = zboss.rectangle
		zboss.collisionRectangle.X += zboss.collisionRectangle.Width / 3
		zboss.collisionRectangle.Width = zboss.collisionRectangle.Width / 3
		zboss.collisionRectangle.Y += zboss.collisionRectangle.Height / 3
		zboss.collisionRectangle.Height = zboss.collisionRectangle.Height / 3
		zboss.collisionRectangle.Y += 8
		zboss.image = animation[138].rectangle
		zboss.name = "zombo"
		zboss.speed = 1
		zboss.dirX = RandF32(-zboss.speed, zboss.speed)
		zboss.dirY = RandF32(-zboss.speed, zboss.speed)
	case 5: //PYRO PIG
		siz := b7
		zboss.atkT = fps * 4
		zboss.moveChangeT = fps
		zboss.hpMax = 35
		zboss.hp = zboss.hpMax
		x := levels[levNum].rectangles[0].X + b/2
		y := levels[levNum].rectangles[0].Y + b/2
		zboss.rectangle = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rectangle)
		zboss.collisionRectangle = zboss.rectangle
		zboss.collisionRectangle.X += zboss.collisionRectangle.Width / 3
		zboss.collisionRectangle.Width = zboss.collisionRectangle.Width / 3
		zboss.collisionRectangle.Y += zboss.collisionRectangle.Height / 3
		zboss.collisionRectangle.Height = zboss.collisionRectangle.Height / 3
		zboss.collisionRectangle.Y += 8
		zboss.image = animation[133].rectangle
		zboss.name = "pyro pig"
		zboss.speed = 4
		zboss.dirX = RandF32(-zboss.speed, zboss.speed)
		zboss.dirY = RandF32(-zboss.speed, zboss.speed)
	case 4: //SPACEMAN
		siz := b5
		zboss.moveChangeT = fps
		zboss.hpMax = 55
		zboss.hp = zboss.hpMax
		x := levels[levNum].rectangles[0].X + b/2
		y := levels[levNum].rectangles[0].Y + b/2
		zboss.rectangle = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rectangle)
		zboss.collisionRectangle = zboss.rectangle
		zboss.collisionRectangle.X += zboss.collisionRectangle.Width / 3
		zboss.collisionRectangle.Width = zboss.collisionRectangle.Width / 3
		zboss.collisionRectangle.Y += zboss.collisionRectangle.Height / 2
		zboss.collisionRectangle.Y -= 12
		zboss.collisionRectangle.Height = zboss.collisionRectangle.Height / 2
		zboss.image = animation[124].rectangle
		zboss.name = "spzman"
		zboss.speed = 2
	case 3: //SPINNA
		siz := b3 + b/2
		zboss.moveChangeT = fps
		zboss.hpMax = 30
		zboss.hp = zboss.hpMax
		x := levels[levNum].rectangles[0].X + b/2
		y := levels[levNum].rectangles[0].Y + b/2
		zboss.rectangle = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rectangle)
		zboss.collisionRectangle = zboss.rectangle
		zboss.collisionRectangle.X += zboss.collisionRectangle.Width / 4
		zboss.collisionRectangle.Width = zboss.collisionRectangle.Width / 2
		zboss.image = animation[118].rectangle
		zboss.name = "spinna"
		zboss.speed = 7
		zboss.dirY = zboss.speed
		if FlipCoin() {
			zboss.dirY -= zboss.speed
		}
	case 2: //MR FRISBEE
		siz := b8
		zboss.idleTime = fps
		zboss.hpMax = 50
		zboss.hp = zboss.hpMax
		x := levels[levNum].rectangles[0].X + b/2
		y := levels[levNum].rectangles[0].Y + b/2
		zboss.rectangle = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rectangle)
		zboss.collisionRectangle = zboss.rectangle
		zboss.collisionRectangle.X += zboss.collisionRectangle.Width / 3
		zboss.collisionRectangle.Y += zboss.collisionRectangle.Height / 3
		zboss.collisionRectangle.Width = zboss.collisionRectangle.Width / 3
		zboss.collisionRectangle.Height = zboss.collisionRectangle.Height / 3
		zboss.carec = zboss.collisionRectangle
		zboss.carec.X -= b
		zboss.carec.Y -= b
		zboss.carec.Width += b2
		zboss.carec.Height += b2
		zboss.name = "mr frisbee"
		zboss.speed = 3
		countbreak := 100
		for {
			zboss.dirX = RandF32(-zboss.speed, zboss.speed)
			if Abs(zboss.dirX) > zboss.speed/3 {
				break
			}
			countbreak--
			if countbreak == 0 {
				break
			}
		}
		zboss.dirY = RandF32(-zboss.speed/3, zboss.speed/3)
		zboss.image = animation[110].rectangle
	case 1: //ICEMAN
		zboss.atkT2 = fps / 2
		zboss.hpMax = 50
		zboss.hp = zboss.hpMax
		bossWALKL = rl.LoadTexture("img/boss/wl1.png")
		zanim := Animation{}
		zanim.frames = 19
		zanim.rectangle = rl.NewRectangle(0, 0, 256, 256)
		zanim.width = 256
		zanim.x = zanim.rectangle.X
		zboss.walkLeftAnimation = zanim
		bossWALKR = rl.LoadTexture("img/boss/wr1.png")
		zanim = Animation{}
		zanim.frames = 19
		zanim.rectangle = rl.NewRectangle(0, 0, 256, 256)
		zanim.width = 256
		zanim.x = zanim.rectangle.X
		zboss.walkRightAnimation = zanim
		bossATK = rl.LoadTexture("img/boss/a1.png")
		zanim = Animation{}
		zanim.frames = 23
		zanim.rectangle = rl.NewRectangle(0, 0, 256, 256)
		zanim.width = 256
		zanim.x = zanim.rectangle.X
		zboss.attackAnimation = zanim
		bossIDL = rl.LoadTexture("img/boss/i1.png")
		zanim = Animation{}
		zanim.frames = 19
		zanim.rectangle = rl.NewRectangle(0, 0, 256, 256)
		zanim.width = 256
		zanim.x = zanim.rectangle.X
		zboss.idleAnimation = zanim
		siz := b7
		x := levels[levNum].rectangles[0].X + b/2
		y := levels[levNum].rectangles[0].Y + b/2
		zboss.rectangle = rl.NewRectangle(x, y, siz, siz)
		zboss.cnt = makecnt(zboss.rectangle)
		zboss.collisionRectangle = zboss.rectangle
		zboss.collisionRectangle.X += zboss.rectangle.Width / 3
		zboss.collisionRectangle.Y += zboss.rectangle.Height / 3
		zboss.collisionRectangle.Height = zboss.rectangle.Height / 3
		zboss.collisionRectangle.Height += b / 2
		zboss.collisionRectangle.X -= bq
		zboss.collisionRectangle.Width = zboss.rectangle.Width / 3
		zboss.collisionRectangle.Width += b / 2
		zboss.image = zboss.idleAnimation.rectangle
		zboss.name = "iceman"
		zboss.idleTime = fps * 2
		zboss.speed = 2
	}

	//zboss.hp = 1

	boss = zboss
	levels[levNum].enemies = append(levels[levNum].enemies, zboss)
}

func makebosslev() { //MARK:MAKE BOSS LEVEL
	//WALLS FLOOR
	floortile = floorTiles[RandInt(0, len(floorTiles))]
	walltile = wallTiles[RandInt(0, len(wallTiles))]
	W3 := float32(3840)
	H3 := float32(2160)
	bossBordRectangle = rl.NewRectangle(currentPosition.X-W3/2, currentPosition.Y-H3/2, W3, H3)
	bossBordRectangle.X -= b3
	bossBordRectangle.Y -= b3
	bossBordRectangle.Width += b6
	bossBordRectangle.Height += b6
	zboss := x1scr{}
	//CENTER REC
	min, max := 17, 25
	numW := RandInt(min, max)
	min, max = 12, 19
	numH := RandInt(min, max)
	W, H := float32(numW)*b, float32(numH)*b
	rec := rl.NewRectangle(currentPosition.X-W/2, currentPosition.Y-H/2, W, H)
	zboss.rectangles = append(zboss.rectangles, rec)
	numWo := numW
	numHo := numH
	//OTHER RECS
	countbreak := 100
	num := RandInt(5, 11)
	for num > 0 {
		side := RandInt(1, 5)
		switch side {
		case 1:
			min, max := 5, 9
			numW = RandInt(min, max)
			min, max = 3, 8
			numH = RandInt(min, max)
			W, H = float32(numW)*b, float32(numH)*b
			diff := numWo - numW
			change := float32(RandInt(0, diff))
			x := zboss.rectangles[0].X + (change * b)
			y := zboss.rectangles[0].Y - H
			rec = rl.NewRectangle(x, y, W, H)
		case 2:
			min, max := 3, 8
			numW = RandInt(min, max)
			min, max = 5, 9
			numH = RandInt(min, max)
			W, H = float32(numW)*b, float32(numH)*b
			diff := numHo - numH
			change := float32(RandInt(0, diff))
			x := zboss.rectangles[0].X + zboss.rectangles[0].Width
			y := zboss.rectangles[0].Y + (change * b)
			rec = rl.NewRectangle(x, y, W, H)
		case 3:
			min, max := 5, 9
			numW = RandInt(min, max)
			min, max = 3, 8
			numH = RandInt(min, max)
			W, H = float32(numW)*b, float32(numH)*b
			diff := numWo - numW
			change := float32(RandInt(0, diff))
			x := zboss.rectangles[0].X + (change * b)
			y := zboss.rectangles[0].Y + zboss.rectangles[0].Height
			rec = rl.NewRectangle(x, y, W, H)
		case 4:
			min, max := 3, 8
			numW = RandInt(min, max)
			min, max = 5, 9
			numH = RandInt(min, max)
			W, H = float32(numW)*b, float32(numH)*b
			diff := numHo - numH
			change := float32(RandInt(0, diff))
			x := zboss.rectangles[0].X - W
			y := zboss.rectangles[0].Y + (change * b)
			rec = rl.NewRectangle(x, y, W, H)
		}
		if len(zboss.rectangles) > 1 {
			canadd := true
			for i := 1; i < len(zboss.rectangles); i++ {
				if rl.CheckCollisionRecs(rec, zboss.rectangles[i]) {
					canadd = false
				}
			}
			if canadd {
				v1 := rl.NewVector2(rec.X, rec.Y)
				v2 := v1
				v2.X += rec.Width
				v3 := v2
				v3.Y += rec.Height
				v4 := v3
				v4.X -= rec.Width
				if !rl.CheckCollisionPointRec(v1, bossBordRectangle) || !rl.CheckCollisionPointRec(v2, bossBordRectangle) || !rl.CheckCollisionPointRec(v3, bossBordRectangle) || !rl.CheckCollisionPointRec(v4, bossBordRectangle) {
					canadd = false
				}
			}
			if canadd {
				zboss.rectangles = append(zboss.rectangles, rec)
				num--
			}
		} else {
			canadd := true
			if canadd {
				v1 := rl.NewVector2(rec.X, rec.Y)
				v2 := v1
				v2.X += rec.Width
				v3 := v2
				v3.Y += rec.Height
				v4 := v3
				v4.X -= rec.Width
				if !rl.CheckCollisionPointRec(v1, bossBordRectangle) || !rl.CheckCollisionPointRec(v2, bossBordRectangle) || !rl.CheckCollisionPointRec(v3, bossBordRectangle) || !rl.CheckCollisionPointRec(v4, bossBordRectangle) {
					canadd = false
				}
			}
			if canadd {
				zboss.rectangles = append(zboss.rectangles, rec)
				num--
			}
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	//WALLS
	for i := 0; i < len(zboss.rectangles); i++ {
		siz := b
		x := zboss.rectangles[i].X
		y := zboss.rectangles[i].Y
		x -= siz
		y -= siz
		//TOP BOTTOM
		for x <= zboss.rectangles[i].X+zboss.rectangles[i].Width {
			rec := rl.NewRectangle(x, y, siz, siz)
			canadd := true
			for i := 0; i < len(zboss.rectangles); i++ {
				if rl.CheckCollisionRecs(rec, zboss.rectangles[i]) {
					canadd = false
				}
			}
			if canadd && len(zboss.walls) > 1 {
				for i := 0; i < len(zboss.walls); i++ {
					if rl.CheckCollisionRecs(rec, zboss.walls[i].rectangle) {
						canadd = false
					}
				}
			}
			if canadd {
				ztile := Tile{}
				ztile.rectangle = rec
				ztile.image = wallBoss
				ztile.fade = RandF32(0.4, 0.7)
				ztile.color = rl.White
				ztile.color2 = RandColor()
				ztile.solid = true
				zboss.walls = append(zboss.walls, ztile)
			}
			rec.Y += zboss.rectangles[i].Height + siz
			canadd = true
			for i := 0; i < len(zboss.rectangles); i++ {
				if rl.CheckCollisionRecs(rec, zboss.rectangles[i]) {
					canadd = false
				}
			}
			if canadd && len(zboss.walls) > 1 {
				for i := 0; i < len(zboss.walls); i++ {
					if rl.CheckCollisionRecs(rec, zboss.walls[i].rectangle) {
						canadd = false
					}
				}
			}
			if canadd {
				ztile := Tile{}
				ztile.rectangle = rec
				ztile.image = wallBoss
				ztile.fade = RandF32(0.3, 0.9)
				ztile.color = rl.White
				ztile.color2 = RandColor()
				ztile.solid = true
				zboss.walls = append(zboss.walls, ztile)
			}
			x += siz
		}
		//RIGHT LEFT
		x = zboss.rectangles[i].X
		y = zboss.rectangles[i].Y
		x -= siz
		for y < zboss.rectangles[i].Y+zboss.rectangles[i].Height {
			rec := rl.NewRectangle(x, y, siz, siz)
			canadd := true
			for i := 0; i < len(zboss.rectangles); i++ {
				if rl.CheckCollisionRecs(rec, zboss.rectangles[i]) {
					canadd = false
				}
			}
			if canadd && len(zboss.walls) > 1 {
				for i := 0; i < len(zboss.walls); i++ {
					if rl.CheckCollisionRecs(rec, zboss.walls[i].rectangle) {
						canadd = false
					}
				}
			}
			if canadd {
				ztile := Tile{}
				ztile.rectangle = rec
				ztile.image = wallBoss
				ztile.fade = RandF32(0.4, 0.7)
				ztile.color = rl.White
				ztile.color2 = RandColor()
				ztile.solid = true
				zboss.walls = append(zboss.walls, ztile)
			}
			rec.X += zboss.rectangles[i].Width + siz
			canadd = true
			for i := 0; i < len(zboss.rectangles); i++ {
				if rl.CheckCollisionRecs(rec, zboss.rectangles[i]) {
					canadd = false
				}
			}
			if canadd && len(zboss.walls) > 1 {
				for i := 0; i < len(zboss.walls); i++ {
					if rl.CheckCollisionRecs(rec, zboss.walls[i].rectangle) {
						canadd = false
					}
				}
			}
			if canadd {
				ztile := Tile{}
				ztile.rectangle = rec
				ztile.image = wallBoss
				ztile.fade = RandF32(0.4, 0.7)
				ztile.color = rl.White
				ztile.color2 = RandColor()
				ztile.solid = true
				zboss.walls = append(zboss.walls, ztile)
			}
			y += siz
		}
	}
	//FLOORS
	for i := 0; i < len(zboss.rectangles); i++ {
		siz := b
		x := zboss.rectangles[i].X
		y := zboss.rectangles[i].Y
		for y < zboss.rectangles[i].Y+zboss.rectangles[i].Height {
			rec := rl.NewRectangle(x, y, siz, siz)
			ztile := Tile{}
			ztile.rectangle = rec
			ztile.image = floorBoss
			ztile.color = rl.White
			ztile.color2 = RandColor()
			ztile.fade = RandF32(0.04, 0.08)
			zboss.floors = append(zboss.floors, ztile)
			x += siz
			if x >= zboss.rectangles[i].X+zboss.rectangles[i].Width {
				x = zboss.rectangles[i].X
				y += siz
			}
		}
	}
	size := b
	for i := 0; i < len(zboss.rectangles); i++ {
		//WATER
		if Roll12() > 10 {
			x := zboss.rectangles[i].X + size
			y := zboss.rectangles[i].Y + size
			x2 := x + zboss.rectangles[i].Width - size*3
			y2 := y + zboss.rectangles[i].Height - size*3
			ztile := Tile{}
			ztile.name = "water"
			ztile.image = animation[0].rectangle
			ztile.color = rl.DarkBlue
			ztile.fade = RandF32(0.2, 0.5)
			ztile.rectangle = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
			ztile.image2 = splat[RandInt(0, len(splat))]
			ztile.rectangle2 = ztile.rectangle
			ztile.rectangle2.X -= b / 2
			ztile.rectangle2.Y -= b / 2
			ztile.rectangle2.Width += b
			ztile.rectangle2.Height += b
			if checkaddtilerecInner(ztile.rectangle, zboss) && checkaddetc(ztile.rectangle, zboss) {
				ztile.center = makecnt(ztile.rectangle)
				zboss.otherTiles = append(zboss.otherTiles, ztile)
			}
		}
		//SPIKE TRAPS
		if Roll12() > 10 {
			x := zboss.rectangles[i].X
			y := zboss.rectangles[i].Y
			x2 := x + zboss.rectangles[i].Width - size
			y2 := y + zboss.rectangles[i].Height - size
			ztile := Tile{}
			ztile.name = "spiketrap"
			ztile.image = animation[1].rectangle
			ztile.color = rl.White
			ztile.color2 = RandColor()
			ztile.fade = 1
			ztile.rectangle = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
			if checkaddtilerecInner(ztile.rectangle, zboss) && checkaddetc(ztile.rectangle, zboss) {
				ztile.center = makecnt(ztile.rectangle)
				zboss.otherTiles = append(zboss.otherTiles, ztile)
			}
		}
		//FLAME TRAPS
		if Roll12() > 10 {
			x := zboss.rectangles[i].X
			y := zboss.rectangles[i].Y
			x2 := x + zboss.rectangles[i].Width - size
			y2 := y + zboss.rectangles[i].Height - size
			ztile := Tile{}
			ztile.name = "flametrap"
			ztile.image = animation[2].rectangle
			ztile.color = rl.White
			ztile.fade = 1
			ztile.rectangle = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
			if checkaddtilerecInner(ztile.rectangle, zboss) && checkaddetc(ztile.rectangle, zboss) {
				ztile.rectangle2 = ztile.rectangle
				ztile.rectangle2.Height = 32
				ztile.rectangle2.Y += 4.5
				ztile.center = makecnt(ztile.rectangle)
				zboss.otherTiles = append(zboss.otherTiles, ztile)
			}
		}
	}
	levels = append(levels, zboss)
	//BGI
	siz := RandF32(b2, b4)
	x := levels[levNum].rectangles[0].X + b/2
	x += RandF32(0, levels[levNum].rectangles[0].Width-(siz+b))
	y := levels[levNum].rectangles[0].Y + b/2
	y += RandF32(0, levels[levNum].rectangles[0].Height-(siz+b))
	rec = rl.NewRectangle(x, y, siz, siz)
	zbgi := bgilist[RandInt(0, len(bgilist))]
	zbgi.rectangle = rec
	zbgi.fade = 1
	levels[levNum].backgroundInformation = append(levels[levNum].backgroundInformation, zbgi)
	//FLOWERS
	num = RandInt(2, 9)
	for num > 0 {
		cntr := findRanCnt()
		siz := RandF32(be3, b/2)
		zbgi := BackgroundInformation{}
		zbgi.rectangle = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
		zbgi.imageRectangle = flowers[RandInt(0, len(flowers))]
		levels[levNum].flowers = append(levels[levNum].flowers, zbgi)
		num--
	}
	player.center = rl.NewVector2(levels[levNum].rectangles[0].X+levels[levNum].rectangles[0].Width-b2, levels[levNum].rectangles[0].Y+levels[levNum].rectangles[0].Height-b2)
	updatePlayerRectangle()
}
func makeScroll(num int) string { //MARK:MAKE SCROLL
	txt := ""
	if checkaddscroll(num) {
		for i := 0; i < len(scrollList[num].scrollprice); i++ {
			switch i {
			case 1:
				found := false
				newcost := scrollList[num].scrollprice[i]
				for j := 0; j < len(storeItm); j++ {
					if storeItm[j].name == "scroll ink" {
						if storeItm[j].numof > newcost {
							storeItm[j].numof -= newcost
							found = true
							break
						} else if storeItm[j].numof == newcost {
							storeItm[j].numof = 0
							storeItm[j].isOff = true
							storeItm[j] = Item{}
							found = true
							break
						} else if storeItm[j].numof < newcost {
							newcost -= storeItm[j].numof
							storeItm[j].numof = 0
							storeItm[j].isOff = true
							storeItm[j] = Item{}
						}
					}
				}
				if !found {
					for j := 0; j < len(player.inventory); j++ {
						if player.inventory[j].name == "scroll ink" {
							if player.inventory[j].numof > newcost {
								player.inventory[j].numof -= newcost
								break
							} else if player.inventory[j].numof == newcost {
								player.inventory[j].numof = 0
								player.inventory[j].isOff = true
								player.inventory[j] = Item{}
								break
							} else if player.inventory[j].numof < newcost {
								newcost -= player.inventory[j].numof
								player.inventory[j].numof = 0
								player.inventory[j].isOff = true
								player.inventory[j] = Item{}
							}
						}
					}
				}
			case 0:
				found := false
				newcost := scrollList[num].scrollprice[i]
				for j := 0; j < len(storeItm); j++ {
					if storeItm[j].name == "scroll paper" {
						if storeItm[j].numof > newcost {
							storeItm[j].numof -= newcost
							found = true
							break
						} else if storeItm[j].numof == newcost {
							storeItm[j].numof = 0
							storeItm[j].isOff = true
							storeItm[j] = Item{}
							found = true
							break
						} else if storeItm[j].numof < newcost {
							newcost -= storeItm[j].numof
							storeItm[j].numof = 0
							storeItm[j].isOff = true
							storeItm[j] = Item{}
						}
					}
				}
				if !found {
					for j := 0; j < len(player.inventory); j++ {
						if player.inventory[j].name == "scroll paper" {
							if player.inventory[j].numof > newcost {
								player.inventory[j].numof -= newcost
								break
							} else if player.inventory[j].numof == newcost {
								player.inventory[j].numof = 0
								player.inventory[j].isOff = true
								player.inventory[j] = Item{}
								break
							} else if player.inventory[j].numof < newcost {
								newcost -= player.inventory[j].numof
								player.inventory[j].numof = 0
								player.inventory[j].isOff = true
								player.inventory[j] = Item{}
							}
						}
					}
				}

			}

		}

		added := addscroll(num)
		if added {
			rl.PlaySound(audfx[48])
			txt = "created " + scrollList[num].name
		}

	} else {
		rl.PlaySound(audfx[43])
		txt = "no more space in inventory or store room"
	}
	return txt
}
func makePotion(num int) string { //MARK:MAKE POTION

	txt := ""

	if checkaddpotion(num) {
		for i := 0; i < len(potionList[num].potionPrice); i++ {
			if potionList[num].potionPrice[i] != 0 {
				switch i {
				case 5:
					found := false
					newcost := potionList[num].potionPrice[i]
					for j := 0; j < len(storeItm); j++ {
						if storeItm[j].name == "larimar mushroom" {
							if storeItm[j].numof > newcost {
								storeItm[j].numof -= newcost
								found = true
								break
							} else if storeItm[j].numof == newcost {
								storeItm[j].numof = 0
								storeItm[j].isOff = true
								storeItm[j] = Item{}
								found = true
								break
							} else if storeItm[j].numof < newcost {
								newcost -= storeItm[j].numof
								storeItm[j].numof = 0
								storeItm[j].isOff = true
								storeItm[j] = Item{}
							}
						}
					}
					if !found {
						for j := 0; j < len(player.inventory); j++ {
							if player.inventory[j].name == "larimar mushroom" {
								if player.inventory[j].numof > newcost {
									player.inventory[j].numof -= newcost
									break
								} else if player.inventory[j].numof == newcost {
									player.inventory[j].numof = 0
									player.inventory[j].isOff = true
									player.inventory[j] = Item{}
									break
								} else if player.inventory[j].numof < newcost {
									newcost -= player.inventory[j].numof
									player.inventory[j].numof = 0
									player.inventory[j].isOff = true
									player.inventory[j] = Item{}
								}
							}
						}
					}
				case 4:
					found := false
					newcost := potionList[num].potionPrice[i]
					for j := 0; j < len(storeItm); j++ {
						if storeItm[j].name == "jade mushroom" {
							if storeItm[j].numof > newcost {
								storeItm[j].numof -= newcost
								found = true
								break
							} else if storeItm[j].numof == newcost {
								storeItm[j].numof = 0
								storeItm[j].isOff = true
								storeItm[j] = Item{}
								found = true
								break
							} else if storeItm[j].numof < newcost {
								newcost -= storeItm[j].numof
								storeItm[j].numof = 0
								storeItm[j].isOff = true
								storeItm[j] = Item{}
							}
						}
					}
					if !found {
						for j := 0; j < len(player.inventory); j++ {
							if player.inventory[j].name == "jade mushroom" {
								if player.inventory[j].numof > newcost {
									player.inventory[j].numof -= newcost
									break
								} else if player.inventory[j].numof == newcost {
									player.inventory[j].numof = 0
									player.inventory[j].isOff = true
									player.inventory[j] = Item{}
									break
								} else if player.inventory[j].numof < newcost {
									newcost -= player.inventory[j].numof
									player.inventory[j].numof = 0
									player.inventory[j].isOff = true
									player.inventory[j] = Item{}
								}
							}
						}
					}
				case 3:
					found := false
					newcost := potionList[num].potionPrice[i]
					for j := 0; j < len(storeItm); j++ {
						if storeItm[j].name == "rubelite mushroom" {
							if storeItm[j].numof > newcost {
								storeItm[j].numof -= newcost
								found = true
								break
							} else if storeItm[j].numof == newcost {
								storeItm[j].numof = 0
								storeItm[j].isOff = true
								storeItm[j] = Item{}
								found = true
								break
							} else if storeItm[j].numof < newcost {
								newcost -= storeItm[j].numof
								storeItm[j].numof = 0
								storeItm[j].isOff = true
								storeItm[j] = Item{}
							}
						}
					}
					if !found {
						for j := 0; j < len(player.inventory); j++ {
							if player.inventory[j].name == "rubelite mushroom" {
								if player.inventory[j].numof > newcost {
									player.inventory[j].numof -= newcost
									break
								} else if player.inventory[j].numof == newcost {
									player.inventory[j].numof = 0
									player.inventory[j].isOff = true
									player.inventory[j] = Item{}
									break
								} else if player.inventory[j].numof < newcost {
									newcost -= player.inventory[j].numof
									player.inventory[j].numof = 0
									player.inventory[j].isOff = true
									player.inventory[j] = Item{}
								}
							}
						}
					}
				case 2:
					found := false
					newcost := potionList[num].potionPrice[i]
					for j := 0; j < len(storeItm); j++ {
						if storeItm[j].name == "topaz mushroom" {
							if storeItm[j].numof > newcost {
								storeItm[j].numof -= newcost
								found = true
								break
							} else if storeItm[j].numof == newcost {
								storeItm[j].numof = 0
								storeItm[j].isOff = true
								storeItm[j] = Item{}
								found = true
								break
							} else if storeItm[j].numof < newcost {
								newcost -= storeItm[j].numof
								storeItm[j].numof = 0
								storeItm[j].isOff = true
								storeItm[j] = Item{}
							}
						}
					}
					if !found {
						for j := 0; j < len(player.inventory); j++ {
							if player.inventory[j].name == "topaz mushroom" {
								if player.inventory[j].numof > newcost {
									player.inventory[j].numof -= newcost
									break
								} else if player.inventory[j].numof == newcost {
									player.inventory[j].numof = 0
									player.inventory[j].isOff = true
									player.inventory[j] = Item{}
									break
								} else if player.inventory[j].numof < newcost {
									newcost -= player.inventory[j].numof
									player.inventory[j].numof = 0
									player.inventory[j].isOff = true
									player.inventory[j] = Item{}
								}
							}
						}
					}
				case 1:
					found := false
					newcost := potionList[num].potionPrice[i]
					for j := 0; j < len(storeItm); j++ {
						if storeItm[j].name == "zircon mushroom" {
							if storeItm[j].numof > newcost {
								storeItm[j].numof -= newcost
								found = true
								break
							} else if storeItm[j].numof == newcost {
								storeItm[j].numof = 0
								storeItm[j].isOff = true
								storeItm[j] = Item{}
								found = true
								break
							} else if storeItm[j].numof < newcost {
								newcost -= storeItm[j].numof
								storeItm[j].numof = 0
								storeItm[j].isOff = true
								storeItm[j] = Item{}
							}
						}
					}
					if !found {
						for j := 0; j < len(player.inventory); j++ {
							if player.inventory[j].name == "zircon mushroom" {
								if player.inventory[j].numof > newcost {
									player.inventory[j].numof -= newcost
									break
								} else if player.inventory[j].numof == newcost {
									player.inventory[j].numof = 0
									player.inventory[j].isOff = true
									player.inventory[j] = Item{}
									break
								} else if player.inventory[j].numof < newcost {
									newcost -= player.inventory[j].numof
									player.inventory[j].numof = 0
									player.inventory[j].isOff = true
									player.inventory[j] = Item{}
								}
							}
						}
					}
				case 0:
					found := false
					newcost := potionList[num].potionPrice[i]
					for j := 0; j < len(storeItm); j++ {
						if storeItm[j].name == "amethyst mushroom" {
							if storeItm[j].numof > newcost {
								storeItm[j].numof -= newcost
								found = true
								break
							} else if storeItm[j].numof == newcost {
								storeItm[j].numof = 0
								storeItm[j].isOff = true
								storeItm[j] = Item{}
								found = true
								break
							} else if storeItm[j].numof < newcost {
								newcost -= storeItm[j].numof
								storeItm[j].numof = 0
								storeItm[j].isOff = true
								storeItm[j] = Item{}
							}
						}
					}
					if !found {
						for j := 0; j < len(player.inventory); j++ {
							if player.inventory[j].name == "amethyst mushroom" {
								if player.inventory[j].numof > newcost {
									player.inventory[j].numof -= newcost
									break
								} else if player.inventory[j].numof == newcost {
									player.inventory[j].numof = 0
									player.inventory[j].isOff = true
									player.inventory[j] = Item{}
									break
								} else if player.inventory[j].numof < newcost {
									newcost -= player.inventory[j].numof
									player.inventory[j].numof = 0
									player.inventory[j].isOff = true
									player.inventory[j] = Item{}
								}
							}
						}
					}

				}
			}
		}

		added := addpotion(num)
		if added {
			rl.PlaySound(audfx[48])
			txt = "created " + potionList[num].name
		}
	} else {
		rl.PlaySound(audfx[43])
		txt = "no more space in inventory or store room"
	}
	return txt
}
func maketreasureroom() { //MARK:MAKE TREASURE ROOM
	//WALLS FLOOR
	floortile = floorTiles[RandInt(0, len(floorTiles))]
	walltile = wallTiles[RandInt(0, len(wallTiles))]
	W3 := float32(3840)
	H3 := float32(2160)
	bossBordRectangle = rl.NewRectangle(currentPosition.X-W3/2, currentPosition.Y-H3/2, W3, H3)
	bossBordRectangle.X -= b3
	bossBordRectangle.Y -= b3
	bossBordRectangle.Width += b6
	bossBordRectangle.Height += b6
	zboss := x1scr{}
	//CENTER REC
	min, max := 20, 29
	numW := RandInt(min, max)
	min, max = 15, 23
	numH := RandInt(min, max)
	W, H := float32(numW)*b, float32(numH)*b
	rec := rl.NewRectangle(currentPosition.X-W/2, currentPosition.Y-H/2, W, H)
	zboss.rectangles = append(zboss.rectangles, rec)
	numWo := numW
	numHo := numH
	//OTHER RECS
	countbreak := 100
	num := RandInt(5, 11)
	for num > 0 {
		side := RandInt(1, 5)
		switch side {
		case 1:
			min, max := 3, 6
			numW = RandInt(min, max)
			min, max = 2, 5
			numH = RandInt(min, max)
			W, H = float32(numW)*b, float32(numH)*b
			diff := numWo - numW
			change := float32(RandInt(0, diff))
			x := zboss.rectangles[0].X + (change * b)
			y := zboss.rectangles[0].Y - H
			rec = rl.NewRectangle(x, y, W, H)
		case 2:
			min, max := 2, 5
			numW = RandInt(min, max)
			min, max = 3, 6
			numH = RandInt(min, max)
			W, H = float32(numW)*b, float32(numH)*b
			diff := numHo - numH
			change := float32(RandInt(0, diff))
			x := zboss.rectangles[0].X + zboss.rectangles[0].Width
			y := zboss.rectangles[0].Y + (change * b)
			rec = rl.NewRectangle(x, y, W, H)
		case 3:
			min, max := 3, 6
			numW = RandInt(min, max)
			min, max = 2, 5
			numH = RandInt(min, max)
			W, H = float32(numW)*b, float32(numH)*b
			diff := numWo - numW
			change := float32(RandInt(0, diff))
			x := zboss.rectangles[0].X + (change * b)
			y := zboss.rectangles[0].Y + zboss.rectangles[0].Height
			rec = rl.NewRectangle(x, y, W, H)
		case 4:
			min, max := 2, 5
			numW = RandInt(min, max)
			min, max = 3, 6
			numH = RandInt(min, max)
			W, H = float32(numW)*b, float32(numH)*b
			diff := numHo - numH
			change := float32(RandInt(0, diff))
			x := zboss.rectangles[0].X - W
			y := zboss.rectangles[0].Y + (change * b)
			rec = rl.NewRectangle(x, y, W, H)
		}
		if len(zboss.rectangles) > 1 {
			canadd := true
			for i := 1; i < len(zboss.rectangles); i++ {
				if rl.CheckCollisionRecs(rec, zboss.rectangles[i]) {
					canadd = false
				}
			}
			if canadd {
				v1 := rl.NewVector2(rec.X, rec.Y)
				v2 := v1
				v2.X += rec.Width
				v3 := v2
				v3.Y += rec.Height
				v4 := v3
				v4.X -= rec.Width
				if !rl.CheckCollisionPointRec(v1, bossBordRectangle) || !rl.CheckCollisionPointRec(v2, bossBordRectangle) || !rl.CheckCollisionPointRec(v3, bossBordRectangle) || !rl.CheckCollisionPointRec(v4, bossBordRectangle) {
					canadd = false
				}
			}
			if canadd {
				zboss.rectangles = append(zboss.rectangles, rec)
				num--
			}
		} else {
			canadd := true
			if canadd {
				v1 := rl.NewVector2(rec.X, rec.Y)
				v2 := v1
				v2.X += rec.Width
				v3 := v2
				v3.Y += rec.Height
				v4 := v3
				v4.X -= rec.Width
				if !rl.CheckCollisionPointRec(v1, bossBordRectangle) || !rl.CheckCollisionPointRec(v2, bossBordRectangle) || !rl.CheckCollisionPointRec(v3, bossBordRectangle) || !rl.CheckCollisionPointRec(v4, bossBordRectangle) {
					canadd = false
				}
			}
			if canadd {
				zboss.rectangles = append(zboss.rectangles, rec)
				num--
			}
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	//WALLS
	for i := 0; i < len(zboss.rectangles); i++ {
		siz := b
		x := zboss.rectangles[i].X
		y := zboss.rectangles[i].Y
		x -= siz
		y -= siz
		//TOP BOTTOM
		for x <= zboss.rectangles[i].X+zboss.rectangles[i].Width {
			rec := rl.NewRectangle(x, y, siz, siz)
			canadd := true
			for i := 0; i < len(zboss.rectangles); i++ {
				if rl.CheckCollisionRecs(rec, zboss.rectangles[i]) {
					canadd = false
				}
			}
			if canadd && len(zboss.walls) > 1 {
				for i := 0; i < len(zboss.walls); i++ {
					if rl.CheckCollisionRecs(rec, zboss.walls[i].rectangle) {
						canadd = false
					}
				}
			}
			if canadd {
				ztile := Tile{}
				ztile.rectangle = rec
				ztile.image = wallBoss
				ztile.fade = RandF32(0.4, 0.7)
				ztile.color = rl.White
				ztile.color2 = RandColor()
				ztile.solid = true
				zboss.walls = append(zboss.walls, ztile)
			}
			rec.Y += zboss.rectangles[i].Height + siz
			canadd = true
			for i := 0; i < len(zboss.rectangles); i++ {
				if rl.CheckCollisionRecs(rec, zboss.rectangles[i]) {
					canadd = false
				}
			}
			if canadd && len(zboss.walls) > 1 {
				for i := 0; i < len(zboss.walls); i++ {
					if rl.CheckCollisionRecs(rec, zboss.walls[i].rectangle) {
						canadd = false
					}
				}
			}
			if canadd {
				ztile := Tile{}
				ztile.rectangle = rec
				ztile.image = wallBoss
				ztile.fade = RandF32(0.3, 0.9)
				ztile.color = rl.White
				ztile.color2 = RandColor()
				ztile.solid = true
				zboss.walls = append(zboss.walls, ztile)
			}
			x += siz
		}
		//RIGHT LEFT
		x = zboss.rectangles[i].X
		y = zboss.rectangles[i].Y
		x -= siz
		for y < zboss.rectangles[i].Y+zboss.rectangles[i].Height {
			rec := rl.NewRectangle(x, y, siz, siz)
			canadd := true
			for i := 0; i < len(zboss.rectangles); i++ {
				if rl.CheckCollisionRecs(rec, zboss.rectangles[i]) {
					canadd = false
				}
			}
			if canadd && len(zboss.walls) > 1 {
				for i := 0; i < len(zboss.walls); i++ {
					if rl.CheckCollisionRecs(rec, zboss.walls[i].rectangle) {
						canadd = false
					}
				}
			}
			if canadd {
				ztile := Tile{}
				ztile.rectangle = rec
				ztile.image = wallBoss
				ztile.fade = RandF32(0.4, 0.7)
				ztile.color = rl.White
				ztile.color2 = RandColor()
				ztile.solid = true
				zboss.walls = append(zboss.walls, ztile)
			}
			rec.X += zboss.rectangles[i].Width + siz
			canadd = true
			for i := 0; i < len(zboss.rectangles); i++ {
				if rl.CheckCollisionRecs(rec, zboss.rectangles[i]) {
					canadd = false
				}
			}
			if canadd && len(zboss.walls) > 1 {
				for i := 0; i < len(zboss.walls); i++ {
					if rl.CheckCollisionRecs(rec, zboss.walls[i].rectangle) {
						canadd = false
					}
				}
			}
			if canadd {
				ztile := Tile{}
				ztile.rectangle = rec
				ztile.image = wallBoss
				ztile.fade = RandF32(0.4, 0.7)
				ztile.color = rl.White
				ztile.color2 = RandColor()
				ztile.solid = true
				zboss.walls = append(zboss.walls, ztile)
			}
			y += siz
		}
	}
	//FLOORS
	for i := 0; i < len(zboss.rectangles); i++ {
		siz := b
		x := zboss.rectangles[i].X
		y := zboss.rectangles[i].Y
		for y < zboss.rectangles[i].Y+zboss.rectangles[i].Height {
			rec := rl.NewRectangle(x, y, siz, siz)
			ztile := Tile{}
			ztile.rectangle = rec
			ztile.image = floorBoss
			ztile.color = rl.White
			ztile.color2 = RandColor()
			ztile.fade = RandF32(0.04, 0.08)
			zboss.floors = append(zboss.floors, ztile)
			x += siz
			if x >= zboss.rectangles[i].X+zboss.rectangles[i].Width {
				x = zboss.rectangles[i].X
				y += siz
			}
		}
	}

	//PLAYER CENTER
	player.center = rl.NewVector2(zboss.rectangles[0].X+zboss.rectangles[0].Width-b2, zboss.rectangles[0].Y+zboss.rectangles[0].Height-b2)
	updatePlayerRectangle()

	//ROOM TYPE
	choose := RandInt(1, 9)
	switch choose {
	case 8:

		countbreak := 100
		num := RandInt(10, 21)

		size := b
		for num > 0 {
			i := RandInt(0, len(zboss.rectangles))
			if Roll6() > 2 {
				i = 0
			}
			//SPIKE TRAPS
			if FlipCoin() {
				x := zboss.rectangles[i].X
				y := zboss.rectangles[i].Y
				x2 := x + zboss.rectangles[i].Width - size
				y2 := y + zboss.rectangles[i].Height - size
				ztile := Tile{}
				ztile.name = "spiketrap"
				ztile.image = animation[1].rectangle
				ztile.color = rl.White
				ztile.color2 = RandColor()
				ztile.fade = 1
				ztile.rectangle = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
				if checkaddtilerecInner(ztile.rectangle, zboss) && checkaddetc(ztile.rectangle, zboss) {
					ztile.center = makecnt(ztile.rectangle)
					zboss.otherTiles = append(zboss.otherTiles, ztile)
					num--
				}
			}
			//FLAME TRAPS
			if FlipCoin() {
				x := zboss.rectangles[i].X
				y := zboss.rectangles[i].Y
				x2 := x + zboss.rectangles[i].Width - size
				y2 := y + zboss.rectangles[i].Height - size
				ztile := Tile{}
				ztile.name = "flametrap"
				ztile.image = animation[2].rectangle
				ztile.color = rl.White
				ztile.fade = 1
				ztile.rectangle = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
				if checkaddtilerecInner(ztile.rectangle, zboss) && checkaddetc(ztile.rectangle, zboss) {
					ztile.rectangle2 = ztile.rectangle
					ztile.rectangle2.Height = 32
					ztile.rectangle2.Y += 4.5
					ztile.center = makecnt(ztile.rectangle)
					zboss.otherTiles = append(zboss.otherTiles, ztile)
					num--
				}
			}
			countbreak--
			if countbreak == 0 {
				break
			}
		}

		countbreak = 100
		num = RandInt(3, 8)
		for num > 0 {
			size := RandF32(b, b3)
			x := zboss.rectangles[0].X + size
			y := zboss.rectangles[0].Y + size
			x2 := x + zboss.rectangles[0].Width - size*3
			y2 := y + zboss.rectangles[0].Height - size*3
			ztile := Tile{}
			ztile.image = walltile
			ztile.color2 = RandColor()
			ztile.color = rl.White
			ztile.fade = RandF32(0.3, 0.9)
			ztile.rectangle = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
			ztile.spikes = true
			if ztile.spikes {
				for j := 0; j < 4; j++ {
					ztile.color2 = RandColor()
					rec2 := ztile.rectangle
					rec2.X += ztile.rectangle.Width / 4
					rec2.Y += ztile.rectangle.Height / 4
					rec2.Width -= ztile.rectangle.Width / 2
					rec2.Height -= ztile.rectangle.Height / 2
					ztile.spikeRectangles = append(ztile.spikeRectangles, rec2)
				}
			}
			if checkaddtilerecInner(ztile.rectangle, zboss) && checkRecPlayer(ztile.rectangle) {
				ztile.speed = RandF32(b/12, b/7)
				if FlipCoin() {
					ztile.dirX = ztile.speed
					if FlipCoin() {
						ztile.dirX = -ztile.dirX
					}
				} else {
					ztile.dirY = ztile.speed
					if FlipCoin() {
						ztile.dirY = -ztile.dirY
					}
				}
				zboss.walls = append(zboss.walls, ztile)
				num--
			}
			countbreak--
			if countbreak == 0 {
				break
			}

		}

		num = RandInt(10, 16) //FLAME HEAD
		for num > 0 {
			zenm := Enemy{}
			zenm = enmlist[13]
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rectangle = rl.NewRectangle(zenm.cnt.X-zenm.rectangle.Width/2, zenm.cnt.Y-zenm.rectangle.Height/2, zenm.rectangle.Width, zenm.rectangle.Height)
			zboss.enemies = append(zboss.enemies, zenm)
			zboss.enemyNum++
			num--
		}

	case 7:
		zboss = makeswitchesTreasureRoom(zboss, 0)
		num := RandInt(5, 9) //ROTATING SPIKES
		for num > 0 {
			zenm := Enemy{}
			zenm = enmlist[24]
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rectangle = rl.NewRectangle(zenm.cnt.X-zenm.rectangle.Width/2, zenm.cnt.Y-zenm.rectangle.Height/2, zenm.rectangle.Width, zenm.rectangle.Height)
			zboss.enemies = append(zboss.enemies, zenm)
			zboss.enemyNum++
			num--
		}
		num = RandInt(5, 9) //ROBOT
		for num > 0 {
			zenm := Enemy{}
			zenm = enmlist[18]
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rectangle = rl.NewRectangle(zenm.cnt.X-zenm.rectangle.Width/2, zenm.cnt.Y-zenm.rectangle.Height/2, zenm.rectangle.Width, zenm.rectangle.Height)
			zboss.enemies = append(zboss.enemies, zenm)
			zboss.enemyNum++
			num--
		}
		num = RandInt(5, 9) //ROCK
		for num > 0 {
			zenm := Enemy{}
			zenm = enmlist[21]
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rectangle = rl.NewRectangle(zenm.cnt.X-zenm.rectangle.Width/2, zenm.cnt.Y-zenm.rectangle.Height/2, zenm.rectangle.Width, zenm.rectangle.Height)
			zboss.enemies = append(zboss.enemies, zenm)
			zboss.enemyNum++
			num--
		}
	case 6:
		zboss = makeswitchesTreasureRoom(zboss, 0)
		num := RandInt(5, 9) //RED ANTENNA
		for num > 0 {
			zenm := Enemy{}
			zenm = enmlist[4]
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rectangle = rl.NewRectangle(zenm.cnt.X-zenm.rectangle.Width/2, zenm.cnt.Y-zenm.rectangle.Height/2, zenm.rectangle.Width, zenm.rectangle.Height)
			zenm.atkT = RandInt32(1, 5) * fps
			zboss.enemies = append(zboss.enemies, zenm)
			zboss.enemyNum++
			num--
		}
	case 5:
		zboss = makeswitchesTreasureRoom(zboss, 0)
		num := RandInt(20, 31) //FLY
		for num > 0 {
			zenm := Enemy{}
			zenm = enmlist[12]
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rectangle = rl.NewRectangle(zenm.cnt.X-zenm.rectangle.Width/2, zenm.cnt.Y-zenm.rectangle.Height/2, zenm.rectangle.Width, zenm.rectangle.Height)
			zboss.enemies = append(zboss.enemies, zenm)
			zboss.enemyNum++
			num--
		}
	case 4:
		num := RandInt(40, 61) //RED BOMB
		for num > 0 {
			zenm := Enemy{}
			zenm = enmlist[2]
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rectangle = rl.NewRectangle(zenm.cnt.X-zenm.rectangle.Width/2, zenm.cnt.Y-zenm.rectangle.Height/2, zenm.rectangle.Width, zenm.rectangle.Height)
			zboss.enemies = append(zboss.enemies, zenm)
			zboss.enemyNum++
			num--
		}
	case 3:
		zboss = makeswitchesTreasureRoom(zboss, 1)
		num := RandInt(25, 36) //CARROT
		for num > 0 {
			zenm := Enemy{}
			zenm = enmlist[17]
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rectangle = rl.NewRectangle(zenm.cnt.X-zenm.rectangle.Width/2, zenm.cnt.Y-zenm.rectangle.Height/2, zenm.rectangle.Width, zenm.rectangle.Height)
			zboss.enemies = append(zboss.enemies, zenm)
			zboss.enemyNum++
			num--
		}
	case 2:
		num := RandInt(70, 91) //BALLOON
		for num > 0 {
			zenm := Enemy{}
			zenm = enmlist[5]
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rectangle = rl.NewRectangle(zenm.cnt.X-zenm.rectangle.Width/2, zenm.cnt.Y-zenm.rectangle.Height/2, zenm.rectangle.Width, zenm.rectangle.Height)
			zboss.enemies = append(zboss.enemies, zenm)
			zboss.enemyNum++
			num--
		}
	case 1:
		num := RandInt(25, 36) //FLAME HEAD
		for num > 0 {
			zenm := Enemy{}
			zenm = enmlist[13]
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
			zenm.cnt = findRanCntLevTreasureRoom(zboss)
			zenm.rectangle = rl.NewRectangle(zenm.cnt.X-zenm.rectangle.Width/2, zenm.cnt.Y-zenm.rectangle.Height/2, zenm.rectangle.Width, zenm.rectangle.Height)
			zboss.enemies = append(zboss.enemies, zenm)
			zboss.enemyNum++
			num--
		}
	}

	//CHEST
	siz := b2
	zchst := Chest{}
	zchst.slots = 4
	for i := 0; i < zchst.slots; i++ {
		zchst.item = append(zchst.item, Item{})
	}
	countbreak = 100
	var unloknums []int
	for i := 27; i < len(itemList); i++ {
		if !itemList[i].isUnlocked && !itemList[i].isNoCrate {
			unloknums = append(unloknums, i)
		}
	}
	count := 0
	for zchst.item[3].name == "" {
		zchst.item[count] = itemList[unloknums[RandInt(0, len(unloknums))]]

		if zchst.item[count].name == "gold" || zchst.item[count].name == "silver" || zchst.item[count].name == "platinum" || zchst.item[count].name == "bronze" || zchst.item[count].name == "lead" {
			zchst.item[count].numof = RandInt(40, 71)
		} else if zchst.item[count].name == "hp potion full" || zchst.item[count].name == "mana potion full" || zchst.item[count].name == "beetroot" || zchst.item[count].name == "honeycomb" || zchst.item[count].name == "bomb" || zchst.item[count].name == "soda" || zchst.item[count].name == "jar of gas" || zchst.item[count].name == "jar of blood" || zchst.item[count].name == "pistol" || zchst.item[count].name == "popcorn" || zchst.item[count].name == "ladybug" {
			zchst.item[count].numof = RandInt(1, 11)
		}

		count++
		countbreak--
		if countbreak == 0 {
			break
		}
	}

	zchst.image = animation[4].rectangle
	zchst.center = makecnt(zboss.rectangles[len(zboss.rectangles)-1])
	zchst.rectangle = rl.NewRectangle(zchst.center.X-siz/2, zchst.center.Y-siz/2, siz, siz)
	zchst.collisionRectangle = zchst.rectangle
	zchst.collisionRectangle.X += zchst.collisionRectangle.Width / 4
	zchst.collisionRectangle.Y += zchst.collisionRectangle.Height / 2
	zchst.collisionRectangle.Y -= 4
	zchst.collisionRectangle.Width = zchst.collisionRectangle.Width / 2
	zchst.collisionRectangle.Height = (zchst.collisionRectangle.Height / 9) * 4
	zboss.chests = append(zboss.chests, zchst)

	levels = append(levels, zboss)
	//BGI
	siz = RandF32(b2, b4)
	x := levels[levNum].rectangles[0].X + b/2
	x += RandF32(0, levels[levNum].rectangles[0].Width-(siz+b))
	y := levels[levNum].rectangles[0].Y + b/2
	y += RandF32(0, levels[levNum].rectangles[0].Height-(siz+b))
	rec = rl.NewRectangle(x, y, siz, siz)
	zbgi := bgilist[RandInt(0, len(bgilist))]
	zbgi.rectangle = rec
	zbgi.fade = 1
	levels[levNum].backgroundInformation = append(levels[levNum].backgroundInformation, zbgi)
	//FLOWERS
	num = RandInt(2, 9)
	for num > 0 {
		cntr := findRanCnt()
		siz := RandF32(be3, b/2)
		zbgi := BackgroundInformation{}
		zbgi.rectangle = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
		zbgi.imageRectangle = flowers[RandInt(0, len(flowers))]
		levels[levNum].flowers = append(levels[levNum].flowers, zbgi)
		num--
	}

	player.center = rl.NewVector2(levels[levNum].rectangles[0].X+levels[levNum].rectangles[0].Width-b2, levels[levNum].rectangles[0].Y+levels[levNum].rectangles[0].Height-b2)
	updatePlayerRectangle()

	completed := makeexit()
	if !completed {
		makelevel()
	}

}
func makeenemies() { //MARK:MAKE ENEMIES

	num := 0

	switch levNumDis {
	case 1:
		num = RandInt(10, 16)
	case 2:
		num = RandInt(10, 16)
	case 3:
		num = RandInt(10, 16)
	case 4:
		num = RandInt(15, 21)
	case 5:
		num = RandInt(15, 21)
	case 6:
		num = RandInt(15, 21)
	case 7:
		num = RandInt(20, 26)
	case 8:
		num = RandInt(20, 26)
	case 9:
		num = RandInt(20, 26)
	case 10:
		num = RandInt(30, 36)
	default:
		num = RandInt(10, 16)
	}

	if bosskey2 {
		num += RandInt(1, 4)
	}
	if bosskey3 {
		num += RandInt(1, 4)
	}

	countbreak := 500
	for {
		zenm := Enemy{}
		choose := 0

		switch levNumDis {
		case 1:
			choose = RandInt(0, 3)
			if bosskey1 || bosskey2 {
				choose = RandInt(0, 4)
			}
		case 2:
			choose = RandInt(0, 5)
			if bosskey1 || bosskey2 {
				choose = RandInt(0, 6)
			}
		case 3:
			choose = RandInt(0, 6)
			if bosskey1 || bosskey2 {
				choose = RandInt(0, 7)
			}
		case 4:
			choose = RandInt(0, 9)
			if bosskey1 || bosskey2 {
				choose = RandInt(0, 11)
			}
		case 5:
			choose = RandInt(0, 12)
			if bosskey1 || bosskey2 {
				choose = RandInt(0, 13)
			}
		case 6:
			choose = RandInt(0, 13)
			if bosskey1 || bosskey2 {
				choose = RandInt(0, 15)
			}
		case 7:
			choose = RandInt(0, 15)
			if bosskey1 || bosskey2 {
				choose = RandInt(0, 17)
			}
		case 8:
			choose = RandInt(0, 17)
			if bosskey1 || bosskey2 {
				choose = RandInt(0, 19)
			}
		case 9:
			choose = RandInt(0, 20)
			if bosskey2 {
				choose = RandInt(0, 25)
			} else if bosskey1 {
				choose = RandInt(0, 23)
			}

		case 10:
			choose = RandInt(0, 21)
			if bosskey2 {
				choose = RandInt(0, 25)
			} else if bosskey1 {
				choose = RandInt(0, 24)
			}
		}

		switch choose {
		case 0:
			zenm = enmlist[0] //BLUE SPIKE
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
		case 1:
			zenm = enmlist[1] //RED EYE
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
		case 2:
			zenm = enmlist[11] //WORM
			countbreak := 100
			for {
				zenm.dirX = RandF32(-zenm.speed, zenm.speed)
				countbreak--
				if countbreak == 0 || Abs(zenm.dirX) > zenm.speed/2 {
					break
				}
			}
		case 3:
			zenm = enmlist[13] //FLAME HEAD
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
		case 4:
			zenm = enmlist[2] //RED BOMB
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
		case 5:
			zenm = enmlist[4] //RED ANTENNA
			countbreak := 100
			for {
				zenm.dirX = RandF32(-zenm.speed, zenm.speed)
				if Abs(zenm.dirX) > 0.4 {
					break
				}
				countbreak--
				if countbreak == 0 {
					break
				}
			}
			zenm.atkT = RandInt32(1, 5) * fps
		case 6:
			zenm = enmlist[5] //BALLOON
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
		case 7:
			zenm = enmlist[12] //FLY
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
		case 8:
			zenm = enmlist[14] //ORANGE
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
		case 9:
			zenm = enmlist[9] //YELLOW DINO
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
		case 10:
			zenm = enmlist[3] //GHOST
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
		case 11:
			zenm = enmlist[6] //CROCODILE
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
		case 12:
			zenm = enmlist[7] //PINK CART WHEEL
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
			zenm.atkT = fps * RandInt32(1, 3)
		case 13:
			zenm = enmlist[8] //GREEN PLANT
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
			zenm.moveChangeT = fps * RandInt32(2, 5)
			zenm.atkT = fps / 4
		case 14:
			zenm = enmlist[10] //BLACK DOT
			zenm.numMax = RandInt(4, 11)
			zenm.atkT = fps
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
		case 15:
			zenm = enmlist[15] //SKELETON
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
		case 16:
			zenm = enmlist[16] //RED BLOB
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
		case 17:
			zenm = enmlist[17] //CARROT
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
		case 18:
			zenm = enmlist[20] //RED DEVIL
		case 19:
			zenm = enmlist[21] //ROCK GUY
			zenm.idl = true
			zenm.moveChangeT = fps * 2
		case 20:
			zenm = enmlist[22] //BIRD
		case 21:
			zenm = enmlist[24] //ROTATING SPIKES
		case 22:
			zenm = enmlist[19] //GREEN PIG
			zenm.dirX = RandF32(-zenm.speed, zenm.speed)
			zenm.dirY = RandF32(-zenm.speed, zenm.speed)
		case 23:
			zenm = enmlist[23] //JERSEY
		case 24:
			zenm = enmlist[18] //ROBOT
		}

		//INCREASE HP WEAP DMG STR
		switch maxWeapDmg {
		case 3:
			zenm.hpMax++
			zenm.hp = zenm.hpMax
		case 4, 5:
			zenm.hpMax += 2
			zenm.hp = zenm.hpMax
		case 6, 7:
			zenm.hpMax += 4
			zenm.hp = zenm.hpMax
		case 8, 9, 10, 11, 12:
			zenm.hpMax += 7
			zenm.hp = zenm.hpMax
		}
		switch stats.strength {
		case 2:
			zenm.hpMax++
			zenm.hp = zenm.hpMax
		case 3:
			zenm.hpMax += 2
			zenm.hp = zenm.hpMax
		case 4:
			zenm.hpMax += 4
			zenm.hp = zenm.hpMax
		case 5:
			zenm.hpMax += 5
			zenm.hp = zenm.hpMax
		}

		canadd := false
		zenm.rectangle, canadd = findranrecpos(zenm.rectangle)

		if canadd {
			zenm.cnt = makecnt(zenm.rectangle)
			switch zenm.name {
			case "bush":
				zenm.collisionRectangle.Y += zenm.collisionRectangle.Width / 4
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
				zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 2
				zenm.collisionRectangle.Height -= zenm.collisionRectangle.Height / 4
				zenm.carec = zenm.rectangle
				zenm.carec.X -= b4
				zenm.carec.Y -= b4
				zenm.carec.Width += b8
				zenm.carec.Height += b8
			case "jersey":
				zenm.collisionRectangle.Y += zenm.collisionRectangle.Width / 2
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
				zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 2
				zenm.collisionRectangle.Height = zenm.collisionRectangle.Height / 2
			case "bird":
				zenm.collisionRectangle.Y += zenm.collisionRectangle.Width / 8
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 8
				zenm.collisionRectangle.Width -= zenm.collisionRectangle.Width / 4
				zenm.collisionRectangle.Height -= zenm.collisionRectangle.Height / 4
			case "greenpig":
				zenm.collisionRectangle.Y += zenm.collisionRectangle.Width / 3
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 3
				zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 3
				zenm.collisionRectangle.Height = zenm.collisionRectangle.Height / 3
				zenm.collisionRectangle.Y += 4
			case "robot":
				zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 2
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
				zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 2
				zenm.collisionRectangle.Height = zenm.collisionRectangle.Height / 2
				zenm.carec = zenm.collisionRectangle
				zenm.carec.X -= b5
				zenm.carec.Y -= b5
				zenm.carec.Width += b10
				zenm.carec.Height += b10
			case "carrot":
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 8
				zenm.collisionRectangle.Width -= zenm.collisionRectangle.Width / 4
				zenm.carec = zenm.rectangle
				zenm.carec.X -= b4
				zenm.carec.Y -= b4
				zenm.carec.Width += b8
				zenm.carec.Height += b8
			case "redblob":
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
				zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 2
				zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 2
				zenm.collisionRectangle.Height = zenm.collisionRectangle.Height / 2
			case "skeleton":
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
				zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 2
				zenm.collisionRectangle.Height -= zenm.collisionRectangle.Height / 8
			case "orange":
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
				zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 2
				zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 3
				zenm.collisionRectangle.Height = zenm.collisionRectangle.Height / 2
				zenm.carec = zenm.rectangle
				zenm.carec.X -= b3
				zenm.carec.Y -= b3
				zenm.carec.Width += b6
				zenm.carec.Height += b6
			case "flamehead":
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
				zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 2
				zenm.carec = zenm.rectangle
				zenm.carec.X -= b3
				zenm.carec.Y -= b3
				zenm.carec.Width += b6
				zenm.carec.Height += b6
			case "fly":
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
				zenm.collisionRectangle.Width -= zenm.collisionRectangle.Width / 2
				zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 4
				zenm.collisionRectangle.Height -= zenm.collisionRectangle.Height / 2
				zenm.carec = zenm.rectangle
				zenm.carec.X -= b3
				zenm.carec.Y -= b3
				zenm.carec.Width += b6
				zenm.carec.Height += b6
			case "worm":
				zenm.collisionRectangle.Y += (zenm.collisionRectangle.Height / 4) * 3
				zenm.collisionRectangle.Height = zenm.collisionRectangle.Height / 4
			case "yellowdino":
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 8
				zenm.collisionRectangle.Width -= zenm.collisionRectangle.Width / 4
				zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 3
				zenm.collisionRectangle.Height = (zenm.collisionRectangle.Height / 3) * 2
			case "greenplant":
				zenm.collisionRectangle.Y += (zenm.collisionRectangle.Height / 3) * 2
				zenm.collisionRectangle.Height = zenm.collisionRectangle.Height / 3
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 3
				zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 3
			case "pinkcart":
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
				zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 2
				zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 2
				zenm.collisionRectangle.Height = zenm.collisionRectangle.Height / 2
			case "crocodile":
				zenm.collisionRectangle.Y += (zenm.collisionRectangle.Height / 12) * 7
				zenm.collisionRectangle.Height = (zenm.collisionRectangle.Height / 12) * 5
				zenm.carec = zenm.collisionRectangle
				zenm.carec.X -= b4
				zenm.carec.Width += b8
			case "balloon":
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
				zenm.collisionRectangle.Width -= zenm.collisionRectangle.Width / 2
				zenm.collisionRectangle.Y += 4
				zenm.collisionRectangle.Height -= zenm.collisionRectangle.Height / 2
			case "redantenna":
				zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 3
				zenm.collisionRectangle.Height -= zenm.collisionRectangle.Height / 3
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 6
				zenm.collisionRectangle.Width -= zenm.collisionRectangle.Width / 3
			case "ghost":
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 8
				zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 8
				zenm.collisionRectangle.Width -= zenm.collisionRectangle.Width / 4
				zenm.collisionRectangle.Height -= zenm.collisionRectangle.Height / 4
				//AREA REC
				zenm.carec = zenm.rectangle
				zenm.carec.X -= b3
				zenm.carec.Y -= b3
				zenm.carec.Width += b6
				zenm.carec.Height += b6
			case "redeye", "redbomb":
				zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 4
				zenm.collisionRectangle.Height -= zenm.collisionRectangle.Height / 4
			case "bluespike":
				zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 8
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 8
				zenm.collisionRectangle.Width -= zenm.collisionRectangle.Width / 4
				zenm.collisionRectangle.Height -= zenm.collisionRectangle.Height / 4
			}

			levels[levNum].enemies = append(levels[levNum].enemies, zenm)
			levels[levNum].enemyNum++
			num--
		}

		countbreak--
		if num == 0 || countbreak == 0 {
			break
		}
	}

}
func makenemcollisrecs() {

	for i := 0; i < len(levels[levNum].enemies); i++ {
		levels[levNum].enemies[i].collisionRectangle = levels[levNum].enemies[i].rectangle
		switch levels[levNum].enemies[i].name {
		case "bush":
			levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Width / 4
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
			levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 2
			levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 4
			levels[levNum].enemies[i].carec = levels[levNum].enemies[i].rectangle
			levels[levNum].enemies[i].carec.X -= b4
			levels[levNum].enemies[i].carec.Y -= b4
			levels[levNum].enemies[i].carec.Width += b8
			levels[levNum].enemies[i].carec.Height += b8
		case "jersey":
			levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Width / 2
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
			levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 2
			levels[levNum].enemies[i].collisionRectangle.Height = levels[levNum].enemies[i].collisionRectangle.Height / 2
		case "bird":
			levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Width / 8
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 8
			levels[levNum].enemies[i].collisionRectangle.Width -= levels[levNum].enemies[i].collisionRectangle.Width / 4
			levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 4
		case "greenpig":
			levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Width / 3
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 3
			levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 3
			levels[levNum].enemies[i].collisionRectangle.Height = levels[levNum].enemies[i].collisionRectangle.Height / 3
			levels[levNum].enemies[i].collisionRectangle.Y += 4
		case "robot":
			levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 2
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
			levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 2
			levels[levNum].enemies[i].collisionRectangle.Height = levels[levNum].enemies[i].collisionRectangle.Height / 2
			levels[levNum].enemies[i].carec = levels[levNum].enemies[i].collisionRectangle
			levels[levNum].enemies[i].carec.X -= b5
			levels[levNum].enemies[i].carec.Y -= b5
			levels[levNum].enemies[i].carec.Width += b10
			levels[levNum].enemies[i].carec.Height += b10
		case "carrot":
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 8
			levels[levNum].enemies[i].collisionRectangle.Width -= levels[levNum].enemies[i].collisionRectangle.Width / 4
			levels[levNum].enemies[i].carec = levels[levNum].enemies[i].rectangle
			levels[levNum].enemies[i].carec.X -= b4
			levels[levNum].enemies[i].carec.Y -= b4
			levels[levNum].enemies[i].carec.Width += b8
			levels[levNum].enemies[i].carec.Height += b8
		case "redblob":
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
			levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 2
			levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 2
			levels[levNum].enemies[i].collisionRectangle.Height = levels[levNum].enemies[i].collisionRectangle.Height / 2
		case "skeleton":
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
			levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 2
			levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 8
		case "orange":
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
			levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 2
			levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 3
			levels[levNum].enemies[i].collisionRectangle.Height = levels[levNum].enemies[i].collisionRectangle.Height / 2
			//AREA REC
			levels[levNum].enemies[i].carec = levels[levNum].enemies[i].rectangle
			levels[levNum].enemies[i].carec.X -= b3
			levels[levNum].enemies[i].carec.Y -= b3
			levels[levNum].enemies[i].carec.Width += b6
			levels[levNum].enemies[i].carec.Height += b6
		case "flamehead":
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
			levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 2
			//AREA REC
			levels[levNum].enemies[i].carec = levels[levNum].enemies[i].rectangle
			levels[levNum].enemies[i].carec.X -= b3
			levels[levNum].enemies[i].carec.Y -= b3
			levels[levNum].enemies[i].carec.Width += b6
			levels[levNum].enemies[i].carec.Height += b6
		case "fly":
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
			levels[levNum].enemies[i].collisionRectangle.Width -= levels[levNum].enemies[i].collisionRectangle.Width / 2
			levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 4
			levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 2
			//AREA REC
			levels[levNum].enemies[i].carec = levels[levNum].enemies[i].rectangle
			levels[levNum].enemies[i].carec.X -= b3
			levels[levNum].enemies[i].carec.Y -= b3
			levels[levNum].enemies[i].carec.Width += b6
			levels[levNum].enemies[i].carec.Height += b6
		case "worm":
			levels[levNum].enemies[i].collisionRectangle.Y += (levels[levNum].enemies[i].collisionRectangle.Height / 4) * 3
			levels[levNum].enemies[i].collisionRectangle.Height = levels[levNum].enemies[i].collisionRectangle.Height / 4
		case "yellowdino":
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 8
			levels[levNum].enemies[i].collisionRectangle.Width -= levels[levNum].enemies[i].collisionRectangle.Width / 4
			levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 3
			levels[levNum].enemies[i].collisionRectangle.Height = (levels[levNum].enemies[i].collisionRectangle.Height / 3) * 2
		case "greenplant":
			levels[levNum].enemies[i].collisionRectangle.Y += (levels[levNum].enemies[i].collisionRectangle.Height / 3) * 2
			levels[levNum].enemies[i].collisionRectangle.Height = levels[levNum].enemies[i].collisionRectangle.Height / 3
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 3
			levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 3
		case "pinkcart":
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
			levels[levNum].enemies[i].collisionRectangle.Width = levels[levNum].enemies[i].collisionRectangle.Width / 2
			levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 2
			levels[levNum].enemies[i].collisionRectangle.Height = levels[levNum].enemies[i].collisionRectangle.Height / 2
		case "crocodile":
			levels[levNum].enemies[i].collisionRectangle.Y += (levels[levNum].enemies[i].collisionRectangle.Height / 12) * 7
			levels[levNum].enemies[i].collisionRectangle.Height = (levels[levNum].enemies[i].collisionRectangle.Height / 12) * 5
			//AREA
			levels[levNum].enemies[i].carec = levels[levNum].enemies[i].collisionRectangle
			levels[levNum].enemies[i].carec.X -= b4
			levels[levNum].enemies[i].carec.Width += b8
		case "balloon":
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 4
			levels[levNum].enemies[i].collisionRectangle.Width -= levels[levNum].enemies[i].collisionRectangle.Width / 2
			levels[levNum].enemies[i].collisionRectangle.Y += 4
			levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 2
		case "redantenna":
			levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 3
			levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 3
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 6
			levels[levNum].enemies[i].collisionRectangle.Width -= levels[levNum].enemies[i].collisionRectangle.Width / 3
		case "ghost":
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 8
			levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 8
			levels[levNum].enemies[i].collisionRectangle.Width -= levels[levNum].enemies[i].collisionRectangle.Width / 4
			levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 4
			//AREA REC
			levels[levNum].enemies[i].carec = levels[levNum].enemies[i].rectangle
			levels[levNum].enemies[i].carec.X -= b3
			levels[levNum].enemies[i].carec.Y -= b3
			levels[levNum].enemies[i].carec.Width += b6
			levels[levNum].enemies[i].carec.Height += b6
		case "redeye", "redbomb":
			levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 4
			levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 4
		case "bluespike":
			levels[levNum].enemies[i].collisionRectangle.Y += levels[levNum].enemies[i].collisionRectangle.Height / 8
			levels[levNum].enemies[i].collisionRectangle.X += levels[levNum].enemies[i].collisionRectangle.Width / 8
			levels[levNum].enemies[i].collisionRectangle.Width -= levels[levNum].enemies[i].collisionRectangle.Width / 4
			levels[levNum].enemies[i].collisionRectangle.Height -= levels[levNum].enemies[i].collisionRectangle.Height / 4
		}
	}
}
func makeenemiesINITIAL() { //MARK:MAKE ENEMIES INITIAL
	//BLUE SPIKE 0
	siz := bq3
	zenm := Enemy{}
	zenm.name = "bluespike"
	zenm.name2 = "blue dude"
	zenm.xp = 4
	zenm.hpMax = 2
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 8
	zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 8
	zenm.collisionRectangle.Width -= zenm.collisionRectangle.Width / 4
	zenm.collisionRectangle.Height -= zenm.collisionRectangle.Height / 4
	zenm.image = animation[23].rectangle
	zenm.speed = b / 16
	zenm.idl = true
	zenm.idleT = fps * RandInt32(5, 9)
	enmlist = append(enmlist, zenm)
	//RED EYE 1
	zenm = Enemy{}
	zenm.name = "redeye"
	zenm.name2 = "red dude"
	zenm.xp = 4
	zenm.hpMax = 2
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.collisionRectangle.Height -= zenm.collisionRectangle.Height / 4
	zenm.collisionRectangle.Y += zenm.rectangle.Height / 4
	zenm.image = animation[26].rectangle
	zenm.speed = b / 16
	zenm.idl = true
	zenm.idleT = fps * RandInt32(5, 9)
	enmlist = append(enmlist, zenm)
	//RED BOMB 2
	zenm = Enemy{}
	zenm.name = "redbomb"
	zenm.name2 = "another red dude"
	zenm.xp = 5
	zenm.hpMax = 2
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle.Height -= zenm.collisionRectangle.Height / 4
	zenm.collisionRectangle.Y += zenm.rectangle.Height / 4
	zenm.collisionRectangle = zenm.rectangle
	zenm.image = animation[29].rectangle
	zenm.speed = b / 16
	zenm.idl = true
	zenm.idleT = fps * RandInt32(5, 9)
	enmlist = append(enmlist, zenm)
	//GHOST 3
	siz = b
	zenm = Enemy{}
	zenm.fly = true
	zenm.name = "ghost"
	zenm.name2 = "kasper"
	zenm.xp = 10
	zenm.hpMax = 5
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 8
	zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 8
	zenm.collisionRectangle.Width -= zenm.collisionRectangle.Width / 4
	zenm.collisionRectangle.Height -= zenm.collisionRectangle.Height / 4
	zenm.image = animation[32].rectangle
	zenm.speed = b / 12
	zenm.hitImgR = rl.NewRectangle(943, 65, 18, 18)
	zenm.hitImgL = rl.NewRectangle(961, 65, 18, 18)
	enmlist = append(enmlist, zenm)
	//RED ANTENNA 4
	siz = b
	zenm = Enemy{}
	zenm.name = "redantenna"
	zenm.name2 = "yet another red dude"
	zenm.xp = 8
	zenm.hpMax = 5
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 3
	zenm.collisionRectangle.Height -= zenm.collisionRectangle.Height / 3
	zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 6
	zenm.collisionRectangle.Width -= zenm.collisionRectangle.Width / 3
	zenm.image = animation[34].rectangle
	zenm.speed = b / 14
	zenm.moveChangeT = fps * RandInt32(1, 4)
	zenm.hitImgR = rl.NewRectangle(955, 84, 22, 22)
	zenm.hitImgL = rl.NewRectangle(977, 84, 22, 22)
	zenm.atkT = fps * RandInt32(1, 5)
	enmlist = append(enmlist, zenm)
	//BALLOON 5
	siz = b + b/2
	zenm = Enemy{}
	zenm.fly = true
	zenm.name = "balloon"
	zenm.name2 = "i lost my balloon"
	zenm.xp = 2
	zenm.hpMax = 1
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
	zenm.collisionRectangle.Width -= zenm.collisionRectangle.Width / 2
	zenm.collisionRectangle.Y += 4
	zenm.collisionRectangle.Height -= zenm.collisionRectangle.Height / 2
	zenm.image = animation[36].rectangle
	zenm.speed = b / 24
	zenm.hitImgR = rl.NewRectangle(955, 84, 22, 22)
	zenm.hitImgL = rl.NewRectangle(977, 84, 22, 22)
	zenm.animFrameT = RandInt32(10, 25)
	enmlist = append(enmlist, zenm)
	//CROCODILE 6
	siz = b + b/2
	zenm = Enemy{}
	zenm.name = "crocodile"
	zenm.name2 = "dundee"
	zenm.xp = 12
	zenm.hpMax = 5
	zenm.hp = zenm.hpMax
	zenm.collisionRectangle = zenm.rectangle
	zenm.collisionRectangle.Y += (zenm.collisionRectangle.Height / 12) * 7
	zenm.collisionRectangle.Height = (zenm.collisionRectangle.Height / 12) * 5
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.image = animation[38].rectangle
	zenm.speed = b / 20
	zenm.hitImgR = rl.NewRectangle(1237, 301, 32, 32)
	zenm.hitImgL = rl.NewRectangle(1652, 301, 32, 32)
	enmlist = append(enmlist, zenm)
	//PINK CARTWHEEL 7
	siz = b + b/2
	zenm = Enemy{}
	zenm.name = "pinkcart"
	zenm.name2 = "random pink dude"
	zenm.xp = 12
	zenm.hpMax = 5
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
	zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 2
	zenm.collisionRectangle.Y += -zenm.collisionRectangle.Height / 2
	zenm.collisionRectangle.Height = zenm.collisionRectangle.Height / 2
	zenm.image = animation[40].rectangle
	zenm.speed = b / 20
	zenm.idl = true
	zenm.idleT = fps * RandInt32(5, 9)
	zenm.atkT = fps * RandInt32(1, 3)
	enmlist = append(enmlist, zenm)
	//GREEN PLANT 8
	siz = b + bq
	zenm = Enemy{}
	zenm.name = "greenplant"
	zenm.name2 = "mutant basil plant"
	zenm.xp = 10
	zenm.hpMax = 5
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.collisionRectangle.Y += (zenm.collisionRectangle.Height / 3) * 2
	zenm.collisionRectangle.Height = zenm.collisionRectangle.Height / 3
	zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 3
	zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 3
	zenm.image = animation[43].rectangle
	zenm.speed = b / 14
	zenm.idl = true
	zenm.idleT = fps * RandInt32(5, 9)
	zenm.moveChangeT = fps * RandInt32(2, 5)
	enmlist = append(enmlist, zenm)
	//YELLOW DINO 9
	siz = b + bq
	zenm = Enemy{}
	zenm.name = "yellowdino"
	zenm.name2 = "tera-giga-flopo-saurus"
	zenm.xp = 12
	zenm.hpMax = 7
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 8
	zenm.collisionRectangle.Width -= zenm.collisionRectangle.Width / 4
	zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 3
	zenm.collisionRectangle.Height = (zenm.collisionRectangle.Height / 3) * 2
	zenm.image = animation[46].rectangle
	zenm.speed = b / 16
	zenm.moveChangeT = fps * RandInt32(2, 4)
	zenm.atkT = fps * RandInt32(1, 5)
	enmlist = append(enmlist, zenm)
	//BLACK DOT 10
	siz = b / 2
	zenm = Enemy{}
	zenm.name = "blackdot"
	zenm.name2 = "ink smudge"
	zenm.xp = 2
	zenm.hpMax = 3
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.image = animation[49].rectangle
	zenm.speed = b / 16
	zenm.hitImgR = rl.NewRectangle(1413, 19, 12, 12)
	zenm.hitImgL = rl.NewRectangle(1425, 19, 12, 12)
	enmlist = append(enmlist, zenm)
	//WORM 11
	siz = b
	zenm = Enemy{}
	zenm.name = "worm"
	zenm.name2 = "jim"
	zenm.xp = 4
	zenm.hpMax = 2
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.collisionRectangle.Y += (zenm.collisionRectangle.Height / 4) * 3
	zenm.collisionRectangle.Height = zenm.collisionRectangle.Height / 4
	zenm.image = animation[51].rectangle
	zenm.speed = 0.7
	enmlist = append(enmlist, zenm)
	//FLY 12
	siz = be5
	zenm = Enemy{}
	zenm.fly = true
	zenm.name = "fly"
	zenm.name2 = "the"
	zenm.xp = 7
	zenm.hpMax = 3
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 8
	zenm.collisionRectangle.Width -= zenm.collisionRectangle.Width / 4
	zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 8
	zenm.collisionRectangle.Height -= zenm.collisionRectangle.Height / 4
	zenm.image = animation[53].rectangle
	zenm.speed = b / 20
	enmlist = append(enmlist, zenm)
	//FLAMEHEAD 13
	siz = b
	zenm = Enemy{}
	zenm.fly = true
	zenm.name = "flamehead"
	zenm.name2 = "light my fire"
	zenm.xp = 4
	zenm.hpMax = 2
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.image = animation[63].rectangle
	zenm.speed = b / 20
	enmlist = append(enmlist, zenm)
	//ORANGE 14
	siz = b
	zenm = Enemy{}
	zenm.name = "orange"
	zenm.name2 = "eat fruit everyday"
	zenm.xp = 7
	zenm.hpMax = 2
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.image = animation[65].rectangle
	zenm.speed = b / 12
	enmlist = append(enmlist, zenm)
	//SKELETON 15
	siz = b
	zenm = Enemy{}
	zenm.name = "skeleton"
	zenm.name2 = "ubiquitous dungeon fiend"
	zenm.xp = 12
	zenm.hpMax = 8
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.image = animation[67].rectangle
	zenm.speed = b / 16
	zenm.atkT = fps * RandInt32(1, 5)
	enmlist = append(enmlist, zenm)
	//RED BLOB 16
	siz = b
	zenm = Enemy{}
	zenm.name = "redblob"
	zenm.name2 = "too many red dudes in this game"
	zenm.xp = 10
	zenm.hpMax = 5
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.image = animation[69].rectangle
	zenm.speed = b / 30
	zenm.moveChangeT = fps * RandInt32(1, 3)
	zenm.atkT = fps * RandInt32(1, 5)
	enmlist = append(enmlist, zenm)
	//CARROT 17
	siz = bq3
	zenm = Enemy{}
	zenm.name = "carrot"
	zenm.name2 = "also eat vegetables everyday"
	zenm.xp = 5
	zenm.hpMax = 3
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.carec = zenm.rectangle
	zenm.carec.X -= b
	zenm.carec.Y -= b
	zenm.carec.Width += b2
	zenm.carec.Height += b2
	zenm.image = animation[156].rectangle
	zenm.speed = 2
	enmlist = append(enmlist, zenm)
	//ROBOT 18
	siz = b
	zenm = Enemy{}
	zenm.name = "robot"
	zenm.name2 = "stand back"
	zenm.xp = 15
	zenm.hpMax = 8
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 2
	zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
	zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 2
	zenm.image = animation[160].rectangle
	zenm.speed = 1
	zenm.moveChangeT = fps * RandInt32(1, 3)
	zenm.atkT = int32(RandInt(int(fps), int(fps*3)))
	enmlist = append(enmlist, zenm)
	//GREEN PIG 19
	siz = b2
	zenm.fly = true
	zenm = Enemy{}
	zenm.name = "greenpig"
	zenm.name2 = "pigs might fly"
	zenm.xp = 12
	zenm.hpMax = 5
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 2
	zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
	zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 2
	zenm.image = animation[158].rectangle
	zenm.speed = 2
	zenm.moveChangeT = fps * RandInt32(1, 3)
	zenm.atkT = fps * 2
	enmlist = append(enmlist, zenm)
	//RED DEVIL 20
	siz = be7
	zenm = Enemy{}
	zenm.name = "reddevil"
	zenm.name2 = "smoking hot"
	zenm.xp = 15
	zenm.hpMax = 5
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 2
	zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
	zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 2
	zenm.image = animation[162].rectangle
	zenm.speed = 5
	zenm.dirX = zenm.speed
	if FlipCoin() {
		zenm.dirX = -zenm.dirX
	}
	zenm.dirY = zenm.speed / RandF32(2, 9)
	if FlipCoin() {
		zenm.dirY = -zenm.dirY
	}
	zenm.atkT = fps / 2
	enmlist = append(enmlist, zenm)
	//ROCK GUY 21
	siz = b
	zenm = Enemy{}
	zenm.name = "bush"
	zenm.name2 = "hide n seek"
	zenm.xp = 15
	zenm.hpMax = 5
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 2
	zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
	zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 2
	zenm.image = otherTiles[151]
	zenm.speed = 4
	enmlist = append(enmlist, zenm)
	//BIRD 22
	siz = b
	zenm = Enemy{}
	zenm.fly = true
	zenm.name = "bird"
	zenm.name2 = "humpty dumpty"
	zenm.xp = 15
	zenm.hpMax = 4
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 2
	zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
	zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 2
	zenm.image = animation[164].rectangle
	zenm.speed = 2
	zenm.moveChangeT = fps * 2
	zenm.dirX = RandF32(-zenm.speed, zenm.speed)
	zenm.dirY = RandF32(-zenm.speed, zenm.speed)
	enmlist = append(enmlist, zenm)
	//GREEN JERSEY 23
	siz = b + be
	zenm = Enemy{}
	zenm.name = "jersey"
	zenm.name2 = "originally from scotland"
	zenm.xp = 15
	zenm.hpMax = 8
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 2
	zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 4
	zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 2
	zenm.image = animation[166].rectangle
	zenm.speed = 3
	zenm.moveChangeT = fps * 2
	zenm.dirX = RandF32(-zenm.speed, zenm.speed)
	zenm.dirY = RandF32(-zenm.speed, zenm.speed)
	zenm.atkT = fps * 2
	enmlist = append(enmlist, zenm)
	//MOVING SPIKE 24
	siz = b + b/2
	zenm = Enemy{}
	zenm.name = "spike"
	zenm.name2 = "mr snuggles mince machine"
	zenm.xp = 100
	zenm.hpMax = 99
	zenm.hp = zenm.hpMax
	zenm.rectangle = rl.NewRectangle(0, 0, siz, siz)
	zenm.collisionRectangle = zenm.rectangle
	zenm.image = animation[184].rectangle
	zenm.speed = 2
	zenm.moveChangeT = fps * 2
	zenm.dirX = RandF32(-zenm.speed, zenm.speed)
	zenm.dirY = RandF32(-zenm.speed, zenm.speed)
	enmlist = append(enmlist, zenm)
}

func makePotionList() { //MARK:MAKE POTION LIST
	potionList = nil
	for i := 0; i < 18; i++ {
		potionList = append(potionList, itemList[i])
	}
	for i := 0; i < len(potionList); i++ {
		for j := 0; j < 6; j++ {
			potionList[i].potionPrice = append(potionList[i].potionPrice, 0)
		}
	}

	potionList[0].potionPrice[0] = 30
	potionList[0].potionPrice[2] = 30
	potionList[0].potionPrice[3] = 30 //HP FULL

	potionList[1].potionPrice[2] = 20
	potionList[1].potionPrice[3] = 20 //HP HALF

	potionList[2].potionPrice[2] = 10
	potionList[2].potionPrice[3] = 10 //HP QUARTER

	potionList[3].potionPrice[1] = 30
	potionList[3].potionPrice[4] = 30
	potionList[3].potionPrice[5] = 30 //MANA FULL

	potionList[4].potionPrice[4] = 20
	potionList[4].potionPrice[5] = 20 //MANA HALF

	potionList[5].potionPrice[4] = 10
	potionList[5].potionPrice[5] = 10 //MANA QUARTER

	potionList[6].potionPrice[1] = 30
	potionList[6].potionPrice[3] = 30
	potionList[6].potionPrice[4] = 30 //RESIST FIRE FULL

	potionList[7].potionPrice[1] = 20
	potionList[7].potionPrice[3] = 20
	potionList[7].potionPrice[4] = 20 //RESIST FIRE HALF

	potionList[8].potionPrice[1] = 15
	potionList[8].potionPrice[4] = 15 //RESIST FIRE QUARTER

	potionList[9].potionPrice[1] = 30
	potionList[9].potionPrice[4] = 30
	potionList[9].potionPrice[5] = 30 //RESIST POISON FULL

	potionList[10].potionPrice[1] = 20
	potionList[10].potionPrice[4] = 20
	potionList[10].potionPrice[5] = 20 //RESIST POISON HALF

	potionList[11].potionPrice[1] = 15
	potionList[11].potionPrice[5] = 15 //RESIST POISON QUARTER

	potionList[12].potionPrice[0] = 30
	potionList[12].potionPrice[2] = 30
	potionList[12].potionPrice[3] = 30
	potionList[12].potionPrice[5] = 30 //INVISIBILTY FULL

	potionList[13].potionPrice[0] = 20
	potionList[13].potionPrice[3] = 20
	potionList[13].potionPrice[5] = 20 //INVISIBILTY HALF

	potionList[14].potionPrice[0] = 15
	potionList[14].potionPrice[3] = 15
	potionList[14].potionPrice[5] = 15 //INVISIBILTY QUARTER

	potionList[15].potionPrice[0] = 30
	potionList[15].potionPrice[1] = 30
	potionList[15].potionPrice[2] = 30
	potionList[15].potionPrice[3] = 30
	potionList[15].potionPrice[4] = 30
	potionList[15].potionPrice[5] = 30 //ARMOR FULL

	potionList[16].potionPrice[1] = 20
	potionList[16].potionPrice[2] = 20
	potionList[16].potionPrice[3] = 20
	potionList[16].potionPrice[4] = 20
	potionList[16].potionPrice[5] = 20 //ARMOR HALF

	potionList[17].potionPrice[2] = 15
	potionList[17].potionPrice[3] = 15
	potionList[17].potionPrice[4] = 15
	potionList[17].potionPrice[5] = 15 //ARMOR QUARTER

}
func makeScrollList() { //MARK:MAKE SCROLL LIST
	scrollList = nil
	for i := 18; i < 26; i++ {
		scrollList = append(scrollList, itemList[i])
	}
	for i := 0; i < len(scrollList); i++ {
		scrollList[i].scrollprice = append(scrollList[i].scrollprice, 0)
		scrollList[i].scrollprice = append(scrollList[i].scrollprice, 0)
	}
	for i := 0; i < len(scrollList); i++ {
		switch i {
		case 0:
			scrollList[i].scrollprice[0] = 15
			scrollList[i].scrollprice[1] = 15 //POISON GAS
		case 1:
			scrollList[i].scrollprice[0] = 20
			scrollList[i].scrollprice[1] = 20 //FROGS
		case 2:
			scrollList[i].scrollprice[0] = 10
			scrollList[i].scrollprice[1] = 10 //INTANGIBILITY
		case 3:
			scrollList[i].scrollprice[0] = 15
			scrollList[i].scrollprice[1] = 15 //DETECTION
		case 4:
			scrollList[i].scrollprice[0] = 15
			scrollList[i].scrollprice[1] = 15 //HOME
		case 5:
			scrollList[i].scrollprice[0] = 10
			scrollList[i].scrollprice[1] = 10 //BEGINNING
		case 6:
			scrollList[i].scrollprice[0] = 25
			scrollList[i].scrollprice[1] = 25 //INFLICT
		case 7:
			scrollList[i].scrollprice[0] = 40
			scrollList[i].scrollprice[1] = 40 //POWER
		}

	}
}

func makedarts(tile Tile) { //MARK:MAKE DARTS
	x := tile.center.X
	y := tile.center.Y
	spd := b / 4
	siz := b / 2
	xl := levels[levNum].rectangles[tile.room].X
	xr := levels[levNum].rectangles[tile.room].X + levels[levNum].rectangles[tile.room].Width
	yt := levels[levNum].rectangles[tile.room].Y
	yb := levels[levNum].rectangles[tile.room].Y + levels[levNum].rectangles[tile.room].Height
	side := RandInt(1, 5)
	switch side {
	case 1:
		//TOP WALL
		zproj := Weapon{}
		zproj.dirY = spd
		zproj.rec = rl.NewRectangle(x-siz/2, yt, siz, siz)
		zproj.crec = zproj.rec
		zproj.image = otherTiles[138]
		zproj.damage = 1
		zproj.name = "dart"
		zproj.col = rl.White
		zproj.rotation = 135
		zproj.fade = 1
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.rec.X -= zproj.rec.Height
		zproj.crec = zproj.rec
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.rec.X += zproj.rec.Height * 2
		zproj.crec = zproj.rec
		enemyProjectiles = append(enemyProjectiles, zproj)
	case 2:
		//RIGHT WALL
		zproj := Weapon{}
		zproj.dirX = -spd
		zproj.rec = rl.NewRectangle(xr-siz, y-siz/2, siz, siz)
		zproj.crec = zproj.rec
		zproj.image = otherTiles[138]
		zproj.damage = 1
		zproj.name = "dart"
		zproj.col = rl.White
		zproj.rotation = -135
		zproj.fade = 1
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.rec.Y -= zproj.rec.Height
		zproj.crec = zproj.rec
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.rec.Y += zproj.rec.Height * 2
		zproj.crec = zproj.rec
		enemyProjectiles = append(enemyProjectiles, zproj)
	case 3:
		//BOTTOM WALL
		zproj := Weapon{}
		zproj.dirY = -spd
		zproj.rec = rl.NewRectangle(x-siz/2, yb-siz, siz, siz)
		zproj.crec = zproj.rec
		zproj.image = otherTiles[138]
		zproj.damage = 1
		zproj.name = "dart"
		zproj.col = rl.White
		zproj.rotation = -45
		zproj.fade = 1
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.rec.X -= zproj.rec.Height
		zproj.crec = zproj.rec
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.rec.X += zproj.rec.Height * 2
		zproj.crec = zproj.rec
		enemyProjectiles = append(enemyProjectiles, zproj)
	case 4:
		//LEFT WALL
		zproj := Weapon{}
		zproj.dirX = spd
		zproj.rec = rl.NewRectangle(xl, y-siz/2, siz, siz)
		zproj.crec = zproj.rec
		zproj.image = otherTiles[138]
		zproj.damage = 1
		zproj.name = "dart"
		zproj.col = rl.White
		zproj.rotation = 45
		zproj.fade = 1
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.rec.Y -= zproj.rec.Height
		zproj.crec = zproj.rec
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.rec.Y += zproj.rec.Height * 2
		zproj.crec = zproj.rec
		enemyProjectiles = append(enemyProjectiles, zproj)
	}
}
func makeEnDeathFx(enNum int) { //MARK:MAKE ENEMY DEATH FX
	levels[levNum].enemyNum--
	//MUG
	if mugnum > 0 {
		if Roll6() <= mugnum {
			zitm := itemList[43]
			zitm.rectangle = rl.NewRectangle(levels[levNum].enemies[enNum].cnt.X-zitm.rectangle.Width/2, levels[levNum].enemies[enNum].cnt.Y-zitm.rectangle.Height/2, zitm.rectangle.Width, zitm.rectangle.Height)
			levels[levNum].items = append(levels[levNum].items, zitm)
		}
	}
	//FRISBEE
	if frisbee {
		frisbeecount++
		if frisbeecount == 7 {
			frisbeecount = 0
			frisbeeT = fps * 10
			zfx := Effect{}
			zfx.name = "frisbee"
			zfx.rectangle = player.rectangle
			zfx.rectangle.X -= b
			zfx.rectangle.Y -= b
			zfx.rectangle.Width += b2
			zfx.rectangle.Height += b2
			zfx.collisionRectangle = zfx.rectangle
			zfx.collisionRectangle.X += zfx.collisionRectangle.Width / 8
			zfx.collisionRectangle.Y += zfx.collisionRectangle.Width / 8
			zfx.collisionRectangle.Width -= zfx.collisionRectangle.Width / 4
			zfx.collisionRectangle.Height -= zfx.collisionRectangle.Width / 4
			zfx.speed = 5
			countbreak := 100
			for {
				zfx.dirX = RandF32(-zfx.speed, zfx.speed)
				zfx.dirY = RandF32(-zfx.speed, zfx.speed)
				if Abs(zfx.dirX) > 2 || Abs(zfx.dirY) > 2 {
					break
				}
				countbreak--
				if countbreak == 0 {
					break
				}
			}
			zfx.center = makecnt(zfx.rectangle)
			zfx.imageRectangle = animation[93].rectangle
			effect = append(effect, zfx)
		}
	}
	//PURPLE RAIN
	if purplerain {
		purpleraincount++
		if purpleraincount == 4 {
			purpleraincount = 0
			purplerainT = fps
			zfx := Effect{}
			zfx.name = "purplerain"
			num := 20
			countbreak := 100
			for num > 0 {
				x2 := RandF32(-b5, b5)
				y2 := RandF32(-b5, b5)
				v2 := rl.NewVector2(player.center.X+x2, player.center.Y+y2)
				if checkV2inRooms(v2) {
					siz := b2
					zfx.rectangles2 = append(zfx.rectangles2, rl.NewRectangle(v2.X-siz/2, v2.Y-siz/2, siz, siz))
					num--
				}
				countbreak--
				if countbreak <= 0 {
					break
				}
			}
			zfx.imageRectangle = animation[92].rectangle
			effect = append(effect, zfx)
		}
	}
	//TESLA
	if tesla {
		teslacount++
		if teslacount == 5 {
			teslacount = 0
			teslaT = fps
			zfx := Effect{}
			zfx.name = "tesla"
			zfx.rectangle = player.rectangle
			zfx.rectangle.X -= b5
			zfx.rectangle.Y -= b5
			zfx.rectangle.Width += b10
			zfx.rectangle.Height += b10
			zfx.imageRectangle = animation[91].rectangle
			effect = append(effect, zfx)
		}
	}
	//BOTTLE OF DEATH
	if deathbottlenum > 0 {
		player.xp += deathbottlenum * 3
	}
	//GARLIC
	if garlicnum > 0 {
		if Roll12() <= garlicnum {
			if player.hp < player.hpMax {
				player.hp++
				admsg("garlic +1 hp", rl.Green)
			}
		}
	}
	fxmade := false
	switch levels[levNum].enemies[enNum].name {
	case "balloon":
		rl.PlaySound(audfx[94])
		fxmade = true
		//FX
		zfx := Effect{}
		zfx.name = "balloonexplode"
		zfx.timer = fps / 4
		zfx.imageRectangle = animation[57].rectangle
		siz2 := b8
		zfx.rectangle = rl.NewRectangle(levels[levNum].enemies[enNum].cnt.X-siz2/2, levels[levNum].enemies[enNum].cnt.Y-siz2/2, siz2, siz2)
		effect = append(effect, zfx)
	case "redbomb":
		rl.PlaySound(audfx[104])
		zenm := Enemy{}
		zenm.name = "fire"
		zenm.stat = true
		zenm.nodmg = true
		zenm.hpMax = 100
		zenm.hp = zenm.hpMax
		zenm.image = animation[55].rectangle
		siz := b2
		zenm.rectangle = rl.NewRectangle(levels[levNum].enemies[enNum].cnt.X-siz/2, levels[levNum].enemies[enNum].cnt.Y-(siz), siz, siz)
		zenm.collisionRectangle = zenm.rectangle
		zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 3
		zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 3
		zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 2
		zenm.collisionRectangle.Height = zenm.collisionRectangle.Height / 2
		zenm.cnt = levels[levNum].enemies[enNum].cnt
		levels[levNum].enemies = append(levels[levNum].enemies, zenm)
		countbreak := 100
		num := RandInt(4, 8)
		for num > 0 {
			siz2 := b3
			cntr := zenm.cnt
			cntr.X += RandF32(-siz2, siz2)
			cntr.Y += RandF32(-siz2, siz2)
			if checkV2Walls(cntr) && checkV2inRooms(cntr) && checkV2water(cntr) && checkV2chest(cntr) {
				zenm.rectangle = rl.NewRectangle(cntr.X-siz/2, cntr.Y-(siz), siz, siz)
				zenm.collisionRectangle = zenm.rectangle
				zenm.collisionRectangle.X += zenm.collisionRectangle.Width / 3
				zenm.collisionRectangle.Width = zenm.collisionRectangle.Width / 3
				zenm.collisionRectangle.Y += zenm.collisionRectangle.Height / 2
				zenm.collisionRectangle.Height = zenm.collisionRectangle.Height / 2
				zenm.cnt = levels[levNum].enemies[enNum].cnt
				levels[levNum].enemies = append(levels[levNum].enemies, zenm)
				num--
			}
			countbreak--
			if countbreak == 0 {
				break
			}
		}
	case "redeye":
		zproj := Weapon{}
		zproj.name = "redspikeproj"
		zproj.damage = 1
		zproj.image = otherTiles[30]
		siz := be3
		zproj.rec = rl.NewRectangle(levels[levNum].enemies[enNum].cnt.X-siz/2, levels[levNum].enemies[enNum].cnt.Y-siz/2, siz, siz)
		zproj.crec = zproj.rec
		zproj.col = RandRed()
		zproj.fade = 1
		zproj.speed = b / 8
		zproj.rotation = 90
		zproj.dirX = zproj.speed
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.rotation = 270
		zproj.dirX = -zproj.speed
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.dirX = 0
		zproj.rotation = 0
		zproj.dirY = -zproj.speed
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.rotation = 180
		zproj.dirY = zproj.speed
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.rotation = 45
		zproj.dirX = zproj.speed
		zproj.dirY = -zproj.speed
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.rotation = 135
		zproj.dirX = zproj.speed
		zproj.dirY = +zproj.speed
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.rotation = -45
		zproj.dirX = -zproj.speed
		zproj.dirY = -zproj.speed
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.rotation = -135
		zproj.dirX = -zproj.speed
		zproj.dirY = +zproj.speed
		enemyProjectiles = append(enemyProjectiles, zproj)
	case "bluespike":
		zproj := Weapon{}
		zproj.name = "bluespikeproj"
		zproj.damage = 1
		zproj.image = otherTiles[30]
		siz := be3
		zproj.rec = rl.NewRectangle(levels[levNum].enemies[enNum].cnt.X-siz/2, levels[levNum].enemies[enNum].cnt.Y-siz/2, siz, siz)
		zproj.crec = zproj.rec
		zproj.col = rl.SkyBlue
		zproj.fade = 1
		zproj.speed = b / 8
		zproj.rotation = 90
		zproj.dirX = zproj.speed
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.rotation = 270
		zproj.dirX = -zproj.speed
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.dirX = 0
		zproj.rotation = 0
		zproj.dirY = -zproj.speed
		enemyProjectiles = append(enemyProjectiles, zproj)
		zproj.rotation = 180
		zproj.dirY = zproj.speed
		enemyProjectiles = append(enemyProjectiles, zproj)
	}
	//FX
	if !fxmade {
		zfx := Effect{}
		zfx.name = "enm"
		zfx.timer = fps
		num := RandInt(40, 55)
		for num > 0 {
			zcirc := Circle{}
			zcirc.center = levels[levNum].enemies[enNum].cnt
			zcirc.radius = RandF32(b/8, b/2)
			zcirc.color = RandRed()
			switch levels[levNum].enemies[enNum].name {
			case "bluespike", "robot":
				zcirc.color = RandBlue()
			case "redbomb", "orange", "flamehead", "carrot":
				zcirc.color = RandOrange()
			case "ghost", "skeleton":
				zcirc.color = RandGrey()
			case "pinkcart":
				zcirc.color = RandPink()
			case "blackdot", "bird":
				zcirc.color = rl.Black
			case "crocodile", "greenplant", "greenpig", "bush":
				zcirc.color = RandGreen()
			}
			zcirc.fade = RandF32(0.5, 0.8)
			zcirc.speed = b / 2
			countbreak := 100
			for {
				zcirc.dirX = RandF32(-zcirc.speed, zcirc.speed)
				zcirc.dirY = RandF32(-zcirc.speed, zcirc.speed)
				if Abs(zcirc.dirX) > 0.5 && Abs(zcirc.dirY) > 0.5 {
					break
				}
				countbreak--
				if countbreak == 0 {
					break
				}
			}
			zfx.circles = append(zfx.circles, zcirc)
			num--
		}
		effect = append(effect, zfx)
	}
	if gascannum > 0 {
		if Roll6() <= gascannum {
			siz := b7
			cntr := levels[levNum].enemies[enNum].cnt
			zfx := Effect{}
			zfx.rectangle = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
			zfx.imageRectangle = animation[57].rectangle
			zfx.name = "gascanExplode"
			effect = append(effect, zfx)
		}
	}

	choose := RandInt(1, 4)
	switch choose {
	case 1:
		rl.PlaySound(audfx[9])
	case 2:
		rl.PlaySound(audfx[10])
	case 3:
		rl.PlaySound(audfx[11])
	}
}
func makebgi() { //MARK:MAKE BACKGROUND IMG
	for i := 0; i < len(levels[levNum].rectangles); i++ {
		//BGI
		if Roll6() > 3 {
			siz := RandF32(b+b/2, b2)
			x := levels[levNum].rectangles[i].X + b/2
			x += RandF32(0, levels[levNum].rectangles[i].Width-(siz+b))
			y := levels[levNum].rectangles[i].Y + b/2
			y += RandF32(0, levels[levNum].rectangles[i].Height-(siz+b))
			rec := rl.NewRectangle(x, y, siz, siz)
			zbgi := bgilist[RandInt(0, len(bgilist))]
			zbgi.rectangle = rec
			zbgi.fade = 1
			levels[levNum].backgroundInformation = append(levels[levNum].backgroundInformation, zbgi)
		}
		//BGI 2
		num := RandInt(1, 5)
		countbreak := 100
		for {
			siz := RandF32(be5, b+be3)
			side := RandInt(1, 5)
			zbgi := bgilist2[RandInt(0, len(bgilist2))]
			zbgi.fade = 1
			switch side {
			case 4: //LEFT
				x := levels[levNum].rectangles[i].X - 2
				y := levels[levNum].rectangles[i].Y + b/4
				y += RandF32(0, levels[levNum].rectangles[i].Height-(siz+b/2))
				rec := rl.NewRectangle(x, y, siz, siz)
				zbgi.rectangle = rec
				zbgi.rotation = 270
			case 3: //BOTTOM
				x := levels[levNum].rectangles[i].X + b/4
				x += RandF32(0, levels[levNum].rectangles[i].Width-(siz+b/2))
				y := levels[levNum].rectangles[i].Y + levels[levNum].rectangles[i].Height - siz + 2
				rec := rl.NewRectangle(x, y, siz, siz)
				zbgi.rectangle = rec
				zbgi.rotation = 180
			case 2: //RIGHT
				x := levels[levNum].rectangles[i].X + levels[levNum].rectangles[i].Width - siz + 2
				y := levels[levNum].rectangles[i].Y + b/4
				y += RandF32(0, levels[levNum].rectangles[i].Height-(siz+b/2))
				rec := rl.NewRectangle(x, y, siz, siz)
				zbgi.rectangle = rec
				zbgi.rotation = 90
			case 1: //TOP
				x := levels[levNum].rectangles[i].X + b/4
				x += RandF32(0, levels[levNum].rectangles[i].Width-(siz+b/2))
				y := levels[levNum].rectangles[i].Y - 2
				rec := rl.NewRectangle(x, y, siz, siz)
				zbgi.rectangle = rec
			}
			if checkRecDoors(zbgi.rectangle) {
				canadd := true
				for j := 0; j < len(levels[levNum].backgroundInformation2); j++ {
					if rl.CheckCollisionRecs(zbgi.rectangle, levels[levNum].backgroundInformation2[j].rectangle) {
						canadd = false
					}
				}
				if canadd {
					num--
					levels[levNum].backgroundInformation2 = append(levels[levNum].backgroundInformation2, zbgi)
				}
			}
			countbreak--
			if num == 0 || countbreak == 0 {
				break
			}
		}
	}
	//FLOWERS
	num := RandInt(5, 11)
	for num > 0 {
		cntr := findRanCnt()
		siz := RandF32(be3, b/2)
		zbgi := BackgroundInformation{}
		zbgi.rectangle = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
		zbgi.imageRectangle = flowers[RandInt(0, len(flowers))]
		levels[levNum].flowers = append(levels[levNum].flowers, zbgi)
		num--
	}
}

func makecnt(rec rl.Rectangle) rl.Vector2 { //MARK:MAKE CENTER
	return rl.NewVector2(rec.X+rec.Width/2, rec.Y+rec.Height/2)
}
func makeinnerbloksetc(lev x1scr) x1scr { //MARK:MAKE INNER BLOKS ETC
	min := 5
	size := b
	for i := 0; i < len(lev.rectangles); i++ {
		//INNER BLOK SHAPES
		if lev.inf[i].numW > min+3 && lev.inf[i].numH > min+3 {
			ztile := Tile{}
			ztile.image = walltile
			ztile.color = rl.White
			ztile.color2 = RandColor()
			ztile.fade = RandF32(0.3, 0.9)
			choose := RandInt(1, 5)
			//choose =4
			switch choose {
			case 4: //FOUR BLOKS
				x := lev.rectangles[i].X + b3
				y := lev.rectangles[i].Y + b3
				x2 := x + lev.rectangles[i].Width - b6
				y2 := y + lev.rectangles[i].Height - b6
				ztile.color2 = RandColor()
				ztile.rectangle = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
				if checkaddtilerecInner(ztile.rectangle, lev) {
					lev.walls = append(lev.walls, ztile)
				}
				choose2 := RandInt(1, 5)
				switch choose2 {
				case 1:
					ztile.rectangle.Y -= size
					if checkaddtilerecInner(ztile.rectangle, lev) {
						ztile.color2 = RandColor()
						lev.walls = append(lev.walls, ztile)
					}
					if FlipCoin() {
						ztile.rectangle.X += size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rectangle.X -= size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
					if FlipCoin() {
						ztile.rectangle.Y += size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rectangle.Y -= size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
				case 2:
					ztile.rectangle.X += size
					if checkaddtilerecInner(ztile.rectangle, lev) {
						ztile.color2 = RandColor()
						lev.walls = append(lev.walls, ztile)
					}
					if FlipCoin() {
						ztile.rectangle.Y += size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rectangle.Y -= size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
					if FlipCoin() {
						ztile.rectangle.X += size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rectangle.X -= size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
				case 3:
					ztile.rectangle.Y += size
					if checkaddtilerecInner(ztile.rectangle, lev) {
						ztile.color2 = RandColor()
						lev.walls = append(lev.walls, ztile)
					}
					if FlipCoin() {
						ztile.rectangle.X += size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rectangle.X -= size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
					if FlipCoin() {
						ztile.rectangle.Y += size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rectangle.Y -= size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
				case 4:
					ztile.rectangle.X -= size
					if checkaddtilerecInner(ztile.rectangle, lev) {
						ztile.color2 = RandColor()
						lev.walls = append(lev.walls, ztile)
					}
					if FlipCoin() {
						ztile.rectangle.Y += size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rectangle.Y -= size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
					if FlipCoin() {
						ztile.rectangle.X += size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rectangle.X -= size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
				}
			case 3: //THREE BLOKS
				x := lev.rectangles[i].X + b3
				y := lev.rectangles[i].Y + b3
				x2 := x + lev.rectangles[i].Width - b6
				y2 := y + lev.rectangles[i].Height - b6
				ztile.color2 = RandColor()
				ztile.rectangle = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
				if checkaddtilerecInner(ztile.rectangle, lev) {
					lev.walls = append(lev.walls, ztile)
				}
				choose2 := RandInt(1, 5)
				switch choose2 {
				case 1:
					ztile.rectangle.Y -= size
					if checkaddtilerecInner(ztile.rectangle, lev) {
						ztile.color2 = RandColor()
						lev.walls = append(lev.walls, ztile)
					}
					if FlipCoin() {
						ztile.rectangle.X += size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rectangle.X -= size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
				case 2:
					ztile.rectangle.X += size
					if checkaddtilerecInner(ztile.rectangle, lev) {
						ztile.color2 = RandColor()
						lev.walls = append(lev.walls, ztile)
					}
					if FlipCoin() {
						ztile.rectangle.Y += size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rectangle.Y -= size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
				case 3:
					ztile.rectangle.Y += size
					if checkaddtilerecInner(ztile.rectangle, lev) {
						ztile.color2 = RandColor()
						lev.walls = append(lev.walls, ztile)
					}
					if FlipCoin() {
						ztile.rectangle.X += size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rectangle.X -= size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
				case 4:
					ztile.rectangle.X -= size
					if checkaddtilerecInner(ztile.rectangle, lev) {
						ztile.color2 = RandColor()
						lev.walls = append(lev.walls, ztile)
					}
					if FlipCoin() {
						ztile.rectangle.Y += size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					} else {
						ztile.rectangle.Y -= size
						if checkaddtilerecInner(ztile.rectangle, lev) {
							ztile.color2 = RandColor()
							lev.walls = append(lev.walls, ztile)
						}
					}
				}
			case 2: //TWO BLOKS
				x := lev.rectangles[i].X + b3
				y := lev.rectangles[i].Y + b3
				x2 := x + lev.rectangles[i].Width - b6
				y2 := y + lev.rectangles[i].Height - b6
				ztile.color2 = RandColor()
				ztile.rectangle = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
				if checkaddtilerecInner(ztile.rectangle, lev) {
					lev.walls = append(lev.walls, ztile)
				}
				choose2 := RandInt(1, 5)
				switch choose2 {
				case 1:
					ztile.rectangle.Y -= size
					if checkaddtilerecInner(ztile.rectangle, lev) {
						lev.walls = append(lev.walls, ztile)
					}
				case 2:
					ztile.rectangle.X += size
					if checkaddtilerecInner(ztile.rectangle, lev) {
						lev.walls = append(lev.walls, ztile)
					}
				case 3:
					ztile.rectangle.Y += size
					if checkaddtilerecInner(ztile.rectangle, lev) {
						lev.walls = append(lev.walls, ztile)
					}
				case 4:
					ztile.rectangle.X -= size
					if checkaddtilerecInner(ztile.rectangle, lev) {
						lev.walls = append(lev.walls, ztile)
					}
				}
			case 1: //SINGLE BLOK
				x := lev.rectangles[i].X + b2
				y := lev.rectangles[i].Y + b2
				x2 := x + lev.rectangles[i].Width - b4
				y2 := y + lev.rectangles[i].Height - b4
				ztile.color2 = RandColor()
				ztile.rectangle = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
				if checkaddtilerecInner(ztile.rectangle, lev) {
					lev.walls = append(lev.walls, ztile)
				}
			}
		}
		//MOVING BLOKS
		if Roll6() > 4 {
			x := lev.rectangles[i].X + size
			y := lev.rectangles[i].Y + size
			x2 := x + lev.rectangles[i].Width - size*2
			y2 := y + lev.rectangles[i].Height - size*2
			ztile := Tile{}
			ztile.image = walltile
			ztile.color2 = RandColor()
			ztile.color = rl.White
			ztile.fade = RandF32(0.3, 0.9)
			ztile.rectangle = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
			ztile.spikes = FlipCoin()
			if ztile.spikes {
				for j := 0; j < 4; j++ {
					ztile.color2 = RandColor()
					rec2 := ztile.rectangle
					rec2.X += ztile.rectangle.Width / 4
					rec2.Y += ztile.rectangle.Height / 4
					rec2.Width -= ztile.rectangle.Width / 2
					rec2.Height -= ztile.rectangle.Height / 2
					ztile.spikeRectangles = append(ztile.spikeRectangles, rec2)
				}
			}
			if checkaddtilerecInner(ztile.rectangle, lev) && checkRecPlayer(ztile.rectangle) {
				ztile.speed = RandF32(b/12, b/7)
				if FlipCoin() {
					ztile.dirX = ztile.speed
					if FlipCoin() {
						ztile.dirX = -ztile.dirX
					}
				} else {
					ztile.dirY = ztile.speed
					if FlipCoin() {
						ztile.dirY = -ztile.dirY
					}
				}
				lev.walls = append(lev.walls, ztile)
			}
		}
		//MARK: MAKE ETC
		//CRATES
		x := lev.rectangles[i].X
		y := lev.rectangles[i].Y
		x2 := x + lev.rectangles[i].Width - size
		y2 := y + lev.rectangles[i].Height - size
		ztile := Tile{}
		ztile.name = "crate"
		choose := RandInt(1, 5)
		switch choose {
		case 1:
			ztile.hp = 3
		case 2:
			ztile.hp = 1
		case 3:
			ztile.hp = 4
		case 4:
			ztile.hp = 2
		}
		ztile.image = otherTiles[choose]
		ztile.solid = true
		ztile.color = rl.White
		ztile.fade = 1
		ztile.rectangle = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), be7, be7)
		if checkaddtilerecInner(ztile.rectangle, lev) && checkaddetc(ztile.rectangle, lev) {
			ztile.center = makecnt(ztile.rectangle)
			lev.otherTiles = append(lev.otherTiles, ztile)
		}
		//WATER
		if Roll6() == 6 {
			x := lev.rectangles[i].X + size
			y := lev.rectangles[i].Y + size
			x2 := x + lev.rectangles[i].Width - size*3
			y2 := y + lev.rectangles[i].Height - size*3
			ztile := Tile{}
			ztile.name = "water"
			ztile.image = animation[0].rectangle
			ztile.color = rl.DarkBlue
			ztile.fade = RandF32(0.2, 0.5)
			ztile.rectangle = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
			ztile.image2 = splat[RandInt(0, len(splat))]
			ztile.rectangle2 = ztile.rectangle
			ztile.rectangle2.X -= b / 2
			ztile.rectangle2.Y -= b / 2
			ztile.rectangle2.Width += b
			ztile.rectangle2.Height += b
			if checkaddtilerecInner(ztile.rectangle, lev) && checkaddetc(ztile.rectangle, lev) {
				ztile.center = makecnt(ztile.rectangle)
				lev.otherTiles = append(lev.otherTiles, ztile)
			}
		}
		//SPIKE TRAPS
		if Roll6() == 6 {
			x := lev.rectangles[i].X + b/2
			y := lev.rectangles[i].Y + b/2
			x2 := x + lev.rectangles[i].Width - (size + b)
			y2 := y + lev.rectangles[i].Height - (size + b)
			ztile := Tile{}
			ztile.name = "spiketrap"
			ztile.image = animation[1].rectangle
			ztile.color = rl.White
			ztile.fade = 1
			ztile.rectangle = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
			if checkaddtilerecInner(ztile.rectangle, lev) && checkaddetc(ztile.rectangle, lev) {
				ztile.center = makecnt(ztile.rectangle)
				lev.otherTiles = append(lev.otherTiles, ztile)
			}
		}
		//FLAME TRAPS
		if Roll6() == 6 {
			x := lev.rectangles[i].X + b/2
			y := lev.rectangles[i].Y + b/2
			x2 := x + lev.rectangles[i].Width - (size + b)
			y2 := y + lev.rectangles[i].Height - (size + b)
			ztile := Tile{}
			ztile.name = "flametrap"
			ztile.image = animation[2].rectangle
			ztile.color = rl.White
			ztile.fade = 1
			ztile.rectangle = rl.NewRectangle(RandF32(x, x2), RandF32(y, y2), size, size)
			if checkaddtilerecInner(ztile.rectangle, lev) && checkaddetc(ztile.rectangle, lev) {
				ztile.rectangle2 = ztile.rectangle
				ztile.rectangle2.Height = 32
				ztile.rectangle2.Y += 4.5
				ztile.center = makecnt(ztile.rectangle)
				lev.otherTiles = append(lev.otherTiles, ztile)
			}
		}
	}
	countbreak := 100
	for {
		choose := RandInt(1, len(lev.rectangles))
		siz := b2 + b/2
		ztile := Tile{}
		ztile.name = "teleporter"
		ztile.image = animation[88].rectangle
		x := lev.rectangles[choose].X + b
		y := lev.rectangles[choose].Y + b
		x += RandF32(0, lev.rectangles[choose].Width-b-siz)
		y += RandF32(0, lev.rectangles[choose].Height-b-siz)
		ztile.rectangle = rl.NewRectangle(x, y, siz, siz)
		canadd := checkaddtilerecInner(ztile.rectangle, lev)
		if canadd {
			canadd = checkaddetc(ztile.rectangle, lev)
		}
		if canadd || countbreak == 0 {
			if canadd {
				ztile.cRectangle = ztile.rectangle
				ztile.cRectangle.X += ztile.cRectangle.Width / 3
				ztile.cRectangle.Width = ztile.cRectangle.Width / 3
				lev.otherTiles = append(lev.otherTiles, ztile)
			}
			break
		}
		countbreak--
	}
	return lev
}
func makelevel() { //MARK:MAKE LEVEL

	//MUSHROOM TIMER
	for i := 0; i < len(base.name); i++ {
		if base.name[i] == "mushroom patch" {
			if base.isUnlocked[i] {
				if mushroomTimer < mushroomTimerMax {
					mushroomTimer++
				}
			}
		}
	}
	//MOVE CHEST ITEMS TO STORE END OF LEVEL
	if levNumDis >= 1 && isStoreUnlocked {
		found := false
		for i := 0; i < len(levels[levNum].chests[0].item); i++ {
			if !levels[levNum].chests[0].item[i].isNoChestMove && levels[levNum].chests[0].item[i].name != "" {
				for j := 0; j < len(storeItm); j++ {
					if storeItm[j].name == levels[levNum].chests[0].item[i].name {
						storeItm[j].numof += levels[levNum].chests[0].item[i].numof
						found = true
						break
					}
				}
				if !found {
					for j := 0; j < len(storeItm); j++ {
						if storeItm[j].name == "" {
							storeItm[j] = levels[levNum].chests[0].item[i]
							found = true
							break
						}
					}
				}
			}
		}
		if found {
			admsg("chest items moved to store room", rl.Magenta)
		}
		if isStoreUnlocked {
			savestore()
			saveT = fps * 2
		}
	}
	//CLEAR NO CHEST MOVE
	for i := 0; i < len(player.inventory); i++ {
		if player.inventory[i].isNoChestMove {
			player.inventory[i].isNoChestMove = false
		}
	}
	//CLEAR ENEMIES XP +100
	if levNumDis >= 1 {
		if levels[levNum].enemyNum == 0 && !isBossOn {
			player.xp += 100
			xpadded = true
		}
	}

	completed := false

	levels = nil
	playerProjectiles = nil
	enemyProjectiles = nil
	effect = nil
	lightningEnm = nil

	if levNumDis == 0 && isBossOn {
		rl.StopMusicStream(music[currentMusic])
		currentMusic = musicNumPrev
		rl.PlayMusicStream(music[currentMusic])
		isBossOn = false
		isBossLevelOn = false
		player.hp = player.hpMax
		player.mana = player.manaMax
		isBaseOn = true
		pause = true
		saveT = fps * 2
		if vineRing {
			for i := 0; i < len(player.art); i++ {
				if player.art[i].name == "ring of vine" {
					player.art[i].isOff = false
				}
			}
		}
		if batty {
			batcomp.cnt = currentPosition
			batcomp.rectangle = rl.NewRectangle(batcomp.cnt.X-batcomp.rectangle.Width/2, batcomp.rectangle.Height/2, batcomp.rectangle.Width, batcomp.rectangle.Height)
			batcomp.moveChangeT = fps * 3
		}
		if rollo {
			rollocomp.cnt = currentPosition
			rollocomp.rectangle = rl.NewRectangle(rollocomp.cnt.X-rollocomp.rectangle.Width/2, rollocomp.cnt.Y-rollocomp.rectangle.Height/2, rollocomp.rectangle.Width, rollocomp.rectangle.Height)
		}
	}

	if !treasureRoom {
		levNumDis++
		if levNumDis == 11 {
			hasBossKeyChanged = false
			isBossOn = true
			isBossLevelOn = true
		}
	}

	msg = nil
	player.freezeTimer = 0
	player.burnTimer = 0
	player.poisonTimer = 0
	player.attackTimer = 0
	player.enemyCollisionTimer = 0
	player.dampTimer = 0
	player.pushTimer = 0
	msgT = 0
	teleportT = 0
	toptxT = 0

	if isBossLevelOn {
		makebosslev()
		makeboss()
	} else if treasureRoom {
		maketreasureroom()
	} else {
		floortile = floorTiles[RandInt(0, len(floorTiles))]
		walltile = wallTiles[RandInt(0, len(wallTiles))]
		admsg("", rl.White)
		admsg("entering level "+fmt.Sprint(levNumDis), rl.White)
		admsg(fmt.Sprint(welcome[RandInt(0, len(welcome))]), rl.White)
		if xpadded {
			admsg("+100 xp cleared all enemies", rl.Green)
			xpadded = false
		}
		//CENTER ROOM
		zlev := x1scr{}
		min, max := 5, 15
		numW, numH := RandInt(min, max), RandInt(min, max)
		numWo := numW
		numHo := numH
		width, height := float32(numW)*b, float32(numH)*b
		rec := rl.NewRectangle(currentPosition.X-width/2, currentPosition.Y-height/2, width, height)
		zdbg := xdbg{}
		zdbg.conecRoom = 0
		zdbg.side = 0
		zinf := xinf{}
		zinf.num = 0
		zinf.isVisible = true
		zlev.rectangles = append(zlev.rectangles, rec)
		zlev.inf = append(zlev.inf, zinf)
		zlev.dbg = append(zlev.dbg, zdbg)
		//OTHER ROOMS
		num := RandInt(11, 25)
		numTotal := 1
		countbreak := 100
		for {
			choose := 0
			if len(zlev.rectangles) > 1 {
				choose = RandInt(0, len(zlev.rectangles))
				numWo = int(zlev.rectangles[choose].Width / b)
				numHo = int(zlev.rectangles[choose].Height / b)
			}
			x := zlev.rectangles[choose].X
			y := zlev.rectangles[choose].Y
			numW, numH = RandInt(min, max), RandInt(min, max)
			width, height = float32(numW)*b, float32(numH)*b
			side := RandInt(1, 5)
			//side = 3
			canadd := true
			switch side {
			case 1: //UP
				y -= float32(numH) * b
				change := RandInt(-(numW - 2), numWo-2)
				x += float32(change) * b
				rec = rl.NewRectangle(x, y, width, height)
				canadd = checkrecaddto1scr(rec, zlev.rectangles)
			case 2: //RIGHT
				x += float32(numWo) * b
				change := RandInt(-(numH - 2), numHo-2)
				y += float32(change) * b
				rec = rl.NewRectangle(x, y, width, height)
				canadd = checkrecaddto1scr(rec, zlev.rectangles)
			case 3: //DOWN
				y += float32(numHo) * b
				change := RandInt(-(numW - 2), numWo-2)
				x += float32(change) * b
				rec = rl.NewRectangle(x, y, width, height)
				canadd = checkrecaddto1scr(rec, zlev.rectangles)
			case 4: //LEFT
				x -= float32(numW) * b
				change := RandInt(-(numH - 2), numHo-2)
				y += float32(change) * b
				rec = rl.NewRectangle(x, y, width, height)
				canadd = checkrecaddto1scr(rec, zlev.rectangles)
			}
			if canadd {
				num--
				zdbg = xdbg{}
				zdbg.conecRoom = choose
				zdbg.side = side
				zinf = xinf{}
				zinf.num = numTotal
				zinf.numW = numW
				zinf.numH = numH
				zinf.width = width
				zinf.height = height
				zinf.center = rl.NewVector2(rec.X+rec.Width/2, rec.Y+rec.Height/2)
				zlev.doors = append(zlev.doors, makedoor(side, zlev.rectangles[choose], rec))
				zlev.doorNums = append(zlev.doorNums, numTotal)
				zlev.rectangles = append(zlev.rectangles, rec)
				zlev.inf = append(zlev.inf, zinf)
				zlev.dbg = append(zlev.dbg, zdbg)
				numTotal++
			}
			countbreak--
			//MARK: ADD LEVEL EXTRAS
			if num == 0 || countbreak == 0 {
				zlev = makeleveltiles(zlev)
				zlev = makeinnerbloksetc(zlev)
				zlev = makeswitches(zlev)
				zlev = makechest(zlev)
				zlev = makeitems(zlev)
				zlev = cleardoorblocks(zlev)
				levels = append(levels, zlev)
				makeenemies()
				makenemcollisrecs()
				makebgi()
				makerocks()
				makemushroomsink()
				completed = makeexit()
				break
			}
		}
	}
	if !completed && !isBossOn && !treasureRoom {
		makelevel()
	}

	levT = 0
	levMins = 0
	levSecs = 0

	if levNumDis > 3 && !treasureRoom {
		if Roll12() > 8 {
			makeweaponcrate()
			rl.PlaySound(audfx[117])
		}
	}
	if isBossOn {
		levNumDis = 0
		musicNumPrev = currentMusic
		rl.StopMusicStream(music[currentMusic])
		currentMusic = 1
		rl.PlayMusicStream(music[currentMusic])
	}

	if !isBossOn && dispMusic == 0 {
		rl.StopMusicStream(music[currentMusic])
		currentMusic = RandInt(4, len(music))
		rl.PlayMusicStream(music[currentMusic])
	}

	player.hpTimer = fps * 3
	cursorV2 = currentPosition
	gameCursor = currentPosition

	//BAT COMPANION
	if batty {
		batcomp.cnt = currentPosition
		batcomp.rectangle = rl.NewRectangle(batcomp.cnt.X-batcomp.rectangle.Width/2, batcomp.rectangle.Height/2, batcomp.rectangle.Width, batcomp.rectangle.Height)
		batcomp.moveChangeT = fps * 3
	}
	//ROLLO COMPANION
	if rollo {
		siz2 := b / 2
		rollocomp.image = animation[153].rectangle
		rollocomp.cnt = currentPosition
		rollocomp.rectangle = rl.NewRectangle(rollocomp.cnt.X-siz2/2, rollocomp.cnt.Y-siz2/2, siz2, siz2)
		rollocomp.speed = 4
		for {
			rollocomp.dirX = RandF32(-rollocomp.speed, rollocomp.speed)
			if Abs(rollocomp.dirX) > rollocomp.speed/3 {
				break
			}
		}
		for {
			rollocomp.dirY = RandF32(-rollocomp.speed, rollocomp.speed)
			if Abs(rollocomp.dirY) > rollocomp.speed/3 {
				break
			}
		}
		rollocomp.atkT = fps * 3
	}

}
func makeweaponcrate() { //MARK:MAKE WEAPON CRATE

	levels[levNum].weaponCrate = WeaponCrate{}
	levels[levNum].weaponCrate.weaponNum = RandInt(1, len(weapons))
	levels[levNum].weaponCrate.tile.image = otherTiles[179]
	levels[levNum].weaponCrate.tile.rectangle = player.rectangle
	levels[levNum].weaponCrate.tile.rectangle.X -= 10
	levels[levNum].weaponCrate.tile.rectangle.Y -= 10
	levels[levNum].weaponCrate.tile.rectangle.Width += 20
	levels[levNum].weaponCrate.tile.rectangle.Height += 20
	levels[levNum].weaponCrate.tile.rectangle = finddropside(levels[levNum].weaponCrate.tile.rectangle, 0)
	levels[levNum].weaponCrate.tile.cRectangle = levels[levNum].weaponCrate.tile.rectangle
	levels[levNum].weaponCrate.tile.cRectangle.Y += 8
	levels[levNum].weaponCrate.tile.cRectangle.Height -= 16
	levels[levNum].weaponCrate.isOn = true

}
func makeexit() bool { //MARK:MAKE EXIT
	found := false
	countbreak := 100
	for {
		siz := b
		ztile := Tile{}
		num := RandInt(1, len(levels[levNum].rectangles))
		choose := levels[levNum].rectangles[num]
		cntr := makecnt(choose)
		ztile.rectangle = rl.NewRectangle(cntr.X-siz/2, cntr.Y-siz/2, siz, siz)
		canadd := checkRecWalls(ztile.rectangle)
		if canadd {
			canadd = checkRecEtc(ztile.rectangle)
		}
		if canadd {
			canadd = checkRecChests(ztile.rectangle)
		}
		if canadd {
			exitRoomNum = num
			ztile.name = "stairs"
			ztile.image = otherTiles[147]
			levels[levNum].otherTiles = append(levels[levNum].otherTiles, ztile)
			found = true
			break
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}

	return found
}
func makemushroomsink() { //MARK:MAKE MUSHROOMS PAPER INK
	//MUSHROOMS
	num := RandInt(2, 8)
	countbreak := 100
	for num > 0 {
		siz := b / 2
		zitm := Item{}
		choose := RandInt(1, 7)
		switch choose {
		case 1:
			zitm = itemList[105]
		case 2:
			zitm = itemList[106]
		case 3:
			zitm = itemList[107]
		case 4:
			zitm = itemList[108]
		case 5:
			zitm = itemList[109]
		case 6:
			zitm = itemList[110]
		}
		zitm.notquick = true
		zitm.center = findRanCnt()
		zitm.rectangle = rl.NewRectangle(zitm.center.X-siz/2, zitm.center.Y-siz/2, siz, siz)
		canadd := checkRecWalls(zitm.rectangle)
		if canadd {
			canadd = checkRecEtc(zitm.rectangle)
		}
		if canadd {
			canadd = checkRecPlayer(zitm.rectangle)
		}
		if canadd {
			levels[levNum].items = append(levels[levNum].items, zitm)
			num--
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	//PAPER INK
	num = RandInt(1, 5)
	countbreak = 100
	for num > 0 {
		siz := b / 2
		zitm := Item{}
		choose := RandInt(1, 3)
		switch choose {
		case 1:
			zitm = itemList[111]
		case 2:
			zitm = itemList[112]
		}
		zitm.notquick = true
		zitm.center = findRanCnt()
		zitm.rectangle = rl.NewRectangle(zitm.center.X-siz/2, zitm.center.Y-siz/2, siz, siz)
		canadd := checkRecWalls(zitm.rectangle)
		if canadd {
			canadd = checkRecEtc(zitm.rectangle)
		}
		if canadd {
			canadd = checkRecPlayer(zitm.rectangle)
		}
		if canadd {
			levels[levNum].items = append(levels[levNum].items, zitm)
			num--
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
}
func makerocks() { //MARK:MAKE ROCKS
	for i := 0; i < len(levels[levNum].rectangles); i++ {
		if Roll6() > 5 {
			countbreak := 100
			for {
				siz := RandF32(be7, b+bq3)
				x := levels[levNum].rectangles[i].X + b/2
				y := levels[levNum].rectangles[i].Y + b/2
				x += RandF32(0, levels[levNum].rectangles[i].Width-siz-b)
				y += RandF32(0, levels[levNum].rectangles[i].Height-siz-b)
				rec := rl.NewRectangle(x, y, siz, siz)
				canadd := checkRecWalls(rec)
				if canadd {
					canadd = checkRecEtc(rec)
				}
				if canadd {
					canadd = checkRecPlayer(rec)
				}
				if canadd {
					ztile := Tile{}
					ztile.image = rocksI[RandInt(0, len(rocksI))]
					ztile.rectangle = rec
					ztile.color = rl.White
					ztile.fade = 1
					ztile.name = "rock"
					levels[levNum].otherTiles = append(levels[levNum].otherTiles, ztile)
					break
				}
				countbreak--
				if countbreak == 0 {
					break
				}
			}
		}
	}
}
func makeswitches(lev x1scr) x1scr { //MARK:MAKE SWITCHES
	num := RandInt(1, 5)
	countbreak := 100
	siz := b / 2
	ztile := Tile{}
	ztile.name = "switch"
	ztile.color = rl.White
	ztile.fade = 1
	ztile.timer = fps * 3
	for num > 0 {
		ztile.numType = RandInt(1, 7)
		if ztile.numType == 4 {
			ztile.timer = fps * 30
		}
		chooseImg := RandInt(1, 3)
		switch chooseImg {
		case 1:
			ztile.image = otherTiles[132]
		case 2:
			ztile.image = otherTiles[134]
		}
		choose := RandInt(0, len(lev.rectangles))
		rec2 := lev.rectangles[choose]
		x := rec2.X + b + b/2
		y := rec2.Y + b + b/2
		x += RandF32(0, rec2.Width-b3-siz)
		y += RandF32(0, rec2.Height-b3-siz)
		ztile.rectangle = rl.NewRectangle(x, y, siz, siz)
		canadd := checkaddtilerecInner(ztile.rectangle, lev)
		if canadd {
			canadd = checkaddetc(ztile.rectangle, lev)
		}
		if canadd {
			num--
			ztile.center = makecnt(ztile.rectangle)
			ztile.room = choose
			lev.otherTiles = append(lev.otherTiles, ztile)
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	return lev
}
func makeswitchesTreasureRoom(lev x1scr, num2 int) x1scr { //MARK:MAKE SWITCHES TREASURE ROOM
	num := RandInt(30, 41)
	if num2 == 1 {
		num = RandInt(15, 21)
	}
	countbreak := 500
	siz := b / 2
	ztile := Tile{}
	ztile.name = "switch"
	ztile.color = rl.White
	ztile.fade = 1
	ztile.timer = fps * 3
	for num > 0 {
		ztile.numType = RandInt(1, 7)
		if ztile.numType == 4 {
			ztile.timer = fps * 30
		}
		chooseImg := RandInt(1, 3)
		switch chooseImg {
		case 1:
			ztile.image = otherTiles[132]
		case 2:
			ztile.image = otherTiles[134]
		}
		choose := RandInt(0, len(lev.rectangles))
		if Roll6() > 3 {
			choose = 0
		}
		rec2 := lev.rectangles[choose]
		x := rec2.X + b + b/2
		y := rec2.Y + b + b/2
		x += RandF32(0, rec2.Width-b3-siz)
		y += RandF32(0, rec2.Height-b3-siz)
		ztile.rectangle = rl.NewRectangle(x, y, siz, siz)
		canadd := checkaddtilerecInner(ztile.rectangle, lev)
		if canadd {
			canadd = checkaddetc(ztile.rectangle, lev)
		}
		if canadd {
			num--
			ztile.center = makecnt(ztile.rectangle)
			ztile.room = choose
			lev.otherTiles = append(lev.otherTiles, ztile)
		}
		countbreak--
		if countbreak == 0 {
			break
		}
	}
	return lev
}
func makeleveltiles(lev x1scr) x1scr { //MARK:MAKE LEVEL TILES
	//FLOORS
	ztile := Tile{}
	ztile.image = floortile
	ztile.fade = 0.08
	ztile.color = rl.White
	size := b
	for i := 0; i < len(lev.rectangles); i++ {
		x := lev.rectangles[i].X
		y := lev.rectangles[i].Y
		ztile := Tile{}
		ztile.image = floortile
		ztile.fade = 0.1
		ztile.color = rl.White
		for {
			ztile.fade = RandF32(0.04, 0.08)
			ztile.color2 = RandColor()
			ztile.rectangle = rl.NewRectangle(x, y, size, size)
			lev.floors = append(lev.floors, ztile)
			x += size
			if x >= lev.rectangles[i].X+lev.rectangles[i].Width {
				x = lev.rectangles[i].X
				y += size
			}
			if y >= lev.rectangles[i].Y+lev.rectangles[i].Height {
				break
			}
		}
	}
	//WALLS
	ztile.image = walltile
	for i := 0; i < len(lev.rectangles); i++ {
		//TOP BOTTOM
		size := b
		x := lev.rectangles[i].X
		y := lev.rectangles[i].Y - size
		for x < lev.rectangles[i].X+lev.rectangles[i].Width {
			ztile.fade = RandF32(0.3, 0.9)
			ztile.color2 = RandColor()
			ztile.rectangle = rl.NewRectangle(x, y, size, size)
			if checkaddtilerec(ztile.rectangle, lev) {
				lev.walls = append(lev.walls, ztile)
			}
			ztile.fade = RandF32(0.3, 0.9)
			ztile.color2 = RandColor()
			ztile.rectangle.Y += lev.rectangles[i].Height + size
			if checkaddtilerec(ztile.rectangle, lev) {
				lev.walls = append(lev.walls, ztile)
			}
			x += size
		}
		//RIGHT LEFT
		x = lev.rectangles[i].X - size
		y = lev.rectangles[i].Y - size
		for y <= lev.rectangles[i].Y+lev.rectangles[i].Height {
			ztile.fade = RandF32(0.3, 0.9)
			ztile.color2 = RandColor()
			ztile.rectangle = rl.NewRectangle(x, y, size, size)
			if checkaddtilerec(ztile.rectangle, lev) {
				lev.walls = append(lev.walls, ztile)
			}
			ztile.fade = RandF32(0.3, 0.9)
			ztile.color2 = RandColor()
			ztile.rectangle.X += lev.rectangles[i].Width + size
			if checkaddtilerec(ztile.rectangle, lev) {
				lev.walls = append(lev.walls, ztile)
			}
			y += size
		}
		lev.inf[i].wallsAdded = true
	}
	//REMOVE WALLS FOR DOORS
	for i := 0; i < len(lev.doors); i++ {
		for j := 0; j < len(lev.walls); j++ {
			if rl.CheckCollisionRecs(lev.doors[i], lev.walls[j].rectangle) {
				lev.walls[j].isOff = true
			}
		}
	}
	//REMOVE TWICE SEEMS TO MISS SOME WHEN ONLY ONCE
	for i := 0; i < len(lev.walls); i++ {
		if lev.walls[i].isOff {
			lev.walls = RemoveTile(lev.walls, i)
		}
	}
	for i := 0; i < len(lev.walls); i++ {
		if lev.walls[i].isOff {
			lev.walls = RemoveTile(lev.walls, i)
		}
	}
	//REMOVE DOUBLE WALL BLOCKS
	for i := 0; i < len(lev.walls); i++ {
	}
	return lev
}
func makedoor(side int, preRec, rec rl.Rectangle) rl.Rectangle { //MARK:MAKE DOOR
	door := rl.Rectangle{}
	siz := b
	switch side {
	case 1: //UP
		if preRec.X < rec.X {
			x := rec.X
			x2 := rec.X + rec.Width
			if preRec.X+preRec.Width < x2 {
				x2 = preRec.X + preRec.Width
			}
			numbloks := int((x2-x)/b) - 1
			x += float32(RandInt(0, numbloks)) * b
			door = rl.NewRectangle(x, preRec.Y-siz*2, siz*2, siz*3)
		} else {
			x := preRec.X
			x2 := rec.X + rec.Width
			if preRec.X+preRec.Width < x2 {
				x2 = preRec.X + preRec.Width
			}
			numbloks := int((x2-x)/b) - 1
			x += float32(RandInt(0, numbloks)) * b
			door = rl.NewRectangle(x, preRec.Y-siz*2, siz*2, siz*3)
		}
	case 2: //RIGHT
		if preRec.Y < rec.Y {
			y := rec.Y
			y2 := rec.Y + rec.Height
			if preRec.Y+preRec.Height < y2 {
				y2 = preRec.Y + preRec.Height
			}
			numbloks := int((y2-y)/b) - 1
			y += float32(RandInt(0, numbloks)) * b
			door = rl.NewRectangle(rec.X-siz, y, siz*3, siz*2)
		} else {
			y := preRec.Y
			y2 := rec.Y + rec.Height
			if preRec.Y+preRec.Height < y2 {
				y2 = preRec.Y + preRec.Height
			}
			numbloks := int((y2-y)/b) - 1
			y += float32(RandInt(0, numbloks)) * b
			door = rl.NewRectangle(rec.X-siz, y, siz*3, siz*2)
		}
	case 3: //DOWN
		if preRec.X < rec.X {
			x := rec.X
			x2 := rec.X + rec.Width
			if preRec.X+preRec.Width < x2 {
				x2 = preRec.X + preRec.Width
			}
			numbloks := int((x2-x)/b) - 1
			x += float32(RandInt(0, numbloks)) * b
			door = rl.NewRectangle(x, preRec.Y+preRec.Height-siz, siz*2, siz*3)
		} else {
			x := preRec.X
			x2 := rec.X + rec.Width
			if preRec.X+preRec.Width < x2 {
				x2 = preRec.X + preRec.Width
			}
			numbloks := int((x2-x)/b) - 1
			x += float32(RandInt(0, numbloks)) * b
			door = rl.NewRectangle(x, preRec.Y+preRec.Height-siz, siz*2, siz*3)
		}
	case 4: //LEFT
		if preRec.Y < rec.Y {
			y := rec.Y
			y2 := rec.Y + rec.Height
			if preRec.Y+preRec.Height < y2 {
				y2 = preRec.Y + preRec.Height
			}
			numbloks := int((y2-y)/b) - 1
			y += float32(RandInt(0, numbloks)) * b
			door = rl.NewRectangle(preRec.X-siz*2, y, siz*3, siz*2)
		} else {
			y := preRec.Y
			y2 := rec.Y + rec.Height
			if preRec.Y+preRec.Height < y2 {
				y2 = preRec.Y + preRec.Height
			}
			numbloks := int((y2-y)/b) - 1
			y += float32(RandInt(0, numbloks)) * b
			door = rl.NewRectangle(preRec.X-siz*2, y, siz*3, siz*2)
		}
	}
	return door
}
func makebgpix() { //MARK:MAKE BG PIX

	bgpix = nil
	spd := b / 2
	dirX := RandF32(-spd, spd)
	dirY := RandF32(-spd, spd)
	num := 100
	for num > 0 {
		z := BackgroundPicture{}
		z.color = RandColor()
		z.siz = RandF32(2, 5)
		z.dirX = dirX
		z.dirY = dirY
		z.fd = RandF32(0.5, 1)
		z.vector2 = rl.NewVector2(RandF32(0, screenWidthF32), RandF32(0, screenHeightF32))
		bgpix = append(bgpix, z)
		num--
	}
}
func makescan() { //MARK:MAKE SCAN LINES
	//SCAN
	scan = nil
	scanlineSpc = float32(5)
	if medium {
		scanlineSpc = 4
	}
	if large {
		scanlineSpc = 8
	}
	if xxl {
		scanlineSpc = 15
	}
	x := float32(0)
	y := float32(-scanlineSpc)
	for y <= screenHeightF32+scanlineSpc {
		scan = append(scan, rl.NewVector2(x, y))
		y += scanlineSpc
	}
}
func makeintroexitbg() { //MARK:MAKE INTRO EXIT BACKGROUND

	introbg = nil
	introbgimgnum = RandInt(1, 5)
	num := 20
	for num > 0 {
		backgroundPicture := BackgroundPicture{}
		backgroundPicture.fd = 0.15
		backgroundPicture.speed = 2
		backgroundPicture.dirX = backgroundPicture.speed
		if FlipCoin() {
			backgroundPicture.dirX *= -1
		}
		backgroundPicture.dirY = backgroundPicture.speed
		if FlipCoin() {
			backgroundPicture.dirY *= -1
		}
		backgroundPicture.color = BrightPink()
		backgroundPicture.siz = b4
		backgroundPicture.vector2 = rl.NewVector2(RandF32(0, screenWidthF32), RandF32(0, screenHeightF32))
		introbg = append(introbg, backgroundPicture)
		num--
	}
}
func makeinitial() { //MARK:MAKE INITIAL

	//END GAME
	endRec = rl.NewRectangle(currentPosition.X-360, currentPosition.Y-360, 720, 720)
	endRec.Y -= b2
	//GAME OVER
	gameoveranimRec = animation[205].rectangle
	makeintroexitbg()
	//MAKE OPTIONS CHARACTER SCREEN MOVING BG
	makebgpix()
	makescan()
	//BORDER SIDEBAR RECS
	W := float32(Wbloks) * b
	H := float32(Hbloks) * b
	inRec = rl.NewRectangle(currentPosition.X-W/2, currentPosition.Y-H/2, W, H)
	siz := b10 * 2
	optionsRec = rl.NewRectangle(currentPosition.X-siz/2, 0, siz, screenHeightF32*2)
	siz *= 2
	storeRec = rl.NewRectangle(currentPosition.X-siz/2, 0, siz, screenHeightF32*2)

	//STORE ROOM
	for i := 0; i < 90; i++ {
		storeItm = append(storeItm, Item{})
	}

	//ROLLO COMPANION
	siz2 := b / 2
	rollocomp.image = animation[153].rectangle
	rollocomp.cnt = currentPosition
	rollocomp.rectangle = rl.NewRectangle(rollocomp.cnt.X-siz2/2, rollocomp.cnt.Y-siz2/2, siz2, siz2)
	rollocomp.speed = 4
	for {
		rollocomp.dirX = RandF32(-rollocomp.speed, rollocomp.speed)
		if Abs(rollocomp.dirX) > rollocomp.speed/3 {
			break
		}
	}
	for {
		rollocomp.dirY = RandF32(-rollocomp.speed, rollocomp.speed)
		if Abs(rollocomp.dirY) > rollocomp.speed/3 {
			break
		}
	}
	rollocomp.atkT = fps * 7

	//BAT COMPANION
	siz2 = b
	batcomp.image = animation[141].rectangle
	batcomp.cnt = currentPosition
	batcomp.rectangle = rl.NewRectangle(batcomp.cnt.X-siz2/2, batcomp.cnt.Y-siz2/2, siz2, siz2)
	batcomp.moveChangeT = fps * 3
	batcomp.speed = 2
	batcomp.dirX = RandF32(-batcomp.speed, batcomp.speed)
	batcomp.dirY = RandF32(-batcomp.speed, batcomp.speed)
	batcomp.atkT = fps * 7

	//RESOLUTION LISTS

	//16X9
	res169 = append(res169, "1280 x 720")
	res169 = append(res169, "1366 x 768")
	res169 = append(res169, "1600 x 900")
	res169 = append(res169, "1760 x 990")
	res169 = append(res169, "1920 x 1080")
	res169 = append(res169, "2560 x 1440")
	res169 = append(res169, "3840 x 2160")

	//16X10
	res1610 = append(res1610, "1280 x 800")
	res1610 = append(res1610, "1440 x 900")
	res1610 = append(res1610, "1680 x 1050")
	res1610 = append(res1610, "1920 x 1200")
	res1610 = append(res1610, "2560 x 1600")
	res1610 = append(res1610, "3840 x 2400")

	//16X9
	if scrW == 1280 && scrH == 720 || scrW == 1366 && scrH == 768 || scrW == 1600 && scrH == 900 || scrW == 1760 && scrH == 990 || scrW == 1920 && scrH == 1080 || scrW == 2560 && scrH == 1440 || scrW == 3840 && scrH == 2160 {
		asp169 = true
		asp1610 = false
	}
	//16X10
	if scrW == 1280 && scrH == 800 || scrW == 1440 && scrH == 900 || scrW == 1680 && scrH == 1050 || scrW == 1920 && scrH == 1200 || scrW == 2560 && scrH == 1600 || scrW == 3840 && scrH == 2400 {
		asp169 = false
		asp1610 = true
	}

	if !asp169 && !asp1610 {
		if scrH >= 720 {
			reslist = append(reslist, res169[0])
			if scrH == 720 {
				currentres = 0
			}
		}
		if scrH >= 800 {
			reslist = append(reslist, res1610[0])
			if scrH == 800 {
				currentres = 1
			}
		}
		if scrH >= 900 {
			reslist = append(reslist, res1610[1])
			reslist = append(reslist, res169[2])
			if scrH == 900 {
				currentres = 2
			}
		}
		if scrH >= 990 {
			reslist = append(reslist, res169[3])
			if scrH == 990 {
				currentres = 4
			}
		}
		if scrH >= 1050 {
			reslist = append(reslist, res1610[2])
			if scrH == 1050 {
				currentres = 5
			}
		}
		if scrH >= 1080 {
			reslist = append(reslist, res169[4])
			if scrH == 1080 {
				currentres = 6
			}
		}
		if scrH >= 1200 {
			reslist = append(reslist, res1610[3])
			if scrH == 1200 {
				currentres = 7
			}
		}
		if scrH >= 1440 {
			reslist = append(reslist, res169[5])
			if scrH == 1440 {
				currentres = 8
			}
		}
		if scrH >= 1600 {
			reslist = append(reslist, res1610[4])
			if scrH == 1600 {
				currentres = 9
			}
		}
		if scrH >= 2160 {
			reslist = append(reslist, res169[6])
			if scrH == 2160 {
				currentres = 10
			}
		}
		if scrH >= 2400 {
			reslist = append(reslist, res1610[5])
			if scrH == 2400 {
				currentres = 11
			}
		}
	} else if asp1610 {
		if scrH >= 800 {
			reslist = append(reslist, res1610[0])
			if scrH == 800 {
				currentres = 0
			}
		}
		if scrH >= 900 {
			reslist = append(reslist, res1610[1])
			if scrH == 900 {
				currentres = 1
			}
		}
		if scrH >= 1050 {
			reslist = append(reslist, res1610[2])
			if scrH == 1050 {
				currentres = 2
			}
		}
		if scrH >= 1200 {
			reslist = append(reslist, res1610[3])
			if scrH == 1200 {
				currentres = 3
			}
		}
		if scrH >= 1600 {
			reslist = append(reslist, res1610[4])
			if scrH == 1600 {
				currentres = 4
			}
		}
		if scrH >= 2400 {
			reslist = append(reslist, res1610[5])
			if scrH == 2400 {
				currentres = 5
			}
		}
	} else if asp169 {
		if scrH >= 720 {
			reslist = append(reslist, res169[0])
			if scrH == 720 {
				currentres = 0
			}
		}
		if scrH >= 768 {
			reslist = append(reslist, res169[1])
			if scrH == 768 {
				currentres = 1
			}
		}
		if scrH >= 900 {
			reslist = append(reslist, res169[2])
			if scrH == 900 {
				currentres = 2
			}
		}
		if scrH >= 990 {
			reslist = append(reslist, res169[3])
			if scrH == 990 {
				currentres = 3
			}
		}
		if scrH >= 1080 {
			reslist = append(reslist, res169[4])
			if scrH == 1080 {
				currentres = 4
			}
		}
		if scrH >= 1440 {
			reslist = append(reslist, res169[5])
			if scrH == 1440 {
				currentres = 5
			}
		}
		if scrH >= 2160 {
			reslist = append(reslist, res169[6])
			if scrH == 2160 {
				currentres = 6
			}
		}
	}

	prevres = currentres
}
func makeshaders() { //MARK:MAKE SHADERS
	if medium {
		shader = rl.LoadShader("", "shaders/bloom_sml.fs")
	} else {
		shader = rl.LoadShader("", "shaders/bloom.fs")
	}
}

func makeimgs() { //MARK:MAKE IMGS
	//ETC IMGS
	otherTiles = append(otherTiles, rl.NewRectangle(0, 33, 13, 13))         //0 MOVING BLOK SPIKE
	otherTiles = append(otherTiles, rl.NewRectangle(0, 52, 32, 32))         //1 PINK CRATE
	otherTiles = append(otherTiles, rl.NewRectangle(32, 52, 32, 32))        //2 OLD CRATE
	otherTiles = append(otherTiles, rl.NewRectangle(64, 52, 32, 32))        //3 BLUE CRATE
	otherTiles = append(otherTiles, rl.NewRectangle(96, 52, 32, 32))        //4 NEW CRATE
	otherTiles = append(otherTiles, rl.NewRectangle(128, 52, 32, 32))       //5 CRATE HIT
	otherTiles = append(otherTiles, rl.NewRectangle(160, 52, 32, 32))       //6 OLD CRATE HIT
	otherTiles = append(otherTiles, rl.NewRectangle(16, 32, 16, 16))        //7 CURSOR
	otherTiles = append(otherTiles, rl.NewRectangle(203, 58, 21, 21))       //8 KITCHEN KNIFE
	otherTiles = append(otherTiles, rl.NewRectangle(517, 55, 43, 43))       //9 SCROLL 1
	otherTiles = append(otherTiles, rl.NewRectangle(560, 55, 43, 43))       //10 SCROLL 2
	otherTiles = append(otherTiles, rl.NewRectangle(603, 55, 43, 43))       //11 SCROLL 3
	otherTiles = append(otherTiles, rl.NewRectangle(646, 55, 43, 43))       //12 SCROLL 4
	otherTiles = append(otherTiles, rl.NewRectangle(689, 55, 43, 43))       //13 SCROLL 5
	otherTiles = append(otherTiles, rl.NewRectangle(732, 55, 43, 43))       //14 SCROLL 6
	otherTiles = append(otherTiles, rl.NewRectangle(775, 55, 43, 43))       //15 SCROLL 7
	otherTiles = append(otherTiles, rl.NewRectangle(818, 55, 43, 43))       //16 SCROLL 8
	otherTiles = append(otherTiles, rl.NewRectangle(228, 51, 32, 32))       //17 SCOPE
	otherTiles = append(otherTiles, rl.NewRectangle(392, 157, 64, 64))      //18 TOOLS
	otherTiles = append(otherTiles, rl.NewRectangle(659, 160, 64, 64))      //19 GAS CAN
	otherTiles = append(otherTiles, rl.NewRectangle(520, 157, 64, 64))      //20 BATTERY
	otherTiles = append(otherTiles, rl.NewRectangle(802, 159, 64, 64))      //21 MAP
	otherTiles = append(otherTiles, rl.NewRectangle(392, 158, 28, 28))      //22 BACKPACK
	otherTiles = append(otherTiles, rl.NewRectangle(712, 157, 64, 64))      //23 AMMO BOX
	otherTiles = append(otherTiles, rl.NewRectangle(396, 192, 26, 26))      //24 STEROIDS
	otherTiles = append(otherTiles, rl.NewRectangle(728, 160, 64, 64))      //25 MEDIKIT
	otherTiles = append(otherTiles, rl.NewRectangle(518, 159, 64, 64))      //26 BRAIN
	otherTiles = append(otherTiles, rl.NewRectangle(1020, 160, 64, 64))     //27 EYE
	otherTiles = append(otherTiles, rl.NewRectangle(430, 158, 20, 20))      //28 BEAR TRAP
	otherTiles = append(otherTiles, rl.NewRectangle(100, 33, 16, 16))       //29 HEART
	otherTiles = append(otherTiles, rl.NewRectangle(496, 59, 9, 9))         //30 MINI SPIKE
	otherTiles = append(otherTiles, rl.NewRectangle(1500, 20, 14, 14))      //31 SKELETON BONE
	otherTiles = append(otherTiles, rl.NewRectangle(117, 33, 16, 16))       //32 GREY HEART
	otherTiles = append(otherTiles, rl.NewRectangle(190, 1309, 114, 114))   //33 TENT
	otherTiles = append(otherTiles, rl.NewRectangle(565, 373, 16, 16))      //34 BASE BG 1
	otherTiles = append(otherTiles, rl.NewRectangle(581, 373, 16, 16))      //35 BASE BG 2
	otherTiles = append(otherTiles, rl.NewRectangle(597, 373, 16, 16))      //36 BASE BG 3
	otherTiles = append(otherTiles, rl.NewRectangle(613, 373, 16, 16))      //37 BASE BG 4
	otherTiles = append(otherTiles, rl.NewRectangle(629, 373, 16, 16))      //38 BASE BG 5
	otherTiles = append(otherTiles, rl.NewRectangle(743, 413, 135, 135))    //39 BASE ROCK
	otherTiles = append(otherTiles, rl.NewRectangle(908, 385, 240, 240))    //40 BASE HOBBIT
	otherTiles = append(otherTiles, rl.NewRectangle(528, 410, 200, 200))    //41 BASE SKULL EXIT
	otherTiles = append(otherTiles, rl.NewRectangle(1376, 268, 27, 27))     //42 BASE ARCADE 1
	otherTiles = append(otherTiles, rl.NewRectangle(1407, 268, 27, 27))     //43 BASE ARCADE 2
	otherTiles = append(otherTiles, rl.NewRectangle(1162, 380, 211, 240))   //44 BASE WEAPON SHED
	otherTiles = append(otherTiles, rl.NewRectangle(1385, 385, 207, 250))   //45 BASE APOTHECARYY
	otherTiles = append(otherTiles, rl.NewRectangle(1608, 412, 112, 112))   //46 BASE LOCK
	otherTiles = append(otherTiles, rl.NewRectangle(1492, 158, 48, 48))     //47 BASE FIRE STONE
	otherTiles = append(otherTiles, rl.NewRectangle(1818, 446, 98, 98))     //48 BASE TREE
	otherTiles = append(otherTiles, rl.NewRectangle(1615, 534, 128, 128))   //49 BASE GROUND
	otherTiles = append(otherTiles, rl.NewRectangle(400, 372, 24, 24))      //50 GOLD
	otherTiles = append(otherTiles, rl.NewRectangle(424, 372, 24, 24))      //51 SILVER
	otherTiles = append(otherTiles, rl.NewRectangle(448, 372, 24, 24))      //52 BRONZE
	otherTiles = append(otherTiles, rl.NewRectangle(472, 372, 24, 24))      //53 LEAD
	otherTiles = append(otherTiles, rl.NewRectangle(496, 372, 24, 24))      //54 PLATINUM
	otherTiles = append(otherTiles, rl.NewRectangle(524, 374, 32, 32))      //55 SCRAP
	otherTiles = append(otherTiles, rl.NewRectangle(485, 404, 32, 32))      //56 WATCH
	otherTiles = append(otherTiles, rl.NewRectangle(458, 400, 24, 24))      //57 SHRIMP
	otherTiles = append(otherTiles, rl.NewRectangle(434, 400, 21, 21))      //58 FLASK
	otherTiles = append(otherTiles, rl.NewRectangle(402, 398, 27, 27))      //59 PISTOL
	otherTiles = append(otherTiles, rl.NewRectangle(491, 440, 19, 19))      //60 TURTLE
	otherTiles = append(otherTiles, rl.NewRectangle(460, 428, 22, 22))      //61 SNEAKERS
	otherTiles = append(otherTiles, rl.NewRectangle(438, 428, 18, 18))      //62 SODA
	otherTiles = append(otherTiles, rl.NewRectangle(416, 428, 20, 20))      //63 KEY
	otherTiles = append(otherTiles, rl.NewRectangle(488, 462, 22, 22))      //64 SUNGLASSES
	otherTiles = append(otherTiles, rl.NewRectangle(462, 454, 21, 21))      //65 ICE CREAM
	otherTiles = append(otherTiles, rl.NewRectangle(440, 454, 21, 21))      //66 BASKETBALL
	otherTiles = append(otherTiles, rl.NewRectangle(415, 454, 20, 20))      //67 JAR ORANGE
	otherTiles = append(otherTiles, rl.NewRectangle(484, 488, 29, 29))      //68 JAR RED
	otherTiles = append(otherTiles, rl.NewRectangle(461, 483, 21, 21))      //69 RECORD
	otherTiles = append(otherTiles, rl.NewRectangle(433, 481, 24, 24))      //70 BROCCOLI
	otherTiles = append(otherTiles, rl.NewRectangle(400, 481, 29, 29))      //71 DRILL
	otherTiles = append(otherTiles, rl.NewRectangle(308, 542, 32, 32))      //72 COOK BOOK
	otherTiles = append(otherTiles, rl.NewRectangle(457, 512, 21, 21))      //73 ICE LOLLY
	otherTiles = append(otherTiles, rl.NewRectangle(435, 511, 23, 23))      //74 TOILET PAPER
	otherTiles = append(otherTiles, rl.NewRectangle(409, 513, 19, 19))      //75 GARLIC
	otherTiles = append(otherTiles, rl.NewRectangle(484, 551, 26, 26))      //76 TENDERISER
	otherTiles = append(otherTiles, rl.NewRectangle(455, 541, 24, 24))      //77 CLEAVER
	otherTiles = append(otherTiles, rl.NewRectangle(431, 542, 24, 24))      //78 SKULL BOTTLE
	otherTiles = append(otherTiles, rl.NewRectangle(1410, 154, 18, 18))     //79 ENEMY BURN ICON
	otherTiles = append(otherTiles, rl.NewRectangle(745, 556, 64, 64))      //80 ENEMY BLEED ICON
	otherTiles = append(otherTiles, rl.NewRectangle(1441, 275, 16, 16))     //81 ENEMY POISON ICON
	otherTiles = append(otherTiles, rl.NewRectangle(1460, 274, 18, 18))     //82 ENEMY STUN ICON
	otherTiles = append(otherTiles, rl.NewRectangle(1480, 275, 16, 16))     //83 MANA ICON
	otherTiles = append(otherTiles, rl.NewRectangle(1497, 275, 14, 14))     //84 RESIST FIRE ICON
	otherTiles = append(otherTiles, rl.NewRectangle(1512, 274, 16, 16))     //85 RESIST POISON ICON
	otherTiles = append(otherTiles, rl.NewRectangle(1531, 274, 16, 16))     //86 INVISIBLE ICON
	otherTiles = append(otherTiles, rl.NewRectangle(1549, 274, 16, 16))     //87 ARMOR ICON
	otherTiles = append(otherTiles, rl.NewRectangle(181, 418, 18, 18))      //88 INTANGIBLE ICON
	otherTiles = append(otherTiles, rl.NewRectangle(208, 411, 42, 42))      //89 STATS POWER ICON
	otherTiles = append(otherTiles, rl.NewRectangle(330, 592, 64, 64))      //90 DICE
	otherTiles = append(otherTiles, rl.NewRectangle(284, 465, 64, 64))      //91 DUMBBELL
	otherTiles = append(otherTiles, rl.NewRectangle(250, 412, 34, 34))      //92 BASKETBALL SNEAKERS
	otherTiles = append(otherTiles, rl.NewRectangle(6, 261, 19, 19))        //93 EMERALD RING
	otherTiles = append(otherTiles, rl.NewRectangle(30, 261, 19, 19))       //94 PEARL RING
	otherTiles = append(otherTiles, rl.NewRectangle(54, 261, 19, 19))       //95 GOLD RING
	otherTiles = append(otherTiles, rl.NewRectangle(80, 263, 17, 17))       //96 QUAIL EGG
	otherTiles = append(otherTiles, rl.NewRectangle(103, 259, 26, 26))      //97 TESLA COIL
	otherTiles = append(otherTiles, rl.NewRectangle(136, 259, 24, 24))      //98 SAPPHIRE AMULET
	otherTiles = append(otherTiles, rl.NewRectangle(166, 259, 24, 24))      //99 TURQUOISE AMULET
	otherTiles = append(otherTiles, rl.NewRectangle(196, 258, 22, 22))      //100 BELT
	otherTiles = append(otherTiles, rl.NewRectangle(224, 261, 20, 20))      //101 MIRROR
	otherTiles = append(otherTiles, rl.NewRectangle(248, 262, 28, 28))      //102 TOXIC SLUDGE
	otherTiles = append(otherTiles, rl.NewRectangle(283, 262, 20, 20))      //103 THROWING KNIFE
	otherTiles = append(otherTiles, rl.NewRectangle(309, 260, 23, 23))      //104 BEETROOT
	otherTiles = append(otherTiles, rl.NewRectangle(334, 259, 24, 24))      //105 MAGICIANS HAT
	otherTiles = append(otherTiles, rl.NewRectangle(366, 261, 16, 16))      //106 PEARL
	otherTiles = append(otherTiles, rl.NewRectangle(4, 284, 24, 24))        //107 CANDY CANE
	otherTiles = append(otherTiles, rl.NewRectangle(34, 286, 28, 28))       //108 LIGHTBULB
	otherTiles = append(otherTiles, rl.NewRectangle(70, 286, 20, 20))       //109 MUG
	otherTiles = append(otherTiles, rl.NewRectangle(97, 291, 26, 26))       //110 FEATHER
	otherTiles = append(otherTiles, rl.NewRectangle(130, 289, 23, 23))      //111 CAPE
	otherTiles = append(otherTiles, rl.NewRectangle(162, 293, 18, 18))      //112 LADYBIRD
	otherTiles = append(otherTiles, rl.NewRectangle(184, 289, 25, 25))      //113 MUG OF TEA
	otherTiles = append(otherTiles, rl.NewRectangle(214, 292, 16, 16))      //114 FLAMINGO
	otherTiles = append(otherTiles, rl.NewRectangle(234, 295, 23, 23))      //115 NINJA STAR
	otherTiles = append(otherTiles, rl.NewRectangle(264, 297, 21, 21))      //116 ORANGE SLICE
	otherTiles = append(otherTiles, rl.NewRectangle(291, 290, 21, 21))      //117 TV
	otherTiles = append(otherTiles, rl.NewRectangle(429, 199, 24, 24))      //118 TOASTER
	otherTiles = append(otherTiles, rl.NewRectangle(349, 287, 31, 31))      //119 LOLLIPOP
	otherTiles = append(otherTiles, rl.NewRectangle(3, 325, 28, 28))        //120 HONEYCOMB
	otherTiles = append(otherTiles, rl.NewRectangle(38, 325, 24, 24))       //121 EGGS
	otherTiles = append(otherTiles, rl.NewRectangle(70, 324, 21, 21))       //122 POPCORN
	otherTiles = append(otherTiles, rl.NewRectangle(93, 325, 29, 29))       //123 BOMB
	otherTiles = append(otherTiles, rl.NewRectangle(129, 328, 26, 26))      //124 OVEN GLOVE
	otherTiles = append(otherTiles, rl.NewRectangle(162, 324, 32, 32))      //125 NOODLES
	otherTiles = append(otherTiles, rl.NewRectangle(199, 324, 28, 28))      //126 GAS MASK
	otherTiles = append(otherTiles, rl.NewRectangle(1845, 706, 56, 56))     //127 TELEPORT CRYSTAL
	otherTiles = append(otherTiles, rl.NewRectangle(220, 538, 16, 16))      //128 VINE
	otherTiles = append(otherTiles, rl.NewRectangle(233, 323, 20, 20))      //129 CROISSANT
	otherTiles = append(otherTiles, rl.NewRectangle(323, 292, 24, 24))      //130 CHICKEN EGG
	otherTiles = append(otherTiles, rl.NewRectangle(326, 387, 64, 64))      //131 POPCORN
	otherTiles = append(otherTiles, rl.NewRectangle(126, 367, 18, 18))      //132 PRESSURE PLATE RED UP
	otherTiles = append(otherTiles, rl.NewRectangle(144, 367, 18, 18))      //133 PRESSURE PLATE RED DOWN
	otherTiles = append(otherTiles, rl.NewRectangle(162, 367, 18, 18))      //134 PRESSURE PLATE BLUE UP
	otherTiles = append(otherTiles, rl.NewRectangle(180, 367, 18, 18))      //135 PRESSURE PLATE BLUE DOWN
	otherTiles = append(otherTiles, rl.NewRectangle(211, 366, 14, 14))      //136 SWITCH LEFT
	otherTiles = append(otherTiles, rl.NewRectangle(225, 366, 14, 14))      //137 SWITCH RIGHT
	otherTiles = append(otherTiles, rl.NewRectangle(127, 390, 12, 12))      //138 DART
	otherTiles = append(otherTiles, rl.NewRectangle(1100, 943, 16, 16))     //139 MUSHROOM INVIS
	otherTiles = append(otherTiles, rl.NewRectangle(1116, 943, 16, 16))     //140 MUSHROOM MANA
	otherTiles = append(otherTiles, rl.NewRectangle(1132, 943, 16, 16))     //141 MUSHROOM FIRE
	otherTiles = append(otherTiles, rl.NewRectangle(1148, 943, 16, 16))     //142 MUSHROOM HEALTH
	otherTiles = append(otherTiles, rl.NewRectangle(1164, 943, 16, 16))     //143 MUSHROOM POISON
	otherTiles = append(otherTiles, rl.NewRectangle(1180, 943, 16, 16))     //144 MUSHROOM ARMOR
	otherTiles = append(otherTiles, rl.NewRectangle(1153, 1307, 64, 64))    //145 PAPER
	otherTiles = append(otherTiles, rl.NewRectangle(1241, 1309, 64, 64))    //146 INK
	otherTiles = append(otherTiles, rl.NewRectangle(1226, 1198, 16, 16))    //147 STAIRS
	otherTiles = append(otherTiles, rl.NewRectangle(1310, 1291, 58, 58))    //148 ICEMAN PROJ
	otherTiles = append(otherTiles, rl.NewRectangle(266, 1658, 256, 256))   //149 ICE CUBE
	otherTiles = append(otherTiles, rl.NewRectangle(1502, 1284, 64, 64))    //150 LANDMINE
	otherTiles = append(otherTiles, rl.NewRectangle(1330, 2405, 16, 16))    //151 BUSH
	otherTiles = append(otherTiles, rl.NewRectangle(1432, 1659, 128, 128))  //152 BIRD EGG PROJ
	otherTiles = append(otherTiles, rl.NewRectangle(1384, 1815, 32, 32))    //153 BIRD PROJ FRIED EGG
	otherTiles = append(otherTiles, rl.NewRectangle(73, 1814, 64, 64))      //154 WEAPON CARROTS
	otherTiles = append(otherTiles, rl.NewRectangle(0, 1835, 29, 29))       //155 WEAPON CARROTS PROJ
	otherTiles = append(otherTiles, rl.NewRectangle(28, 1837, 32, 32))      //156 WINDOW CLEANER
	otherTiles = append(otherTiles, rl.NewRectangle(4, 1878, 24, 24))       //157 RUBBER DUCK
	otherTiles = append(otherTiles, rl.NewRectangle(34, 1878, 28, 28))      //158 FRYING PAN
	otherTiles = append(otherTiles, rl.NewRectangle(74, 1884, 28, 28))      //159 ROLLING PIN
	otherTiles = append(otherTiles, rl.NewRectangle(104, 1882, 32, 32))     //160 MUSTARD
	otherTiles = append(otherTiles, rl.NewRectangle(0, 1910, 32, 32))       //161 POWER STRIP
	otherTiles = append(otherTiles, rl.NewRectangle(150, 1819, 15, 15))     //162 SPLINTERS
	otherTiles = append(otherTiles, rl.NewRectangle(172, 1818, 31, 31))     //163 MINT ICREAM
	otherTiles = append(otherTiles, rl.NewRectangle(158, 1868, 64, 64))     //164 LIGHTER
	otherTiles = append(otherTiles, rl.NewRectangle(1490, 2381, 64, 64))    //165 MAGNIFIYING GLASS
	otherTiles = append(otherTiles, rl.NewRectangle(412, 539, 15, 15))      //166 RASPBERRY
	otherTiles = append(otherTiles, rl.NewRectangle(46, 1916, 22, 22))      //167 ORBITAL LOLLY
	otherTiles = append(otherTiles, rl.NewRectangle(1567, 1642, 38, 38))    //168 PINEAPPLE
	otherTiles = append(otherTiles, rl.NewRectangle(1608, 1627, 64, 64))    //169 PINEAPPLE RING
	otherTiles = append(otherTiles, rl.NewRectangle(1856, 2316, 64, 64))    //170 FORK
	otherTiles = append(otherTiles, rl.NewRectangle(1939, 2317, 58, 58))    //171 CHILLI
	otherTiles = append(otherTiles, rl.NewRectangle(1763, 2318, 15, 15))    //172 EMOJI
	otherTiles = append(otherTiles, rl.NewRectangle(1784, 2316, 19, 19))    //173 FRENCH FRIES
	otherTiles = append(otherTiles, rl.NewRectangle(1812, 2313, 25, 25))    //174 SOUP LADLE
	otherTiles = append(otherTiles, rl.NewRectangle(1856, 2394, 22, 22))    //175 MUSIC NOTE
	otherTiles = append(otherTiles, rl.NewRectangle(2024, 2317, 64, 64))    //176 GUITAR
	otherTiles = append(otherTiles, rl.NewRectangle(2112, 2319, 64, 64))    //177 DRAWING PIN
	otherTiles = append(otherTiles, rl.NewRectangle(1897, 2391, 64, 64))    //178 FRENCH FRIES PROJ
	otherTiles = append(otherTiles, rl.NewRectangle(1925, 0, 128, 128))     //179 WEAPON CRATE
	otherTiles = append(otherTiles, rl.NewRectangle(1941, 206, 256, 256))   //180 BOOK
	otherTiles = append(otherTiles, rl.NewRectangle(2254, 224, 128, 128))   //181 STAR
	otherTiles = append(otherTiles, rl.NewRectangle(2227, 1, 25, 25))       //182 PSYCHEDELICS
	otherTiles = append(otherTiles, rl.NewRectangle(2257, 3, 24, 24))       //183 BOOTS
	otherTiles = append(otherTiles, rl.NewRectangle(2283, 1, 28, 28))       //184 FART GAS
	otherTiles = append(otherTiles, rl.NewRectangle(2311, 1, 28, 28))       //185 MACHINE
	otherTiles = append(otherTiles, rl.NewRectangle(2346, 1, 32, 32))       //186 SALT
	otherTiles = append(otherTiles, rl.NewRectangle(2085, 70, 18, 18))      //187 UMBRELLA
	otherTiles = append(otherTiles, rl.NewRectangle(2109, 71, 28, 28))      //188 WEAPON CASE
	otherTiles = append(otherTiles, rl.NewRectangle(2145, 69, 40, 40))      //189 BOSS STATUE
	otherTiles = append(otherTiles, rl.NewRectangle(1325, 2771, 1075, 229)) //190 UNKLNIK LOGO
	otherTiles = append(otherTiles, rl.NewRectangle(905, 2839, 400, 157))   //191 GO LOGO
	otherTiles = append(otherTiles, rl.NewRectangle(1888, 1658, 500, 500))  //192 MR SNUGGLES LOGO
	otherTiles = append(otherTiles, rl.NewRectangle(2249, 374, 128, 128))   //193 INTRO BG STAR
	otherTiles = append(otherTiles, rl.NewRectangle(2245, 530, 146, 146))   //194 INTRO BG YINYANG
	otherTiles = append(otherTiles, rl.NewRectangle(2139, 705, 152, 152))   //195 INTRO BG SMILEY
	otherTiles = append(otherTiles, rl.NewRectangle(1959, 708, 143, 143))   //196 INTRO BG CLOVER
	otherTiles = append(otherTiles, rl.NewRectangle(1960, 527, 18, 18))     //197 XP UPDATE
	otherTiles = append(otherTiles, rl.NewRectangle(1984, 527, 16, 16))     //198 SWITCH WEAPON
	otherTiles = append(otherTiles, rl.NewRectangle(2043, 539, 128, 128))   //199 CONTROLLER
	otherTiles = append(otherTiles, rl.NewRectangle(1983, 2403, 64, 64))    //200 ICEMAN CRYSTAL BOSS ITEM
	otherTiles = append(otherTiles, rl.NewRectangle(456, 3326, 48, 48))     //201 ICEMAN ICE RING BOSS ITEM EFFECT
	otherTiles = append(otherTiles, rl.NewRectangle(2266, 1054, 128, 128))  //202 MR FRISBEE FRISBEE BOSS ITEM
	otherTiles = append(otherTiles, rl.NewRectangle(1696, 1701, 64, 64))    //203 SPINNA BOSS ITEM
	otherTiles = append(otherTiles, rl.NewRectangle(2182, 1061, 64, 64))    //204 SPACEMAN HELMET BOSS ITEM
	otherTiles = append(otherTiles, rl.NewRectangle(1385, 1299, 31, 31))    //205 PYRO PIG BOSS ITEM
	otherTiles = append(otherTiles, rl.NewRectangle(2106, 1061, 64, 64))    //206 ZOMBO BOSS ITEM
	otherTiles = append(otherTiles, rl.NewRectangle(10, 2257, 43, 43))      //207 BATTY BOSS ITEM
	otherTiles = append(otherTiles, rl.NewRectangle(80, 1794, 16, 16))      //208 ROLLO BOSS ITEM
	otherTiles = append(otherTiles, rl.NewRectangle(1257, 1199, 16, 16))    //209 ARROW WEAPON SPECIAL
	otherTiles = append(otherTiles, rl.NewRectangle(1279, 1201, 14, 14))    //210 FIREWORK
	otherTiles = append(otherTiles, rl.NewRectangle(1297, 1190, 32, 32))    //211 ROCKET
	otherTiles = append(otherTiles, rl.NewRectangle(1733, 3671, 667, 129))  //212 THE END
	otherTiles = append(otherTiles, rl.NewRectangle(1981, 1067, 88, 88))    //213 WEAPON STAND

	//MARK: IMGS RECTANGLE SLICES
	//ROCKS
	rocksI = append(rocksI, rl.NewRectangle(777, 1251, 96, 96))
	rocksI = append(rocksI, rl.NewRectangle(879, 1253, 82, 82))
	rocksI = append(rocksI, rl.NewRectangle(979, 1250, 79, 79))
	rocksI = append(rocksI, rl.NewRectangle(764, 1347, 111, 111))
	rocksI = append(rocksI, rl.NewRectangle(878, 1333, 136, 136))
	rocksI = append(rocksI, rl.NewRectangle(1018, 1351, 103, 103))
	//FLOWERS
	flowers = append(flowers, rl.NewRectangle(1695, 383, 18, 18))
	flowers = append(flowers, rl.NewRectangle(1693, 317, 18, 18))
	flowers = append(flowers, rl.NewRectangle(1694, 342, 18, 18))
	flowers = append(flowers, rl.NewRectangle(1693, 363, 18, 18))
	flowers = append(flowers, rl.NewRectangle(1716, 300, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1717, 322, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1716, 344, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1716, 365, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1740, 300, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1741, 322, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1740, 344, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1740, 365, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1764, 300, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1765, 322, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1764, 344, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1764, 365, 16, 16))
	flowers = append(flowers, rl.NewRectangle(1719, 385, 13, 13))
	flowers = append(flowers, rl.NewRectangle(1743, 387, 11, 11))
	flowers = append(flowers, rl.NewRectangle(1767, 386, 12, 12))
	//BGI
	zbgi := BackgroundInformation{}
	zbgi.imageRectangle = rl.NewRectangle(1629, 52, 63, 63)
	zbgi.isSmall = true
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(1561, 116, 63, 63)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(1630, 116, 63, 63)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(419, 1087, 73, 73)
	bgilist = append(bgilist, zbgi)
	zbgi.isSmall = false
	zbgi.imageRectangle = rl.NewRectangle(1694, 63, 114, 114)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(1795, 66, 120, 120)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(1581, 182, 120, 120)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(1706, 187, 105, 105)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(1812, 187, 105, 105)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(1805, 298, 113, 113)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(34, 938, 115, 115)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(155, 945, 102, 102)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(271, 933, 120, 120)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(419, 940, 127, 127)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(553, 941, 117, 117)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(38, 1059, 117, 117)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(158, 1057, 120, 120)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(290, 1063, 105, 105)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(506, 1072, 120, 120)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(641, 1087, 120, 120)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(46, 1196, 120, 120)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(178, 1184, 120, 120)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(328, 1194, 125, 125)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(477, 1224, 125, 125)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(609, 1229, 125, 125)
	bgilist = append(bgilist, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(45, 1330, 125, 125)
	bgilist = append(bgilist, zbgi)
	//BGI 2
	zbgi = BackgroundInformation{}
	zbgi.imageRectangle = rl.NewRectangle(1292, 153, 22, 22)
	bgilist2 = append(bgilist2, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(1315, 153, 15, 15)
	bgilist2 = append(bgilist2, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(1293, 176, 16, 16)
	bgilist2 = append(bgilist2, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(1310, 176, 12, 12)
	bgilist2 = append(bgilist2, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(1323, 173, 18, 18)
	bgilist2 = append(bgilist2, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(1341, 154, 36, 36)
	bgilist2 = append(bgilist2, zbgi)
	zbgi.imageRectangle = rl.NewRectangle(1377, 154, 30, 30)
	bgilist2 = append(bgilist2, zbgi)
	//ANIMS
	//0 WATER
	zanim := Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(273, 17, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim) //0 WATER
	//1 SPIKE TRAP
	zanim = Animation{}
	zanim.frames = 9
	zanim.rectangle = rl.NewRectangle(340, 17, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//2 FLAME TRAP
	zanim = Animation{}
	zanim.frames = 13
	zanim.rectangle = rl.NewRectangle(900, 1, 32, 41)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//3 PLAYER SMOKE
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(32, 32, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//4 CHEST
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(1216, 46, 48, 48)
	zanim.width = 48
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//5 POTION HP FULL
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(0, 152, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//6 POTION HP HALF
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(128, 152, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//7 POTION HP QUARTER
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(256, 152, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//8 POTION MANA FULL
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(0, 169, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//9 POTION MANA HALF
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(128, 169, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//10 POTION MANA QUARTER
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(256, 169, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//11 POTION RESIST FIRE FULL
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(0, 186, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//12 POTION RESIST FIRE HALF
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(128, 186, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//13 POTION RESIST FIRE QUARTER
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(256, 186, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//14 POTION RESIST POISON FULL
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(0, 203, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//15 POTION RESIST POISON HALF
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(128, 203, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//16 POTION RESIST POISON QUARTER
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(256, 203, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//17 POTION INVISIBILITY FULL
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(0, 220, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//18 POTION INVISIBILITY HALF
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(128, 220, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//19 POTION INVISIBILITY QUARTER
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(256, 220, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//20 POTION ARMOR FULL
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(0, 237, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//21 POTION ARMOR HALF
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(128, 237, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//22 POTION ARMOR QUARTER
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(256, 237, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//23 ENEMY 0 BLUE SPIKE RIGHT
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(269, 55, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//24 ENEMY 0 BLUE SPIKE LEFT
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(445, 55, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//25 ENEMY 0 BLUE SPIKE IDLE
	zanim = Animation{}
	zanim.frames = 1
	zanim.rectangle = rl.NewRectangle(462, 55, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//26 ENEMY 1 RED EYE RIGHT
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1352, 0, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//27 ENEMY 1 RED EYE LEFT
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1528, 0, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//28 ENEMY 1 RED EYE IDLE
	zanim = Animation{}
	zanim.frames = 1
	zanim.rectangle = rl.NewRectangle(1544, 0, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//29 ENEMY 2 RED BOMB RIGHT
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(871, 45, 18, 18)
	zanim.width = 18
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//30 ENEMY 2 RED BOMB LEFT
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1069, 45, 18, 18)
	zanim.width = 18
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//31 ENEMY 2 RED BOMB IDLE
	zanim = Animation{}
	zanim.frames = 1
	zanim.rectangle = rl.NewRectangle(1087, 45, 18, 18)
	zanim.width = 18
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//32 ENEMY 3 GHOST RIGHT
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(871, 65, 18, 18)
	zanim.width = 18
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//33 ENEMY 3 GHOST LEFT
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1033, 65, 18, 18)
	zanim.width = 18
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//34 ENEMY 4 RED ANTENNA RIGHT
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(867, 84, 22, 22)
	zanim.width = 22
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//35 ENEMY 4 RED ANTENNA LEFT
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1065, 84, 22, 22)
	zanim.width = 22
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//36 ENEMY 5 BALLOON RIGHT
	zanim = Animation{}
	zanim.frames = 1
	zanim.rectangle = rl.NewRectangle(1088, 66, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//37 ENEMY 5 BALLOON LEFT
	zanim = Animation{}
	zanim.frames = 1
	zanim.rectangle = rl.NewRectangle(1184, 66, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//38 ENEMY 6 CROCODILE RIGHT
	zanim = Animation{}
	zanim.frames = 6
	zanim.rectangle = rl.NewRectangle(789, 301, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//39 ENEMY 6 CROCODILE LEFT
	zanim = Animation{}
	zanim.frames = 6
	zanim.rectangle = rl.NewRectangle(1205, 301, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//40 ENEMY 7 PINK CARTWHEEL RIGHT
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(392, 226, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//41 ENEMY 7 PINK CARTWHEEL LEFT
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(872, 226, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//42 ENEMY 7 PINK CARTWHEEL IDLE
	zanim = Animation{}
	zanim.frames = 9
	zanim.rectangle = rl.NewRectangle(904, 226, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//43 ENEMY 8 GREEN PLANT RIGHT
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(395, 261, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//44 ENEMY 8 GREEN PLANT LEFT
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(747, 261, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//45 ENEMY 8 GREEN PLANT IDLE
	zanim = Animation{}
	zanim.frames = 11
	zanim.rectangle = rl.NewRectangle(779, 261, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//46 ENEMY 9 YELLOW DINO RIGHT
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1096, 191, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//47 ENEMY 9 YELLOW DINO LEFT
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1448, 191, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//48 ENEMY 9 YELLOW DINO IDLE
	zanim = Animation{}
	zanim.frames = 8
	zanim.rectangle = rl.NewRectangle(1228, 227, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//49 ENEMY 10 BLACK DOT RIGHT
	zanim = Animation{}
	zanim.frames = 4
	zanim.rectangle = rl.NewRectangle(1353, 19, 12, 12)
	zanim.width = 12
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//50 ENEMY 10 BLACK DOT LEFT
	zanim = Animation{}
	zanim.frames = 4
	zanim.rectangle = rl.NewRectangle(1485, 19, 12, 12)
	zanim.width = 12
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//51 ENEMY 11 WORM RIGHT
	zanim = Animation{}
	zanim.frames = 2
	zanim.rectangle = rl.NewRectangle(1167, 264, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//52 ENEMY 11 WORM LEFT
	zanim = Animation{}
	zanim.frames = 2
	zanim.rectangle = rl.NewRectangle(1327, 264, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//53 ENEMY 12 FLY RIGHT
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(462, 298, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//54 ENEMY 12 FLY LEFT
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(686, 298, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//55 FIRE RED BOMB
	zanim = Animation{}
	zanim.frames = 18
	zanim.rectangle = rl.NewRectangle(0, 664, 96, 96)
	zanim.width = 96
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//56 RED ANTENNA BULLET
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(792, 20, 12, 12)
	zanim.width = 12
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//57 BALLOON EXPLOSION
	zanim = Animation{}
	zanim.frames = 4
	zanim.rectangle = rl.NewRectangle(1582, 2, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//58 ENEMY 6 CROCODILE ATK RIGHT
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1269, 301, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//59 ENEMY 6 CROCODILE ATK LEFT
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1620, 301, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//60 PINK CART WHEEL BULLET
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1754, 2, 41, 41)
	zanim.width = 41
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//61 GREEN PLANT BULLET
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1096, 162, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//62 FIRE YELLOW DINO
	zanim = Animation{}
	zanim.frames = 4
	zanim.rectangle = rl.NewRectangle(0, 596, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//63 FLAMEHEAD RIGHT
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(1176, 336, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//64 FLAMEHEAD LEFT
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(1656, 336, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//65 ORANGE RIGHT
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(796, 338, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//66 ORANGE LEFT
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1148, 336, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//67 SKELETON RIGHT
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(393, 333, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//68 SKELETON LEFT
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(745, 333, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//69 RED BLOB RIGHT
	zanim = Animation{}
	zanim.frames = 2
	zanim.rectangle = rl.NewRectangle(654, 370, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//70 RED BLOB LEFT
	zanim = Animation{}
	zanim.frames = 2
	zanim.rectangle = rl.NewRectangle(814, 370, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//71 RED BLOB BULLET
	zanim = Animation{}
	zanim.frames = 4
	zanim.rectangle = rl.NewRectangle(0, 538, 42, 42)
	zanim.width = 42
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//72 CAMPFIRE
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(1722, 416, 24, 24)
	zanim.width = 24
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//73 PIGEON RIGHT
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1788, 550, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//74 PIGEON LEFT
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1900, 550, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//75 TURTLE SHIELD
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1, 468, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//76 POISON GAS
	zanim = Animation{}
	zanim.frames = 14
	zanim.rectangle = rl.NewRectangle(0, 1480, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//77 ARMOR SHIELD
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(0, 418, 44, 44)
	zanim.width = 44
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//78 FROG IDLE R
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(916, 818, 48, 48)
	zanim.width = 48
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//79 FROG IDLE L
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(1636, 818, 48, 48)
	zanim.width = 48
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//80 FROG JUMP R
	zanim = Animation{}
	zanim.frames = 6
	zanim.rectangle = rl.NewRectangle(912, 770, 48, 48)
	zanim.width = 48
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//81 FROG JUMP L
	zanim = Animation{}
	zanim.frames = 6
	zanim.rectangle = rl.NewRectangle(1536, 770, 48, 48)
	zanim.width = 48
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//82 FROG EXIT
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1583, 779, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//83 TELEPORT
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(926, 869, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//84 INFLICT
	zanim = Animation{}
	zanim.frames = 4
	zanim.rectangle = rl.NewRectangle(1464, 867, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//85 REVIVE
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1629, 857, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//86 BEAR TRAP
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(0, 375, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//87 BEAR TRAP
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1656, 926, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//88 CRYSTAL TELEPORT
	zanim = Animation{}
	zanim.frames = 23
	zanim.rectangle = rl.NewRectangle(0, 1572, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//89 THORNS
	zanim = Animation{}
	zanim.frames = 8
	zanim.rectangle = rl.NewRectangle(1344, 992, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//90 TORNADO
	zanim = Animation{}
	zanim.frames = 4
	zanim.rectangle = rl.NewRectangle(1692, 822, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//91 TESLA
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(839, 943, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//92 PURPLE RAIN
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(1405, 1059, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//93 FRISBEE
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1445, 906, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//94 BELT
	zanim = Animation{}
	zanim.frames = 4
	zanim.rectangle = rl.NewRectangle(353, 1364, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//95 BEETROOT EXPLODE
	zanim = Animation{}
	zanim.frames = 8
	zanim.rectangle = rl.NewRectangle(1344, 1133, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//96 CLOAK SPARKS
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1664, 1210, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//97 LADYBUG TURRET PROJ
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1783, 780, 13, 13)
	zanim.width = 13
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//98 FLAMINGO FLAME
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1447, 949, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//99 SHOCKWAVE
	zanim = Animation{}
	zanim.frames = 4
	zanim.rectangle = rl.NewRectangle(1016, 1008, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//100 BEE LEFT
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(432, 589, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//101 BEE RIGHT
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(432, 605, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//102 CHICKEN LEFT
	zanim = Animation{}
	zanim.frames = 13
	zanim.rectangle = rl.NewRectangle(1237, 1143, 34, 34)
	zanim.width = 34
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//103 CHICKEN RIGHT
	zanim = Animation{}
	zanim.frames = 13
	zanim.rectangle = rl.NewRectangle(792, 1101, 34, 34)
	zanim.width = 34
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//104 EGG EXPLODE
	zanim = Animation{}
	zanim.frames = 8
	zanim.rectangle = rl.NewRectangle(1095, 1222, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//105 BOMB FUSE
	zanim = Animation{}
	zanim.frames = 4
	zanim.rectangle = rl.NewRectangle(1600, 1288, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//106 BOMB EXPLODE
	zanim = Animation{}
	zanim.frames = 4
	zanim.rectangle = rl.NewRectangle(855, 1014, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//107 STUN STARS
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(777, 1183, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//108 SUMMON ITEM
	zanim = Animation{}
	zanim.frames = 4
	zanim.rectangle = rl.NewRectangle(1048, 1193, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//109 ICEMAN CHANGE
	zanim = Animation{}
	zanim.frames = 8
	zanim.rectangle = rl.NewRectangle(1344, 1367, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//110 MR FRISBEE IDLE R
	zanim = Animation{}
	zanim.frames = 8
	zanim.rectangle = rl.NewRectangle(552, 1658, 48, 48)
	zanim.width = 48
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//111 MR FRISBEE IDLE L
	zanim = Animation{}
	zanim.frames = 8
	zanim.rectangle = rl.NewRectangle(1368, 1658, 48, 48)
	zanim.width = 48
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//112 MR FRISBEE WALK R
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(600, 1706, 48, 48)
	zanim.width = 48
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//113 MR FRISBEE WALK L
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(1320, 1706, 48, 48)
	zanim.width = 48
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//114 MR FRISBEE ATK R
	zanim = Animation{}
	zanim.frames = 8
	zanim.rectangle = rl.NewRectangle(552, 1754, 48, 48)
	zanim.width = 48
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//115 MR FRISBEE ATK L
	zanim = Animation{}
	zanim.frames = 8
	zanim.rectangle = rl.NewRectangle(1368, 1754, 48, 48)
	zanim.width = 48
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//116 MR FRISBEE PROJ
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(970, 1477, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//117 MR FRISBEE NEAR HIT
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(1408, 1444, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//118 SPINNA IDLE R
	zanim = Animation{}
	zanim.frames = 4
	zanim.rectangle = rl.NewRectangle(568, 1816, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//119 SPINNA IDLE L
	zanim = Animation{}
	zanim.frames = 4
	zanim.rectangle = rl.NewRectangle(856, 1816, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//120 SPINNA SPIN START
	zanim = Animation{}
	zanim.frames = 4
	zanim.rectangle = rl.NewRectangle(888, 1816, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//121 SPINNA SPIN
	zanim = Animation{}
	zanim.frames = 6
	zanim.rectangle = rl.NewRectangle(1048, 1816, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//122 SPINNA SPIN END
	zanim = Animation{}
	zanim.frames = 6
	zanim.rectangle = rl.NewRectangle(1048, 1816, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//123 SPINNA PROJ
	zanim = Animation{}
	zanim.frames = 2
	zanim.rectangle = rl.NewRectangle(1568, 1702, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//124 SPACEMAN IDLE R
	zanim = Animation{}
	zanim.frames = 4
	zanim.rectangle = rl.NewRectangle(560, 1860, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//125 SPACEMAN IDLE L
	zanim = Animation{}
	zanim.frames = 4
	zanim.rectangle = rl.NewRectangle(848, 1860, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//126 SPACEMAN SHOOT R
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(880, 1860, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//127 SPACEMAN SHOOT L
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1232, 1860, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//128 SPACEMAN HIT R
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1264, 1860, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//129 SPACEMAN HIT L
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1616, 1860, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//130 SPACEMAN DEATH
	zanim = Animation{}
	zanim.frames = 6
	zanim.rectangle = rl.NewRectangle(1648, 1860, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//131 SPACEMAN PROJ
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1159, 1398, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//132 BLOCK PROJ
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(1100, 967, 14, 14)
	zanim.width = 14
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//133 PYRO PIG R
	zanim = Animation{}
	zanim.frames = 9
	zanim.rectangle = rl.NewRectangle(0, 1940, 90, 90)
	zanim.width = 90
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//134 PYRO PIG L
	zanim = Animation{}
	zanim.frames = 9
	zanim.rectangle = rl.NewRectangle(1710, 1940, 90, 90)
	zanim.width = 90
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//135 PYRO PIG PROJ
	zanim = Animation{}
	zanim.frames = 2
	zanim.rectangle = rl.NewRectangle(1385, 1298, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//136 ZOMBO ATK R
	zanim = Animation{}
	zanim.frames = 11
	zanim.rectangle = rl.NewRectangle(0, 2048, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//137 ZOMBO ATK L
	zanim = Animation{}
	zanim.frames = 11
	zanim.rectangle = rl.NewRectangle(1472, 2048, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//138 ZOMBO WALK R
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(0, 2116, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//139 ZOMBO WALK L
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(960, 2116, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//140 ZOMBO PROJ
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(0, 1692, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//141 RED BAT FLY R
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(0, 2180, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//142 RED BAT FLY L
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(960, 2180, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//143 RED BAT ATK R
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(0, 2244, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//144 RED BAT ATK L
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(960, 2244, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//145 RED BAT IDLE R
	zanim = Animation{}
	zanim.frames = 11
	zanim.rectangle = rl.NewRectangle(0, 2308, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//146 RED BAT IDLE L
	zanim = Animation{}
	zanim.frames = 11
	zanim.rectangle = rl.NewRectangle(1472, 2308, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//147 RED BAT PROJ
	zanim = Animation{}
	zanim.frames = 2
	zanim.rectangle = rl.NewRectangle(0, 1725, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//148 MUSHROOM WALK R
	zanim = Animation{}
	zanim.frames = 9
	zanim.rectangle = rl.NewRectangle(1036, 2244, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//149 MUSHROOM WALK L
	zanim = Animation{}
	zanim.frames = 9
	zanim.rectangle = rl.NewRectangle(2252, 2244, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//150 MUSHROOM ATK R
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(1032, 2181, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//151 MUSHROOM ATK L
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(1992, 2181, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//152 MUSHROOM PROJ
	zanim = Animation{}
	zanim.frames = 15
	zanim.rectangle = rl.NewRectangle(0, 2374, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	zanim.y = zanim.rectangle.Y
	animation = append(animation, zanim)
	//153 ROLLO R
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(0, 1794, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//154 ROLLO L
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(176, 1794, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//155 ROLLO PROJ
	zanim = Animation{}
	zanim.frames = 14
	zanim.rectangle = rl.NewRectangle(1044, 2126, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//156 CARROT R
	zanim = Animation{}
	zanim.frames = 1
	zanim.rectangle = rl.NewRectangle(996, 2373, 20, 20)
	zanim.width = 20
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//157 CARROT L
	zanim = Animation{}
	zanim.frames = 1
	zanim.rectangle = rl.NewRectangle(1056, 2373, 20, 20)
	zanim.width = 20
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//158 GREEN PIG R
	zanim = Animation{}
	zanim.frames = 9
	zanim.rectangle = rl.NewRectangle(0, 2463, 90, 90)
	zanim.width = 90
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//159 GREEN PIG L
	zanim = Animation{}
	zanim.frames = 9
	zanim.rectangle = rl.NewRectangle(1710, 2463, 90, 90)
	zanim.width = 90
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//160 BLUE ROBOT R
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1090, 2364, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//161 BLUE ROBOT L
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1442, 2364, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//162 RED DEVIL R
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(998, 2405, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//163 RED DEVIL L
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1110, 2405, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//164 BLACKBIRD R
	zanim = Animation{}
	zanim.frames = 2
	zanim.rectangle = rl.NewRectangle(1000, 2431, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//165 BLACKBIRD L
	zanim = Animation{}
	zanim.frames = 2
	zanim.rectangle = rl.NewRectangle(1080, 2431, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//166 GREEN JERSEY R
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1110, 2427, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//167 GREEN JERSEY L
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1334, 2427, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//168 ROBOT SHOCK
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1555, 1579, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//169 RED DEVIL FLAME
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(0, 1816, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//170 BUSH R
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1138, 2405, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//171 BUSH L
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1314, 2405, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//172 JERSEY SPELL
	zanim = Animation{}
	zanim.frames = 16
	zanim.rectangle = rl.NewRectangle(0, 2691, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//173 BUSH PROJ
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1562, 2060, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//174 POISON BUBBLES
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1243, 1398, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//175 MAP PIN
	zanim = Animation{}
	zanim.frames = 25
	zanim.rectangle = rl.NewRectangle(0, 2568, 48, 48)
	zanim.width = 48
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//176 CHEST PIN
	zanim = Animation{}
	zanim.frames = 25
	zanim.rectangle = rl.NewRectangle(0, 2624, 48, 48)
	zanim.width = 48
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//177 KITCHEN SPRAY PROJ
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1373, 2439, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//178 FRYING PAN SHOCK
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1556, 2323, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//179 PINEAPPLE RING EXPLODE
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1583, 2366, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//180 FLOOR SWITCH FX COLLECT ITEM
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1599, 2433, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//181 WEAPON CRATE OPEN
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1929, 124, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//182 WHITE MOUSE
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(2085, 0, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//183 BROWN MOUSE
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(2151, 0, 16, 16)
	zanim.width = 16
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//184 SPINNING TRAP
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(1958, 483, 32, 32)
	zanim.width = 32
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//185 FART FIREBALL
	zanim = Animation{}
	zanim.frames = 3
	zanim.rectangle = rl.NewRectangle(1777, 581, 48, 48)
	zanim.width = 48
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//186 USE SCROLL FX
	zanim = Animation{}
	zanim.frames = 8
	zanim.rectangle = rl.NewRectangle(0, 2781, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//187 ROTATING TREASURE EXIT COIN
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1941, 899, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//188 USE POTION FX
	zanim = Animation{}
	zanim.frames = 5
	zanim.rectangle = rl.NewRectangle(1952, 987, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//189 ICEMAN DEATH FX
	zanim = Animation{}
	zanim.frames = 17
	zanim.rectangle = rl.NewRectangle(0, 3240, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//190 MR FRISBEE DEATH FX
	zanim = Animation{}
	zanim.frames = 10
	zanim.rectangle = rl.NewRectangle(1275, 2633, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//191 SPINNA DEATH FX
	zanim = Animation{}
	zanim.frames = 17
	zanim.rectangle = rl.NewRectangle(0, 3024, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//192 SPZMAN DEATH FX
	zanim = Animation{}
	zanim.frames = 16
	zanim.rectangle = rl.NewRectangle(0, 3100, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//193 PYRO PIG DEATH FX
	zanim = Animation{}
	zanim.frames = 16
	zanim.rectangle = rl.NewRectangle(0, 3172, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//194 ZOMBO DEATH FX
	zanim = Animation{}
	zanim.frames = 16
	zanim.rectangle = rl.NewRectangle(1283, 2566, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//195 RED BAT DEATH FX
	zanim = Animation{}
	zanim.frames = 15
	zanim.rectangle = rl.NewRectangle(1331, 3035, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//196 MUSHROOM DEATH FX
	zanim = Animation{}
	zanim.frames = 17
	zanim.rectangle = rl.NewRectangle(1235, 3104, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//197 ROLLO DEATH FX
	zanim = Animation{}
	zanim.frames = 14
	zanim.rectangle = rl.NewRectangle(0, 3318, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//198 SAVE ANIMATION
	zanim = Animation{}
	zanim.frames = 11
	zanim.rectangle = rl.NewRectangle(0, 2860, 50, 50)
	zanim.width = 50
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//199 BASE UNLOCK FX
	zanim = Animation{}
	zanim.frames = 13
	zanim.rectangle = rl.NewRectangle(1504, 3193, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//200 BASE UPGRADE FX
	zanim = Animation{}
	zanim.frames = 19
	zanim.rectangle = rl.NewRectangle(1115, 3335, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//201 FIREWORKS FIRE
	zanim = Animation{}
	zanim.frames = 6
	zanim.rectangle = rl.NewRectangle(1945, 1517, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//202 RING OF FIRE
	zanim = Animation{}
	zanim.frames = 13
	zanim.rectangle = rl.NewRectangle(0, 3396, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//203 SLUDGE GEYSER
	zanim = Animation{}
	zanim.frames = 7
	zanim.rectangle = rl.NewRectangle(0, 3467, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//204 INTRO ANIM
	zanim = Animation{}
	zanim.frames = 15
	zanim.rectangle = rl.NewRectangle(1376, 3416, 64, 64)
	zanim.width = 64
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)
	//205 DEATH ANIM
	zanim = Animation{}
	zanim.frames = 19
	zanim.rectangle = rl.NewRectangle(0, 3548, 96, 96)
	zanim.width = 96
	zanim.x = zanim.rectangle.X
	animation = append(animation, zanim)

	//MARK: IMG ANIMATIONS
	//FLOOR
	x := float32(0)
	y := float32(0)
	for {
		floorTiles = append(floorTiles, rl.NewRectangle(x, y, 16, 16))
		x += 16
		if x >= 896 {
			break
		}
	}
	x = float32(0)
	y = float32(1660)
	for {
		floorTiles = append(floorTiles, rl.NewRectangle(x, y, 16, 16))
		x += 16
		if x >= 256 {
			break
		}
	}
	//INNER WALLS
	x = 0
	y = 16
	for {
		wallTiles = append(wallTiles, rl.NewRectangle(x, y, 16, 16))
		x += 16
		if x >= 256 {
			break
		}
	}
	x = 0
	y = 1676
	for {
		wallTiles = append(wallTiles, rl.NewRectangle(x, y, 16, 16))
		x += 16
		if x >= 112 {
			break
		}
	}
	//SPLAT
	x = 0
	y = 772
	for {
		splat = append(splat, rl.NewRectangle(x, y, 128, 128))
		x += 128
		if x > 768 {
			break
		}
	}

	for i := 0; i < 57; i++ {
		txt := fmt.Sprint(i) + ".png"
		if i < 10 {
			txt = "0" + txt
		}
		txt = "img/raylib_logo/" + txt
		raylibAnim = append(raylibAnim, rl.LoadTexture(txt))
	}

}

// MARK: CORE CORE CORE CORE CORE CORE CORE CORE CORE CORE CORE CORE CORE CORE CORE CORE CORE
func inp() { //MARK:INP
	//CONTROLLER DISCONNECT
	if controllerINITIAL {
		if !rl.IsGamepadAvailable(0) {
			if !options && !exit && !credits && !intro && !startScreen && !endgame {
				pause = true
				options = true
				disconnectT = fps * 3
				controllerINITIAL = false
			}
		}
	}
	//MOUSE LEFT CLICK GAMEPAD R TRIGGER & A
	if rl.IsMouseButtonPressed(rl.MouseLeftButton) || rl.IsGamepadButtonPressed(0, 12) || rl.IsGamepadButtonPressed(0, 7) {
		inpL = true
	} else {
		inpL = false
	}
	//MOUSE RIGHT CLICK GAMEPAD L TRIGGER & X
	if rl.IsMouseButtonPressed(rl.MouseButtonRight) || rl.IsGamepadButtonPressed(0, 10) || rl.IsGamepadButtonPressed(0, 8) {
		inpR = true
	} else {
		inpR = false
	}
	//MOUSE GAMEPAD ON/OFF
	if rl.GetMousePosition() != mouseoffpos {
		mouseoff = false
	}
	if mouseoff {
		cursorV2 = gameCursor
	}
	//GAMEPAD QUICK SLOTS
	if rl.IsGamepadButtonPressed(0, 1) {
		if player.quik[0].name != "" {
			useitm(0, 1)
		}
	}
	if rl.IsGamepadButtonPressed(0, 2) {
		if player.quik[1].name != "" {
			useitm(1, 1)
		}
	}
	if rl.IsGamepadButtonPressed(0, 3) {
		if player.quik[2].name != "" {
			useitm(2, 1)
		}
	}
	if rl.IsGamepadButtonPressed(0, 4) {
		if player.quik[3].name != "" {
			useitm(3, 1)
		}
	}
	//KEYS QUICK SLOTS
	if rl.IsKeyPressed(rl.KeyOne) {
		if player.quik[0].name != "" {
			useitm(0, 1)
		}
	}
	if rl.IsKeyPressed(rl.KeyTwo) {
		if player.quik[1].name != "" {
			useitm(1, 1)
		}
	}
	if rl.IsKeyPressed(rl.KeyThree) {
		if player.quik[2].name != "" {
			useitm(2, 1)
		}
	}
	if rl.IsKeyPressed(rl.KeyFour) {
		if player.quik[3].name != "" {
			useitm(3, 1)
		}
	}
	//GAMEPAD MOUSE CURSOR
	if rl.GetGamepadAxisMovement(0, 2) != 0 { //LR
		controllerINITIAL = true
		if !mouseoff {
			mouseoffpos = rl.GetMousePosition()
			gameCursor = rl.GetMousePosition()
		}
		mouseoff = true
		change := rl.GetGamepadAxisMovement(0, 2)
		if Abs(change) > deadZ {
			change *= 100
			change *= stickMov
			gameCursor.X += change + delta
		}
		if gameCursor.X > screenWidthF32 {
			gameCursor.X = screenWidthF32
		}
		if gameCursor.X < 0 {
			gameCursor.X = 0
		}

	}
	if rl.GetGamepadAxisMovement(0, 3) != 0 { //UD
		if !mouseoff {
			mouseoffpos = rl.GetMousePosition()
			gameCursor = rl.GetMousePosition()
		}
		mouseoff = true
		change := rl.GetGamepadAxisMovement(0, 3)
		if Abs(change) > deadZ {
			change *= 100
			change *= stickMov
			gameCursor.Y += change + delta
		}
		if gameCursor.Y > screenHeightF32 {
			gameCursor.Y = screenHeightF32
		}
		if gameCursor.Y < 0 {
			gameCursor.Y = 0
		}
	}

	//CHAR SCR OPTIONS
	if rl.IsKeyPressed(rl.KeyTab) && !options && !exit && !credits && !intro && !startScreen && !endgame || rl.IsGamepadButtonPressed(0, 5) && !options && !exit && !credits && !intro && !startScreen && !endgame {
		makebgpix()
		charscr = !charscr
		if !isBaseOn {
			pause = !pause
		}
		invenInfo = false
		inMenuOn = false
		inMenuItm = blankint
		invDisTxtT = 0
		rl.PlaySound(audfx[17])
	}
	if rl.IsKeyPressed(rl.KeyEscape) && !helpon && !charscr && !exit && !credits && !intro && !startScreen && !endgame || rl.IsGamepadButtonPressed(0, 15) && !helpon && !charscr && !exit && !credits && !intro && !startScreen && !endgame {
		makebgpix()
		options = !options
		if !isBaseOn {
			pause = !pause
		}
		rl.PlaySound(audfx[19])
	}
	//CURSOR
	if mouseoff {
		cursorV2 = gameCursor
		cursorV2cam = rl.GetScreenToWorld2D(gameCursor, cam2)
		cursorV2Base = rl.GetScreenToWorld2D(gameCursor, camBase)
		cursorV2camInven = rl.GetScreenToWorld2D(gameCursor, camInventory)
		cursorV2Strucs = rl.GetScreenToWorld2D(gameCursor, camStructures)
	} else {
		cursorV2 = rl.GetMousePosition()
		cursorV2cam = rl.GetScreenToWorld2D(cursorV2, cam2)
		cursorV2Base = rl.GetScreenToWorld2D(cursorV2, camBase)
		cursorV2camInven = rl.GetScreenToWorld2D(cursorV2, camInventory)
		cursorV2Strucs = rl.GetScreenToWorld2D(cursorV2, camStructures)
	}

	//DEBUG
	/*
		if rl.IsKeyPressed(rl.KeyF7) {
			if mushroomTimer > 0 {
				mushroomTimer--
			}
		}
		if rl.IsKeyPressed(rl.KeyF6) {
			weaponshedon = !weaponshedon
		}
		if rl.IsKeyPressed(rl.KeyF5) {
			bookon = !bookon
		}
		if rl.IsKeyPressed(rl.KeyF4) {
			makeweaponcrate()
		}
		if rl.IsKeyPressed(rl.KeyF3) {
			baseon = !baseon
			pause = !pause
		}
		if rl.IsKeyPressed(rl.KeyF2) {
			pl.cnt = cnt
			pl.hp = pl.hpmax
			pl.mana = pl.manamax
			if bosson {
				bosslevon = false
				bosson = false
			}
			upplayerrec()
			makelevel()
		}
		if rl.IsKeyPressed(rl.KeyF1) {
			debug = !debug
		}
		//ZOOM
		if rl.IsKeyPressed(rl.KeyKpAdd) {
			if cam2.Zoom == 1 {
				cam2.Zoom = 2
			} else if cam2.Zoom == 2 {
				cam2.Zoom = 3
			} else if cam2.Zoom == 3 {
				cam2.Zoom = 4
			} else if cam2.Zoom == 4 {
				cam2.Zoom = 1
			}
			if camBase.Zoom == 1 {
				camBase.Zoom = 2
			} else if camBase.Zoom == 2 {
				camBase.Zoom = 3
			} else if camBase.Zoom == 3 {
				camBase.Zoom = 4
			} else if camBase.Zoom == 4 {
				camBase.Zoom = 1
			}
			if camBoss.Zoom == 1 {
				camBoss.Zoom = 2
			} else if camBoss.Zoom == 2 {
				camBoss.Zoom = 3
			} else if camBoss.Zoom == 3 {
				camBoss.Zoom = 4
			} else if camBoss.Zoom == 4 {
				camBoss.Zoom = 1
			}
			cams()
		}
		if rl.IsKeyPressed(rl.KeyKpSubtract) {
			if cam2.Zoom == 1 {
				cam2.Zoom = 4
			} else if cam2.Zoom == 2 {
				cam2.Zoom = 1
			} else if cam2.Zoom == 3 {
				cam2.Zoom = 2
			} else if cam2.Zoom == 4 {
				cam2.Zoom = 3
			}
			if camBase.Zoom == 1 {
				camBase.Zoom = 4
			} else if camBase.Zoom == 2 {
				camBase.Zoom = 1
			} else if camBase.Zoom == 3 {
				camBase.Zoom = 2
			} else if camBase.Zoom == 4 {
				camBase.Zoom = 3
			}
			if camBoss.Zoom == 1 {
				camBoss.Zoom = 4
			} else if camBoss.Zoom == 2 {
				camBoss.Zoom = 1
			} else if camBoss.Zoom == 3 {
				camBoss.Zoom = 2
			} else if camBoss.Zoom == 4 {
				camBoss.Zoom = 3
			}
			cams()
		}
	*/

}
func timers() { //MARK:TIMERS

	if frames%15 == 0 {
		onoff15 = !onoff15
	}

	//OUTSIDE PAUSE
	if clickT > 0 {
		clickT--
	}
	//IN PAUSE
	if !pause {
		if landmineT > 0 {
			landmineT--
			if landmineT == 1 {
				siz := b / 2
				ztile := Tile{}
				ztile.image = otherTiles[150]
				ztile.rectangle = rl.NewRectangle(player.center.X-siz/2, player.center.Y-siz/2, siz, siz)
				ztile.cRectangle = ztile.rectangle
				ztile.name = "landmine"
				ztile.center = makecnt(ztile.rectangle)
				canadd := true
				for i := 0; i < len(levels[levNum].otherTiles); i++ {
					if levels[levNum].otherTiles[i].name == "landmine" {
						if rl.CheckCollisionRecs(levels[levNum].otherTiles[i].rectangle, ztile.rectangle) {
							canadd = false
						}
					}
				}
				if canadd {
					levels[levNum].otherTiles = append(levels[levNum].otherTiles, ztile)
				}
				landmineT = fps * 7
			}
		}
		if pyroballT > 0 {
			pyroballT--
			if pyroballT == 1 {
				zproj := Weapon{}
				zproj.damage = 2
				zproj.name = "pigProj"
				siz := b + b/2
				zproj.speed = 4
				cntr2 := makecnt(player.rectangle)
				zproj.rec = rl.NewRectangle(cntr2.X-siz/2, cntr2.Y-siz/2, siz, siz)
				zproj.crec = zproj.rec
				zproj.crec.Y += zproj.crec.Height / 4
				zproj.crec.Height = zproj.crec.Height / 2
				zproj.crec.X += zproj.crec.Width / 4
				zproj.crec.Width = zproj.crec.Width / 2
				zproj.image = animation[135].rectangle
				zproj.dirY = -zproj.speed
				zproj.rotation = 180
				playerProjectiles = append(playerProjectiles, zproj)
				zproj.rotation = 0
				zproj.dirY = zproj.speed
				playerProjectiles = append(playerProjectiles, zproj)
				zproj.rotation = -90
				zproj.dirY = 0
				zproj.dirX = zproj.speed
				playerProjectiles = append(playerProjectiles, zproj)
				zproj.rotation = 90
				zproj.dirX = -zproj.speed
				playerProjectiles = append(playerProjectiles, zproj)
				zproj.rotation = -45
				zproj.dirX = zproj.speed
				zproj.dirY = zproj.speed
				playerProjectiles = append(playerProjectiles, zproj)
				zproj.rotation = -135
				zproj.dirX = zproj.speed
				zproj.dirY = -zproj.speed
				playerProjectiles = append(playerProjectiles, zproj)
				zproj.rotation = 45
				zproj.dirX = -zproj.speed
				zproj.dirY = zproj.speed
				playerProjectiles = append(playerProjectiles, zproj)
				zproj.rotation = 135
				zproj.dirX = -zproj.speed
				zproj.dirY = -zproj.speed
				playerProjectiles = append(playerProjectiles, zproj)

				pyroballT = fps * 7
			}
		}
		if spinnaT > 0 {
			spinnaT--
			if spinnaT == 1 {
				spinnaT2 = fps * 3
				player.bossEffectRectangle = animation[123].rectangle
			}
		}
		if mrfrisbeeT > 0 {
			mrfrisbeeT--
			if mrfrisbeeT == 1 {
				zproj := Weapon{}
				zproj.name = "mrfrisbeeProj"
				zproj.image = animation[116].rectangle
				zproj.damage = 2
				zproj.bounce = 12
				zproj.speed = 8
				siz := b
				zproj.rec = rl.NewRectangle(player.center.X-siz/2, player.center.Y-siz/2, siz, siz)
				zproj.crec = zproj.rec
				zproj.WOrig = zproj.rec.Width
				if player.center.X > player.center.X {
					zproj.dirX = zproj.speed
				} else {
					zproj.dirX = -zproj.speed
				}
				if player.center.Y > player.center.Y {
					zproj.dirY = zproj.speed / 4
				} else {
					zproj.dirY = -zproj.speed / 4
				}
				zproj.fade = 1
				zproj.col = rl.White
				playerProjectiles = append(playerProjectiles, zproj)
				if Roll6() > 2 {
					zproj.dirY = zproj.speed
					if FlipCoin() {
						if FlipCoin() {
							zproj.dirX = zproj.speed / 4
						} else {
							zproj.dirX -= zproj.speed / 4
						}
					}
					playerProjectiles = append(playerProjectiles, zproj)
				}
				if Roll6() > 2 {
					zproj.dirY = -zproj.speed
					if FlipCoin() {
						if FlipCoin() {
							zproj.dirX = zproj.speed / 4
						} else {
							zproj.dirX -= zproj.speed / 4
						}
					}
					playerProjectiles = append(playerProjectiles, zproj)
				}

				mrfrisbeeT = fps * 7
			}
		}
		if icecrystalT > 0 {
			icecrystalT--
			if icecrystalT == 1 {
				siz := b3
				zfx := Effect{}
				zfx.name = "icecrystal"
				zfx.center = player.center
				zfx.rectangle = rl.NewRectangle(zfx.center.X-siz/2, zfx.center.Y-siz/2, siz, siz)
				zfx.imageRectangle = otherTiles[201]
				effect = append(effect, zfx)
				icecrystalT = fps * 5
			}
		}
		if fartT > 0 {
			fartT--
			if fartT%30 == 0 {
				choose := RandInt(1, 5)
				switch choose {
				case 1:
					rl.PlaySound(audfx[98])
				case 2:
					rl.PlaySound(audfx[99])
				case 3:
					rl.PlaySound(audfx[100])
				case 4:
					rl.PlaySound(audfx[101])
				}

				siz := bq3
				zproj := Weapon{}
				zproj.damage = 1
				zproj.name = "fartfire"
				zproj.col = rl.White
				zproj.fade = 1
				zproj.speed = 4
				zproj.rotation = AngleBetweenTwoPoints(player.center, cursorV2cam) + 180
				xdiff := AbsDiff(player.center.X, cursorV2cam.X)
				ydiff := AbsDiff(player.center.Y, cursorV2cam.Y)
				if xdiff > ydiff {
					zproj.dirX = zproj.speed
					zproj.dirY = ydiff / (xdiff / zproj.dirX)
				} else {
					zproj.dirY = zproj.speed
					zproj.dirX = xdiff / (ydiff / zproj.dirY)
				}
				if player.center.X > cursorV2cam.X {
					zproj.dirX = -zproj.dirX
				}
				if player.center.Y > cursorV2cam.Y {
					zproj.dirY = -zproj.dirY
				}
				zproj.dirX *= -1
				zproj.dirY *= -1
				zproj.rec = rl.NewRectangle(player.center.X-siz/2, player.center.Y-siz/2, siz, siz)
				zproj.crec = zproj.rec
				zproj.crec.X += b / 4
				zproj.crec.Y += b / 4
				zproj.crec.Width -= b / 2
				zproj.crec.Height -= b / 2
				zproj.image = animation[185].rectangle
				playerProjectiles = append(playerProjectiles, zproj)
			}
			if fartT == 1 {
				admsg("flatulence ended", rl.Yellow)
			}
		}
		if saltT > 0 {
			saltT--
			if saltT == 1 {
				admsg("salt ended", rl.Yellow)
			}
		}
		if bootsT > 0 {
			bootsT--
			if bootsT == 1 {
				admsg("no more boots", rl.Yellow)
			}
		}
		if psychedelicsT > 0 {
			psychedelicsT--
			if psychedelicsT == 1 {
				admsg("back to dull gray", rl.Yellow)
			}
		}
		if gasmaskT > 0 {
			gasmaskT--
			if gasmaskT == 1 && poisongasCount <= 10 {
				zproj := Weapon{}
				zproj.T = fps * 30
				siz := b4
				zproj.rec = rl.NewRectangle(player.center.X-siz/2, player.center.Y-siz/2, siz, siz)
				zproj.crec = zproj.rec
				zproj.crec.X += zproj.crec.Width / 4
				zproj.crec.Y += zproj.crec.Height / 4
				zproj.crec.Width = zproj.crec.Width / 2
				zproj.crec.Height = zproj.crec.Height / 2
				zproj.image = animation[76].rectangle
				zproj.center = makecnt(zproj.rec)
				zproj.fade = 1
				zproj.col = rl.White
				zproj.rotationSpeed = RandF32(2, 4)
				if FlipCoin() {
					zproj.rotationSpeed = -zproj.rotationSpeed
				}
				zproj.damage = 1
				zproj.speed = 4
				zproj.dirX = RandF32(-zproj.speed, zproj.speed)
				zproj.dirY = RandF32(-zproj.speed, zproj.speed)
				zproj.name = "poisongas"
				playerProjectiles = append(playerProjectiles, zproj)
				gasmaskT = fps*8 - (gasmasknum * fps)
			}
		}
		if eggsT > 0 {
			eggsT--
			if frames%2 == 0 {
				animation[103].rectangle.X += animation[103].width
				if animation[103].rectangle.X > animation[103].x+animation[103].frames*animation[103].width {
					animation[103].rectangle.X = animation[103].x
				}
				animation[102].rectangle.X -= animation[102].width
				if animation[102].rectangle.X < animation[102].x-animation[102].frames*animation[102].width {
					animation[102].rectangle.X = animation[102].x
				}
			}
		}
		if honeycombT > 0 {
			honeycombT--
			if frames%3 == 0 {
				animation[101].rectangle.X += animation[101].width
				if animation[101].rectangle.X > animation[101].x+animation[101].frames*animation[101].width {
					animation[101].rectangle.X = animation[101].x
				}
				animation[100].rectangle.X += animation[100].width
				if animation[100].rectangle.X > animation[100].x+animation[100].frames*animation[100].width {
					animation[100].rectangle.X = animation[100].x
				}
			}
		}
		if lollipopT > 0 {
			lollipopT--
			if frames%300 == 0 {
				if player.mana < player.manaMax {
					player.mana++
				}
			}
		}
		if orangeT > 0 {
			orangeT--
			if frames%300 == 0 {
				if player.hp < player.hpMax {
					player.hp++
				}
			}
		}
		if tvT > 0 {
			tvT--
		}
		if flamingoT > 0 {
			flamingoT--
			if flamingoT == 0 {
				if player.animationNum != 0 && player.animationNum != 1 {
					zfx := Effect{}
					zfx.name = "flamingoflame"
					zfx.fade = 0.8
					zfx.imageRectangle = animation[98].rectangle
					zfx.rectangle = player.rectangle
					zfx.rectangle.X -= b / 4
					zfx.rectangle.Y -= b / 4
					zfx.rectangle.Width += b / 2
					zfx.rectangle.Height += b / 2
					zfx.collisionRectangle = zfx.rectangle
					zfx.collisionRectangle.X += zfx.collisionRectangle.Width / 8
					zfx.collisionRectangle.Y += zfx.collisionRectangle.Height / 8
					zfx.collisionRectangle.Width -= zfx.collisionRectangle.Width / 4
					zfx.collisionRectangle.Height -= zfx.collisionRectangle.Height / 4
					zfx.timer = fps * 3
					zfx.isBelow = true
					effect = append(effect, zfx)
				}
				flamingoT = (fps + fps/2) / flamingonum
			}
		}
		if cloakT > 0 {
			cloakT--
		}
		if beetrootT > 0 {
			beetrootT--
		}
		if throwingknifenum > 0 {
			spd := player.speed + 2
			siz := b / 2
			if frames%int(fps*3) == 0 {
				zproj := Weapon{}
				zproj.damage = 1
				zproj.image = otherTiles[103]
				zproj.rec = rl.NewRectangle(player.center.X-siz/2, player.center.Y-siz/2, siz, siz)
				zproj.fade = 1
				zproj.col = rl.White
				zproj.crec = zproj.rec
				if throwingknifenum >= 1 {
					zproj.dirY = -spd
					zproj.rotation = -45
					playerProjectiles = append(playerProjectiles, zproj)
				}
				if throwingknifenum >= 2 {
					zproj.dirY = spd
					zproj.rotation = 135
					playerProjectiles = append(playerProjectiles, zproj)
				}
				if throwingknifenum >= 3 {
					zproj.dirY = 0
					zproj.dirX = spd
					zproj.rotation = 45
					playerProjectiles = append(playerProjectiles, zproj)
				}
				if throwingknifenum >= 4 {
					zproj.dirY = 0
					zproj.dirX = -spd
					zproj.rotation = -135
					playerProjectiles = append(playerProjectiles, zproj)
				}
				if throwingknifenum >= 5 {
					zproj.dirY = -spd
					zproj.dirX = spd
					zproj.rotation = 0
					playerProjectiles = append(playerProjectiles, zproj)
				}
				if throwingknifenum >= 6 {
					zproj.dirY = spd
					zproj.dirX = -spd
					zproj.rotation = 180
					playerProjectiles = append(playerProjectiles, zproj)
				}
				if throwingknifenum >= 7 {
					zproj.dirY = spd
					zproj.dirX = spd
					zproj.rotation = 90
					playerProjectiles = append(playerProjectiles, zproj)
				}
				if throwingknifenum == 8 {
					zproj.dirY = -spd
					zproj.dirX = -spd
					zproj.rotation = 270
					playerProjectiles = append(playerProjectiles, zproj)
				}
			}
		}
		if toxic {
			if frames%int(fps*3) == 0 {
				zfx := Effect{}
				zfx.imageRectangle = splat[RandInt(0, len(splat))]
				zfx.name = "toxic"
				zfx.rectangle = player.rectangle
				zfx.rectangle.X -= b
				zfx.rectangle.Y -= b
				zfx.rectangle.Width += b2
				zfx.rectangle.Height += b2
				zfx.collisionRectangle = zfx.rectangle
				zfx.collisionRectangle.X += zfx.collisionRectangle.Width / 8
				zfx.collisionRectangle.Y += zfx.collisionRectangle.Height / 8
				zfx.collisionRectangle.Width -= zfx.collisionRectangle.Width / 4
				zfx.collisionRectangle.Height -= zfx.collisionRectangle.Height / 4
				zfx.fade = 0.7
				zfx.isBelow = true
				effect = append(effect, zfx)
			}
		}
		if frisbeeT > 0 {
			frisbeeT--
		}
		if purplerainT > 0 {
			purplerainT--
		}
		if teslaT > 0 {
			teslaT--
		}
		if quailT > 0 {
			quailT--
		}
		if beartrapT > 0 {
			beartrapT--
			if beartrapT == 1 {
				siz := b + bq
				ztile := Tile{}
				ztile.image = animation[86].rectangle
				ztile.rectangle = rl.NewRectangle(player.center.X-siz/2, player.center.Y-siz/2, siz, siz)
				ztile.cRectangle = ztile.rectangle
				ztile.cRectangle.Height = ztile.cRectangle.Height / 2
				ztile.cRectangle.Y += 12
				ztile.cRectangle.X += 8
				ztile.cRectangle.Width -= 16
				ztile.name = "beartrap"
				ztile.center = makecnt(ztile.rectangle)
				canadd := true
				for i := 0; i < len(levels[levNum].otherTiles); i++ {
					if levels[levNum].otherTiles[i].name == "beartrap" {
						if rl.CheckCollisionRecs(levels[levNum].otherTiles[i].rectangle, ztile.rectangle) {
							canadd = false
						}
					}
				}
				if canadd {
					levels[levNum].otherTiles = append(levels[levNum].otherTiles, ztile)
				}
				beartrapT = (fps * 12) - (int32(beartrapnum*2) * fps)
			}
		}
		if reviveT > 0 {
			reviveT--
		}
		if steroidsT > 0 {
			steroidsT--
			if steroidsT == 1 {
				stats.strength = stats.strength2
			}
		}
		if powerT > 0 {
			powerT--
			if powerT == 1 {
				stats.dexterity = stats.dexterity2
				stats.intelligence = stats.intelligence2
				stats.luck = stats.luck2
				stats.perception = stats.perception2
				stats.strength = stats.strength2
			}
		}
		if inflictT > 0 {
			inflictT--
		}
		if teleportT > 0 {
			teleportT--
			if teleportT == 1 {
				if telBase {
					pause = true
					isBaseOn = true
					telBase = false
					if player.hp < player.hpMax {
						player.hp += 2
						if player.hp > player.hpMax {
							player.hp = player.hpMax
						}
						admsg("+2 hp @ camp", rl.Green)
					}
					rl.StopMusicStream(music[currentMusic])
					currentMusic = 2
					rl.PlayMusicStream(music[currentMusic])
					if vineRing {
						for i := 0; i < len(player.art); i++ {
							if player.art[i].name == "ring of vine" {
								player.art[i].isOff = false
							}
						}
					}
					if batty {
						batcomp.cnt = currentPosition
						batcomp.rectangle = rl.NewRectangle(batcomp.cnt.X-batcomp.rectangle.Width/2, batcomp.rectangle.Height/2, batcomp.rectangle.Width, batcomp.rectangle.Height)
						batcomp.moveChangeT = fps * 3
					}
					if rollo {
						rollocomp.cnt = currentPosition
						rollocomp.rectangle = rl.NewRectangle(rollocomp.cnt.X-rollocomp.rectangle.Width/2, rollocomp.cnt.Y-rollocomp.rectangle.Height/2, rollocomp.rectangle.Width, rollocomp.rectangle.Height)
					}
				}
				if telCntr {
					player.center = currentPosition
					updatePlayerRectangle()
					telCntr = false
				}
			}
		}
		if intangibleT > 0 {
			intangibleT--
			if intangibleT == 1 {
				telCntr = true
				teleportT = fps / 2
			}
		}
		if icelollyT > 0 {
			icelollyT--
		}
		if bloodT > 0 {
			bloodT--
		}
		if gasT > 0 {
			gasT--
		}
		if icecreamT > 0 {
			icecreamT--
		}
		if sodaT > 0 {
			sodaT--
		}
		if msgT > 0 {
			msgT--
		}
		if turtleT > 0 {
			turtleT--
		}
		if pistolT > 0 {
			pistolT--
		}
		if slugT > 0 {
			slugT--
		}
		if watchT > 0 {
			watchT--
		}
		if toptxT > 0 {
			toptxT--
		}
	}
}
func initCams() { //MARK:CAMS
	cam2.Target = player.center
	camBase.Target = currentPosition
	camBoss.Target = currentPosition
	cam2.Offset.X = screenWidthF32 / 2
	cam2.Offset.Y = screenHeightF32 / 2
	camBase.Offset.X = screenWidthF32 / 2
	camBase.Offset.Y = screenHeightF32 / 2
	camBoss.Offset.X = screenWidthF32 / 2
	camBoss.Offset.Y = screenHeightF32 / 2

	if scopeon {
		if cam2.Zoom > scopeZmax {
			cam2.Zoom -= 0.1
		} else {
			scopeT--
			if scopeT == 0 {
				scopeon = false
			}
		}
	} else {
		if cam2.Zoom < cam2Zorig {
			cam2.Zoom += 0.1
			if cam2.Zoom > cam2Zorig {
				cam2.Zoom = cam2Zorig
			}
		}
	}
	W := screenWidthF32 / cam2.Zoom
	H := screenHeightF32 / cam2.Zoom
	screenBordRec = rl.NewRectangle(player.center.X-W/2, player.center.Y-H/2, W, H)
	drawRec = rl.NewRectangle(player.center.X-W/2, player.center.Y-H/2, W, H)
	drawRec.X -= b2
	drawRec.Y -= b2
	drawRec.Width += b4
	drawRec.Height += b4
}
func initialWindow() { //MARK:INITIAL WINDOW
	rl.SetExitKey(rl.KeyNull)
	renderTarget = rl.LoadRenderTexture(screenWidth32, screenHeight32)
	imgs = rl.LoadTexture("img/imgs.png")
	endimg = rl.LoadTexture("img/end.png")
	helpimg = rl.LoadTexture("img/help.png")
	controlsimg = rl.LoadTexture("img/controls.png")
	//rl.HideCursor()
	shaderon = true
	makeshaders()
	makeimgs()
	initCams()

	rl.SetMousePosition(int(currentPosition.X+b2), int(currentPosition.Y))

	introAnim = animation[204].rectangle

	//treasureroom = true
	makeinitial()
	makesound()
	makeweaponsINTIIAL()
	makeitemsINITAL()
	makeenemiesINITIAL()
	makeplayer()
	makebase()
	makelevel()
	makePotionList()
	makeScrollList()
	ReadSaves()

	if rl.IsGamepadAvailable(0) {
		controllerINITIAL = true
	}

	//currentMusic = 2
	rl.SetMasterVolume(float32(volume) / 10)
	rl.SetMusicVolume(music[currentMusic], float32(volume)/10)
	rl.PlayMusicStream(music[currentMusic])

	musicon = true
	//rl.SetMasterVolume(0)

	exitmsg = exitText[RandInt(0, len(exitText))]

	scanlines = true
	pixels = true

	if medium {
		scanlines = false
		pixels = false
	}

	//bosskey1 = true
	//bosskey2 = true
	pause = true
	//helpon = true
	//endgame = true
	//startScreen = true
	intro = true
	//options = true
	//exit = true
	//baseon = true
	//apothercaryon = true
	//weaponshedon = true
	//storeon = true
	//bookon = true
	//options = true
	//loadon = true
	//credits = true
	//charscr = true
	//stats.str = 6
	//pl.xp = 100
	//invincible = true

}
func unload() { //MARK:UNLOAD
	rl.UnloadShader(shader)
	rl.UnloadRenderTexture(renderTarget)
	rl.UnloadTexture(imgs)
	rl.UnloadTexture(controlsimg)
	rl.UnloadTexture(endimg)
	rl.UnloadTexture(bossATK)
	rl.UnloadTexture(bossIDL)
	rl.UnloadTexture(bossWALKL)
	rl.UnloadTexture(bossWALKR)
	for i := 0; i < len(raylibAnim); i++ {
		rl.UnloadTexture(raylibAnim[i])
	}
	for i := 0; i < len(audfx); i++ {
		rl.UnloadSound(audfx[i])
	}
	for i := 0; i < len(music); i++ {
		rl.UnloadMusicStream(music[i])
	}
}
func main() { //MARK:MAIN
	rl.SetConfigFlags(rl.FlagMsaa4xHint | rl.FlagVsyncHint)
	rl.SetTraceLogLevel(rl.LogError)
	rl.InitWindow(0, 0, "Mr Snuggles Dungeon Adventure")
	rl.InitAudioDevice()
	rl.SetWindowState(rl.FlagBorderlessWindowedMode)
	scrW, scrH = rl.GetScreenWidth(), rl.GetScreenHeight()
	screenWidth32, screenHeight32 = int32(scrW), int32(scrH)
	screenWidthF32, screenHeightF32 = float32(scrW), float32(scrH)
	currentPosition = rl.NewVector2(screenWidthF32/2, screenHeightF32/2)

	siz := b10 * 2
	optionsRec = rl.NewRectangle(currentPosition.X-siz/2, 0, siz, screenHeightF32*2)
	siz *= 2
	storeRec = rl.NewRectangle(currentPosition.X-siz/2, 0, siz, screenHeightF32)

	if scrH >= 2160 {
		cam2.Zoom = 4
		xxl = true
	} else if scrH >= 1440 && scrH < 2160 {
		cam2.Zoom = 3
		xl = true
	} else if scrH > 1050 && scrH < 1440 {
		cam2.Zoom = 2.5
		large = true
	} else if scrH >= 900 && scrH <= 1050 {
		cam2.Zoom = 2
		large = true
	} else if scrH >= 720 && scrH < 900 {
		cam2.Zoom = 1.75
		medium = true
	} else if scrH < 720 {
		cam2.Zoom = 1
		medium = true
	}

	//CAM STRUCTURES
	camStructures.Zoom = 1
	camStructures.Target = currentPosition
	camStructures.Offset.X = screenWidthF32 / 2
	camStructures.Offset.Y = screenHeightF32 / 2
	if xl {
		camStructures.Zoom = 1.5
		camStructures.Offset.Y = screenHeightF32 / 1.35
	} else if xxl {
		camStructures.Zoom = 2.25
		camStructures.Offset.Y = screenHeightF32 / 0.89
	} else if medium {
		camStructures.Zoom = 0.75
		camStructures.Offset.Y = screenHeightF32 / 2.7
	}

	//CAM MAP
	camMap.Zoom = 0.1
	if xxl {
		camMap.Zoom = 0.2
	}
	if xl {
		camMap.Zoom = 0.15
	}

	//CAM INVEN
	camInventory.Zoom = 1
	camInventory.Target = currentPosition
	camInventory.Offset.X = screenWidthF32 / 2
	camInventory.Offset.Y = optionsRec.Height / 4.05
	if xl {
		camInventory.Zoom = 1.5
		camInventory.Offset.Y = screenHeightF32 / 1.35
	} else if xxl {
		camInventory.Zoom = 2.25
		camInventory.Offset.Y = screenHeightF32 / 0.89
	} else if medium {
		camInventory.Zoom = 0.8
		camInventory.Offset.Y = optionsRec.Height / 5
	}

	//CAM BASE
	if screenHeightF32 > 720 {
		diff := screenHeightF32 - 720
		diff = diff / 720
		camBase.Zoom = 1 + diff
	} else if screenHeightF32 == 720 {
		camBase.Zoom = 1
	}

	camBase.Target = currentPosition
	camBase.Offset.X = screenWidthF32 / 2
	camBase.Offset.Y = screenHeightF32 / 2

	camBoss.Target = currentPosition
	camBoss.Zoom = 3
	camBoss.Offset.X = screenWidthF32 / 2
	camBoss.Offset.Y = screenHeightF32 / 2

	//CAM END GAME
	camEnd.Zoom = 1
	if xl {
		camEnd.Zoom = 1.5
	}
	if xxl {
		camEnd.Zoom = 2.5
	}
	if medium {
		camEnd.Zoom = 0.75
	}
	camEnd.Target = currentPosition
	camEnd.Offset.X = screenWidthF32 / 2
	camEnd.Offset.Y = screenHeightF32 / 2

	initialWindow() //INITIAL INSIDE WINDOW
	rl.SetTargetFPS(fps)
	for !rl.WindowShouldClose() {
		delta = rl.GetFrameTime()
		frames++
		rl.BeginDrawing()
		rl.ClearBackground(rl.Black)
		if shaderon { //BLOOM SHADER
			rl.BeginTextureMode(renderTarget) // Enable drawing to texture
			rl.ClearBackground(rl.Black)

			rl.BeginMode2D(cam2)
			drawcam()
			rl.EndMode2D()
			drawnocam()
			rl.EndTextureMode()
			rl.BeginShaderMode(shader)
			rl.DrawTextureRec(renderTarget.Texture, rl.NewRectangle(0, 0, float32(renderTarget.Texture.Width), float32(-renderTarget.Texture.Height)), rl.NewVector2(0, 0), rl.White)
			rl.EndShaderMode()
		} else { //NO BLOOM SHADER
			rl.ClearBackground(rl.Black)

			rl.BeginMode2D(cam2)
			drawcam()
			rl.EndMode2D()
			drawnocam()
		}
		drawnoRender()
		up() //UPDATE
		rl.EndDrawing()
	}
	unload() //UNLOAD
	rl.CloseAudioDevice()
	rl.CloseWindow()
}
